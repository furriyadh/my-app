module.exports = {

"[project]/node_modules/google-ads-api/build/src/version.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.googleAdsVersion = void 0;
exports.googleAdsVersion = "v20";
}}),
"[project]/node_modules/google-ads-api/build/src/utils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromMicros = fromMicros;
exports.toMicros = toMicros;
exports.normaliseQuery = normaliseQuery;
exports.capitaliseFirstLetter = capitaliseFirstLetter;
exports.toCamelCase = toCamelCase;
exports.toSnakeCase = toSnakeCase;
exports.recursiveFieldMaskSearch = recursiveFieldMaskSearch;
exports.getFieldMask = getFieldMask;
const protos_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
/**
 * @param micros Money value in micros format
 * @description Converts a micro amount to a normalised value
 * @example
 * const cost = fromMicros(campaign.metrics.costMicros)
 */ function fromMicros(micros) {
    return micros / 1000000;
}
/**
 * @param value Money value in decimal format
 * @description Converts a number to micro format
 * @example
 * const costMicros = toMicros(12.5) // 12,500,000
 */ function toMicros(value) {
    return Math.round(value * 1000000);
}
/**
 * @param query String gaql query
 * @description Normalises a query by replacing multiple whitespace with single whitespace
 * @example
 * const gaqlQuery =
 *  `SELECT campaign.name
 *  FROM campaign
 *  LIMIT 10`
 * const normalisedQuery = normaliseQuery(gaqlQuery) // "SELECT campaign.name FROM campaign LIMIT 10"
 */ function normaliseQuery(query) {
    return `${query.replace(/\s{2,}/g, " ")}`;
}
/**
 * @param str
 * @description Capitalises the first letter of a string
 * @example
 * const capitalisedString = capitaliseFirstLetter("adGroupCriterionSimulation") // "AdGroupCriterionSimulation"
 */ function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * @param str
 * @description Converts a string to a camel case string. Works on space case, snake case and title case strings.
 * @example
 * const camelCaseString = toCamelCase("ad_group_criterion_simulation") // "adGroupCriterionSimulation"
 */ function toCamelCase(str) {
    return str.replace(/\s+/g, "_") // convert spaces to underscores
    .replace(/(_)([A-Za-z])/g, (pattern)=>pattern[1].toUpperCase()) // replace "_x" patterns with "X"
    .replace(/^([A-Z])/g, (pattern)=>pattern.toLowerCase()); // capitalises the first letter of the string
}
/**
 * @param str
 * @description Converts a string to a snake case string. Works on space case, camel case and title case strings.
 * @example
 * const snakeCaseString = toSnakeCase("adGroupCriterionSimulation") // "ad_group_criterion_simulation"
 */ function toSnakeCase(str) {
    return str.replace(/\s+/g, "_") // convert spaces to underscores
    .replace(/(?<!(^|_))([A-Z])/g, (pattern)=>"_" + pattern) // places an underscore before any capital chars, unless there is already an underscore or it is the first char of the string
    .toLowerCase();
}
function recursiveFieldMaskSearch(data) {
    const paths = [];
    for (const key of Object.keys(data)){
        if (key === "resourceName") {
            continue;
        }
        const fieldKey = toSnakeCase(key);
        const value = data[key];
        if (typeof value === "object" && !Array.isArray(value) && value !== null) {
            const children = recursiveFieldMaskSearch(value);
            for (const child of children){
                paths.push(`${fieldKey}.${child}`);
            }
            continue;
        }
        paths.push(fieldKey);
    }
    return paths;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getFieldMask(data) {
    const paths = recursiveFieldMaskSearch(data);
    return new protos_1.protobuf.FieldMask({
        paths
    });
}
}}),
"[project]/node_modules/google-ads-api/build/src/parserRest.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * JSON Rest parsing
 */ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decamelizeKeys = void 0;
const map_obj_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/map-obj/index.js [app-route] (ecmascript)"));
const circ_json_1 = __turbopack_context__.r("[project]/node_modules/circ-json/app/dist/cjs/circJson.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/utils.js [app-route] (ecmascript)");
const fields_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/autogen/fields.js [app-route] (ecmascript)");
const enums_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/autogen/enums.js [app-route] (ecmascript)");
const fieldDataTypes = (0, circ_json_1.parse)(fields_1.fieldDataTypes);
const decamelizeCache = new Map();
const fieldTypeCache = new Map();
const isObject = (value)=>typeof value === "object" && value !== null;
const decamelizeKeys = (input)=>{
    if (!isObject(input)) {
        return input;
    }
    const makeMapper = (parentPath)=>(key, value)=>{
            key = cachedDecamelize(key);
            if (isObject(value)) {
                const path = parentPath === undefined ? key : `${parentPath}.${key}`;
                // @ts-ignore
                value = (0, map_obj_1.default)(value, makeMapper(path));
            } else {
                value = cachedValueParser(key, parentPath, value);
            }
            return [
                key,
                value
            ];
        };
    // @ts-ignore
    return (0, map_obj_1.default)(input, makeMapper());
};
exports.decamelizeKeys = decamelizeKeys;
const cachedDecamelize = (key)=>{
    const cachedResult = decamelizeCache.get(key);
    if (cachedResult) {
        return cachedResult;
    }
    const newKey = (0, utils_1.toSnakeCase)(key);
    decamelizeCache.set(key, newKey);
    return newKey;
};
const cachedValueParser = (key, parentPath, value)=>{
    let newValue = value;
    const fullPath = parentPath ? `${parentPath}.${key}` : key;
    const megaDataType = getTypeFromPath(fullPath);
    if (megaDataType === undefined && !fullPath.startsWith("@")) {
        console.warn(`No data type found for ${fullPath}`);
    } else if (typeof megaDataType === "object") {
        newValue = megaDataType[value];
    } else if (megaDataType === "INT64") {
        newValue = Number(value);
    } else if (megaDataType === "ENUM") {
        // Some enums aren't embedded in megaDataType, so we need this fallback.
        // @ts-expect-error typescript doesn't like accessing items in a namespace with a string
        newValue = enums_1.enums[fields_1.fields.enumFields[fullPath]][value]; // e.g. enums['CampaignStatus'][ENABLED] = "2"
    }
    return newValue;
};
const getTypeFromPath = (path)=>{
    const cachedResult = fieldTypeCache.get(path);
    if (cachedResult) {
        return cachedResult;
    }
    const t = get(fieldDataTypes, path);
    fieldTypeCache.set(path, t);
    return t;
};
// Copied from youmightnotneed.com
const get = (obj, path)=>{
    if (!path) return undefined;
    // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.
    // Regex explained: https://regexr.com/58j0k
    const pathArray = path.match(/([^[.\]])+/g);
    if (!pathArray) return undefined;
    // Find value
    return pathArray.reduce((prevObj, key)=>prevObj && prevObj[key], obj);
};
}}),
"[project]/node_modules/google-ads-api/build/src/service.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Service = exports.FAILURE_KEY = void 0;
const google_gax_1 = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/index.js [app-route] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-route] (ecmascript)");
const protos_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/utils.js [app-route] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/version.js [app-route] (ecmascript)");
const ttlcache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@isaacs/ttlcache/index.js [app-route] (ecmascript)"));
// Make sure to update this version number when upgrading
exports.FAILURE_KEY = `google.ads.googleads.${version_1.googleAdsVersion}.errors.googleadsfailure-bin`;
// A global service cache to avoid re-initialising services
const serviceCache = new ttlcache_1.default({
    max: 1_000,
    ttl: 10 * 60 * 1000,
    dispose: async (service)=>{
        // Close connections when services are removed from the cache
        await service.close();
    }
});
// A global access token cache used by REST calls. Issued tokens expire after 1 hour, so we cache them for 50 minutes.
const accessTokenCache = new ttlcache_1.default({
    max: 100_000,
    ttl: 50 * 60 * 1000
});
class Service {
    clientOptions;
    customerOptions;
    hooks;
    constructor(clientOptions, customerOptions, hooks){
        this.clientOptions = clientOptions;
        this.customerOptions = customerOptions;
        this.hooks = hooks ?? {};
        // @ts-expect-error All fields don't need to be set here
        this.serviceCache = {};
    }
    get credentials() {
        return {
            customer_id: this.customerOptions.customer_id,
            login_customer_id: this.customerOptions.login_customer_id,
            linked_customer_id: this.customerOptions.linked_customer_id
        };
    }
    get callHeaders() {
        const headers = {
            "developer-token": this.clientOptions.developer_token
        };
        if (this.customerOptions.login_customer_id) {
            headers["login-customer-id"] = this.customerOptions.login_customer_id;
        }
        if (this.customerOptions.linked_customer_id) {
            headers["linked-customer-id"] = this.customerOptions.linked_customer_id;
        }
        return headers;
    }
    // Used only by gRPC calls
    getCredentials() {
        const sslCreds = google_gax_1.grpc.credentials.createSsl();
        const authClient = new google_auth_library_1.UserRefreshClient(this.clientOptions.client_id, this.clientOptions.client_secret, this.customerOptions.refresh_token);
        const credentials = google_gax_1.grpc.credentials.combineChannelCredentials(sslCreds, google_gax_1.grpc.credentials.createFromGoogleCredential(authClient));
        return credentials;
    }
    // Used only by REST calls
    async getAccessToken() {
        const cachedToken = accessTokenCache.get(this.customerOptions.refresh_token);
        if (cachedToken) {
            return cachedToken;
        }
        const oAuth2Client = new google_auth_library_1.OAuth2Client(this.clientOptions.client_id, this.clientOptions.client_secret);
        oAuth2Client.setCredentials({
            refresh_token: this.customerOptions.refresh_token
        });
        const { token } = await oAuth2Client.getAccessToken();
        if (typeof token !== "string") {
            throw new Error("Failed to retrieve access token");
        }
        accessTokenCache.set(this.customerOptions.refresh_token, token);
        return token;
    }
    loadService(service) {
        const serviceCacheKey = `${service}_${this.customerOptions.refresh_token}`;
        if (serviceCache.has(serviceCacheKey)) {
            return serviceCache.get(serviceCacheKey);
        }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { [service]: protoService } = __turbopack_context__.r("[project]/node_modules/google-ads-node/build/src/index.js [app-route] (ecmascript)");
        if (typeof protoService === "undefined") {
            throw new Error(`Service "${service}" could not be found`);
        }
        // Initialising services can take a few ms, so we cache when possible.
        const client = new protoService({
            sslCreds: this.getCredentials()
        });
        serviceCache.set(serviceCacheKey, client);
        return client;
    }
    getGoogleAdsError(error) {
        // @ts-expect-error No type exists for GA query error
        if (typeof error?.metadata?.internalRepr.get(exports.FAILURE_KEY) === "undefined") {
            return error;
        }
        // @ts-expect-error No type exists for GA query error
        const [buffer] = error.metadata.internalRepr.get(exports.FAILURE_KEY);
        return this.decodeGoogleAdsFailureBuffer(buffer);
    }
    decodeGoogleAdsFailureBuffer(buffer) {
        const googleAdsFailure = protos_1.errors.GoogleAdsFailure.decode(buffer);
        return googleAdsFailure;
    }
    decodePartialFailureError(response) {
        if (typeof response?.partial_failure_error === "undefined" || !response?.partial_failure_error) {
            return response;
        }
        const { details } = response.partial_failure_error;
        const buffer = details?.find((d)=>d.type_url.includes("errors.GoogleAdsFailure"))?.value;
        if (typeof buffer === "undefined") {
            return response;
        }
        // Update the partial failure field with the decoded error details
        return {
            ...response,
            partial_failure_error: this.decodeGoogleAdsFailureBuffer(buffer)
        };
    }
    buildSearchRequestAndService(gaql, options) {
        const service = this.loadService("GoogleAdsServiceClient");
        const request = new protos_1.services.SearchGoogleAdsRequest({
            customer_id: this.customerOptions.customer_id,
            query: gaql,
            ...options
        });
        return {
            service,
            request
        };
    }
    buildSearchStreamRequestAndService(gaql, options) {
        const service = this.loadService("GoogleAdsServiceClient");
        const request = new protos_1.services.SearchGoogleAdsStreamRequest({
            customer_id: this.customerOptions.customer_id,
            query: gaql,
            ...options
        });
        return {
            service,
            request
        };
    }
    buildMutationRequestAndService(mutations, options) {
        const service = this.loadService("GoogleAdsServiceClient");
        const mutateOperations = mutations.map((mutation)=>{
            const opKey = (0, utils_1.toSnakeCase)(`${mutation.entity}Operation`);
            const operation = {
                [mutation.operation ?? "create"]: mutation.resource
            };
            if (mutation.operation === "create" && //@ts-ignore
            mutation?.exempt_policy_violation_keys?.length) {
                //@ts-ignore
                operation.exempt_policy_violation_keys = mutation.exempt_policy_violation_keys;
            } else if (mutation.operation === "update") {
                // @ts-expect-error Resource operations should have updateMask defined
                operation.update_mask = (0, utils_1.getFieldMask)(mutation.resource);
            }
            const mutateOperation = new protos_1.services.MutateOperation({
                [opKey]: operation
            });
            return mutateOperation;
        });
        const request = new protos_1.services.MutateGoogleAdsRequest({
            customer_id: this.customerOptions.customer_id,
            mutate_operations: mutateOperations,
            ...options
        });
        return {
            service,
            request
        };
    }
    buildOperations(type, entities, message) {
        const ops = entities.map((e)=>{
            const op = {
                [type]: e,
                operation: type
            };
            //@ts-ignore
            if (type === "create" && e?.exempt_policy_violation_keys?.length) {
                // @ts-expect-error Field required for policy violation exemptions
                op.exempt_policy_violation_keys = e.exempt_policy_violation_keys;
                //@ts-ignore
                delete e.exempt_policy_violation_keys;
            } else if (type === "update") {
                // @ts-expect-error Field required for updates
                op.update_mask = (0, utils_1.getFieldMask)(// @ts-expect-error Message types have a toObject method
                message.toObject(e, {
                    defaults: false
                }));
            }
            return op;
        });
        return ops;
    }
    buildRequest(operations, options) {
        const request = {
            customer_id: this.customerOptions.customer_id,
            operations,
            ...options
        };
        return request;
    }
}
exports.Service = Service;
}}),
"[project]/node_modules/google-ads-api/build/src/types.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dateConstants = void 0;
exports.dateConstants = [
    "TODAY",
    "YESTERDAY",
    "LAST_7_DAYS",
    "LAST_BUSINESS_WEEK",
    "THIS_MONTH",
    "LAST_MONTH",
    "LAST_14_DAYS",
    "LAST_30_DAYS",
    "THIS_WEEK_SUN_TODAY",
    "THIS_WEEK_MON_TODAY",
    "LAST_WEEK_SUN_SAT",
    "LAST_WEEK_MON_SUN"
];
}}),
"[project]/node_modules/google-ads-api/build/src/query.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryError = void 0;
exports.buildSelectClause = buildSelectClause;
exports.buildFromClause = buildFromClause;
exports.validateConstraintKeyAndValue = validateConstraintKeyAndValue;
exports.convertNumericEnumToString = convertNumericEnumToString;
exports.extractConstraintConditions = extractConstraintConditions;
exports.extractDateConstantConditions = extractDateConstantConditions;
exports.extractDateConditions = extractDateConditions;
exports.buildWhereClause = buildWhereClause;
exports.buildLimitClause = buildLimitClause;
exports.buildParametersClause = buildParametersClause;
exports.completeOrderly = completeOrderly;
exports.buildOrderClauseOld = buildOrderClauseOld;
exports.buildOrderClauseNew = buildOrderClauseNew;
exports.buildOrderClause = buildOrderClause;
exports.buildRequestOptions = buildRequestOptions;
exports.buildQuery = buildQuery;
const protos_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/types.js [app-route] (ecmascript)");
var QueryKeywords;
(function(QueryKeywords) {
    QueryKeywords["SELECT"] = "SELECT";
    QueryKeywords["FROM"] = "FROM";
    QueryKeywords["WHERE"] = "WHERE";
    QueryKeywords["ORDER_BY"] = "ORDER BY";
    QueryKeywords["LIMIT"] = "LIMIT";
    QueryKeywords["PARAMETERS"] = "PARAMETERS";
    QueryKeywords["AND"] = "AND";
    QueryKeywords["OR"] = "OR";
})(QueryKeywords || (QueryKeywords = {}));
exports.QueryError = {
    INVALID_CONSTRAINTS_FORMAT: "Constraints must be an array of objects or a singular object.",
    INVALID_CONSTRAINT_KEY: "A constraint key must have a string value.",
    INVALID_CONSTRAINT_VALUE: (key, val)=>// @ts-ignore
        `The value of the constraint ${key} must be a string, number, boolean, or an array of these types. Here, typeof ${key} is ${typeof val}.`,
    INVALID_CONSTRAINT_OBJECT_FORMAT: "Must specify { key, op, val } or { key: value } when using object-style constraints.",
    INVALID_DATE_CONSTANT_TYPE: (dateConstant)=>`Date constant must be a string. Here, typeof date constant is ${typeof dateConstant}`,
    INVALID_FROM_DATE_TYPE: (fromDate)=>`From date must be a string. Here, typeof from date is ${typeof fromDate}`,
    INVALID_TO_DATE_TYPE: (toDate)=>`To date must be a string. Here, typeof to date is ${typeof toDate}`,
    INVALID_LIMIT: "Limit must be a positive integer.",
    INVALID_PARAMETERS: "Parameters must be a string.",
    INVALID_ORDER: "Order must be an array.",
    INVALID_ORDERLY: "OrderBy arrays must only contain strings.",
    INVALID_ORDERBY: "OrderBy must be a string or an array of strings.",
    INVALID_SORT_ORDER: `Sort order must be "ASC" or "DESC".`,
    MISSING_FIELDS: 'Must specify at least one field in ("attributes","metrics","segments").',
    MISSING_FROM_DATE: 'Expected start date range is missing - "from_date".',
    UNDEFINED_ENTITY: "The entity of the query must be defined."
};
function buildSelectClause(attributes, metrics, segments) {
    if (!attributes?.length && !metrics?.length && !segments?.length) {
        throw new Error(exports.QueryError.MISSING_FIELDS);
    }
    const selections = [
        ...attributes || [],
        ...metrics || [],
        ...segments || []
    ].join(", ");
    return `${QueryKeywords.SELECT} ${selections}`;
}
function buildFromClause(entity) {
    if (typeof entity === "undefined") {
        throw new Error(exports.QueryError.UNDEFINED_ENTITY);
    }
    return ` ${QueryKeywords.FROM} ${entity}`;
}
function formatGaqlString(val) {
    const len = val.length;
    const startsWithSingle = val.startsWith("'");
    const endsWithSingle = val.endsWith("'");
    const startsWithDouble = val.startsWith('"');
    const endsWithDouble = val.endsWith('"');
    // Returns the original string if it seems correctly quoted already.
    if (len >= 2) {
        if (startsWithSingle && endsWithSingle && !val.slice(1, -1).includes("'")) {
            return val;
        }
        if (startsWithDouble && endsWithDouble && !val.slice(1, -1).includes('"')) {
            return val;
        }
    }
    // Always use double quotes and escape internal double quotes and backslashes
    if (val.includes('"') || val.includes("\\")) {
        const escapedVal = val.replace(/\\/g, "\\\\").replace(/"/g, '\\"'); // Escape backslashes first, then double quotes
        return `"${escapedVal}"`;
    } else {
        // No escaping needed, just wrap in double quotes
        return `"${val}"`;
    }
}
function validateConstraintKeyAndValue(key, op, val) {
    if (typeof val === "number" || typeof val === "boolean") {
        return {
            op: "=",
            val: convertNumericEnumToString(key, val)
        };
    }
    if (typeof val === "string") {
        if (types_1.dateConstants.includes(val)) {
            return {
                op,
                val
            };
        }
        return {
            op: "=",
            val: formatGaqlString(val)
        };
    }
    if (Array.isArray(val)) {
        const stringifiedValue = val.map((v)=>{
            if (typeof v === "string") {
                return formatGaqlString(v);
            } else {
                return convertNumericEnumToString(key, v);
            }
        }).join(`, `);
        return {
            op: "IN",
            val: `(${stringifiedValue})`
        };
    }
    throw new Error(exports.QueryError.INVALID_CONSTRAINT_VALUE(key, val));
}
function convertNumericEnumToString(key, val) {
    // @ts-expect-error key does not always match an enum field
    if (protos_1.fields.enumFields[key] && typeof val === "number") {
        // @ts-expect-error typescript doesn't like accessing items in a namespace with a string
        const enumStringValue = protos_1.enums[protos_1.fields.enumFields[key]][val]; // e.g. enums['CampaignStatus'][2] = "ENABLED"
        if (enumStringValue) {
            return `"${enumStringValue}"`;
        }
    }
    return val;
}
function extractConstraintConditions(constraints) {
    if (typeof constraints === "undefined") {
        return [];
    } else if (Array.isArray(constraints)) {
        return constraints.map((con)=>{
            if (typeof con === "object" && !Array.isArray(con) && con !== null) {
                // @ts-ignore
                if (con.key && con.op && typeof con.val !== "undefined") {
                    const { key, op, val } = con;
                    if (typeof key !== "string") {
                        throw new Error(exports.QueryError.INVALID_CONSTRAINT_KEY);
                    }
                    const validatedValue = validateConstraintKeyAndValue(key, op, val);
                    // @ts-ignore
                    return `${key} ${op} ${validatedValue.val}`;
                } else if (Object.keys(con).length === 1) {
                    const [[key, val]] = Object.entries(con);
                    const validatedValue = validateConstraintKeyAndValue(key, "=", val);
                    return `${key} ${validatedValue.op} ${validatedValue.val}`;
                } else {
                    throw new Error(exports.QueryError.INVALID_CONSTRAINT_OBJECT_FORMAT);
                }
            } else if (typeof con === "string") {
                return con;
            } else {
                throw new Error(exports.QueryError.INVALID_CONSTRAINT_OBJECT_FORMAT);
            }
        });
    } else if (typeof constraints === "object" && constraints !== null) {
        return Object.entries(constraints).map(([key, val])=>{
            const validatedValue = validateConstraintKeyAndValue(key, "=", val);
            return `${key} ${validatedValue.op} ${validatedValue.val}`;
        });
    } else {
        throw new Error(exports.QueryError.INVALID_CONSTRAINTS_FORMAT);
    }
}
function extractDateConstantConditions(dateConstant) {
    if (typeof dateConstant === "undefined") {
        return [];
    } else if (typeof dateConstant !== "string") {
        throw new Error(exports.QueryError.INVALID_DATE_CONSTANT_TYPE(dateConstant));
    }
    return [
        `segments.date DURING ${dateConstant}`
    ];
}
function extractDateConditions(fromDate, toDate) {
    if (typeof fromDate === "undefined" && typeof toDate === "undefined") {
        return [];
    }
    if (typeof fromDate === "undefined" && typeof toDate !== "undefined") {
        throw new Error(exports.QueryError.MISSING_FROM_DATE);
    }
    if (typeof fromDate !== "undefined" && typeof toDate === "undefined") {
        const d = new Date();
        toDate = `${d.getFullYear()}-${("0" + (d.getMonth() + 1)).slice(-2)}-${("0" + d.getDate()).slice(-2)}`;
    }
    if (typeof fromDate !== "string") {
        throw new Error(exports.QueryError.INVALID_FROM_DATE_TYPE(fromDate));
    }
    if (typeof toDate !== "string") {
        throw new Error(exports.QueryError.INVALID_TO_DATE_TYPE(toDate));
    }
    return [
        `segments.date >= "${fromDate}"`,
        `segments.date <= "${toDate}"`
    ];
}
function buildWhereClause(constraints, dateConstant, fromDate, toDate) {
    const constraintClauses = extractConstraintConditions(constraints);
    const dateConstantClauses = extractDateConstantConditions(dateConstant);
    const dateClauses = extractDateConditions(fromDate, toDate);
    const whereClauses = [
        ...constraintClauses,
        ...dateConstantClauses,
        ...dateClauses
    ].join(` ${QueryKeywords.AND} `);
    return whereClauses.length ? ` ${QueryKeywords.WHERE} ${whereClauses}` : ``;
}
function buildLimitClause(limit) {
    if (typeof limit === "undefined") {
        return ``;
    }
    if (typeof limit !== "number" || limit < 1 || !Number.isInteger(limit)) {
        throw new Error(exports.QueryError.INVALID_LIMIT);
    }
    return ` ${QueryKeywords.LIMIT} ${limit}`;
}
function buildParametersClause(parameters) {
    if (typeof parameters === "undefined") {
        return ``;
    }
    if (typeof parameters !== "string") {
        throw new Error(exports.QueryError.INVALID_PARAMETERS);
    }
    return ` ${QueryKeywords.PARAMETERS} ${parameters}`;
}
function completeOrderly(orderly, entity) {
    if (!orderly.length) {
        throw new Error(exports.QueryError.INVALID_ORDERLY);
    } else if (new RegExp(/^[^.\s]+(\.[^.\s]+)+$/g).test(orderly)) {
        // text containing full stops
        return orderly;
    } else if (new RegExp(/^[^.\s]+$/g).test(orderly)) {
        // text without a full stop (e.g. resource_name)
        return `${entity}.${orderly}`;
    } else {
        throw new Error(exports.QueryError.INVALID_ORDERLY);
    }
}
function buildOrderClauseOld(orderBy, sortOrder, entity) {
    if (typeof orderBy === "undefined") {
        return ``;
    } else if (typeof sortOrder === "undefined") {
        sortOrder = "DESC";
    } else if (sortOrder !== "ASC" && sortOrder !== "DESC") {
        throw new Error(exports.QueryError.INVALID_SORT_ORDER);
    }
    if (Array.isArray(orderBy)) {
        const orders = orderBy.map((orderly)=>{
            if (typeof orderly !== "string") {
                throw new Error(exports.QueryError.INVALID_ORDERLY);
            } else {
                return completeOrderly(orderly, entity);
            }
        }).join(", ");
        return ` ${QueryKeywords.ORDER_BY} ${orders} ${sortOrder}`;
    } else if (typeof orderBy === "string") {
        return ` ${QueryKeywords.ORDER_BY} ${completeOrderly(orderBy, entity)} ${sortOrder}`;
    } else {
        throw new Error(exports.QueryError.INVALID_ORDERBY);
    }
}
function buildOrderClauseNew(order, entity) {
    if (!order || !Array.isArray(order)) {
        throw new Error(exports.QueryError.INVALID_ORDER);
    }
    if (!order.length) {
        return "";
    }
    const orders = order.map((o)=>{
        const orderly = completeOrderly(o.field, entity);
        const sortOrder = o.sort_order ? o.sort_order : "DESC";
        return `${orderly} ${sortOrder}`;
    }).join(", ");
    return ` ${QueryKeywords.ORDER_BY} ${orders}`;
}
function buildOrderClause(order, orderBy, sortOrder, entity) {
    if (order) {
        return buildOrderClauseNew(order, entity);
    } else {
        return buildOrderClauseOld(orderBy, sortOrder, entity);
    }
}
function buildRequestOptions(reportOptions) {
    const { page_size, page_token, validate_only, search_settings } = reportOptions;
    return {
        page_size,
        page_token,
        validate_only,
        search_settings
    };
}
function buildQuery(reportOptions) {
    const SELECT = buildSelectClause(reportOptions.attributes, reportOptions.metrics, reportOptions.segments);
    const FROM = buildFromClause(reportOptions.entity);
    const WHERE = buildWhereClause(reportOptions.constraints, reportOptions.date_constant, reportOptions.from_date, reportOptions.to_date);
    const ORDER = buildOrderClause(reportOptions.order, reportOptions.order_by, reportOptions.sort_order, reportOptions.entity);
    const LIMIT = buildLimitClause(reportOptions.limit);
    const PARAMETERS = buildParametersClause(reportOptions.parameters);
    const requestOptions = buildRequestOptions(reportOptions);
    return {
        gaqlQuery: `${SELECT}${FROM}${WHERE}${ORDER}${LIMIT}${PARAMETERS}`,
        requestOptions
    };
}
}}),
"[project]/node_modules/google-ads-api/build/src/customer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Customer = void 0;
const axios_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-route] (ecmascript)"));
const stream_chain_1 = __turbopack_context__.r("[project]/node_modules/stream-chain/index.js [app-route] (ecmascript)");
const stream_json_1 = __turbopack_context__.r("[project]/node_modules/stream-json/index.js [app-route] (ecmascript)");
const StreamArray_1 = __turbopack_context__.r("[project]/node_modules/stream-json/streamers/StreamArray.js [app-route] (ecmascript)");
const parserRest_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/parserRest.js [app-route] (ecmascript)");
const protos_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
const serviceFactory_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/autogen/serviceFactory.js [app-route] (ecmascript)"));
const query_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/query.js [app-route] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/version.js [app-route] (ecmascript)");
const ROWS_PER_STREAMED_CHUNK = 10_000; // From experience, this is what can be expected from the API.
class Customer extends serviceFactory_1.default {
    constructor(clientOptions, customerOptions, hooks){
        super(clientOptions, customerOptions, hooks ?? {});
    }
    /**
      @description Single query using a raw GAQL string.
      @hooks onQueryStart, onQueryError, onQueryEnd
    */ async query(gaqlQuery, requestOptions = {}) {
        const { response } = await this.querier(gaqlQuery, requestOptions);
        return response;
    }
    /**
      @description Stream query using a raw GAQL string. If a generic type is provided, it must be the type of a single row.
      If a summary row is requested then this will be the last emitted row of the stream.
      @hooks onStreamStart, onStreamError
      @example
      const stream = queryStream<T>(gaqlQuery)
      for await (const row of stream) { ... }
    */ async *queryStream(gaqlQuery, requestOptions = {}) {
        const stream = this.streamer(gaqlQuery, requestOptions);
        for await (const row of stream){
            yield row;
        }
    }
    /**
      @description Single query using ReportOptions.
      If a summary row is requested then this will be the first row of the results.
      @hooks onQueryStart, onQueryError, onQueryEnd
    */ async report(options) {
        const { gaqlQuery, requestOptions } = (0, query_1.buildQuery)(options);
        const { response } = await this.querier(gaqlQuery, requestOptions, options);
        return response;
    }
    /**
      @description Get the total row count of a report.
      @hooks none
    */ async reportCount(options) {
        // must get at least one row
        const { gaqlQuery, requestOptions } = (0, query_1.buildQuery)({
            ...options,
            limit: 1
        });
        // We do not allow this field in reportOptions, however it is still a valid request option
        requestOptions.search_settings = {
            return_total_results_count: true
        };
        const useHooks = false; // to avoid cacheing conflicts
        const { totalResultsCount } = await this.querier(gaqlQuery, requestOptions, options, useHooks);
        return totalResultsCount;
    }
    /**
      @description Stream query using ReportOptions. If a generic type is provided, it must be the type of a single row.
      If a summary row is requested then this will be the last emitted row of the stream.
      @hooks onStreamStart, onStreamError
      @example
      const stream = reportStream<T>(reportOptions)
      for await (const row of stream) { ... }
    */ async *reportStream(reportOptions) {
        const { gaqlQuery, requestOptions } = (0, query_1.buildQuery)(reportOptions);
        const stream = this.streamer(gaqlQuery, requestOptions, reportOptions);
        for await (const row of stream){
            yield row;
        }
    }
    /**
      @description Retreive the raw stream using ReportOptions.
      @hooks onStreamStart
      @example
      const stream = reportStreamRaw(reportOptions)
      stream.on('data', (chunk) => { ... }) // a chunk contains up to 10,000 un-parsed rows
      stream.on('error', (error) => { ... })
      stream.on('end', () => { ... })
    */ async reportStreamRaw(reportOptions) {
        const { gaqlQuery, requestOptions } = (0, query_1.buildQuery)(reportOptions);
        const baseHookArguments = {
            credentials: this.credentials,
            query: gaqlQuery,
            reportOptions
        };
        const queryStart = {
            cancelled: false
        };
        if (this.hooks.onStreamStart) {
            await this.hooks.onStreamStart({
                ...baseHookArguments,
                cancel: ()=>{
                    queryStart.cancelled = true;
                },
                editOptions: (options)=>{
                    Object.entries(options).forEach(([key, val])=>{
                        // @ts-ignore
                        requestOptions[key] = val;
                    });
                }
            });
            if (queryStart.cancelled) {
                return;
            }
        }
        const { service, request } = this.buildSearchStreamRequestAndService(gaqlQuery, requestOptions);
        return service.searchStream(request, {
            otherArgs: {
                headers: this.callHeaders
            }
        });
    }
    async search(gaqlQuery, requestOptions) {
        const accessToken = await this.getAccessToken();
        try {
            const rawResponse = await (0, axios_1.default)(this.prepareGoogleAdsServicePostRequestArgs("search", accessToken, {
                data: {
                    query: gaqlQuery,
                    ...requestOptions
                }
            }));
            const searchResponse = rawResponse.data;
            const results = searchResponse.results ?? [];
            const response = results.map((row)=>this.decamelizeKeysIfNeeded(row));
            const summaryRow = this.decamelizeKeysIfNeeded(searchResponse.summaryRow);
            const nextPageToken = searchResponse.nextPageToken;
            const totalResultsCount = searchResponse.totalResultsCount ? +searchResponse.totalResultsCount : undefined;
            return {
                response,
                nextPageToken,
                totalResultsCount,
                summaryRow
            };
        } catch (e) {
            if (e.response?.data.error.details[0]) {
                throw new protos_1.errors.GoogleAdsFailure(this.decamelizeKeysIfNeeded(e.response.data.error.details[0]));
            }
            throw e;
        }
    }
    async paginatedSearch(gaqlQuery, requestOptions) {
        /*
          When possible, use the searchStream method to avoid the overhead of pagination.
        */ if (requestOptions.page_size === undefined && requestOptions.search_settings === undefined // If search_settings is set, we can't use searchStream.
        ) {
            // If no pagination or summary options are set, we can use the non-paginated search method.
            const { response } = await this.useStreamToImitateRegularSearch(gaqlQuery, requestOptions);
            return {
                response
            };
        }
        const response = [];
        let nextPageToken = undefined;
        const initialSearch = await this.search(gaqlQuery, requestOptions);
        let totalResultsCount = initialSearch.totalResultsCount;
        // Sometimes (when no results?) the totalResultsCount field is not included in the response.
        // In this case, we set it to 0.
        if (requestOptions.search_settings?.return_total_results_count && initialSearch.totalResultsCount === undefined) {
            totalResultsCount = 0;
        }
        let summaryRow = initialSearch.summaryRow;
        response.push(...initialSearch.response);
        nextPageToken = initialSearch.nextPageToken;
        while(nextPageToken){
            const nextSearch = await this.search(gaqlQuery, {
                ...requestOptions,
                page_token: nextPageToken
            });
            response.push(...nextSearch.response);
            nextPageToken = nextSearch.nextPageToken;
            if (nextSearch.summaryRow) {
                summaryRow = nextSearch.summaryRow;
            }
        }
        if (summaryRow) {
            response.unshift(summaryRow);
        }
        return {
            response,
            totalResultsCount
        };
    }
    // Google's searchStream method is faster than search, but it does not support all features.
    // When report() is called, we use searchStream if possible, otherwise we use paginatedSearch.
    // Note that just like `paginatedSearch`, this method accumulates results in memory. Use
    // `reportStream` for a more memory-efficient alternative (at the cost of more CPU usage).
    async useStreamToImitateRegularSearch(gaqlQuery, requestOptions) {
        const accessToken = await this.getAccessToken();
        try {
            const args = this.prepareGoogleAdsServicePostRequestArgs("searchStream", accessToken, {
                responseType: "stream",
                data: {
                    query: gaqlQuery,
                    ...requestOptions
                }
            });
            const response = await (0, axios_1.default)(args);
            const stream = response.data;
            const buffers = [];
            let rowCount = -ROWS_PER_STREAMED_CHUNK;
            for await (const data of stream){
                if (this.clientOptions.max_reporting_rows && !this.gaqlQueryStringIncludesLimit(gaqlQuery)) {
                    // This is a quick-and-dirty way to count rows, but it's good enough for our purposes.
                    // We want to avoid using a proper JSON streamer here for performance reasons.
                    if (data.toString("utf-8").includes(`results":`)) {
                        rowCount += ROWS_PER_STREAMED_CHUNK;
                    }
                    if (rowCount > this.clientOptions.max_reporting_rows) {
                        throw this.generateTooManyRowsError();
                    }
                }
                buffers.push(data);
            }
            const asString = Buffer.concat(buffers).toString("utf-8");
            const accumulator = [];
            let foundSummaryRow;
            for (const { results, summaryRow } of JSON.parse(asString)){
                if (summaryRow) {
                    foundSummaryRow = this.decamelizeKeysIfNeeded(summaryRow);
                }
                accumulator.push(...(results ?? []).map((row)=>{
                    return this.decamelizeKeysIfNeeded(row);
                }));
                if (foundSummaryRow) {
                    accumulator.unshift(foundSummaryRow);
                }
            }
            return {
                response: accumulator
            };
        } catch (e) {
            await this.handleStreamError(e);
            throw e; // The line above should always throw.
        }
    }
    async querier(gaqlQuery, requestOptions = {}, reportOptions, useHooks = true) {
        const baseHookArguments = {
            credentials: this.credentials,
            query: gaqlQuery,
            reportOptions
        };
        if (this.hooks.onQueryStart && useHooks) {
            const queryCancellation = {
                cancelled: false
            };
            await this.hooks.onQueryStart({
                ...baseHookArguments,
                cancel: (res)=>{
                    queryCancellation.cancelled = true;
                    queryCancellation.res = res;
                },
                editOptions: (options)=>{
                    Object.entries(options).forEach(([key, val])=>{
                        // @ts-ignore
                        requestOptions[key] = val;
                    });
                }
            });
            if (queryCancellation.cancelled) {
                return {
                    response: queryCancellation.res
                };
            }
        }
        try {
            const { response, totalResultsCount } = await this.paginatedSearch(gaqlQuery, requestOptions);
            if (this.hooks.onQueryEnd && useHooks) {
                const queryResolution = {
                    resolved: false
                };
                await this.hooks.onQueryEnd({
                    ...baseHookArguments,
                    response,
                    resolve: (res)=>{
                        queryResolution.resolved = true;
                        queryResolution.res = res;
                    }
                });
                if (queryResolution.resolved) {
                    return {
                        response: queryResolution.res,
                        totalResultsCount
                    };
                }
            }
            return {
                response: response,
                totalResultsCount
            };
        } catch (searchError) {
            const googleAdsError = this.getGoogleAdsError(searchError);
            if (this.hooks.onQueryError && useHooks) {
                await this.hooks.onQueryError({
                    ...baseHookArguments,
                    error: googleAdsError
                });
            }
            throw googleAdsError;
        }
    }
    async *streamer(gaqlQuery, requestOptions = {}, reportOptions) {
        const baseHookArguments = {
            credentials: this.credentials,
            query: gaqlQuery,
            reportOptions
        };
        if (this.hooks.onStreamStart) {
            const queryStart = {
                cancelled: false
            };
            await this.hooks.onStreamStart({
                ...baseHookArguments,
                cancel: ()=>{
                    queryStart.cancelled = true;
                },
                editOptions: (options)=>{
                    Object.entries(options).forEach(([key, val])=>{
                        // @ts-expect-error
                        requestOptions[key] = val;
                    });
                }
            });
            if (queryStart.cancelled) {
                return;
            }
        }
        try {
            const accessToken = await this.getAccessToken();
            const args = this.prepareGoogleAdsServicePostRequestArgs("searchStream", accessToken, {
                responseType: "stream",
                data: {
                    query: gaqlQuery,
                    ...requestOptions
                }
            });
            const response = await (0, axios_1.default)(args);
            const stream = response.data;
            // The options below help to make the stream less CPU intensive.
            const parser = new stream_json_1.Parser({
                streamValues: false,
                streamKeys: false,
                packValues: true,
                packKeys: true
            });
            const pipeline = (0, stream_chain_1.chain)([
                stream,
                parser,
                (0, StreamArray_1.streamArray)()
            ]);
            let count = 0;
            for await (const data of pipeline){
                const results = data.value.results ?? (data.value.summaryRow ? [
                    data.value.summaryRow
                ] : undefined) ?? [];
                count += results.length;
                if (this.clientOptions.max_reporting_rows && count > this.clientOptions.max_reporting_rows && !this.gaqlQueryStringIncludesLimit(gaqlQuery)) {
                    throw this.generateTooManyRowsError();
                }
                for (const row of results){
                    const parsed = this.decamelizeKeysIfNeeded(row);
                    yield parsed;
                }
            }
            return;
        } catch (e) {
            try {
                await this.handleStreamError(e);
            } catch (_e) {
                if (this.hooks.onStreamError) {
                    await this.hooks.onStreamError({
                        ...baseHookArguments,
                        error: _e
                    });
                }
                throw _e;
            }
        }
    }
    async handleStreamError(e) {
        if (!e?.response?.data) {
            throw e;
        }
        // The error is a stream, so some effort is required to parse it.
        const stream = e.response.data;
        const pipeline = (0, stream_chain_1.chain)([
            stream,
            (0, stream_json_1.parser)(),
            (0, StreamArray_1.streamArray)()
        ]);
        const defaultErrorMessage = "Unknown GoogleAdsFailure";
        let googleAdsFailure = new Error(defaultErrorMessage);
        // Only throw the first error.
        pipeline.once("data", (data)=>{
            if (data?.value?.error?.details?.[0]) {
                googleAdsFailure = new protos_1.errors.GoogleAdsFailure(this.decamelizeKeysIfNeeded(data.value.error.details[0]));
            } else {
                googleAdsFailure = new Error(data?.value?.error?.message ?? defaultErrorMessage, {
                    cause: data?.value?.error ?? data?.value
                });
            }
        });
        // Must always reject.
        await new Promise((_, reject)=>{
            pipeline.on("end", ()=>reject(googleAdsFailure));
            pipeline.on("error", (err)=>reject(err));
        });
    }
    /**
     * @description Creates, updates, or removes resources. This method supports atomic transactions
     * with multiple types of resources. For example, you can atomically create a campaign and a
     * campaign budget, or perform up to thousands of mutates atomically.
     * @hooks onMutationStart, onMutationError, onMutationEnd
     */ async mutateResources(mutations, mutateOptions = {}) {
        const baseHookArguments = {
            credentials: this.credentials,
            method: "GoogleAdsService.mutate",
            mutations,
            isServiceCall: false
        };
        if (this.hooks.onMutationStart) {
            const mutationCancellation = {
                cancelled: false
            };
            await this.hooks.onMutationStart({
                ...baseHookArguments,
                cancel: (res)=>{
                    mutationCancellation.cancelled = true;
                    mutationCancellation.res = res;
                },
                editOptions: (options)=>{
                    Object.entries(options).forEach(([key, val])=>{
                        // @ts-ignore
                        mutateOptions[key] = val;
                    });
                }
            });
            if (mutationCancellation.cancelled) {
                return mutationCancellation.res;
            }
        }
        const { service, request } = this.buildMutationRequestAndService(mutations, mutateOptions);
        try {
            const response = (await service.mutate(request, {
                otherArgs: {
                    headers: this.callHeaders
                }
            }))[0];
            const parsedResponse = request.partial_failure ? this.decodePartialFailureError(response) : response;
            if (this.hooks.onMutationEnd) {
                const mutationResolution = {
                    resolved: false
                };
                await this.hooks.onMutationEnd({
                    ...baseHookArguments,
                    response: parsedResponse,
                    resolve: (res)=>{
                        mutationResolution.resolved = true;
                        mutationResolution.res = res;
                    }
                });
                if (mutationResolution.resolved) {
                    return mutationResolution.res;
                }
            }
            return parsedResponse;
        } catch (mutateError) {
            const googleAdsError = this.getGoogleAdsError(mutateError);
            if (this.hooks.onMutationError) {
                await this.hooks.onMutationError({
                    ...baseHookArguments,
                    error: googleAdsError
                });
            }
            throw googleAdsError;
        }
    }
    get googleAdsFields() {
        return {
            searchGoogleAdsFields: async (request)=>{
                const service = await this.loadService("GoogleAdsFieldServiceClient");
                return service.searchGoogleAdsFields(request, {
                    // @ts-expect-error This method does support call headers
                    otherArgs: {
                        headers: this.callHeaders
                    }
                });
            }
        };
    }
    prepareGoogleAdsServicePostRequestArgs(functionName, accessToken, extra) {
        return {
            method: "POST",
            url: `https://googleads.googleapis.com/${version_1.googleAdsVersion}/customers/${this.customerOptions.customer_id}/googleAds:${functionName}`,
            headers: {
                Authorization: `Bearer ${accessToken}`,
                ...this.callHeaders
            },
            ...extra
        };
    }
    decamelizeKeysIfNeeded(input) {
        if (this.clientOptions.disable_parsing) {
            return input;
        }
        return (0, parserRest_1.decamelizeKeys)(input);
    }
    gaqlQueryStringIncludesLimit(gaqlQuery) {
        return gaqlQuery.toLowerCase().includes("limit ");
    }
    generateTooManyRowsError() {
        return new Error(`Exceeded the maximum number of rows set by "max_reporting_rows" (${this.clientOptions.max_reporting_rows}).`);
    }
}
exports.Customer = Customer;
}}),
"[project]/node_modules/google-ads-api/build/src/client.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Client = void 0;
const customer_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/customer.js [app-route] (ecmascript)");
const service_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/service.js [app-route] (ecmascript)");
class Client {
    options;
    constructor(options){
        this.options = options;
    }
    Customer(customerOptions, hooks) {
        const cus = new customer_1.Customer(this.options, customerOptions, hooks);
        return cus;
    }
    async listAccessibleCustomers(refreshToken) {
        const service = new service_1.Service(this.options, {
            customer_id: "",
            refresh_token: refreshToken
        });
        // @ts-expect-error Protected usage is fine here
        const customerService = await service.loadService("CustomerServiceClient");
        try {
            // @ts-expect-error Type definition is incorrect, response is an array
            const [response] = await customerService.listAccessibleCustomers({}, {
                // @ts-expect-error Field not included in type definitions
                otherArgs: {
                    // @ts-expect-error Protected usage is fine here
                    headers: service.callHeaders
                }
            });
            return response;
        } catch (err) {
            console.log(err);
            // @ts-expect-error Protected usage is fine here
            throw service.getGoogleAdsError(err);
        }
    }
}
exports.Client = Client;
}}),
"[project]/node_modules/google-ads-api/build/src/parser.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParsingError = void 0;
exports.parse = parse;
exports.getGAQLFields = getGAQLFields;
exports.getReportOptionFields = getReportOptionFields;
exports.parseRows = parseRows;
const long_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/long/src/long.js [app-route] (ecmascript)"));
const protos_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/utils.js [app-route] (ecmascript)");
exports.ParsingError = {
    NO_REPORT_OPTIONS_OR_GAQL_QUERY: "Must provided reportOptions or gaqlString to parse results.",
    NO_FIELDS_IN_GAQL_QUERY: "GAQL Query must contain at least one attribute, metric or segment.",
    NO_FIELDS_IN_REPORT_OPTIONS: "Report Options must contain at least one attribute, metric or segment."
};
/**
  @description Parse the results of a query
  @example
  const parsedResults = parse({ results, reportOptions })
  const parsedResults = parse({ results, gaqlString })
*/ function parse({ results, reportOptions, gaqlString }) {
    if (results.length === 0) {
        return results;
    }
    if (typeof reportOptions === "undefined" && typeof gaqlString === "undefined") {
        throw new Error(exports.ParsingError.NO_REPORT_OPTIONS_OR_GAQL_QUERY);
    }
    const queryFields = reportOptions ? getReportOptionFields(reportOptions) : getGAQLFields(gaqlString);
    // Add in all relevant resource_name fields, which are always returned by API
    const entities = queryFields.map((field)=>field.split(".")[0]);
    const resourceNameFields = protos_1.fields.resourceNames.filter((resourceNameField)=>entities.includes(resourceNameField.split(".")[0]));
    const allFields = [
        ...queryFields,
        ...resourceNameFields
    ];
    return parseRows(results, allFields);
}
// This function assumes that a gaql query is of the format "select * * * from * ...".
// Queries that are not in this format should have thrown an error when called.
function getGAQLFields(gaqlString) {
    const normalisedQuery = (0, utils_1.normaliseQuery)(gaqlString);
    const fields = normalisedQuery.toLowerCase().replace(/(^\s*select)|( from .*)|(\s+)/g, "").split(",").filter((field)=>field.length > 0);
    if (!fields.length) {
        throw new Error(exports.ParsingError.NO_FIELDS_IN_GAQL_QUERY);
    }
    return fields;
}
function getReportOptionFields(reportOptions) {
    const fields = [
        ...reportOptions.attributes || [],
        ...reportOptions.metrics || [],
        ...reportOptions.segments || []
    ];
    if (!fields.length) {
        throw new Error(exports.ParsingError.NO_FIELDS_IN_REPORT_OPTIONS);
    }
    return fields;
}
function parseRows(rows, fields) {
    const fieldsPreSplit = {};
    // pre-split all the field strings for performance reasons (increases speed by ~5x for large number of rows)
    for (const field of fields){
        fieldsPreSplit[field] = field.split(".");
    }
    const newRows = [];
    for(let r = 0; r < rows.length; r++){
        const newRow = {};
        const originalRow = protos_1.services.GoogleAdsRow.fromObject(rows[r]);
        for(const split in fieldsPreSplit){
            // @ts-expect-error These are the best we can do for these types
            const [parent, ...children] = fieldsPreSplit[split];
            // Ignore null fields (unspecified resource names)
            if (!originalRow[parent]) {
                continue;
            }
            newRow[parent] = parseNestedValues(newRow[parent], originalRow[parent], parent, children);
        }
        newRows.push(newRow);
    }
    return newRows;
}
function parseNestedValues(row, data, field, paths) {
    if (!data) return null;
    const [parentField, ...childFields] = paths;
    if (!row) row = {};
    if (childFields.length === 0) {
        const rawVal = data[parentField];
        const parsedVal = long_1.default.isLong(rawVal) ? new long_1.default(rawVal.low, rawVal.high, rawVal.unsigned).toNumber() : rawVal;
        row[parentField] = parsedVal;
        return row;
    }
    row[parentField] = parseNestedValues(row[parentField], data[parentField], parentField, childFields);
    return row;
}
}}),
"[project]/node_modules/google-ads-api/build/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Customer = exports.ResourceNames = exports.parse = exports.toMicros = exports.fromMicros = exports.protobuf = exports.longrunning = exports.services = exports.resources = exports.errors = exports.fields = exports.enums = exports.common = exports.GoogleAdsApi = void 0;
// Core library client
var client_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/client.js [app-route] (ecmascript)");
Object.defineProperty(exports, "GoogleAdsApi", {
    enumerable: true,
    get: function() {
        return client_1.Client;
    }
});
// Compiled proto types
var index_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "common", {
    enumerable: true,
    get: function() {
        return index_1.common;
    }
});
Object.defineProperty(exports, "enums", {
    enumerable: true,
    get: function() {
        return index_1.enums;
    }
});
Object.defineProperty(exports, "fields", {
    enumerable: true,
    get: function() {
        return index_1.fields;
    }
});
Object.defineProperty(exports, "errors", {
    enumerable: true,
    get: function() {
        return index_1.errors;
    }
});
Object.defineProperty(exports, "resources", {
    enumerable: true,
    get: function() {
        return index_1.resources;
    }
});
Object.defineProperty(exports, "services", {
    enumerable: true,
    get: function() {
        return index_1.services;
    }
});
Object.defineProperty(exports, "longrunning", {
    enumerable: true,
    get: function() {
        return index_1.longrunning;
    }
});
Object.defineProperty(exports, "protobuf", {
    enumerable: true,
    get: function() {
        return index_1.protobuf;
    }
});
// Util functions
var utils_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/utils.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fromMicros", {
    enumerable: true,
    get: function() {
        return utils_1.fromMicros;
    }
});
Object.defineProperty(exports, "toMicros", {
    enumerable: true,
    get: function() {
        return utils_1.toMicros;
    }
});
var parser_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/parser.js [app-route] (ecmascript)");
Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
        return parser_1.parse;
    }
});
exports.ResourceNames = __importStar(__turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/protos/autogen/resourceNames.js [app-route] (ecmascript)"));
var customer_1 = __turbopack_context__.r("[project]/node_modules/google-ads-api/build/src/customer.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Customer", {
    enumerable: true,
    get: function() {
        return customer_1.Customer;
    }
});
}}),

};

//# sourceMappingURL=node_modules_google-ads-api_build_src_b6965885._.js.map