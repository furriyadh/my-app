module.exports = {

"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let result = "", cursor = 0;
    do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }while (~index)
    return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported)=>{
    let f = enabled ? formatter : ()=>String;
    return {
        isColorSupported: enabled,
        reset: f("\x1b[0m", "\x1b[0m"),
        bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
        dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
        italic: f("\x1b[3m", "\x1b[23m"),
        underline: f("\x1b[4m", "\x1b[24m"),
        inverse: f("\x1b[7m", "\x1b[27m"),
        hidden: f("\x1b[8m", "\x1b[28m"),
        strikethrough: f("\x1b[9m", "\x1b[29m"),
        black: f("\x1b[30m", "\x1b[39m"),
        red: f("\x1b[31m", "\x1b[39m"),
        green: f("\x1b[32m", "\x1b[39m"),
        yellow: f("\x1b[33m", "\x1b[39m"),
        blue: f("\x1b[34m", "\x1b[39m"),
        magenta: f("\x1b[35m", "\x1b[39m"),
        cyan: f("\x1b[36m", "\x1b[39m"),
        white: f("\x1b[37m", "\x1b[39m"),
        gray: f("\x1b[90m", "\x1b[39m"),
        bgBlack: f("\x1b[40m", "\x1b[49m"),
        bgRed: f("\x1b[41m", "\x1b[49m"),
        bgGreen: f("\x1b[42m", "\x1b[49m"),
        bgYellow: f("\x1b[43m", "\x1b[49m"),
        bgBlue: f("\x1b[44m", "\x1b[49m"),
        bgMagenta: f("\x1b[45m", "\x1b[49m"),
        bgCyan: f("\x1b[46m", "\x1b[49m"),
        bgWhite: f("\x1b[47m", "\x1b[49m"),
        blackBright: f("\x1b[90m", "\x1b[39m"),
        redBright: f("\x1b[91m", "\x1b[39m"),
        greenBright: f("\x1b[92m", "\x1b[39m"),
        yellowBright: f("\x1b[93m", "\x1b[39m"),
        blueBright: f("\x1b[94m", "\x1b[39m"),
        magentaBright: f("\x1b[95m", "\x1b[39m"),
        cyanBright: f("\x1b[96m", "\x1b[39m"),
        whiteBright: f("\x1b[97m", "\x1b[39m"),
        bgBlackBright: f("\x1b[100m", "\x1b[49m"),
        bgRedBright: f("\x1b[101m", "\x1b[49m"),
        bgGreenBright: f("\x1b[102m", "\x1b[49m"),
        bgYellowBright: f("\x1b[103m", "\x1b[49m"),
        bgBlueBright: f("\x1b[104m", "\x1b[49m"),
        bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
        bgCyanBright: f("\x1b[106m", "\x1b[49m"),
        bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
};
module.exports = createColors();
module.exports.createColors = createColors;
}}),
"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = '';
        // A compact alternative for `for (var i = 0; i < step; i++)`.
        let i = size | 0;
        while(i--){
            // `| 0` is more compact and faster than `Math.floor()`.
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
let nanoid = (size = 21)=>{
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while(i--){
        // `| 0` is more compact and faster than `Math.floor()`.
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
module.exports = {
    nanoid,
    customAlphabet
};
}}),
"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */ exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */ exports.decode = function(charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
}}),
"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var base64 = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)");
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */ function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */ function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */ exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }while (vlq > 0)
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    }while (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}}),
"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */ function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
        return aArgs[aName];
    } else if (arguments.length === 3) {
        return aDefaultValue;
    } else {
        throw new Error('"' + aName + '" is a required argument.');
    }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
        return null;
    }
    return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
    };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;
/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */ function lruMemoize(f) {
    var cache = [];
    return function(input) {
        for(var i = 0; i < cache.length; i++){
            if (cache[i].input === input) {
                var temp = cache[0];
                cache[0] = cache[i];
                cache[i] = temp;
                return cache[0].result;
            }
        }
        var result = f(input);
        cache.unshift({
            input,
            result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
        }
        return result;
    };
}
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */ var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
        if (!url.path) {
            return aPath;
        }
        path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while(true){
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
            parts.push(path.slice(start));
            break;
        } else {
            parts.push(path.slice(start, i));
            while(i < path.length && path[i] === "/"){
                i++;
            }
        }
    }
    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
        part = parts[i];
        if (part === '.') {
            parts.splice(i, 1);
        } else if (part === '..') {
            up++;
        } else if (up > 0) {
            if (part === '') {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
            } else {
                parts.splice(i, 2);
                up--;
            }
        }
    }
    path = parts.join('/');
    if (path === '') {
        path = isAbsolute ? '/' : '.';
    }
    if (url) {
        url.path = path;
        return urlGenerate(url);
    }
    return path;
});
exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */ function join(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    if (aPath === "") {
        aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
    }
    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
    }
    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
    }
    return joined;
}
exports.join = join;
exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */ function relative(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, '');
    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while(aPath.indexOf(aRoot + '/') !== 0){
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
            return aPath;
        }
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
        }
        ++level;
    }
    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function() {
    var obj = Object.create(null);
    return !('__proto__' in obj);
}();
function identity(s) {
    return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */ function toSetString(aStr) {
    if (isProtoString(aStr)) {
        return '$' + aStr;
    }
    return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
    if (isProtoString(aStr)) {
        return aStr.slice(1);
    }
    return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
    if (!s) {
        return false;
    }
    var length = s.length;
    if (length < 9 /* "__proto__".length */ ) {
        return false;
    }
    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {
        return false;
    }
    for(var i = length - 10; i >= 0; i--){
        if (s.charCodeAt(i) !== 36 /* '$' */ ) {
            return false;
        }
    }
    return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
        return 0;
    }
    if (aStr1 === null) {
        return 1; // aStr2 !== null
    }
    if (aStr2 === null) {
        return -1; // aStr1 !== null
    }
    if (aStr1 > aStr2) {
        return 1;
    }
    return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */ function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';
    if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
    }
    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}}),
"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */ function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for(var i = 0, len = aArray.length; i < len; i++){
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
exports.ArraySet = ArraySet;
}}),
"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */ function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */ function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
        generatedLine: -1,
        generatedColumn: 0
    };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */ MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    } else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */ MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
exports.MappingList = MappingList;
}}),
"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var MappingList = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */ function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
            generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
            }
        };
        if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
            };
            if (mapping.name != null) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
            return;
        }
    }
    if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
            this._sources.add(source);
        }
    }
    if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
            this._names.add(name);
        }
    }
    this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    });
};
/**
 * Set the source content for a source file.
 */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
        }
    }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
            });
            if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                    mapping.name = original.name;
                }
            }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
            newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
            newNames.add(name);
        }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
        }
    }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        // Cases 2 and 3.
        return;
    } else {
        var message = 'Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
        });
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for(var i = 0, len = mappings.length; i < len; i++){
        mapping = mappings[i];
        next = '';
        if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while(mapping.generatedLine !== previousGeneratedLine){
                next += ';';
                previousGeneratedLine++;
            }
        } else {
            if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                    continue;
                }
                next += ',';
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
        if (!this._sourcesContents) {
            return null;
        }
        if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
};
/**
 * Externalize the source map.
 */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
    };
    if (this._file != null) {
        map.file = this._file;
    }
    if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
};
/**
 * Render the source map being generated to a string.
 */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}}),
"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
    } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
        } else {
            return mid;
        }
    } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
        } else {
            return aLow < 0 ? -1 : aLow;
        }
    }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
        return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
        return -1;
    }
    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while(index - 1 >= 0){
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
        }
        --index;
    }
    return index;
};
}}),
"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
function SortTemplate(comparator) {
    /**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */ function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
    }
    /**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */ function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
    }
    /**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */ function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
        if (p < r) {
            // (1) Partitioning.
            //
            // The partitioning chooses a pivot between `p` and `r` and moves all
            // elements that are less than or equal to the pivot to the before it, and
            // all the elements that are greater than it after it. The effect is that
            // once partition is done, the pivot is in the exact place it will be when
            // the array is put in sorted order, and it will not need to be moved
            // again. This runs in O(n) time.
            // Always choose a random pivot so that an input array which is reverse
            // sorted does not cause O(n^2) running time.
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            // Immediately after `j` is incremented in this loop, the following hold
            // true:
            //
            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
            //
            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
            for(var j = p; j < r; j++){
                if (comparator(ary[j], pivot, false) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            // (2) Recurse on each half.
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
        }
    }
    return doQuickSort;
}
function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */ let sortCache = new WeakMap();
exports.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
};
}}),
"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var binarySearch = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var quickSort = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)").quickSort;
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */ SourceMapConsumer.prototype._version = 3;
// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch(order){
        case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
        case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
        default:
            throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;
    for(var i = 0, n = mappings.length; i < n; i++){
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        if (source !== null) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
        });
    }
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
        return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while(mapping && mapping.originalLine === originalLine){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        } else {
            var originalColumn = mapping.originalColumn;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        }
    }
    return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);
    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
    }
    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for(i = 0; i < this._absoluteSources.length; ++i){
        if (this._absoluteSources[i] == aSource) {
            return i;
        }
    }
    return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for(var i = 0, length = generatedMappings.length; i < length; i++){
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */ BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function() {
        return this._absoluteSources.slice();
    }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */ function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;
    if (n <= 1) {
        return;
    } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
            array[start] = b;
            array[start + 1] = a;
        }
    } else if (n < 20) {
        for(let i = start; i < l; i++){
            for(let j = i; j > start; j--){
                let a = array[j - 1];
                let b = array[j];
                if (compareGenerated(a, b) <= 0) {
                    break;
                }
                array[j - 1] = b;
                array[j] = a;
            }
        }
    } else {
        quickSort(array, compareGenerated, start);
    }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while(index < length){
        if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ',') {
            index++;
        } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for(end = index; end < length; end++){
                if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                }
            }
            str = aStr.slice(index, end);
            segment = [];
            while(index < end){
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
            }
            if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
            }
            if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
            }
            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
                let currentSource = mapping.source;
                while(originalMappings.length <= currentSource){
                    originalMappings.push(null);
                }
                if (originalMappings[currentSource] === null) {
                    originalMappings[currentSource] = [];
                }
                originalMappings[currentSource].push(mapping);
            }
        }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for(var i = 0; i < originalMappings.length; i++){
        if (originalMappings[i] != null) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
    }
    this.__originalMappings = [].concat(...originalMappings);
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for(var index = 0; index < this._generatedMappings.length; ++index){
        var mapping = this._generatedMappings[index];
        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
            }
        }
        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
    }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
                name = this._names.at(name);
            }
            return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
            };
        }
    }
    return {
        source: null,
        line: null,
        column: null,
        name: null
    };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
        return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
        return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
        return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
    }
    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
        return {
            line: null,
            column: null,
            lastColumn: null
        };
    }
    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
            return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
        }
    }
    return {
        line: null,
        column: null,
        lastColumn: null
    };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
        line: -1,
        column: 0
    };
    this._sections = sections.map(function(s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        };
    });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */ IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function() {
        var sources = [];
        for(var i = 0; i < this._sections.length; i++){
            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
            return cmp;
        }
        return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
        return {
            source: null,
            line: null,
            column: null,
            name: null
        };
    }
    return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
    });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === '') {
            return content;
        }
    }
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
            var ret = {
                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
        }
    }
    return {
        line: null,
        column: null
    };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for(var j = 0; j < sectionMappings.length; j++){
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            if (source !== null) {
                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            }
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
            }
            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
            }
        }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}}),
"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;
// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;
// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();
    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        "TURBOPACK unreachable";
        function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
    };
    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
            // The remaining code is added without mapping
            } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[remainingLinesIndex] || '';
                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
            }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while(lastGeneratedLine < mapping.generatedLine){
            node.add(shiftNextLine());
            lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
        }
    });
    return node;
    "TURBOPACK unreachable";
    function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
            node.add(code);
        } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
    }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
            this.add(chunk);
        }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
            this.children.push(aChunk);
        }
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
        for(var i = aChunk.length - 1; i >= 0; i--){
            this.prepend(aChunk[i]);
        }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for(var i = 0, len = this.children.length; i < len; i++){
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
            chunk.walk(aFn);
        } else {
            if (chunk !== '') {
                aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }
        }
    }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */ SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
        newChildren = [];
        for(i = 0; i < len - 1; i++){
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
    }
    return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
        this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for(var i = 0, len = this.children.length; i < len; i++){
        if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
        }
    }
    var sources = Object.keys(this.sourceContents);
    for(var i = 0, len = sources.length; i < len; i++){
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */ SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
        str += chunk;
    });
    return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({
                    source: original.source,
                    original: {
                        line: original.line,
                        column: original.column
                    },
                    generated: {
                        line: generated.line,
                        column: generated.column
                    },
                    name: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
        } else if (sourceMappingActive) {
            map.addMapping({
                generated: {
                    line: generated.line,
                    column: generated.column
                }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
        }
        for(var idx = 0, length = chunk.length; idx < length; idx++){
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                // Mappings end at eol
                if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                } else if (sourceMappingActive) {
                    map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                }
            } else {
                generated.column++;
            }
        }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
    });
    return {
        code: generated.code,
        map: map
    };
};
exports.SourceNode = SourceNode;
}}),
"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
exports.SourceMapConsumer = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)").SourceMapConsumer;
exports.SourceNode = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)").SourceNode;
}}),
"[project]/node_modules/cssesc/cssesc.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! https://mths.be/cssesc v3.0.0 by @mathias */ 'use strict';
var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
    if (!options) {
        return defaults;
    }
    var result = {};
    for(var key in defaults){
        // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
        // only recognized option names are used.
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
    }
    return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
    options = merge(options, cssesc.options);
    if (options.quotes != 'single' && options.quotes != 'double') {
        options.quotes = 'single';
    }
    var quote = options.quotes == 'double' ? '"' : '\'';
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = '';
    var counter = 0;
    var length = string.length;
    while(counter < length){
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        // If it’s not a printable ASCII character…
        if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
                // It’s a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                    // next character is low surrogate
                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
                } else {
                    // It’s an unmatched surrogate; only append this code unit, in case
                    // the next code unit is the high surrogate of a surrogate pair.
                    counter--;
                }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        } else {
            if (options.escapeEverything) {
                if (regexAnySingleEscape.test(character)) {
                    value = '\\' + character;
                } else {
                    value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
                }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
                value = '\\' + character;
            } else {
                value = character;
            }
        }
        output += value;
    }
    if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
        } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
        }
    }
    // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
    // since they’re redundant. Note that this is only possible if the escape
    // sequence isn’t preceded by an odd number of backslashes.
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
            // It’s not safe to remove the space, so don’t.
            return $0;
        }
        // Strip the space.
        return ($1 || '') + $2;
    });
    if (!isIdentifier && options.wrap) {
        return quote + output + quote;
    }
    return output;
};
// Expose default options (so they can be overridden globally).
cssesc.options = {
    'escapeEverything': false,
    'isIdentifier': false,
    'quotes': 'single',
    'wrap': false
};
cssesc.version = '3.0.0';
module.exports = cssesc;
}}),
"[project]/node_modules/util-deprecate/node.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").deprecate;
}}),
"[project]/node_modules/postcss-nested/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let parser = __turbopack_context__.r("[project]/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function parse(str, rule) {
    let nodes;
    let saver = parser((parsed)=>{
        nodes = parsed;
    });
    try {
        saver.processSync(str);
    } catch (e) {
        if (str.includes(':')) {
            throw rule ? rule.error('Missed semicolon') : e;
        } else {
            throw rule ? rule.error(e.message) : e;
        }
    }
    return nodes.at(0);
}
function replace(nodes, parent) {
    let replaced = false;
    nodes.each((i)=>{
        if (i.type === 'nesting') {
            let clonedParent = parent.clone();
            if (i.value !== '&') {
                i.replaceWith(parse(i.value.replace('&', clonedParent.toString())));
            } else {
                i.replaceWith(clonedParent);
            }
            replaced = true;
        } else if (i.nodes) {
            if (replace(i, parent)) {
                replaced = true;
            }
        }
    });
    return replaced;
}
function selectors(parent, child) {
    let result = [];
    parent.selectors.forEach((i)=>{
        let parentNode = parse(i, parent);
        child.selectors.forEach((j)=>{
            if (j.length) {
                let node = parse(j, child);
                let replaced = replace(node, parentNode);
                if (!replaced) {
                    node.prepend(parser.combinator({
                        value: ' '
                    }));
                    node.prepend(parentNode.clone());
                }
                result.push(node.toString());
            }
        });
    });
    return result;
}
function pickComment(comment, after) {
    if (comment && comment.type === 'comment') {
        after.after(comment);
        return comment;
    } else {
        return after;
    }
}
function createFnAtruleChilds(bubble) {
    return function atruleChilds(rule, atrule, bubbling) {
        let children = [];
        atrule.each((child)=>{
            if (child.type === 'comment') {
                children.push(child);
            } else if (child.type === 'decl') {
                children.push(child);
            } else if (child.type === 'rule' && bubbling) {
                child.selectors = selectors(rule, child);
            } else if (child.type === 'atrule') {
                if (child.nodes && bubble[child.name]) {
                    atruleChilds(rule, child, true);
                } else {
                    children.push(child);
                }
            }
        });
        if (bubbling) {
            if (children.length) {
                let clone = rule.clone({
                    nodes: []
                });
                for (let child of children){
                    clone.append(child);
                }
                atrule.prepend(clone);
            }
        }
    };
}
function pickDeclarations(selector, declarations, after, Rule) {
    let parent = new Rule({
        selector,
        nodes: []
    });
    for (let declaration of declarations){
        parent.append(declaration);
    }
    after.after(parent);
    return parent;
}
function atruleNames(defaults, custom) {
    let list = {};
    for (let i of defaults){
        list[i] = true;
    }
    if (custom) {
        for (let i of custom){
            let name = i.replace(/^@/, '');
            list[name] = true;
        }
    }
    return list;
}
module.exports = (opts = {})=>{
    let bubble = atruleNames([
        'media',
        'supports'
    ], opts.bubble);
    let atruleChilds = createFnAtruleChilds(bubble);
    let unwrap = atruleNames([
        'document',
        'font-face',
        'keyframes',
        '-webkit-keyframes',
        '-moz-keyframes'
    ], opts.unwrap);
    let preserveEmpty = opts.preserveEmpty;
    return {
        postcssPlugin: 'postcss-nested',
        Rule (rule, { Rule }) {
            let unwrapped = false;
            let after = rule;
            let copyDeclarations = false;
            let declarations = [];
            rule.each((child)=>{
                if (child.type === 'rule') {
                    if (declarations.length) {
                        after = pickDeclarations(rule.selector, declarations, after, Rule);
                        declarations = [];
                    }
                    copyDeclarations = true;
                    unwrapped = true;
                    child.selectors = selectors(rule, child);
                    after = pickComment(child.prev(), after);
                    after.after(child);
                    after = child;
                } else if (child.type === 'atrule') {
                    if (declarations.length) {
                        after = pickDeclarations(rule.selector, declarations, after, Rule);
                        declarations = [];
                    }
                    if (child.name === 'at-root') {
                        unwrapped = true;
                        atruleChilds(rule, child, false);
                        let nodes = child.nodes;
                        if (child.params) {
                            nodes = new Rule({
                                selector: child.params,
                                nodes
                            });
                        }
                        after.after(nodes);
                        after = nodes;
                        child.remove();
                    } else if (bubble[child.name]) {
                        copyDeclarations = true;
                        unwrapped = true;
                        atruleChilds(rule, child, true);
                        after = pickComment(child.prev(), after);
                        after.after(child);
                        after = child;
                    } else if (unwrap[child.name]) {
                        copyDeclarations = true;
                        unwrapped = true;
                        atruleChilds(rule, child, false);
                        after = pickComment(child.prev(), after);
                        after.after(child);
                        after = child;
                    } else if (copyDeclarations) {
                        declarations.push(child);
                    }
                } else if (child.type === 'decl' && copyDeclarations) {
                    declarations.push(child);
                }
            });
            if (declarations.length) {
                after = pickDeclarations(rule.selector, declarations, after, Rule);
            }
            if (unwrapped && preserveEmpty !== true) {
                rule.raws.semicolon = true;
                if (rule.nodes.length === 0) rule.remove();
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/node-releases/data/processed/envs.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("[{\"name\":\"nodejs\",\"version\":\"0.2.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.3.8.0\"},{\"name\":\"nodejs\",\"version\":\"0.3.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.5.1.0\"},{\"name\":\"nodejs\",\"version\":\"0.4.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.2.0\"},{\"name\":\"nodejs\",\"version\":\"0.5.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.8.25\"},{\"name\":\"nodejs\",\"version\":\"0.6.0\",\"date\":\"2011-11-04\",\"lts\":false,\"security\":false,\"v8\":\"3.6.6.6\"},{\"name\":\"nodejs\",\"version\":\"0.7.0\",\"date\":\"2012-01-17\",\"lts\":false,\"security\":false,\"v8\":\"3.8.6.0\"},{\"name\":\"nodejs\",\"version\":\"0.8.0\",\"date\":\"2012-06-22\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.10\"},{\"name\":\"nodejs\",\"version\":\"0.9.0\",\"date\":\"2012-07-20\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.15\"},{\"name\":\"nodejs\",\"version\":\"0.10.0\",\"date\":\"2013-03-11\",\"lts\":false,\"security\":false,\"v8\":\"3.14.5.8\"},{\"name\":\"nodejs\",\"version\":\"0.11.0\",\"date\":\"2013-03-28\",\"lts\":false,\"security\":false,\"v8\":\"3.17.13.0\"},{\"name\":\"nodejs\",\"version\":\"0.12.0\",\"date\":\"2015-02-06\",\"lts\":false,\"security\":false,\"v8\":\"3.28.73.0\"},{\"name\":\"nodejs\",\"version\":\"4.0.0\",\"date\":\"2015-09-08\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.30\"},{\"name\":\"nodejs\",\"version\":\"4.1.0\",\"date\":\"2015-09-17\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.33\"},{\"name\":\"nodejs\",\"version\":\"4.2.0\",\"date\":\"2015-10-12\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.3.0\",\"date\":\"2016-02-09\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.4.0\",\"date\":\"2016-03-08\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.5.0\",\"date\":\"2016-08-16\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.6.0\",\"date\":\"2016-09-27\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.7.0\",\"date\":\"2016-12-06\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.43\"},{\"name\":\"nodejs\",\"version\":\"4.8.0\",\"date\":\"2017-02-21\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.45\"},{\"name\":\"nodejs\",\"version\":\"4.9.0\",\"date\":\"2018-03-28\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.53\"},{\"name\":\"nodejs\",\"version\":\"5.0.0\",\"date\":\"2015-10-29\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.28\"},{\"name\":\"nodejs\",\"version\":\"5.1.0\",\"date\":\"2015-11-17\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.2.0\",\"date\":\"2015-12-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.3.0\",\"date\":\"2015-12-15\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.4.0\",\"date\":\"2016-01-06\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.5.0\",\"date\":\"2016-01-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.6.0\",\"date\":\"2016-02-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.7.0\",\"date\":\"2016-02-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.8.0\",\"date\":\"2016-03-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.9.0\",\"date\":\"2016-03-16\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.10.0\",\"date\":\"2016-04-01\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.11.0\",\"date\":\"2016-04-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.12.0\",\"date\":\"2016-06-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.32\"},{\"name\":\"nodejs\",\"version\":\"6.0.0\",\"date\":\"2016-04-26\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.1.0\",\"date\":\"2016-05-05\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.2.0\",\"date\":\"2016-05-17\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.47\"},{\"name\":\"nodejs\",\"version\":\"6.3.0\",\"date\":\"2016-07-06\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.52\"},{\"name\":\"nodejs\",\"version\":\"6.4.0\",\"date\":\"2016-08-12\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.60\"},{\"name\":\"nodejs\",\"version\":\"6.5.0\",\"date\":\"2016-08-26\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.81\"},{\"name\":\"nodejs\",\"version\":\"6.6.0\",\"date\":\"2016-09-14\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.7.0\",\"date\":\"2016-09-27\",\"lts\":false,\"security\":true,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.8.0\",\"date\":\"2016-10-12\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.9.0\",\"date\":\"2016-10-18\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.10.0\",\"date\":\"2017-02-21\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.93\"},{\"name\":\"nodejs\",\"version\":\"6.11.0\",\"date\":\"2017-06-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.102\"},{\"name\":\"nodejs\",\"version\":\"6.12.0\",\"date\":\"2017-11-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.108\"},{\"name\":\"nodejs\",\"version\":\"6.13.0\",\"date\":\"2018-02-10\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.14.0\",\"date\":\"2018-03-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.15.0\",\"date\":\"2018-11-27\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.16.0\",\"date\":\"2018-12-26\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.17.0\",\"date\":\"2019-02-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"7.0.0\",\"date\":\"2016-10-25\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.1.0\",\"date\":\"2016-11-08\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.2.0\",\"date\":\"2016-11-22\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.43\"},{\"name\":\"nodejs\",\"version\":\"7.3.0\",\"date\":\"2016-12-20\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.4.0\",\"date\":\"2017-01-04\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.5.0\",\"date\":\"2017-01-31\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.48\"},{\"name\":\"nodejs\",\"version\":\"7.6.0\",\"date\":\"2017-02-21\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.40\"},{\"name\":\"nodejs\",\"version\":\"7.7.0\",\"date\":\"2017-02-28\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.41\"},{\"name\":\"nodejs\",\"version\":\"7.8.0\",\"date\":\"2017-03-29\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.9.0\",\"date\":\"2017-04-11\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.10.0\",\"date\":\"2017-05-02\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"8.0.0\",\"date\":\"2017-05-30\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.1.0\",\"date\":\"2017-06-08\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.2.0\",\"date\":\"2017-07-19\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.3.0\",\"date\":\"2017-08-08\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.4.0\",\"date\":\"2017-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.5.0\",\"date\":\"2017-09-12\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.6.0\",\"date\":\"2017-09-26\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.7.0\",\"date\":\"2017-10-11\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.8.0\",\"date\":\"2017-10-24\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.9.0\",\"date\":\"2017-10-31\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.1.534.46\"},{\"name\":\"nodejs\",\"version\":\"8.10.0\",\"date\":\"2018-03-06\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.11.0\",\"date\":\"2018-03-28\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.12.0\",\"date\":\"2018-09-10\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.66\"},{\"name\":\"nodejs\",\"version\":\"8.13.0\",\"date\":\"2018-11-20\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.75\"},{\"name\":\"nodejs\",\"version\":\"8.16.0\",\"date\":\"2019-04-16\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.77\"},{\"name\":\"nodejs\",\"version\":\"8.17.0\",\"date\":\"2019-12-17\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.78\"},{\"name\":\"nodejs\",\"version\":\"9.0.0\",\"date\":\"2017-10-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.1.0\",\"date\":\"2017-11-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.2.0\",\"date\":\"2017-11-14\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.44\"},{\"name\":\"nodejs\",\"version\":\"9.3.0\",\"date\":\"2017-12-12\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.4.0\",\"date\":\"2018-01-10\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.5.0\",\"date\":\"2018-01-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.6.0\",\"date\":\"2018-02-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.7.0\",\"date\":\"2018-03-01\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.8.0\",\"date\":\"2018-03-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.9.0\",\"date\":\"2018-03-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.10.0\",\"date\":\"2018-03-28\",\"lts\":false,\"security\":true,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.11.0\",\"date\":\"2018-04-04\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"10.0.0\",\"date\":\"2018-04-24\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.24\"},{\"name\":\"nodejs\",\"version\":\"10.1.0\",\"date\":\"2018-05-08\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.27\"},{\"name\":\"nodejs\",\"version\":\"10.2.0\",\"date\":\"2018-05-23\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.3.0\",\"date\":\"2018-05-29\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.4.0\",\"date\":\"2018-06-06\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.43\"},{\"name\":\"nodejs\",\"version\":\"10.5.0\",\"date\":\"2018-06-20\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.6.0\",\"date\":\"2018-07-04\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.7.0\",\"date\":\"2018-07-18\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.8.0\",\"date\":\"2018-08-01\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.9.0\",\"date\":\"2018-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.24\"},{\"name\":\"nodejs\",\"version\":\"10.10.0\",\"date\":\"2018-09-06\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.30\"},{\"name\":\"nodejs\",\"version\":\"10.11.0\",\"date\":\"2018-09-19\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.12.0\",\"date\":\"2018-10-10\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.13.0\",\"date\":\"2018-10-30\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.16.0\",\"date\":\"2019-05-28\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.17.0\",\"date\":\"2019-10-22\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.18.0\",\"date\":\"2019-12-17\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.19.0\",\"date\":\"2020-02-05\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.20.0\",\"date\":\"2020-03-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.21.0\",\"date\":\"2020-06-02\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.22.0\",\"date\":\"2020-07-21\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.23.0\",\"date\":\"2020-10-27\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.24.0\",\"date\":\"2021-02-23\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"11.0.0\",\"date\":\"2018-10-23\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.28\"},{\"name\":\"nodejs\",\"version\":\"11.1.0\",\"date\":\"2018-10-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.32\"},{\"name\":\"nodejs\",\"version\":\"11.2.0\",\"date\":\"2018-11-15\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.3.0\",\"date\":\"2018-11-27\",\"lts\":false,\"security\":true,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.4.0\",\"date\":\"2018-12-07\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.5.0\",\"date\":\"2018-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.6.0\",\"date\":\"2018-12-26\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.7.0\",\"date\":\"2019-01-17\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.8.0\",\"date\":\"2019-01-24\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.9.0\",\"date\":\"2019-01-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.10.0\",\"date\":\"2019-02-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.11.0\",\"date\":\"2019-03-05\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.12.0\",\"date\":\"2019-03-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.13.0\",\"date\":\"2019-03-28\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.14.0\",\"date\":\"2019-04-10\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.15.0\",\"date\":\"2019-04-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"12.0.0\",\"date\":\"2019-04-23\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.1.0\",\"date\":\"2019-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.2.0\",\"date\":\"2019-05-07\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.3.0\",\"date\":\"2019-05-21\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.4.0\",\"date\":\"2019-06-04\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.5.0\",\"date\":\"2019-06-26\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.6.0\",\"date\":\"2019-07-03\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.7.0\",\"date\":\"2019-07-23\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.8.0\",\"date\":\"2019-08-06\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.9.0\",\"date\":\"2019-08-20\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.10.0\",\"date\":\"2019-09-04\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.11.0\",\"date\":\"2019-09-25\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.11\"},{\"name\":\"nodejs\",\"version\":\"12.12.0\",\"date\":\"2019-10-11\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.13.0\",\"date\":\"2019-10-21\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.14.0\",\"date\":\"2019-12-17\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.15.0\",\"date\":\"2020-02-05\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.16.0\",\"date\":\"2020-02-11\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.17.0\",\"date\":\"2020-05-26\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.18.0\",\"date\":\"2020-06-02\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.19.0\",\"date\":\"2020-10-06\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.20.0\",\"date\":\"2020-11-24\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.21.0\",\"date\":\"2021-02-23\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.22.0\",\"date\":\"2021-03-30\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"13.0.0\",\"date\":\"2019-10-22\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.1.0\",\"date\":\"2019-11-05\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.2.0\",\"date\":\"2019-11-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.23\"},{\"name\":\"nodejs\",\"version\":\"13.3.0\",\"date\":\"2019-12-03\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.4.0\",\"date\":\"2019-12-17\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.5.0\",\"date\":\"2019-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.6.0\",\"date\":\"2020-01-07\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.7.0\",\"date\":\"2020-01-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.8.0\",\"date\":\"2020-02-05\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.9.0\",\"date\":\"2020-02-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.10.0\",\"date\":\"2020-03-04\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.11.0\",\"date\":\"2020-03-12\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.12.0\",\"date\":\"2020-03-26\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.13.0\",\"date\":\"2020-04-14\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.14.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"14.0.0\",\"date\":\"2020-04-21\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.30\"},{\"name\":\"nodejs\",\"version\":\"14.1.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.2.0\",\"date\":\"2020-05-05\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.3.0\",\"date\":\"2020-05-19\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.4.0\",\"date\":\"2020-06-02\",\"lts\":false,\"security\":true,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.5.0\",\"date\":\"2020-06-30\",\"lts\":false,\"security\":false,\"v8\":\"8.3.110.9\"},{\"name\":\"nodejs\",\"version\":\"14.6.0\",\"date\":\"2020-07-20\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.7.0\",\"date\":\"2020-07-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.8.0\",\"date\":\"2020-08-11\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.9.0\",\"date\":\"2020-08-27\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.10.0\",\"date\":\"2020-09-08\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.11.0\",\"date\":\"2020-09-15\",\"lts\":false,\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.12.0\",\"date\":\"2020-09-22\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.13.0\",\"date\":\"2020-09-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.14.0\",\"date\":\"2020-10-15\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.15.0\",\"date\":\"2020-10-27\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.16.0\",\"date\":\"2021-02-23\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.17.0\",\"date\":\"2021-05-11\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.18.0\",\"date\":\"2021-09-28\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.19.0\",\"date\":\"2022-02-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.20.0\",\"date\":\"2022-07-07\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.21.0\",\"date\":\"2022-11-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"15.0.0\",\"date\":\"2020-10-20\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.16\"},{\"name\":\"nodejs\",\"version\":\"15.1.0\",\"date\":\"2020-11-04\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.2.0\",\"date\":\"2020-11-10\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.3.0\",\"date\":\"2020-11-24\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.4.0\",\"date\":\"2020-12-09\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.5.0\",\"date\":\"2020-12-22\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.6.0\",\"date\":\"2021-01-14\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.7.0\",\"date\":\"2021-01-25\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.8.0\",\"date\":\"2021-02-02\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.9.0\",\"date\":\"2021-02-18\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.10.0\",\"date\":\"2021-02-23\",\"lts\":false,\"security\":true,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.11.0\",\"date\":\"2021-03-03\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.12.0\",\"date\":\"2021-03-17\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.13.0\",\"date\":\"2021-03-31\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.14.0\",\"date\":\"2021-04-06\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"16.0.0\",\"date\":\"2021-04-20\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.17\"},{\"name\":\"nodejs\",\"version\":\"16.1.0\",\"date\":\"2021-05-04\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.24\"},{\"name\":\"nodejs\",\"version\":\"16.2.0\",\"date\":\"2021-05-19\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.3.0\",\"date\":\"2021-06-03\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.4.0\",\"date\":\"2021-06-23\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.36\"},{\"name\":\"nodejs\",\"version\":\"16.5.0\",\"date\":\"2021-07-14\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.38\"},{\"name\":\"nodejs\",\"version\":\"16.6.0\",\"date\":\"2021-07-29\",\"lts\":false,\"security\":true,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.7.0\",\"date\":\"2021-08-18\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.8.0\",\"date\":\"2021-08-25\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.9.0\",\"date\":\"2021-09-07\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.16\"},{\"name\":\"nodejs\",\"version\":\"16.10.0\",\"date\":\"2021-09-22\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.19\"},{\"name\":\"nodejs\",\"version\":\"16.11.0\",\"date\":\"2021-10-08\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.12.0\",\"date\":\"2021-10-20\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.13.0\",\"date\":\"2021-10-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.14.0\",\"date\":\"2022-02-08\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.15.0\",\"date\":\"2022-04-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.16.0\",\"date\":\"2022-07-07\",\"lts\":\"Gallium\",\"security\":true,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.17.0\",\"date\":\"2022-08-16\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.18.0\",\"date\":\"2022-10-12\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.19.0\",\"date\":\"2022-12-13\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.20.0\",\"date\":\"2023-03-28\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"17.0.0\",\"date\":\"2021-10-19\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.21\"},{\"name\":\"nodejs\",\"version\":\"17.1.0\",\"date\":\"2021-11-09\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.25\"},{\"name\":\"nodejs\",\"version\":\"17.2.0\",\"date\":\"2021-11-30\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.14\"},{\"name\":\"nodejs\",\"version\":\"17.3.0\",\"date\":\"2021-12-17\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.4.0\",\"date\":\"2022-01-18\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.5.0\",\"date\":\"2022-02-10\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.6.0\",\"date\":\"2022-02-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.7.0\",\"date\":\"2022-03-09\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.8.0\",\"date\":\"2022-03-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.9.0\",\"date\":\"2022-04-07\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"18.0.0\",\"date\":\"2022-04-18\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.1.0\",\"date\":\"2022-05-03\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.2.0\",\"date\":\"2022-05-17\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.3.0\",\"date\":\"2022-06-02\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.4.0\",\"date\":\"2022-06-16\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.5.0\",\"date\":\"2022-07-06\",\"lts\":false,\"security\":true,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.6.0\",\"date\":\"2022-07-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.7.0\",\"date\":\"2022-07-26\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.8.0\",\"date\":\"2022-08-24\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.9.0\",\"date\":\"2022-09-07\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.10.0\",\"date\":\"2022-09-28\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.11.0\",\"date\":\"2022-10-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.12.0\",\"date\":\"2022-10-25\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.13.0\",\"date\":\"2023-01-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.14.0\",\"date\":\"2023-02-01\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.15.0\",\"date\":\"2023-03-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.16.0\",\"date\":\"2023-04-12\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.17.0\",\"date\":\"2023-07-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.18.0\",\"date\":\"2023-09-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.19.0\",\"date\":\"2023-11-29\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.20.0\",\"date\":\"2024-03-26\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"19.0.0\",\"date\":\"2022-10-17\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.13\"},{\"name\":\"nodejs\",\"version\":\"19.1.0\",\"date\":\"2022-11-14\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.20\"},{\"name\":\"nodejs\",\"version\":\"19.2.0\",\"date\":\"2022-11-29\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.20\"},{\"name\":\"nodejs\",\"version\":\"19.3.0\",\"date\":\"2022-12-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.21\"},{\"name\":\"nodejs\",\"version\":\"19.4.0\",\"date\":\"2023-01-05\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.5.0\",\"date\":\"2023-01-24\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.6.0\",\"date\":\"2023-02-01\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.7.0\",\"date\":\"2023-02-21\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.8.0\",\"date\":\"2023-03-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.9.0\",\"date\":\"2023-04-10\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"20.0.0\",\"date\":\"2023-04-17\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.4\"},{\"name\":\"nodejs\",\"version\":\"20.1.0\",\"date\":\"2023-05-03\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.2.0\",\"date\":\"2023-05-16\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.3.0\",\"date\":\"2023-06-08\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.4.0\",\"date\":\"2023-07-04\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.5.0\",\"date\":\"2023-07-19\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.6.0\",\"date\":\"2023-08-23\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.7.0\",\"date\":\"2023-09-18\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.8.0\",\"date\":\"2023-09-28\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.9.0\",\"date\":\"2023-10-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.10.0\",\"date\":\"2023-11-22\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.11.0\",\"date\":\"2024-01-09\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.12.0\",\"date\":\"2024-03-26\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.13.0\",\"date\":\"2024-05-07\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.14.0\",\"date\":\"2024-05-28\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.15.0\",\"date\":\"2024-06-20\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.16.0\",\"date\":\"2024-07-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.17.0\",\"date\":\"2024-08-21\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.18.0\",\"date\":\"2024-10-03\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"21.0.0\",\"date\":\"2023-10-17\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.13\"},{\"name\":\"nodejs\",\"version\":\"21.1.0\",\"date\":\"2023-10-24\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.15\"},{\"name\":\"nodejs\",\"version\":\"21.2.0\",\"date\":\"2023-11-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.3.0\",\"date\":\"2023-11-30\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.4.0\",\"date\":\"2023-12-05\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.5.0\",\"date\":\"2023-12-19\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.6.0\",\"date\":\"2024-01-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.7.0\",\"date\":\"2024-03-06\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"22.0.0\",\"date\":\"2024-04-24\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.1.0\",\"date\":\"2024-05-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.2.0\",\"date\":\"2024-05-15\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.3.0\",\"date\":\"2024-06-11\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.20\"},{\"name\":\"nodejs\",\"version\":\"22.4.0\",\"date\":\"2024-07-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.5.0\",\"date\":\"2024-07-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.6.0\",\"date\":\"2024-08-06\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.7.0\",\"date\":\"2024-08-21\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.8.0\",\"date\":\"2024-09-03\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.9.0\",\"date\":\"2024-09-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.10.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.11.0\",\"date\":\"2024-10-29\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.12.0\",\"date\":\"2024-12-02\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"23.0.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.26\"},{\"name\":\"nodejs\",\"version\":\"23.1.0\",\"date\":\"2024-10-24\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.2.0\",\"date\":\"2024-11-11\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.3.0\",\"date\":\"2024-11-20\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"}]"));}}),
"[project]/node_modules/node-releases/data/release-schedule/release-schedule.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"v0.8\":{\"start\":\"2012-06-25\",\"end\":\"2014-07-31\"},\"v0.10\":{\"start\":\"2013-03-11\",\"end\":\"2016-10-31\"},\"v0.12\":{\"start\":\"2015-02-06\",\"end\":\"2016-12-31\"},\"v4\":{\"start\":\"2015-09-08\",\"lts\":\"2015-10-12\",\"maintenance\":\"2017-04-01\",\"end\":\"2018-04-30\",\"codename\":\"Argon\"},\"v5\":{\"start\":\"2015-10-29\",\"maintenance\":\"2016-04-30\",\"end\":\"2016-06-30\"},\"v6\":{\"start\":\"2016-04-26\",\"lts\":\"2016-10-18\",\"maintenance\":\"2018-04-30\",\"end\":\"2019-04-30\",\"codename\":\"Boron\"},\"v7\":{\"start\":\"2016-10-25\",\"maintenance\":\"2017-04-30\",\"end\":\"2017-06-30\"},\"v8\":{\"start\":\"2017-05-30\",\"lts\":\"2017-10-31\",\"maintenance\":\"2019-01-01\",\"end\":\"2019-12-31\",\"codename\":\"Carbon\"},\"v9\":{\"start\":\"2017-10-01\",\"maintenance\":\"2018-04-01\",\"end\":\"2018-06-30\"},\"v10\":{\"start\":\"2018-04-24\",\"lts\":\"2018-10-30\",\"maintenance\":\"2020-05-19\",\"end\":\"2021-04-30\",\"codename\":\"Dubnium\"},\"v11\":{\"start\":\"2018-10-23\",\"maintenance\":\"2019-04-22\",\"end\":\"2019-06-01\"},\"v12\":{\"start\":\"2019-04-23\",\"lts\":\"2019-10-21\",\"maintenance\":\"2020-11-30\",\"end\":\"2022-04-30\",\"codename\":\"Erbium\"},\"v13\":{\"start\":\"2019-10-22\",\"maintenance\":\"2020-04-01\",\"end\":\"2020-06-01\"},\"v14\":{\"start\":\"2020-04-21\",\"lts\":\"2020-10-27\",\"maintenance\":\"2021-10-19\",\"end\":\"2023-04-30\",\"codename\":\"Fermium\"},\"v15\":{\"start\":\"2020-10-20\",\"maintenance\":\"2021-04-01\",\"end\":\"2021-06-01\"},\"v16\":{\"start\":\"2021-04-20\",\"lts\":\"2021-10-26\",\"maintenance\":\"2022-10-18\",\"end\":\"2023-09-11\",\"codename\":\"Gallium\"},\"v17\":{\"start\":\"2021-10-19\",\"maintenance\":\"2022-04-01\",\"end\":\"2022-06-01\"},\"v18\":{\"start\":\"2022-04-19\",\"lts\":\"2022-10-25\",\"maintenance\":\"2023-10-18\",\"end\":\"2025-04-30\",\"codename\":\"Hydrogen\"},\"v19\":{\"start\":\"2022-10-18\",\"maintenance\":\"2023-04-01\",\"end\":\"2023-06-01\"},\"v20\":{\"start\":\"2023-04-18\",\"lts\":\"2023-10-24\",\"maintenance\":\"2024-10-22\",\"end\":\"2026-04-30\",\"codename\":\"Iron\"},\"v21\":{\"start\":\"2023-10-17\",\"maintenance\":\"2024-04-01\",\"end\":\"2024-06-01\"},\"v22\":{\"start\":\"2024-04-24\",\"lts\":\"2024-10-29\",\"maintenance\":\"2025-10-21\",\"end\":\"2027-04-30\",\"codename\":\"Jod\"},\"v23\":{\"start\":\"2024-10-16\",\"maintenance\":\"2025-04-01\",\"end\":\"2025-06-01\"},\"v24\":{\"start\":\"2025-04-22\",\"lts\":\"2025-10-28\",\"maintenance\":\"2026-10-20\",\"end\":\"2028-04-30\",\"codename\":\"\"}}"));}}),
"[project]/node_modules/electron-to-chromium/versions.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "32.3": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "33.4": "130",
    "34.0": "132",
    "34.1": "132",
    "34.2": "132",
    "34.3": "132",
    "34.4": "132",
    "34.5": "132",
    "35.0": "134",
    "35.1": "134",
    "35.2": "134",
    "35.3": "134",
    "35.4": "134",
    "35.5": "134",
    "36.0": "136",
    "36.1": "136",
    "36.2": "136",
    "36.3": "136",
    "36.4": "136",
    "36.5": "136",
    "37.0": "138"
};
}}),
"[project]/node_modules/normalize-range/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = {
    wrap: wrapRange,
    limit: limitRange,
    validate: validateRange,
    test: testRange,
    curry: curry,
    name: name
};
function wrapRange(min, max, value) {
    var maxLessMin = max - min;
    return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
}
function limitRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
}
function validateRange(min, max, value, minExclusive, maxExclusive) {
    if (!testRange(min, max, value, minExclusive, maxExclusive)) {
        throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
    }
    return value;
}
function testRange(min, max, value, minExclusive, maxExclusive) {
    return !(value < min || value > max || maxExclusive && value === max || minExclusive && value === min);
}
function name(min, max, minExcl, maxExcl) {
    return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
}
function curry(min, max, minExclusive, maxExclusive) {
    var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
    return {
        wrap: wrapRange.bind(null, min, max),
        limit: limitRange.bind(null, min, max),
        validate: function(value) {
            return validateRange(min, max, value, minExclusive, maxExclusive);
        },
        test: function(value) {
            return testRange(min, max, value, minExclusive, maxExclusive);
        },
        toString: boundNameFn,
        name: boundNameFn
    };
}
}}),
"[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code >= 48 && code <= 57) {
        return true;
    }
    return false;
}
// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
        return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
        pos++;
    }
    while(pos < length){
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
            break;
        }
        pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
    };
};
}}),
"[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;
module.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [
        {
            nodes: tokens
        }
    ];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while(pos < max){
        // Whitespaces
        if (code <= 32) {
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
                after = token;
            } else if (prev && prev.type === "div") {
                prev.after = token;
                prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                before = token;
            } else {
                tokens.push({
                    type: "space",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        // Quotes
        } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
                type: "string",
                sourceIndex: pos,
                quote: quote
            };
            do {
                escape = false;
                next = value.indexOf(quote, next + 1);
                if (~next) {
                    escapePos = next;
                    while(value.charCodeAt(escapePos - 1) === backslash){
                        escapePos -= 1;
                        escape = !escape;
                    }
                } else {
                    value += quote;
                    next = value.length - 1;
                    token.unclosed = true;
                }
            }while (escape)
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);
        // Comments
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
                type: "comment",
                sourceIndex: pos,
                sourceEndIndex: next + 2
            };
            if (next === -1) {
                token.unclosed = true;
                next = value.length;
                token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value.charCodeAt(pos);
        // Operation within calc
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
                type: "word",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token
            });
            pos += 1;
            code = value.charCodeAt(pos);
        // Dividers
        } else if (code === slash || code === comma || code === colon) {
            token = value[pos];
            tokens.push({
                type: "div",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token,
                before: before,
                after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
        // Open parentheses
        } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            parenthesesOpenPos = pos;
            token = {
                type: "function",
                sourceIndex: pos - name.length,
                value: name,
                before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                next -= 1;
                do {
                    escape = false;
                    next = value.indexOf(")", next + 1);
                    if (~next) {
                        escapePos = next;
                        while(value.charCodeAt(escapePos - 1) === backslash){
                            escapePos -= 1;
                            escape = !escape;
                        }
                    } else {
                        value += ")";
                        next = value.length - 1;
                        token.unclosed = true;
                    }
                }while (escape)
                // Whitespaces before closed
                whitespacePos = next;
                do {
                    whitespacePos -= 1;
                    code = value.charCodeAt(whitespacePos);
                }while (code <= 32)
                if (parenthesesOpenPos < whitespacePos) {
                    if (pos !== whitespacePos + 1) {
                        token.nodes = [
                            {
                                type: "word",
                                sourceIndex: pos,
                                sourceEndIndex: whitespacePos + 1,
                                value: value.slice(pos, whitespacePos + 1)
                            }
                        ];
                    } else {
                        token.nodes = [];
                    }
                    if (token.unclosed && whitespacePos + 1 !== next) {
                        token.after = "";
                        token.nodes.push({
                            type: "space",
                            sourceIndex: whitespacePos + 1,
                            sourceEndIndex: next,
                            value: value.slice(whitespacePos + 1, next)
                        });
                    } else {
                        token.after = value.slice(whitespacePos + 1, next);
                        token.sourceEndIndex = next;
                    }
                } else {
                    token.after = "";
                    token.nodes = [];
                }
                pos = next + 1;
                token.sourceEndIndex = token.unclosed ? next : pos;
                code = value.charCodeAt(pos);
                tokens.push(token);
            } else {
                balanced += 1;
                token.after = "";
                token.sourceEndIndex = pos + 1;
                tokens.push(token);
                stack.push(token);
                tokens = token.nodes = [];
                parent = token;
            }
            name = "";
        // Close parentheses
        } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
        // Words
        } else {
            next = pos;
            do {
                if (code === backslash) {
                    next += 1;
                }
                next += 1;
                code = value.charCodeAt(next);
            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced))
            token = value.slice(pos, next);
            if (openParentheses === code) {
                name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                tokens.push({
                    type: "unicode-range",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            } else {
                tokens.push({
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        }
    }
    for(pos = stack.length - 1; pos; pos -= 1){
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
};
}}),
"[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for(i = 0, max = nodes.length; i < max; i += 1){
        node = nodes[i];
        if (!bubble) {
            result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
        }
        if (bubble) {
            cb(node, i, nodes);
        }
    }
};
}}),
"[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
        return customResult;
    } else if (type === "word" || type === "space") {
        return value;
    } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
            return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
}
function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
        result = "";
        for(i = nodes.length - 1; ~i; i -= 1){
            result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
    }
    return stringifyNode(nodes, custom);
}
module.exports = stringify;
}}),
"[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var parse = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)");
var walk = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)");
var stringify = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)");
function ValueParser(value) {
    if (this instanceof ValueParser) {
        this.nodes = parse(value);
        return this;
    }
    return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
};
ValueParser.unit = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)");
ValueParser.walk = walk;
ValueParser.stringify = stringify;
module.exports = ValueParser;
}}),
"[project]/node_modules/fraction.js/fraction.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ /**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <numerator>, 1 => <denominator> ]
 * [ n => <numerator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */ (function(root) {
    "use strict";
    // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
    var MAX_CYCLE_LEN = 2000;
    // Parsed data to avoid calling "new" all the time
    var P = {
        "s": 1,
        "n": 0,
        "d": 1
    };
    function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
            throw InvalidParameter();
        }
        return n * s;
    }
    // Creates a new Fraction internally without the need of the bulky constructor
    function newFraction(n, d) {
        if (d === 0) {
            throw DivisionByZero();
        }
        var f = Object.create(Fraction.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
    }
    function factorize(num) {
        var factors = {};
        var n = num;
        var i = 2;
        var s = 4;
        while(s <= n){
            while(n % i === 0){
                n /= i;
                factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
        }
        if (n !== num) {
            if (n > 1) factors[n] = (factors[n] || 0) + 1;
        } else {
            factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
    }
    var parse = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 10000000;
        var M;
        if (p1 === undefined || p1 === null) {
        /* void */ } else if (p2 !== undefined) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
                throw NonIntegerParameter();
            }
        } else switch(typeof p1){
            case "object":
                {
                    if ("d" in p1 && "n" in p1) {
                        n = p1["n"];
                        d = p1["d"];
                        if ("s" in p1) n *= p1["s"];
                    } else if (0 in p1) {
                        n = p1[0];
                        if (1 in p1) d = p1[1];
                    } else {
                        throw InvalidParameter();
                    }
                    s = n * d;
                    break;
                }
            case "number":
                {
                    if (p1 < 0) {
                        s = p1;
                        p1 = -p1;
                    }
                    if (p1 % 1 === 0) {
                        n = p1;
                    } else if (p1 > 0) {
                        if (p1 >= 1) {
                            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                            p1 /= z;
                        }
                        // Using Farey Sequences
                        // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/
                        while(B <= N && D <= N){
                            M = (A + C) / (B + D);
                            if (p1 === M) {
                                if (B + D <= N) {
                                    n = A + C;
                                    d = B + D;
                                } else if (D > B) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                                break;
                            } else {
                                if (p1 > M) {
                                    A += C;
                                    B += D;
                                } else {
                                    C += A;
                                    D += B;
                                }
                                if (B > N) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                            }
                        }
                        n *= z;
                    } else if (isNaN(p1) || isNaN(p2)) {
                        d = n = NaN;
                    }
                    break;
                }
            case "string":
                {
                    B = p1.match(/\d+|./g);
                    if (B === null) throw InvalidParameter();
                    if (B[A] === '-') {
                        s = -1;
                        A++;
                    } else if (B[A] === '+') {
                        A++;
                    }
                    if (B.length === A + 1) {
                        w = assign(B[A++], s);
                    } else if (B[A + 1] === '.' || B[A] === '.') {
                        if (B[A] !== '.') {
                            v = assign(B[A++], s);
                        }
                        A++;
                        // Check for decimal places
                        if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                            w = assign(B[A], s);
                            y = Math.pow(10, B[A].length);
                            A++;
                        }
                        // Check for repeating places
                        if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                            x = assign(B[A + 1], s);
                            z = Math.pow(10, B[A + 1].length) - 1;
                            A += 3;
                        }
                    } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                        w = assign(B[A], s);
                        y = assign(B[A + 2], 1);
                        A += 3;
                    } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                        v = assign(B[A], s);
                        w = assign(B[A + 2], s);
                        y = assign(B[A + 4], 1);
                        A += 5;
                    }
                    if (B.length <= A) {
                        d = y * z;
                        s = /* void */ n = x + d * v + z * w;
                        break;
                    }
                /* Fall through on error */ }
            default:
                throw InvalidParameter();
        }
        if (d === 0) {
            throw DivisionByZero();
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
    };
    function modpow(b, e, m) {
        var r = 1;
        for(; e > 0; b = b * b % m, e >>= 1){
            if (e & 1) {
                r = r * b % m;
            }
        }
        return r;
    }
    function cycleLen(n, d) {
        for(; d % 2 === 0; d /= 2){}
        for(; d % 5 === 0; d /= 5){}
        if (d === 1) return 0;
        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.
        var rem = 10 % d;
        var t = 1;
        for(; rem !== 1; t++){
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }
        return t;
    }
    function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for(var t = 0; t < 300; t++){
            // Solve 10^s == 10^(s+t) (mod d)
            if (rem1 === rem2) return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
        }
        return 0;
    }
    function gcd(a, b) {
        if (!a) return b;
        if (!b) return a;
        while(1){
            a %= b;
            if (!a) return b;
            b %= a;
            if (!b) return a;
        }
    }
    ;
    /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */ function Fraction(a, b) {
        parse(a, b);
        if (this instanceof Fraction) {
            a = gcd(P["d"], P["n"]); // Abuse variable a
            this["s"] = P["s"];
            this["n"] = P["n"] / a;
            this["d"] = P["d"] / a;
        } else {
            return newFraction(P['s'] * P['n'], P['d']);
        }
    }
    var DivisionByZero = function() {
        return new Error("Division by Zero");
    };
    var InvalidParameter = function() {
        return new Error("Invalid argument");
    };
    var NonIntegerParameter = function() {
        return new Error("Parameters must be integer");
    };
    Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/ "abs": function() {
            return newFraction(this["n"], this["d"]);
        },
        /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/ "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/ "add": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/ "sub": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/ "mul": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/ "div": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
        },
        /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/ "clone": function() {
            return newFraction(this['s'] * this['n'], this['d']);
        },
        /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/ "mod": function(a, b) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return new Fraction(NaN);
            }
            if (a === undefined) {
                return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P["n"] && 0 === this["d"]) {
                throw DivisionByZero();
            }
            /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/ /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */ return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */ "gcd": function(a, b) {
            parse(a, b);
            // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)
            return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */ "lcm": function(a, b) {
            parse(a, b);
            // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)
            if (P["n"] === 0 && this["n"] === 0) {
                return newFraction(0, 1);
            }
            return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },
        /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/ "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/ "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/ "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational number to a multiple of another rational number
     *
     * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
     **/ "roundTo": function(a, b) {
            /*
      k * x/y ≤ a/b < (k+1) * x/y
      ⇔ k ≤ a/b / (x/y) < (k+1)
      ⇔ k = floor(a/b * y/x)
      */ parse(a, b);
            return newFraction(this['s'] * Math.round(this['n'] * P['d'] / (this['d'] * P['n'])) * P['n'], P['d']);
        },
        /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/ "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */ "pow": function(a, b) {
            parse(a, b);
            // Trivial case when exp is an integer
            if (P['d'] === 1) {
                if (P['s'] < 0) {
                    return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
                } else {
                    return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
                }
            }
            // Negative roots become complex
            //     (-a/b)^(c/d) = x
            // <=> (-1)^(c/d) * (a/b)^(c/d) = x
            // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
            // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
            // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
            if (this['s'] < 0) return null;
            // Now prime factor n and d
            var N = factorize(this['n']);
            var D = factorize(this['d']);
            // Exponentiate and take root for n and d individually
            var n = 1;
            var d = 1;
            for(var k in N){
                if (k === '1') continue;
                if (k === '0') {
                    n = 0;
                    break;
                }
                N[k] *= P['n'];
                if (N[k] % P['d'] === 0) {
                    N[k] /= P['d'];
                } else return null;
                n *= Math.pow(k, N[k]);
            }
            for(var k in D){
                if (k === '1') continue;
                D[k] *= P['n'];
                if (D[k] % P['d'] === 0) {
                    D[k] /= P['d'];
                } else return null;
                d *= Math.pow(k, D[k]);
            }
            if (P['s'] < 0) {
                return newFraction(d, n);
            }
            return newFraction(n, d);
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
            return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return this;
            }
            eps = eps || 0.001;
            var thisABS = this['abs']();
            var cont = thisABS['toContinued']();
            for(var i = 1; i < cont.length; i++){
                var s = newFraction(cont[i - 1], 1);
                for(var k = i - 2; k >= 0; k--){
                    s = s['inverse']()['add'](cont[k]);
                }
                if (Math.abs(s['sub'](thisABS).valueOf()) < eps) {
                    return s['mul'](this['s']);
                }
            }
            return this;
        },
        /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */ "divisible": function(a, b) {
            parse(a, b);
            return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/ 'valueOf': function() {
            return this["s"] * this["n"] / this["d"];
        },
        /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/ 'toFraction': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    str += " ";
                    n %= d;
                }
                str += n;
                str += '/';
                str += d;
            }
            return str;
        },
        /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/ 'toLatex': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    n %= d;
                }
                str += "\\frac{";
                str += n;
                str += '}{';
                str += d;
                str += '}';
            }
            return str;
        },
        /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */ 'toContinued': function() {
            var t;
            var a = this['n'];
            var b = this['d'];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
                return res;
            }
            do {
                res.push(Math.floor(a / b));
                t = a % b;
                a = b;
                b = t;
            }while (a !== 1)
            return res;
        },
        /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/ 'toString': function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
                return "NaN";
            }
            dec = dec || 15; // 15 = decimal places when no repetation
            var cycLen = cycleLen(N, D); // Cycle length
            var cycOff = cycleStart(N, D, cycLen); // Cycle start
            var str = this['s'] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N) str += ".";
            if (cycLen) {
                for(var i = cycOff; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += "(";
                for(var i = cycLen; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += ")";
            } else {
                for(var i = dec; N && i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
            }
            return str;
        }
    };
    if ("TURBOPACK compile-time truthy", 1) {
        Object.defineProperty(exports, "__esModule", {
            'value': true
        });
        exports['default'] = Fraction;
        module['exports'] = Fraction;
    } else {
        "TURBOPACK unreachable";
    }
})(this);
}}),
"[project]/node_modules/cssdb/cssdb.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("[{\"id\":\"all-property\",\"title\":\"`all` Property\",\"description\":\"A property for defining the reset of all properties of an element\",\"specification\":\"https://www.w3.org/TR/css-cascade-3/#all-shorthand\",\"stage\":4,\"browser_support\":{\"and_chr\":\"37\",\"and_ff\":\"27\",\"android\":\"37\",\"chrome\":\"37\",\"edge\":\"79\",\"firefox\":\"27\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"24\",\"opera\":\"24\",\"safari\":\"9.1\",\"samsung\":\"3.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/all\"},\"example\":\"a {\\n  all: initial;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/maximkoretskiy/postcss-initial\"}],\"vendors_implementations\":3},{\"id\":\"any-link-pseudo-class\",\"title\":\"`:any-link` Hyperlink Pseudo-Class\",\"description\":\"A pseudo-class for matching anchor elements independent of whether they have been visited\",\"specification\":\"https://www.w3.org/TR/selectors-4/#any-link-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"4\",\"android\":\"4.4\",\"chrome\":\"1\",\"edge\":\"79\",\"firefox\":\"1\",\"ios_saf\":\"1\",\"oculus\":\"5.0\",\"op_mob\":\"14\",\"opera\":\"15\",\"safari\":\"3\",\"samsung\":\"1.0\",\"webview_ios\":\"1\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link\"},\"example\":\"nav :any-link > span {\\n  background-color: yellow;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-pseudo-class-any-link\"}],\"vendors_implementations\":3},{\"id\":\"blank-pseudo-class\",\"title\":\"`:blank` Empty-Value Pseudo-Class\",\"description\":\"A pseudo-class for matching form elements when they are empty\",\"specification\":\"https://www.w3.org/TR/selectors-4/#blank\",\"stage\":2,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:blank\"},\"example\":\"input:blank {\\n  background-color: yellow;\\n}\",\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-blank-pseudo\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-blank-pseudo\"}],\"vendors_implementations\":0},{\"id\":\"break-properties\",\"title\":\"Break Properties\",\"description\":\"Properties for defining the break behavior between and within boxes\",\"specification\":\"https://www.w3.org/TR/css-break-3/#breaking-controls\",\"stage\":3,\"browser_support\":{\"and_chr\":\"51\",\"and_ff\":\"92\",\"android\":\"51\",\"chrome\":\"51\",\"edge\":\"12\",\"firefox\":\"92\",\"oculus\":\"5.0\",\"op_mob\":\"37\",\"opera\":\"11.1\",\"samsung\":\"5.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/break-after\"},\"example\":\"a {\\n  break-inside: avoid;\\n  break-before: avoid-column;\\n  break-after: always;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/shrpne/postcss-page-break\"}],\"vendors_implementations\":2},{\"id\":\"calc-constants\",\"title\":\"`e`, `pi`, `infinity`, `-infinity` and `NaN` constants for calculation\",\"description\":\"Constants for calculation simplification\",\"specification\":\"https://drafts.csswg.org/css-values-4/#calc-keywords\",\"stage\":2,\"browser_support\":{\"and_chr\":\"110\",\"and_ff\":\"114\",\"android\":\"110\",\"chrome\":\"110\",\"edge\":\"110\",\"firefox\":\"114\",\"ios_saf\":\"16\",\"op_mob\":\"74\",\"opera\":\"96\",\"safari\":\"16\",\"samsung\":\"21.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/calc-keyword\"},\"example\":\"p {\\n  font-size: calc(pow(e, pi) * 1rem);\\n}\",\"interoperable_at\":1686009600,\"vendors_implementations\":3},{\"id\":\"cascade-layers\",\"title\":\"CSS Cascade Layers\",\"description\":\"The `@layer` at-rule allows authors to explicitly layer their styles in the cascade, before specificity and order of appearance are considered.\",\"specification\":\"https://www.w3.org/TR/css-cascade-5/#layering\",\"stage\":2,\"browser_support\":{\"and_chr\":\"99\",\"and_ff\":\"97\",\"android\":\"99\",\"chrome\":\"99\",\"edge\":\"99\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"oculus\":\"21.0\",\"op_mob\":\"68\",\"opera\":\"85\",\"safari\":\"15.4\",\"samsung\":\"18.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@layer\"},\"example\":\"/* Un-layered styles have the highest priority */\\na {\\n  color: mediumvioletred;\\n}\\n\\n@layer defaults {\\n  a { color: maroon; }\\n}\",\"interoperable_at\":1647216000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-cascade-layers\"}],\"vendors_implementations\":3,\"web-feature\":\"cascade-layers\"},{\"id\":\"case-insensitive-attributes\",\"title\":\"Case-Insensitive Attributes\",\"description\":\"An attribute selector matching attribute values case-insensitively\",\"specification\":\"https://www.w3.org/TR/selectors-4/#attribute-case\",\"stage\":2,\"browser_support\":{\"and_chr\":\"49\",\"and_ff\":\"47\",\"android\":\"49\",\"chrome\":\"49\",\"edge\":\"79\",\"firefox\":\"47\",\"ios_saf\":\"9\",\"oculus\":\"5.0\",\"op_mob\":\"36\",\"opera\":\"36\",\"safari\":\"9\",\"samsung\":\"5.0\",\"webview_ios\":\"9\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\"},\"example\":\"[frame=hsides i] {\\n  border-style: solid none;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-attribute-case-insensitive\"}],\"vendors_implementations\":3},{\"id\":\"clamp\",\"title\":\"`clamp` Function\",\"description\":\"The clamp() CSS function clamps a value between an upper and lower bound. It enables selecting a middle value within a range of values between a defined minimum and maximum.\",\"specification\":\"https://www.w3.org/TR/css-values-4/#funcdef-clamp\",\"stage\":2,\"browser_support\":{\"and_chr\":\"79\",\"and_ff\":\"79\",\"android\":\"79\",\"chrome\":\"79\",\"edge\":\"79\",\"firefox\":\"75\",\"ios_saf\":\"13.4\",\"oculus\":\"8.0\",\"op_mob\":\"57\",\"opera\":\"66\",\"safari\":\"13.1\",\"samsung\":\"12.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/clamp\"},\"example\":\"button {\\n  font-size: clamp(1rem, 2.5vw, 2rem);\\n}\",\"interoperable_at\":1595894400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/polemius/postcss-clamp\"}],\"vendors_implementations\":3},{\"id\":\"color-adjust\",\"title\":\"`color-adjust` Property\",\"description\":\"The color-adjust property is a non-standard CSS extension that can be used to force printing of background colors and images\",\"specification\":\"https://www.w3.org/TR/css-color-4/#color-adjust\",\"stage\":2,\"browser_support\":{\"and_chr\":\"136\",\"and_ff\":\"97\",\"chrome\":\"136\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"safari\":\"15.4\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/print-color-adjust\"},\"example\":\".background {\\n  background-color:#ccc;\\n}\\n.background.color-adjust {\\n  color-adjust: economy;\\n}\\n.background.color-adjust-exact {\\n  color-adjust: exact;\\n}\",\"vendors_implementations\":2},{\"id\":\"color-function\",\"title\":\"`color()` Function\",\"description\":\"A function that allows a color to be specified in a particular, specified color space rather than the implicit sRGB color space that most of the other color functions operate in.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-color\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"113\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"113\",\"ios_saf\":\"15\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"15\",\"samsung\":\"22.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color\"},\"example\":\"p {\\n  color: color(display-p3 1 0.5 0);\\n  color: color(display-p3 1 0.5 0 / .5);\\n}\",\"interoperable_at\":1683590400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-function\"}],\"vendors_implementations\":3,\"web-feature\":\"color-function\"},{\"id\":\"color-functional-notation\",\"title\":\"Color Functional Notation\",\"description\":\"A space and slash separated notation for specifying colors\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-rgb\",\"stage\":2,\"browser_support\":{\"and_chr\":\"65\",\"and_ff\":\"52\",\"android\":\"65\",\"chrome\":\"65\",\"edge\":\"79\",\"firefox\":\"52\",\"ios_saf\":\"12.2\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"52\",\"safari\":\"12.1\",\"samsung\":\"9.0\",\"webview_ios\":\"12.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb#syntax\"},\"example\":\"em {\\n  background-color: hsl(120deg 100% 25%);\\n  color: rgb(0 255 0);\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-functional-notation\"}],\"vendors_implementations\":3},{\"id\":\"color-mix\",\"title\":\"`color-mix()` Function\",\"description\":\"A function for mixing colors\",\"specification\":\"https://www.w3.org/TR/css-color-5/#color-mix\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"113\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"16.2\",\"samsung\":\"22.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix\"},\"example\":\"p {\\n  color: color-mix(in lch, purple 50%, plum 50%);\\n}\",\"interoperable_at\":1683590400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-mix-function\"}],\"vendors_implementations\":3,\"web-feature\":\"color-mix\"},{\"id\":\"color-mix-variadic-function-arguments\",\"title\":\"`color-mix()` Function with 1+ arguments\",\"description\":\"Mix any number of colors\",\"specification\":\"https://www.w3.org/TR/css-color-5/#color-mix\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"p {\\n  color: color-mix(in lch, red, lime, blue);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-mix-variadic-function-arguments\"}],\"vendors_implementations\":0},{\"id\":\"container-queries\",\"title\":\"Container Queries\",\"description\":\"New container property and container at rule to make changes depending on the container's size\",\"specification\":\"https://www.w3.org/TR/css-contain-3/#container-queries\",\"stage\":2,\"browser_support\":{\"and_chr\":\"105\",\"and_ff\":\"110\",\"android\":\"105\",\"chrome\":\"105\",\"edge\":\"105\",\"firefox\":\"110\",\"ios_saf\":\"16\",\"op_mob\":\"72\",\"opera\":\"91\",\"safari\":\"16\",\"samsung\":\"20.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries\"},\"example\":\".container {\\n  contain: layout inline-size;\\n}\\n\\n@container (min-width: 700px) {\\n  .container {\\n    /* styles applied when a container is at least 700px */\\n  }\\n}\",\"interoperable_at\":1676332800,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://www.npmjs.com/package/container-query-polyfill\"}],\"vendors_implementations\":3,\"web-feature\":\"container-queries\"},{\"id\":\"content-alt-text\",\"title\":\"Alt text for `content`\",\"description\":\"Syntax that allows setting alternative text\",\"specification\":\"https://drafts.csswg.org/css-content/#content-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"77\",\"and_ff\":\"128\",\"android\":\"77\",\"chrome\":\"77\",\"edge\":\"79\",\"firefox\":\"128\",\"ios_saf\":\"17.4\",\"oculus\":\"7.0\",\"op_mob\":\"55\",\"opera\":\"64\",\"safari\":\"17.4\",\"samsung\":\"12.0\",\"webview_ios\":\"17.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/content#adding_an_image_with_alternative_text\"},\"example\":\".element {\\n  content: url(tree.jpg) / \\\"image with a tree\\\";\\n}\",\"interoperable_at\":1720483200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-content-alt-text\"}],\"vendors_implementations\":3},{\"id\":\"contrast-color-function\",\"title\":\"`contrast-color()` Function\",\"description\":\"Dynamically specifying a text color with adequate contrast.\",\"specification\":\"https://drafts.csswg.org/css-color-5/#contrast-color\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"p {\\n  color: contrast-color( purple max );\\n}\",\"polyfills\":[],\"vendors_implementations\":0},{\"id\":\"custom-media-queries\",\"title\":\"Custom Media Queries\",\"description\":\"An at-rule for defining aliases that represent media queries\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#at-ruledef-custom-media\",\"stage\":2,\"browser_support\":{},\"example\":\"@custom-media --narrow-window (max-width: 30em);\\n\\n@media (--narrow-window) {}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-media\"}],\"vendors_implementations\":0},{\"id\":\"custom-properties\",\"title\":\"Custom Properties\",\"description\":\"A syntax for defining custom values accepted by all CSS properties\",\"specification\":\"https://www.w3.org/TR/css-variables-1/\",\"stage\":3,\"browser_support\":{\"and_chr\":\"49\",\"and_ff\":\"31\",\"android\":\"50\",\"chrome\":\"49\",\"edge\":\"15\",\"firefox\":\"31\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"36\",\"opera\":\"36\",\"safari\":\"9.1\",\"samsung\":\"5.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/var\"},\"example\":\":root {\\n  --some-length: 32px;\\n\\n  height: var(--some-length);\\n  width: var(--some-length);\\n}\",\"interoperable_at\":1491350400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-properties\"}],\"vendors_implementations\":3,\"web-feature\":\"custom-properties\"},{\"id\":\"custom-selectors\",\"title\":\"Custom Selectors\",\"description\":\"An at-rule for defining aliases that represent selectors\",\"specification\":\"https://drafts.csswg.org/css-extensions/#custom-selectors\",\"stage\":1,\"browser_support\":{},\"example\":\"@custom-selector :--heading h1, h2, h3, h4, h5, h6;\\n\\narticle :--heading + p {}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-selectors\"}],\"vendors_implementations\":0},{\"id\":\"dir-pseudo-class\",\"title\":\"`:dir` Directionality Pseudo-Class\",\"description\":\"A pseudo-class for matching elements based on their directionality\",\"specification\":\"https://www.w3.org/TR/selectors-4/#dir-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"49\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"49\",\"ios_saf\":\"16.4\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"16.4\",\"samsung\":\"25.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:dir\"},\"example\":\"blockquote:dir(rtl) {\\n  margin-right: 10px;\\n}\\n\\nblockquote:dir(ltr) {\\n  margin-left: 10px;\\n}\",\"interoperable_at\":1701907200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-dir-pseudo-class\"}],\"vendors_implementations\":3},{\"id\":\"display-two-values\",\"title\":\"Two values syntax for `display`\",\"description\":\"Syntax that allows definition of outer and inner displays types for an element\",\"specification\":\"https://www.w3.org/TR/css-display-3/#the-display-properties\",\"stage\":2,\"browser_support\":{\"and_chr\":\"115\",\"and_ff\":\"79\",\"android\":\"115\",\"chrome\":\"115\",\"edge\":\"115\",\"firefox\":\"70\",\"ios_saf\":\"15\",\"op_mob\":\"77\",\"opera\":\"101\",\"safari\":\"15\",\"samsung\":\"23.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/multi-keyword_syntax_of_display\"},\"example\":\".element {\\n  display: inline flow-root;\\n  display: inline flex;\\n  display: block grid;\\n}\",\"interoperable_at\":1689897600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-normalize-display-values\"}],\"vendors_implementations\":3},{\"id\":\"double-position-gradients\",\"title\":\"Double Position Gradients\",\"description\":\"A syntax for using two positions in a gradient.\",\"specification\":\"https://www.w3.org/TR/css-images-4/#color-stop-syntax\",\"stage\":2,\"browser_support\":{\"and_chr\":\"72\",\"and_ff\":\"83\",\"android\":\"72\",\"chrome\":\"72\",\"edge\":\"79\",\"firefox\":\"83\",\"ios_saf\":\"12.2\",\"oculus\":\"6.0\",\"op_mob\":\"51\",\"opera\":\"60\",\"safari\":\"12.1\",\"samsung\":\"11.0\",\"webview_ios\":\"12.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient\"},\"example\":\".pie_chart {\\n  background-image: conic-gradient(yellowgreen 40%, gold 0deg 75%, #f06 0deg);\\n}\",\"interoperable_at\":1605571200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-double-position-gradients\"}],\"vendors_implementations\":3},{\"id\":\"environment-variables\",\"title\":\"Custom Environment Variables\",\"description\":\"A syntax for using custom values accepted by CSS globally\",\"specification\":\"https://drafts.csswg.org/css-env-1/\",\"stage\":0,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/env\"},\"example\":\"@media (max-width: env(--brand-small)) {\\n  body {\\n    padding: env(--brand-spacing);\\n  }\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-env-function\"}],\"vendors_implementations\":0},{\"id\":\"exponential-functions\",\"title\":\"`pow()`, `sqrt()`, `hypot()`, `log()`, `exp()` exponential functions\",\"description\":\"Compute various exponential functions with their arguments\",\"specification\":\"https://www.w3.org/TR/css-values-4/#exponent-funcs\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"118\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"15.4\",\"samsung\":\"25.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/exp\"},\"example\":\"p {\\n  font-size: calc(pow(10, 12) * 1rem);\\n  font-size: calc(sqrt(100) * 1rem);\\n  font-size: calc(hypot(3, 4) * 1rem);\\n  font-size: calc(log(10) * 1rem);\\n  font-size: calc(exp(10) * 1rem);\\n}\",\"interoperable_at\":1701907200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-exponential-functions\"}],\"vendors_implementations\":3},{\"id\":\"fangsong-font-family\",\"title\":\"`fangsong` Font Family\",\"description\":\"A generic font used for Fang Song (仿宋) typefaces in Chinese\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#fangsong-def\",\"stage\":2,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Syntax\"},\"example\":\"body {\\n  font-family: fangsong;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/JLHwung/postcss-font-family-fangsong\"}],\"vendors_implementations\":0},{\"id\":\"float-clear-logical-values\",\"title\":\"Logical Values in float and clear\",\"description\":\"Flow-relative (inline-start and inline-end) values for float and clear\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"118\",\"and_ff\":\"55\",\"android\":\"118\",\"chrome\":\"118\",\"edge\":\"118\",\"firefox\":\"55\",\"ios_saf\":\"15\",\"op_mob\":\"79\",\"opera\":\"104\",\"safari\":\"15\",\"samsung\":\"25.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/float\"},\"example\":\"span:first-child {\\n  float: inline-start;\\n}\",\"interoperable_at\":1697155200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-float-and-clear\"}],\"vendors_implementations\":3},{\"id\":\"focus-visible-pseudo-class\",\"title\":\"`:focus-visible` Focus-Indicated Pseudo-Class\",\"description\":\"A pseudo-class for matching focused elements that indicate that focus to a user\",\"specification\":\"https://www.w3.org/TR/selectors-4/#focus-visible-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"86\",\"and_ff\":\"85\",\"android\":\"86\",\"chrome\":\"86\",\"edge\":\"86\",\"firefox\":\"85\",\"ios_saf\":\"15.4\",\"oculus\":\"12.0\",\"op_mob\":\"61\",\"opera\":\"72\",\"safari\":\"15.4\",\"samsung\":\"14.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible\"},\"example\":\":focus:not(:focus-visible) {\\n  outline: 0;\\n}\",\"interoperable_at\":1647216000,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/WICG/focus-visible\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-focus-visible\"}],\"vendors_implementations\":3,\"web-feature\":\"focus-visible\"},{\"id\":\"focus-within-pseudo-class\",\"title\":\"`:focus-within` Focus Container Pseudo-Class\",\"description\":\"A pseudo-class for matching elements that are either focused or that have focused descendants\",\"specification\":\"https://www.w3.org/TR/selectors-4/#focus-within-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"60\",\"and_ff\":\"52\",\"android\":\"60\",\"chrome\":\"60\",\"edge\":\"79\",\"firefox\":\"52\",\"ios_saf\":\"10.3\",\"oculus\":\"5.0\",\"op_mob\":\"44\",\"opera\":\"47\",\"safari\":\"10.1\",\"samsung\":\"8.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-within\"},\"example\":\"form:focus-within {\\n  background: rgb(0 128 0);\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/jsxtools/focus-within\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-focus-within\"}],\"vendors_implementations\":3},{\"id\":\"font-format-keywords\",\"title\":\"Font `format()` Keywords\",\"description\":\"A syntax for specifying font format as a keyword in `@font-face` rule’s `format()` function\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#font-format-values\",\"stage\":2,\"browser_support\":{\"and_chr\":\"108\",\"android\":\"108\",\"chrome\":\"108\",\"edge\":\"108\",\"ios_saf\":\"5\",\"op_mob\":\"73\",\"opera\":\"94\",\"safari\":\"4\",\"samsung\":\"21.0\",\"webview_ios\":\"5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face\"},\"example\":\"@font-face {\\n  src: url(file.woff2) format(woff2);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/valtlai/postcss-font-format-keywords\"}],\"vendors_implementations\":2},{\"id\":\"font-variant-property\",\"title\":\"`font-variant` Property\",\"description\":\"A property for defining the usage of alternate glyphs in a font\",\"specification\":\"https://www.w3.org/TR/css-fonts-3/#propdef-font-variant\",\"stage\":4,\"browser_support\":{\"and_ff\":\"34\",\"firefox\":\"34\",\"ios_saf\":\"9.3\",\"safari\":\"9.1\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant\"},\"example\":\"h2 {\\n  font-variant: small-caps;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/postcss/postcss-font-variant\"}],\"vendors_implementations\":2},{\"id\":\"gamut-mapping\",\"title\":\"Gamut mapping for CSS color functions\",\"description\":\"Gamut map css colors to fit display specific gamuts.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#gamut-mapping\",\"stage\":2,\"browser_support\":{},\"example\":\"@media (color-gamut: rec2020) {\\n\\tp {\\n\\t\\tcolor: oklch(40% 0.234 0.39 / 0.5);\\n\\t}\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gamut-mapping\"}],\"vendors_implementations\":0},{\"id\":\"gap-properties\",\"title\":\"Gap Properties\",\"description\":\"Properties for defining gutters within a layout\",\"specification\":\"https://www.w3.org/TR/css-grid-1/#gutters\",\"stage\":3,\"browser_support\":{\"and_chr\":\"66\",\"and_ff\":\"61\",\"android\":\"66\",\"chrome\":\"66\",\"edge\":\"16\",\"firefox\":\"61\",\"ios_saf\":\"12\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"53\",\"safari\":\"12\",\"samsung\":\"9.0\",\"webview_ios\":\"12\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gap\"},\"example\":\".grid-1 {\\n  gap: 20px;\\n}\\n\\n.grid-2 {\\n  column-gap: 40px;\\n  row-gap: 20px;\\n}\",\"interoperable_at\":1537142400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gap-properties\"}],\"vendors_implementations\":3},{\"id\":\"gradients-interpolation-method\",\"title\":\"Gradients Interpolation Method\",\"description\":\"Define the interpolation method for gradients\",\"specification\":\"https://www.w3.org/TR/css-images-4/#color-interpolation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"127\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"127\",\"ios_saf\":\"16.2\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"16.2\",\"samsung\":\"22.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#syntax\"},\"example\":\".pie_chart {\\n  background-image: conic-gradient(in oklch, yellowgreen 40%, gold 0deg 75%, #f06 0deg);\\n}\",\"interoperable_at\":1718064000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gradients-interpolation-method\"}],\"vendors_implementations\":3},{\"id\":\"grid-layout\",\"title\":\"Grid Layout\",\"description\":\"A syntax for using a grid concept to lay out content\",\"specification\":\"https://www.w3.org/TR/css-grid-1/\",\"stage\":3,\"browser_support\":{\"and_chr\":\"57\",\"and_ff\":\"52\",\"android\":\"57\",\"chrome\":\"57\",\"edge\":\"16\",\"firefox\":\"52\",\"ios_saf\":\"10.3\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"44\",\"safari\":\"10.1\",\"samsung\":\"6.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/grid\"},\"example\":\"section {\\n  display: grid;\\n  grid-template-columns: 100px 100px 100px;\\n  grid-gap: 10px;\\n}\",\"interoperable_at\":1508198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/postcss/autoprefixer\"}],\"vendors_implementations\":3},{\"id\":\"has-pseudo-class\",\"title\":\"`:has()` Relational Pseudo-Class\",\"description\":\"A pseudo-class for matching ancestor and sibling elements\",\"specification\":\"https://www.w3.org/TR/selectors-4/#has-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"105\",\"and_ff\":\"121\",\"android\":\"105\",\"chrome\":\"105\",\"edge\":\"105\",\"firefox\":\"121\",\"ios_saf\":\"15.4\",\"op_mob\":\"72\",\"opera\":\"91\",\"safari\":\"15.4\",\"samsung\":\"20.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:has\"},\"example\":\"a:has(> img) {\\n  display: block;\\n}\",\"interoperable_at\":1702944000,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-has-pseudo\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-has-pseudo\"}],\"vendors_implementations\":3,\"web-feature\":\"has\"},{\"id\":\"hexadecimal-alpha-notation\",\"title\":\"Hexadecimal Alpha Notation\",\"description\":\"A 4 & 8 character hex color notation for specifying the opacity level\",\"specification\":\"https://www.w3.org/TR/css-color-4/#hex-notation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"62\",\"and_ff\":\"49\",\"android\":\"62\",\"chrome\":\"62\",\"edge\":\"79\",\"firefox\":\"49\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"49\",\"safari\":\"10\",\"samsung\":\"8.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Syntax_2\"},\"example\":\"section {\\n  background-color: #f3f3f3f3;\\n  color: #0003;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-hex-alpha\"}],\"vendors_implementations\":3},{\"id\":\"hwb-function\",\"title\":\"`hwb()` Function\",\"description\":\"A function for specifying colors by hue and then a degree of whiteness and blackness to mix into it\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-hwb\",\"stage\":2,\"browser_support\":{\"and_chr\":\"101\",\"and_ff\":\"96\",\"android\":\"101\",\"chrome\":\"101\",\"edge\":\"101\",\"firefox\":\"96\",\"ios_saf\":\"15\",\"oculus\":\"22.0\",\"op_mob\":\"70\",\"opera\":\"87\",\"safari\":\"15\",\"samsung\":\"19.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb\"},\"example\":\"p {\\n  color: hwb(120 44% 50%);\\n}\",\"interoperable_at\":1651104000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-hwb-function\"}],\"vendors_implementations\":3},{\"id\":\"ic-unit\",\"title\":\"`ic` length unit\",\"description\":\"Equal to the used advance measure of the \\\"水\\\" (CJK water ideograph, U+6C34) glyph found in the font used to render it\",\"specification\":\"https://www.w3.org/TR/css-values-4/#ic\",\"stage\":2,\"browser_support\":{\"and_chr\":\"106\",\"and_ff\":\"97\",\"android\":\"106\",\"chrome\":\"106\",\"edge\":\"106\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"op_mob\":\"72\",\"opera\":\"92\",\"safari\":\"15.4\",\"samsung\":\"20.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Values_and_Units#dimensions\"},\"example\":\"p {\\n  text-indent: 2ic;\\n}\",\"interoperable_at\":1664755200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-ic-unit\"}],\"vendors_implementations\":3,\"web-feature\":\"ic\"},{\"id\":\"image-set-function\",\"title\":\"`image-set()` Function\",\"description\":\"A function for specifying image sources based on the user’s resolution\",\"specification\":\"https://www.w3.org/TR/css-images-4/#image-set-notation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"25\",\"and_ff\":\"89\",\"android\":\"4.4\",\"chrome\":\"21\",\"edge\":\"79\",\"firefox\":\"89\",\"ios_saf\":\"14\",\"oculus\":\"5.0\",\"op_mob\":\"14\",\"opera\":\"15\",\"safari\":\"14\",\"samsung\":\"1.5\",\"webview_ios\":\"17\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set\"},\"example\":\"p {\\n  background-image: image-set(\\n    \\\"foo.png\\\" 1x,\\n    \\\"foo-2x.png\\\" 2x,\\n    \\\"foo-print.png\\\" 600dpi\\n  );\\n}\",\"interoperable_at\":1622505600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-image-set-function\"}],\"vendors_implementations\":3},{\"id\":\"in-out-of-range-pseudo-class\",\"title\":\"`:in-range` and `:out-of-range` Pseudo-Classes\",\"description\":\"A pseudo-class for matching elements that have range limitations\",\"specification\":\"https://www.w3.org/TR/selectors-4/#range-pseudos\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"16\",\"android\":\"2.2\",\"chrome\":\"10\",\"edge\":\"13\",\"firefox\":\"29\",\"ios_saf\":\"5\",\"oculus\":\"5.0\",\"op_mob\":\"11\",\"opera\":\"11\",\"safari\":\"5.1\",\"samsung\":\"1.0\",\"webview_ios\":\"5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range\"},\"example\":\"input:in-range {\\n  background-color: rgb(0 255 0 / 0.25);\\n}\\ninput:out-of-range {\\n  background-color: rgb(255 0 0 / 0.25);\\n  border: 2px solid red;\\n}\",\"interoperable_at\":1447286400,\"vendors_implementations\":3},{\"id\":\"is-pseudo-class\",\"title\":\"`:is()` Matches-Any Pseudo-Class\",\"description\":\"A pseudo-class for matching elements in a selector list\",\"specification\":\"https://www.w3.org/TR/selectors-4/#matches-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"82\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"82\",\"ios_saf\":\"14\",\"oculus\":\"14.0\",\"op_mob\":\"63\",\"opera\":\"74\",\"safari\":\"14\",\"samsung\":\"15.0\",\"webview_ios\":\"14\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:is\"},\"example\":\"p:is(:first-child, .special) {\\n  margin-top: 1em;\\n}\",\"interoperable_at\":1611187200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-is-pseudo-class\"}],\"vendors_implementations\":3,\"web-feature\":\"is\"},{\"id\":\"lab-function\",\"title\":\"`lab()` Function\",\"description\":\"A function for specifying colors expressed in the CIE Lab color space\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-lab\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab\"},\"example\":\"body {\\n  color: lab(80% 50 20);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-lab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"lab\"},{\"id\":\"lch-function\",\"title\":\"`lch()` Function\",\"description\":\"A function for specifying colors expressed in the CIE Lab color space with chroma and hue\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-lch\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch\"},\"example\":\"body {\\n  color: lch(53% 105 40);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-lab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"lab\"},{\"id\":\"light-dark-function\",\"title\":\"`light-dark()` Function\",\"description\":\"React to the current used `color-scheme` value\",\"specification\":\"https://drafts.csswg.org/css-color-5/#light-dark\",\"stage\":2,\"browser_support\":{\"and_chr\":\"123\",\"and_ff\":\"120\",\"android\":\"123\",\"chrome\":\"123\",\"edge\":\"123\",\"firefox\":\"120\",\"ios_saf\":\"17.5\",\"op_mob\":\"82\",\"opera\":\"109\",\"safari\":\"17.5\",\"samsung\":\"27.0\",\"webview_ios\":\"17.5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark\"},\"example\":\"body {\\n  color: light-dark(cyan, magenta);\\n}\",\"interoperable_at\":1715558400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-light-dark-function\"}],\"vendors_implementations\":3},{\"id\":\"logical-overflow\",\"title\":\"Logical Overflow\",\"description\":\"Flow-relative `overflow` properties\",\"specification\":\"https://www.w3.org/TR/css-overflow-3/#overflow-control\",\"stage\":2,\"browser_support\":{\"and_chr\":\"135\",\"and_ff\":\"79\",\"android\":\"135\",\"chrome\":\"135\",\"edge\":\"135\",\"firefox\":\"69\",\"op_mob\":\"89\",\"opera\":\"120\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-block\"},\"example\":\"div {\\n  overflow-block: scroll;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-overflow\"}],\"vendors_implementations\":2},{\"id\":\"logical-overscroll-behavior\",\"title\":\"Logical Overscroll Behavior\",\"description\":\"Flow-relative `overscroll-behavior` properties\",\"specification\":\"https://www.w3.org/TR/css-overscroll-1/#overscroll-behavior-longhands-logical\",\"stage\":2,\"browser_support\":{\"and_chr\":\"77\",\"and_ff\":\"79\",\"android\":\"77\",\"chrome\":\"77\",\"edge\":\"79\",\"firefox\":\"73\",\"ios_saf\":\"16\",\"oculus\":\"7.0\",\"op_mob\":\"55\",\"opera\":\"64\",\"safari\":\"16\",\"samsung\":\"12.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior-block\"},\"example\":\"div {\\n  overscroll-behavior-block: scroll;\\n}\",\"interoperable_at\":1662940800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-overscroll-behavior\"}],\"vendors_implementations\":3},{\"id\":\"logical-properties-and-values\",\"title\":\"Logical Properties and Values\",\"description\":\"Flow-relative (left-to-right or right-to-left) properties and values\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"89\",\"and_ff\":\"66\",\"android\":\"89\",\"chrome\":\"89\",\"edge\":\"89\",\"firefox\":\"66\",\"ios_saf\":\"15\",\"oculus\":\"15.0\",\"op_mob\":\"63\",\"opera\":\"75\",\"safari\":\"15\",\"samsung\":\"15.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values\"},\"example\":\"span:first-child {\\n  margin-inline-start: 10px;\\n}\",\"interoperable_at\":1632096000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical\"}],\"vendors_implementations\":3},{\"id\":\"logical-resize\",\"title\":\"Logical values in the `resize` property\",\"description\":\"Flow-relative (block or inline) values in resize\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"118\",\"and_ff\":\"63\",\"android\":\"118\",\"chrome\":\"118\",\"edge\":\"118\",\"firefox\":\"63\",\"op_mob\":\"79\",\"opera\":\"104\",\"safari\":\"16\",\"samsung\":\"25.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/resize\"},\"example\":\"area {\\n  resize: inline;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-resize\"}],\"vendors_implementations\":2},{\"id\":\"logical-viewport-units\",\"title\":\"Logical Viewport Units\",\"description\":\"Flow-relative (horizontal or vertical) Viewport Units\",\"specification\":\"https://www.w3.org/TR/css-values-4/#viewport-relative-units\",\"stage\":2,\"browser_support\":{\"and_chr\":\"108\",\"and_ff\":\"101\",\"android\":\"108\",\"chrome\":\"108\",\"edge\":\"108\",\"firefox\":\"101\",\"ios_saf\":\"15.4\",\"op_mob\":\"73\",\"opera\":\"94\",\"safari\":\"15.4\",\"samsung\":\"21.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/length#vb\"},\"example\":\"span:first-child {\\n  width: 5vi; height: 10vb; \\n}\",\"interoperable_at\":1670198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-viewport-units\"}],\"vendors_implementations\":3,\"web-feature\":\"viewport-unit-variants\"},{\"id\":\"media-queries-aspect-ratio-number-values\",\"title\":\"Aspect-Ratio number values\",\"description\":\"Support `<ratio>` values with `<number>` components in `@media`\",\"specification\":\"https://www.w3.org/TR/css-values-4/#ratio-value\",\"stage\":2,\"browser_support\":{\"and_chr\":\"110\",\"and_ff\":\"79\",\"android\":\"110\",\"chrome\":\"110\",\"edge\":\"110\",\"firefox\":\"78\",\"ios_saf\":\"16.4\",\"op_mob\":\"74\",\"opera\":\"96\",\"safari\":\"16.4\",\"samsung\":\"21.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/ratio\"},\"example\":\"@media (aspect-ratio: 1.77) {\\n  html {\\n    background-color: cyan;\\n  }\\n}\",\"interoperable_at\":1679875200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-media-queries-aspect-ratio-number-values\"}],\"vendors_implementations\":3},{\"id\":\"media-query-ranges\",\"title\":\"Media Query Ranges\",\"description\":\"A syntax for defining media query ranges using ordinary comparison operators\",\"specification\":\"https://www.w3.org/TR/mediaqueries-4/#range-context\",\"stage\":3,\"browser_support\":{\"and_chr\":\"104\",\"and_ff\":\"102\",\"android\":\"104\",\"chrome\":\"104\",\"edge\":\"104\",\"firefox\":\"102\",\"ios_saf\":\"16.4\",\"oculus\":\"23.0\",\"op_mob\":\"71\",\"opera\":\"90\",\"safari\":\"16.4\",\"samsung\":\"20.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries#Syntax_improvements_in_Level_4\"},\"example\":\"@media (width < 480px) {}\\n\\n@media (480px <= width < 768px) {}\\n\\n@media (width >= 768px) {}\",\"interoperable_at\":1679875200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-media-minmax\"}],\"vendors_implementations\":3,\"web-feature\":\"media-query-range-syntax\"},{\"id\":\"nested-calc\",\"title\":\"Nested `calc()`\",\"description\":\"Nest calc functions with the calc function name\",\"specification\":\"https://www.w3.org/TR/css-values-4/#calc-func\",\"stage\":2,\"browser_support\":{\"and_chr\":\"51\",\"and_ff\":\"48\",\"android\":\"51\",\"chrome\":\"51\",\"edge\":\"16\",\"firefox\":\"48\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"41\",\"opera\":\"38\",\"safari\":\"11\",\"samsung\":\"5.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/calc\"},\"example\":\"p {\\n  padding: calc(1px + calc(4 / 3));\\n}\",\"interoperable_at\":1508198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nested-calc\"}],\"vendors_implementations\":3},{\"id\":\"nesting-rules\",\"title\":\"Nesting Rules\",\"description\":\"A syntax for nesting relative rules within rules\",\"specification\":\"https://www.w3.org/TR/css-nesting-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"117\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"117\",\"ios_saf\":\"17.2\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"17.2\",\"samsung\":\"25.0\",\"webview_ios\":\"17.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector\"},\"example\":\"article {\\n  & p {\\n    color: #333;\\n  }\\n}\",\"interoperable_at\":1702252800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting\"}],\"vendors_implementations\":3,\"web-feature\":\"nesting\"},{\"id\":\"not-pseudo-class\",\"title\":\"`:not()` Negation List Pseudo-Class\",\"description\":\"A pseudo-class for ignoring elements in a selector list\",\"specification\":\"https://www.w3.org/TR/selectors-4/#negation-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"84\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"84\",\"ios_saf\":\"9\",\"oculus\":\"14.0\",\"opera\":\"74\",\"safari\":\"9\",\"samsung\":\"15.0\",\"webview_ios\":\"9\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\"},\"example\":\"p:not(:first-child, .special) {\\n  margin-top: 1em;\\n}\",\"interoperable_at\":1611187200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-selector-not\"}],\"vendors_implementations\":3},{\"id\":\"oklab-function\",\"title\":\"`oklab` and `oklch` color functions\",\"description\":\"Functions that allow colors to be expressed in OKLab and OKLCH.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklab\"},\"example\":\"p {\\n  color: oklab(72.322% -0.0465 -0.1150);\\n  color: oklch(72.322% 0.12403 247.996);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-oklab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"oklab\"},{\"id\":\"opacity-percentage\",\"title\":\"Support for percentages for `opacity`\",\"description\":\"Syntactic sugar to use percentages instead of a float between 0 and 1.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#transparency\",\"stage\":2,\"browser_support\":{\"and_chr\":\"78\",\"and_ff\":\"79\",\"android\":\"78\",\"chrome\":\"78\",\"edge\":\"79\",\"firefox\":\"70\",\"ios_saf\":\"13.4\",\"oculus\":\"8.0\",\"op_mob\":\"56\",\"opera\":\"65\",\"safari\":\"13.1\",\"samsung\":\"12.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\"},\"example\":\"img {\\n  opacity: 90%;\\n}\",\"interoperable_at\":1595894400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/mrcgrtz/postcss-opacity-percentage\"}],\"vendors_implementations\":3},{\"id\":\"overflow-property\",\"title\":\"`overflow` Shorthand Property\",\"description\":\"A property for defining `overflow-x` and `overflow-y`\",\"specification\":\"https://www.w3.org/TR/css-overflow-3/#propdef-overflow\",\"stage\":2,\"browser_support\":{\"and_chr\":\"68\",\"and_ff\":\"61\",\"android\":\"68\",\"chrome\":\"68\",\"edge\":\"79\",\"firefox\":\"61\",\"ios_saf\":\"13.4\",\"oculus\":\"6.0\",\"op_mob\":\"48\",\"opera\":\"55\",\"safari\":\"13.1\",\"samsung\":\"10.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\"},\"example\":\"html {\\n  overflow: hidden auto;\\n}\",\"interoperable_at\":1585008000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-overflow-shorthand\"}],\"vendors_implementations\":3},{\"id\":\"overflow-wrap-property\",\"title\":\"`overflow-wrap` Property\",\"description\":\"A property for defining whether to insert line breaks within words to prevent overflowing\",\"specification\":\"https://www.w3.org/TR/css-text-3/#overflow-wrap-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"25\",\"and_ff\":\"49\",\"android\":\"4.4\",\"chrome\":\"23\",\"edge\":\"18\",\"firefox\":\"49\",\"ios_saf\":\"7\",\"oculus\":\"5.0\",\"op_mob\":\"12.1\",\"opera\":\"12.1\",\"safari\":\"7\",\"samsung\":\"1.5\",\"webview_ios\":\"7\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap\"},\"example\":\"p {\\n  overflow-wrap: break-word;\\n}\",\"interoperable_at\":1538438400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/mattdimu/postcss-replace-overflow-wrap\"}],\"vendors_implementations\":3},{\"id\":\"overscroll-behavior-property\",\"title\":\"`overscroll-behavior` Property\",\"description\":\"Properties for controlling when the scroll position of a scroll container reaches the edge of a scrollport\",\"specification\":\"https://www.w3.org/TR/css-overscroll-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"63\",\"and_ff\":\"59\",\"android\":\"63\",\"chrome\":\"63\",\"edge\":\"18\",\"firefox\":\"59\",\"ios_saf\":\"16\",\"oculus\":\"5.0\",\"op_mob\":\"46\",\"opera\":\"50\",\"safari\":\"16\",\"samsung\":\"8.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior\"},\"example\":\".messages {\\n  height: 220px;\\n  overflow: auto;\\n  overscroll-behavior-y: contain;\\n}\\n\\nbody {\\n  margin: 0;\\n  overscroll-behavior: none;\\n}\",\"interoperable_at\":1662940800,\"vendors_implementations\":3},{\"id\":\"place-properties\",\"title\":\"Place Properties\",\"description\":\"Properties for defining alignment within a layout\",\"specification\":\"https://www.w3.org/TR/css-align-3/#place-items-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"59\",\"and_ff\":\"53\",\"android\":\"59\",\"chrome\":\"59\",\"edge\":\"79\",\"firefox\":\"53\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"46\",\"safari\":\"11\",\"samsung\":\"7.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/place-content\"},\"example\":\".example {\\n  place-content: flex-end;\\n  place-items: center / space-between;\\n  place-self: flex-start / center;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-place\"}],\"vendors_implementations\":3},{\"id\":\"prefers-color-scheme-query\",\"title\":\"`prefers-color-scheme` Media Query\",\"description\":\"A media query to detect if the user has requested the system use a light or dark color theme\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#prefers-color-scheme\",\"stage\":2,\"browser_support\":{\"and_chr\":\"76\",\"and_ff\":\"67\",\"android\":\"76\",\"chrome\":\"76\",\"edge\":\"79\",\"firefox\":\"67\",\"ios_saf\":\"13\",\"oculus\":\"7.0\",\"op_mob\":\"54\",\"opera\":\"62\",\"safari\":\"12.1\",\"samsung\":\"14.2\",\"webview_ios\":\"13\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\"},\"example\":\"body {\\n  background-color: white;\\n  color: black;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  body {\\n    background-color: black;\\n    color: white;\\n  }\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-prefers-color-scheme\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-prefers-color-scheme\"}],\"vendors_implementations\":3},{\"id\":\"prefers-reduced-motion-query\",\"title\":\"`prefers-reduced-motion` Media Query\",\"description\":\"A media query to detect if the user has requested less animation and general motion on the page\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#prefers-reduced-motion\",\"stage\":2,\"browser_support\":{\"and_chr\":\"74\",\"and_ff\":\"64\",\"android\":\"74\",\"chrome\":\"74\",\"edge\":\"79\",\"firefox\":\"63\",\"ios_saf\":\"10.3\",\"oculus\":\"6.0\",\"op_mob\":\"53\",\"opera\":\"62\",\"safari\":\"10.1\",\"samsung\":\"11.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion\"},\"example\":\".animation {\\n  animation: vibrate 0.3s linear infinite both; \\n}\\n\\n@media (prefers-reduced-motion: reduce) {\\n  .animation {\\n    animation: none;\\n  }\\n}\",\"interoperable_at\":1579046400,\"vendors_implementations\":3},{\"id\":\"random-function\",\"title\":\"`random()` function\",\"description\":\"Represents a random value between a minimum and maximum value, drawn from a uniform distribution, optionally limiting the possible values to a step between those limits\",\"specification\":\"https://drafts.csswg.org/css-values-5/#random\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"div {\\n  color: oklch(0.7, 0.2, random(120deg, 240deg));\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-random-function\"}],\"vendors_implementations\":0},{\"id\":\"read-only-write-pseudo-class\",\"title\":\"`:read-only` and `:read-write` selectors\",\"description\":\"Pseudo-classes to match elements which are considered user-alterable\",\"specification\":\"https://www.w3.org/TR/selectors-4/#rw-pseudos\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"79\",\"android\":\"4.4\",\"chrome\":\"1\",\"edge\":\"13\",\"firefox\":\"78\",\"ios_saf\":\"3.2\",\"oculus\":\"5.0\",\"op_mob\":\"10.1\",\"opera\":\"9\",\"safari\":\"4\",\"samsung\":\"1.0\",\"webview_ios\":\"3.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only\"},\"example\":\"input:read-only {\\n  background-color: #ccc;\\n}\",\"interoperable_at\":1595894400,\"vendors_implementations\":3,\"web-feature\":\"read-write-pseudos\"},{\"id\":\"rebeccapurple-color\",\"title\":\"`rebeccapurple` Color\",\"description\":\"A particularly lovely shade of purple in memory of Rebecca Alison Meyer\",\"specification\":\"https://www.w3.org/TR/css-color-4/#valdef-color-rebeccapurple\",\"stage\":2,\"browser_support\":{\"and_chr\":\"38\",\"and_ff\":\"33\",\"android\":\"38\",\"chrome\":\"38\",\"edge\":\"12\",\"firefox\":\"33\",\"ie\":\"11\",\"ios_saf\":\"8\",\"oculus\":\"5.0\",\"op_mob\":\"25\",\"opera\":\"25\",\"safari\":\"9\",\"samsung\":\"3.0\",\"webview_ios\":\"8\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\"},\"example\":\"html {\\n  color: rebeccapurple;\\n}\",\"interoperable_at\":1443571200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-rebeccapurple\"}],\"vendors_implementations\":3},{\"id\":\"relative-color-syntax\",\"title\":\"Relative Colors\",\"description\":\"Modify existing colors using color functions\",\"specification\":\"https://www.w3.org/TR/css-color-5/#relative-colors\",\"stage\":2,\"browser_support\":{\"and_chr\":\"125\",\"and_ff\":\"128\",\"android\":\"125\",\"chrome\":\"125\",\"edge\":\"125\",\"firefox\":\"128\",\"ios_saf\":\"18\",\"op_mob\":\"83\",\"opera\":\"111\",\"safari\":\"18\",\"samsung\":\"27.0\",\"webview_ios\":\"18\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_colors/Relative_colors\"},\"example\":\"p {\\n  color: lch(from peru calc(l * 0.8) c h);\\n}\",\"interoperable_at\":1726444800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-relative-color-syntax\"}],\"vendors_implementations\":3,\"web-feature\":\"relative-color\"},{\"id\":\"scope-pseudo-class\",\"title\":\"`:scope()` Reference Element Pseudo-class\",\"description\":\"A pseudo-class for matching one or more scoping roots\",\"specification\":\"https://www.w3.org/TR/selectors-4/#the-scope-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"27\",\"and_ff\":\"32\",\"android\":\"4.4\",\"chrome\":\"27\",\"edge\":\"79\",\"firefox\":\"32\",\"ios_saf\":\"7\",\"oculus\":\"5.0\",\"op_mob\":\"15\",\"opera\":\"15\",\"safari\":\"7\",\"samsung\":\"1.5\",\"webview_ios\":\"7\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:scope\"},\"example\":\":scope {\\n  background-color: pink;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-scope-pseudo-class\"}],\"vendors_implementations\":3},{\"id\":\"sign-functions\",\"title\":\"`abs()` and `sign()` functions\",\"description\":\"The sign-related functions—abs() and sign()—compute various functions related to the sign of their argument\",\"specification\":\"https://www.w3.org/TR/css-values-4/#sign-funcs\",\"stage\":2,\"browser_support\":{\"and_ff\":\"118\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"safari\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/sign\"},\"example\":\"div {\\n  order: abs(-10);\\n  order: sign(-10);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-sign-functions\"}],\"vendors_implementations\":2},{\"id\":\"src-function\",\"title\":\"`src()` function\",\"description\":\"The argument of `src()` can be provided by functions, such as var(). Otherwise this behaves the same as `url()`\",\"specification\":\"https://www.w3.org/TR/css-values-4/#funcdef-src\",\"stage\":2,\"browser_support\":{},\"example\":\"div {\\n  background: src('./image.jpg');\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/google/postcss-src\"}],\"vendors_implementations\":0},{\"id\":\"stepped-value-functions\",\"title\":\"`round()`, `mod()` and `rem()` functions\",\"description\":\"The stepped-value functions, `round()`, `mod()`, and `rem()`, all transform a given value according to another \\\"step value\\\", in different ways\",\"specification\":\"https://www.w3.org/TR/css-values-4/#round-func\",\"stage\":2,\"browser_support\":{\"and_chr\":\"125\",\"and_ff\":\"118\",\"android\":\"125\",\"chrome\":\"125\",\"edge\":\"125\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"op_mob\":\"83\",\"opera\":\"111\",\"safari\":\"15.4\",\"samsung\":\"27.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/round\"},\"example\":\"div {\\n  left: mod(18px, 5px);\\n  top: rem(18px, 5px);\\n  right: round(2.5px, 1px);\\n  bottom: round(up, 15px, 7px);\\n}\",\"interoperable_at\":1715904000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-stepped-value-functions\"}],\"vendors_implementations\":3},{\"id\":\"system-ui-font-family\",\"title\":\"`system-ui` Font Family\",\"description\":\"A generic font used to match the user’s interface\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#system-ui-def\",\"stage\":2,\"browser_support\":{\"and_chr\":\"56\",\"and_ff\":\"92\",\"android\":\"56\",\"chrome\":\"56\",\"edge\":\"79\",\"firefox\":\"92\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"43\",\"safari\":\"11\",\"samsung\":\"6.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Syntax\"},\"example\":\"body {\\n  font-family: system-ui;\\n}\",\"interoperable_at\":1630972800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/JLHwung/postcss-font-family-system-ui\"}],\"vendors_implementations\":3},{\"id\":\"text-decoration-shorthand\",\"title\":\"`text-decoration` shorthand\",\"description\":\"A property for defining `text-decoration-line`, `text-decoration-thickness`, `text-decoration-style` and `text-decoration-color`\",\"specification\":\"https://www.w3.org/TR/css-text-decor-4/#text-decoration-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"87\",\"and_ff\":\"79\",\"android\":\"87\",\"chrome\":\"87\",\"edge\":\"87\",\"firefox\":\"70\",\"oculus\":\"13.0\",\"op_mob\":\"62\",\"opera\":\"73\",\"samsung\":\"14.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration\"},\"example\":\"p {\\n  text-decoration: green wavy underline 2px;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-text-decoration-shorthand\"}],\"vendors_implementations\":2},{\"id\":\"trigonometric-functions\",\"title\":\"`sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()` and `atan2()` functions\",\"description\":\"Functions to calculate various basic trigonometric relationships\",\"specification\":\"https://www.w3.org/TR/css-values-4/#trig-funcs\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"108\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"108\",\"ios_saf\":\"15.4\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"15.4\",\"samsung\":\"22.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/sin\"},\"example\":\"body {\\n  left: sin(45deg);\\n  left: cos(45deg);\\n  left: tan(45deg);\\n  left: asin(0.5);\\n  left: acos(0.5);\\n  left: atan(10);\\n  left: atan2(-1, 1);\\n}\",\"interoperable_at\":1678665600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-trigonometric-functions\"}],\"vendors_implementations\":3},{\"id\":\"unset-value\",\"title\":\"`unset` Keyword\",\"description\":\"The unset CSS keyword resets a property to its inherited value if the property naturally inherits from its parent, and to its initial value if not.\",\"specification\":\"https://www.w3.org/TR/css-cascade-4/#inherit-initial\",\"stage\":3,\"browser_support\":{\"and_chr\":\"41\",\"and_ff\":\"27\",\"android\":\"41\",\"chrome\":\"41\",\"edge\":\"13\",\"firefox\":\"27\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"28\",\"opera\":\"28\",\"safari\":\"9.1\",\"samsung\":\"4.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/unset\"},\"example\":\"div {\\n  border-color: unset;\\n  color: unset;\\n}\",\"interoperable_at\":1458518400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-unset-value\"}],\"vendors_implementations\":3},{\"id\":\"when-else-rules\",\"title\":\"When/Else Rules\",\"description\":\"At-rules for specifying media queries and support queries in a single grammar\",\"specification\":\"https://www.w3.org/TR/2021/WD-css-conditional-5-20211221/\",\"stage\":2,\"browser_support\":{},\"example\":\"@when media(width >= 640px) and (supports(display: flex) or supports(display: grid)) {\\n  /* A */\\n} @else media(pointer: coarse) {\\n  /* B */\\n} @else {\\n  /* C */\\n}\",\"vendors_implementations\":0},{\"id\":\"where-pseudo-class\",\"title\":\"`:where()` Zero-Specificity Pseudo-Class\",\"description\":\"A pseudo-class for matching elements in a selector list without contributing specificity\",\"specification\":\"https://www.w3.org/TR/selectors-4/#where-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"82\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"82\",\"ios_saf\":\"14\",\"oculus\":\"14.0\",\"op_mob\":\"63\",\"opera\":\"74\",\"safari\":\"14\",\"samsung\":\"15.0\",\"webview_ios\":\"14\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:where\"},\"example\":\"a:where(:not(:hover)) {\\n  text-decoration: none;\\n}\",\"interoperable_at\":1611187200,\"vendors_implementations\":3,\"web-feature\":\"where\"}]"));}}),
"[project]/node_modules/postcss-pseudo-class-any-link/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-pseudo-class-any-link/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const t = e().astSync(":link").nodes[0], s = e().astSync(":visited").nodes[0], n = e().astSync("area[href]").nodes[0], o = e().astSync("[href]").nodes[0];
function replaceAnyLink(e, t, s, n) {
    const o = [], r = [];
    try {
        for(let t = 0; t < e.selectors.length; t++){
            const s = e.selectors[t], l = modifiedSelector(s, n);
            l.length ? o.push(...l) : r.push(s);
        }
    } catch (s) {
        return e.warn(t, `Failed to parse selector : "${e.selector}" with message: "${s instanceof Error ? s.message : s}"`), !1;
    }
    return !!o.length && (e.cloneBefore({
        selectors: o
    }), r.length && e.cloneBefore({
        selectors: r
    }), s || e.remove(), !0);
}
function modifiedSelector(r, l) {
    const c = [];
    return e((e)=>{
        const r = [];
        if (e.walkPseudos((e)=>{
            if (":not" === e.value.toLowerCase()) return !1;
            if (":any-link" !== e.value.toLowerCase() || e.nodes && e.nodes.length) return;
            if (!l) return void r.push([
                t.clone(),
                s.clone()
            ]);
            const c = getTagElementsNextToPseudo(e);
            c.includes("area") ? r.push([
                t.clone(),
                s.clone(),
                o.clone()
            ]) : c.length ? r.push([
                t.clone(),
                s.clone()
            ]) : r.push([
                t.clone(),
                s.clone(),
                n.clone()
            ]);
        }), !r.length) return;
        cartesianProduct(...r).forEach((t)=>{
            const s = e.clone();
            s.walkPseudos((e)=>{
                ":any-link" !== e.value.toLowerCase() || e.nodes && e.nodes.length || (insertNode(e.parent, e, t.shift()), e.remove());
            }), c.push(s.toString());
        });
    }).processSync(r), c;
}
function cartesianProduct(...e) {
    const t = [], s = e.length - 1;
    return function helper(n, o) {
        for(let r = 0, l = e[o].length; r < l; r++){
            const l = n.slice(0);
            l.push(e[o][r]), o == s ? t.push(l) : helper(l, o + 1);
        }
    }([], 0), t;
}
function getTagElementsNextToPseudo(t) {
    const s = [];
    let n = t.prev();
    for(; n && "combinator" !== n.type && !e.isPseudoElement(n);)"tag" === n.type && s.push(n.value.toLowerCase()), n = n.prev();
    let o = t.next();
    for(; o && "combinator" !== o.type && !e.isPseudoElement(o);)"tag" === o.type && s.push(o.value.toLowerCase()), o = o.next();
    return s;
}
function insertNode(t, s, n) {
    if (!t || !n) return;
    let o = n.type;
    "selector" === n.type && n.nodes && n.nodes.length && (o = n.nodes[0].type);
    let r = -1, l = -1;
    const c = t.index(s);
    for(let s = c; s >= 0 && "combinator" !== t.nodes[s].type && !e.isPseudoElement(t.nodes[s].type); s--)r = s;
    if ("tag" !== o) {
        for(let s = c; s < t.nodes.length && "combinator" !== t.nodes[s].type && !e.isPseudoElement(t.nodes[s].type); s++)l = s;
        for(let e = r; e <= l; e++)if (t.nodes[e].type === o) return void t.insertAfter(t.at(e), n);
        t.insertAfter(t.at(r), n);
    } else t.insertBefore(t.at(r), n);
}
const creator = (e)=>{
    const t = {
        preserve: e?.preserve ?? !0,
        subFeatures: {
            areaHrefNeedsFixing: e?.subFeatures?.areaHrefNeedsFixing ?? !1
        }
    };
    return {
        postcssPlugin: "postcss-pseudo-class-any-link",
        prepare () {
            const e = new WeakSet;
            return {
                postcssPlugin: "postcss-pseudo-class-any-link",
                Rule (s, { result: n }) {
                    if (!s.selector.toLowerCase().includes(":any-link")) return;
                    if (e.has(s)) return;
                    if ((s.raws.selector && s.raws.selector.raw || s.selector).endsWith(":")) return;
                    replaceAnyLink(s, n, t.preserve, t.subFeatures.areaHrefNeedsFixing) && e.add(s);
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/css-blank-pseudo/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-blank-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = [
    " ",
    ">",
    "~",
    ":",
    "+",
    "@",
    "#",
    "(",
    ")"
];
function isValidReplacement(e) {
    let n = !0;
    for(let t = 0, o = s.length; t < o && n; t++)e.indexOf(s[t]) > -1 && (n = !1);
    return n;
}
const n = "js-blank-pseudo", t = ":blank", creator = (s)=>{
    const o = Object.assign({
        preserve: !0,
        replaceWith: "[blank]",
        disablePolyfillReadyClass: !1
    }, s), r = e().astSync(o.replaceWith);
    return isValidReplacement(o.replaceWith) ? {
        postcssPlugin: "css-blank-pseudo",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "css-blank-pseudo",
                Rule (l, { result: a }) {
                    if (s.has(l)) return;
                    if (!l.selector.toLowerCase().includes(t)) return;
                    const i = l.selectors.flatMap((s)=>{
                        if (!s.toLowerCase().includes(t)) return [
                            s
                        ];
                        let i;
                        try {
                            i = e().astSync(s);
                        } catch (e) {
                            return l.warn(a, `Failed to parse selector : "${s}" with message: "${e instanceof Error ? e.message : e}"`), [
                                s
                            ];
                        }
                        if (void 0 === i) return [
                            s
                        ];
                        let c = !1;
                        if (i.walkPseudos((e)=>{
                            e.value.toLowerCase() === t && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(r.clone({}))));
                        }), !c) return [
                            s
                        ];
                        const d = i.clone();
                        if (!o.disablePolyfillReadyClass) {
                            if (i.nodes?.[0]?.nodes?.length) for(let s = 0; s < i.nodes[0].nodes.length; s++){
                                const t = i.nodes[0].nodes[s];
                                if ("combinator" === t.type || e.isPseudoElement(t)) {
                                    i.nodes[0].insertBefore(t, e.className({
                                        value: n
                                    }));
                                    break;
                                }
                                if (s === i.nodes[0].nodes.length - 1) {
                                    i.nodes[0].append(e.className({
                                        value: n
                                    }));
                                    break;
                                }
                            }
                            return i.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: n
                            }))), [
                                i.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            i.toString()
                        ];
                    });
                    i.join(",") !== l.selectors.join(",") && (s.add(l), l.cloneBefore({
                        selectors: i
                    }), o.preserve || l.remove());
                }
            };
        }
    } : {
        postcssPlugin: "css-blank-pseudo",
        Once (e, { result: s }) {
            e.warn(s, `${o.replaceWith} is not a valid replacement since it can't be applied to single elements.`);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-page-break/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function(options) {
    return {
        postcssPlugin: 'postcss-page-break',
        Declaration (decl) {
            if (decl.prop.startsWith('break-') && /^break-(inside|before|after)/.test(decl.prop)) {
                // do not process column|region related properties
                if (decl.value.search(/column|region/) >= 0) {
                    return;
                }
                let newValue;
                switch(decl.value){
                    case 'page':
                        newValue = 'always';
                        break;
                    case 'avoid-page':
                        newValue = 'avoid';
                        break;
                    default:
                        newValue = decl.value;
                }
                const newProperty = 'page-' + decl.prop;
                if (decl.parent.every((sibling)=>sibling.prop !== newProperty)) {
                    decl.cloneBefore({
                        prop: newProperty,
                        value: newValue
                    });
                }
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/css-has-pseudo/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/css-has-pseudo/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
function encodeCSS(e) {
    if ("" === e) return "";
    let t, s = "";
    for(let r = 0; r < e.length; r++)t = e.charCodeAt(r).toString(36), s += 0 === r ? t : "-" + t;
    return "csstools-has-" + s;
}
function isGuardedByAtSupportsFromAtRuleParams(e) {
    if (!e.toLowerCase().includes(":has(")) return !1;
    let s = !1;
    try {
        const r = new Set;
        t(e).walk((e)=>{
            if ("function" === e.type && "selector" === e.value.toLowerCase()) return r.add(t.stringify(e.nodes)), !1;
        }), r.forEach((e)=>{
            selectorContainsHasPseudo(e) && (s = !0);
        });
    } catch  {}
    return s;
}
function selectorContainsHasPseudo(t) {
    if (!t.toLowerCase().includes(":has(")) return !1;
    let s = !1;
    try {
        e().astSync(t).walk((e)=>{
            if ("pseudo" === e.type && ":has" === e.value.toLowerCase() && e.nodes && e.nodes.length > 0) return s = !0, !1;
        });
    } catch  {}
    return s;
}
const creator = (t)=>{
    const r = {
        preserve: !0,
        specificityMatchingName: "does-not-exist",
        ...t || {}
    }, o = ":not(#" + r.specificityMatchingName + ")", n = ":not(." + r.specificityMatchingName + ")", a = ":not(" + r.specificityMatchingName + ")";
    return {
        postcssPlugin: "css-has-pseudo",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "css-has-pseudo",
                RuleExit (c, { result: i }) {
                    if (t.has(c)) return;
                    if (!c.selector.toLowerCase().includes(":has(") || isWithinSupportCheck(c)) return;
                    const l = c.selectors.map((t)=>{
                        if (!t.toLowerCase().includes(":has(")) return t;
                        let l;
                        try {
                            l = e().astSync(t);
                        } catch (e) {
                            return c.warn(i, `Failed to parse selector : "${t}" with message: "${e instanceof Error ? e.message : e}"`), t;
                        }
                        if (void 0 === l) return t;
                        l.walkPseudos((t)=>{
                            let s = t.parent, o = !1;
                            for(; s;)e.isPseudoClass(s) && ":has" === s.value.toLowerCase() && (o = !0), s = s.parent;
                            o && (":visited" === t.value.toLowerCase() && t.replaceWith(e.className({
                                value: r.specificityMatchingName
                            })), ":any-link" === t.value.toLowerCase() && (t.value = ":link"));
                        }), l.walkPseudos((t)=>{
                            if (":has" !== t.value.toLowerCase() || !t.nodes) return;
                            const r = t.parent;
                            if (!r) return;
                            const c = e.selector({
                                value: "",
                                nodes: []
                            });
                            {
                                let t = r.nodes.length;
                                e: for(let s = 0; s < r.nodes.length; s++){
                                    const o = r.nodes[s];
                                    if (e.isPseudoElement(o)) {
                                        for(let e = s - 1; e >= 0; e--)if ("combinator" !== r.nodes[s].type && "comment" !== r.nodes[s].type) {
                                            t = e + 1;
                                            break e;
                                        }
                                    }
                                }
                                r.nodes.slice(0, t).forEach((e)=>{
                                    e.remove(), "selector" === e.type ? e.nodes.forEach((e)=>{
                                        delete e.parent, c.append(e);
                                    }) : (delete e.parent, c.append(e));
                                });
                            }
                            const i = "[" + encodeCSS(c.toString()) + "]", l = s.selectorSpecificity(c);
                            let u = i;
                            for(let e = 0; e < l.a; e++)u += o;
                            const p = Math.max(1, l.b) - 1;
                            for(let e = 0; e < p; e++)u += n;
                            for(let e = 0; e < l.c; e++)u += a;
                            const d = e().astSync(u).nodes[0].nodes;
                            for(let e = d.length - 1; e >= 0; e--)r.prepend(d[e]);
                        });
                        const u = l.toString();
                        return u !== t ? ".js-has-pseudo " + u : t;
                    });
                    l.join(",") !== c.selectors.join(",") && (t.add(c), c.cloneBefore({
                        selectors: l
                    }), r.preserve || c.remove());
                }
            };
        }
    };
};
function isWithinSupportCheck(e) {
    let t = e.parent;
    for(; t;){
        if ("atrule" === t.type && isGuardedByAtSupportsFromAtRuleParams(t.params)) return !0;
        t = t.parent;
    }
    return !1;
}
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-resolve-nested/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function sourceFrom(e) {
    return {
        sourceIndex: e.sourceIndex ?? 0,
        source: e.source
    };
}
function sortCompoundSelectorsInsideComplexSelector(o) {
    const t = [];
    let r = [];
    o.each((o)=>{
        if ("combinator" === o.type) return t.push(r, [
            o
        ]), void (r = []);
        if (e.isPseudoElement(o)) return t.push(r), void (r = [
            o
        ]);
        if ("universal" === o.type && r.find((e)=>"universal" === e.type)) o.remove();
        else {
            if ("tag" === o.type && r.find((e)=>"tag" === e.type)) {
                o.remove();
                const t = e.selector({
                    value: "",
                    ...sourceFrom(o)
                });
                t.append(o);
                const n = e.pseudo({
                    value: ":is",
                    ...sourceFrom(o)
                });
                return n.append(t), void r.push(n);
            }
            r.push(o);
        }
    }), t.push(r);
    const n = [];
    for(let e = 0; e < t.length; e++){
        const o = t[e];
        o.sort((e, o)=>selectorTypeOrder(e) - selectorTypeOrder(o)), n.push(...o);
    }
    o.removeAll();
    for(let e = n.length - 1; e >= 0; e--)n[e].remove(), n[e].parent = o, o.nodes.unshift(n[e]);
}
function selectorTypeOrder(t) {
    return e.isPseudoElement(t) ? o.pseudoElement : o[t.type];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    nesting: 3,
    id: 4,
    class: 5,
    attribute: 6,
    pseudo: 7,
    comment: 8
};
function prepareParentSelectors(o, t = !1) {
    if (t || !isCompoundSelector(o.nodes)) {
        const t = e.pseudo({
            value: ":is",
            ...sourceFrom(o)
        });
        return o.nodes.forEach((e)=>{
            t.append(e.clone());
        }), [
            t
        ];
    }
    return o.nodes[0].nodes.map((e)=>e.clone());
}
function isCompoundSelector(o) {
    return 1 === o.length && !o[0].nodes.some((o)=>"combinator" === o.type || e.isPseudoElement(o));
}
function combinationsWithSizeN(e, o) {
    if (o < 2) throw new Error("n must be greater than 1");
    if (e.length < 2) throw new Error("s must be greater than 1");
    if (Math.pow(e.length, o) > 1e4) throw new Error("Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors");
    const t = [];
    for(let e = 0; e < o; e++)t[e] = 0;
    const r = [];
    for(;;){
        const n = [];
        for(let s = o - 1; s >= 0; s--){
            let o = t[s];
            if (o >= e.length) {
                if (o = 0, t[s] = 0, 0 === s) return r;
                t[s - 1] += 1;
            }
            n[s] = e[o].clone();
        }
        r.push(n), t[t.length - 1]++;
    }
}
exports.flattenNestedSelector = function flattenNestedSelector(o, t) {
    const r = [];
    for(let n = 0; n < o.nodes.length; n++){
        const s = o.nodes[n].clone();
        let c, l = 0;
        {
            let o = !1;
            s.walkNesting(()=>{
                o = !0, l++;
            }), o ? "combinator" === s.nodes[0]?.type && (s.prepend(e.nesting({
                ...sourceFrom(s)
            })), l++) : (s.prepend(e.combinator({
                value: " ",
                ...sourceFrom(s)
            })), s.prepend(e.nesting({
                ...sourceFrom(s)
            })), l++);
        }
        let p = [];
        if (l > 1 && t.nodes.length > 1) p = combinationsWithSizeN(t.nodes, l), c = p.length;
        else {
            c = t.nodes.length;
            for(let e = 0; e < t.nodes.length; e++){
                p.push([]);
                for(let o = 0; o < l; o++)p[e].push(t.nodes[e].clone());
            }
        }
        for(let e = 0; e < c; e++){
            let o = 0;
            const t = s.clone();
            t.walkNesting((t)=>{
                const r = p[e][o];
                o++, t.replaceWith(...r.nodes);
            }), r.push(t);
        }
    }
    const n = e.root({
        value: "",
        ...sourceFrom(o)
    });
    return r.forEach((e)=>{
        n.append(e);
    }), n;
}, exports.resolveNestedSelector = function resolveNestedSelector(o, t, r) {
    const n = [];
    for(let s = 0; s < o.nodes.length; s++){
        const c = o.nodes[s].clone();
        if (!r?.ignoreImplicitNesting) {
            let o = !1;
            c.walkNesting(()=>(o = !0, !1)), o ? "combinator" === c.nodes[0]?.type && c.prepend(e.nesting({
                ...sourceFrom(c)
            })) : (c.prepend(e.combinator({
                value: " ",
                ...sourceFrom(c)
            })), c.prepend(e.nesting({
                ...sourceFrom(c)
            })));
        }
        {
            const e = new Set;
            c.walkNesting((o)=>{
                const r = o.parent;
                r && (e.add(r), "pseudo" === r.parent?.type && ":has" === r.parent.value?.toLowerCase() ? o.replaceWith(...prepareParentSelectors(t, !0)) : o.replaceWith(...prepareParentSelectors(t)));
            });
            for (const o of e)sortCompoundSelectorsInsideComplexSelector(o);
        }
        c.walk((e)=>{
            "combinator" === e.type && "" !== e.value.trim() ? (e.rawSpaceAfter = " ", e.rawSpaceBefore = " ") : (e.rawSpaceAfter = "", e.rawSpaceBefore = "");
        }), n.push(c);
    }
    const s = e.root({
        value: "",
        ...sourceFrom(o)
    });
    return n.forEach((e)=>{
        s.append(e);
    }), s;
};
}}),
"[project]/node_modules/postcss-nesting/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-resolve-nested/dist/index.cjs [postcss] (ecmascript)");
const r = e.pseudo({
    value: ":is"
});
function sortCompoundSelectorsInsideComplexSelector(t) {
    if (!t || !t.nodes) return;
    const n = [];
    let o = [];
    for(let s = 0; s < t.nodes.length; s++)if ("combinator" !== t.nodes[s].type) if (e.isPseudoElement(t.nodes[s])) n.push(o), o = [
        t.nodes[s]
    ];
    else {
        if ("tag" === t.nodes[s].type && o.find((e)=>"tag" === e.type)) {
            const n = r.clone({}), o = t.nodes[s];
            o.replaceWith(n), n.append(e.selector({
                nodes: [
                    o
                ],
                value: void 0
            }));
        }
        o.push(t.nodes[s]);
    }
    else n.push(o), n.push([
        t.nodes[s]
    ]), o = [];
    n.push(o);
    const s = [];
    for(let e = 0; e < n.length; e++){
        const t = n[e];
        t.sort((e, t)=>"selector" === e.type && "selector" === t.type && e.nodes.length && t.nodes.length ? selectorTypeOrder(e.nodes[0]) - selectorTypeOrder(t.nodes[0]) : "selector" === e.type && e.nodes.length ? selectorTypeOrder(e.nodes[0]) - selectorTypeOrder(t) : "selector" === t.type && t.nodes.length ? selectorTypeOrder(e) - selectorTypeOrder(t.nodes[0]) : selectorTypeOrder(e) - selectorTypeOrder(t));
        for(let e = 0; e < t.length; e++)s.push(t[e]);
    }
    t.removeAll();
    for(let e = s.length - 1; e >= 0; e--)s[e].remove(), s[e].parent = t, t.nodes.unshift(s[e]);
}
function selectorTypeOrder(t) {
    return e.isPseudoElement(t) ? o.pseudoElement : o[t.type];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    id: 3,
    class: 4,
    attribute: 5,
    pseudo: 6,
    selector: 7,
    string: 8,
    root: 9,
    comment: 10
};
function isAtRule(e) {
    return e && "atrule" === e.type;
}
function isNestRule(e) {
    return e && isAtRule(e) && "nest" === e.name;
}
function isRule(e) {
    return e && "rule" === e.type;
}
function ampersandToScope$1(t, n) {
    let r, o = t.parent;
    for(; o;){
        if ("rule" === o.type) return;
        if (isAtRule(o) && "scope" === o.name) return;
        o = o.parent;
    }
    try {
        r = e().astSync(t.selector);
    } catch (e) {
        return void t.warn(n, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
    }
    r && (r.walkNesting((t)=>{
        const n = t.parent;
        t.replaceWith(e.pseudo({
            value: ":scope"
        })), n && sortCompoundSelectorsInsideComplexSelector(n);
    }), t.selector = r.toString());
}
function cleanupParent(e) {
    if (!e.nodes.length) return void e.remove();
    const t = e.nodes.filter((e)=>"comment" === e.type);
    t.length === e.nodes.length && e.replaceWith(...t);
}
function groupDeclarations(e) {
    const t = [], n = [];
    e.each((e)=>{
        if (isDeclarationLike(e, n.length > 0)) t.push(e);
        else {
            if ("comment" === e.type) {
                let r = e.next();
                for(; r && "comment" === r.type;)r = r.next();
                if (isDeclarationLike(r, n.length > 0)) return void t.push(e);
            }
            n.push(e);
        }
    }), e.removeAll(), t.forEach((t)=>{
        e.append(t);
    }), n.forEach((t)=>{
        e.append(t);
    });
}
function isDeclarationLike(e, t) {
    return !!e && ("decl" === e.type || "atrule" === e.type && "mixin" === e.name.toLowerCase() && !t);
}
function comma(e) {
    const t = [];
    let n = "", r = !1, o = 0, s = !1, i = !1;
    for (const l of e)i ? i = !1 : "\\" === l ? i = !0 : s ? l === s && (s = !1) : '"' === l || "'" === l ? s = l : "(" === l ? o += 1 : ")" === l ? o > 0 && (o -= 1) : 0 === o && "," === l && (r = !0), r ? ("" !== n && t.push(n.trim()), n = "", r = !1) : n += l;
    return t.push(n.trim()), t;
}
function shiftNodesBeforeParent(e, t) {
    const n = t.index(e);
    if (n) {
        const e = t.cloneBefore().removeAll().append(t.nodes.slice(0, n));
        e.raws.semicolon = !0, cleanupParent(e);
    }
    t.before(e), t.raws.semicolon = !0;
}
var s = [
    "container",
    "document",
    "media",
    "supports",
    "layer",
    "starting-style"
];
function transformAtruleWithinAtrule(e, t) {
    var n, r;
    groupDeclarations(t), shiftNodesBeforeParent(e, t), e.params = (n = t.params, r = e.params, comma(n).map((e)=>comma(r).map((t)=>`${e} and ${t}`).join(", ")).join(", ")), cleanupParent(t);
}
function isAtruleWithinAtrule(e, t) {
    return s.includes(e.name) && e.name === t.name;
}
function atruleWithinRule$1(e, t, n, r, o) {
    if (groupDeclarations(t), shiftNodesBeforeParent(e, t), e.nodes) {
        const s = t.clone().removeAll().append(e.nodes);
        e.append(s), cleanupParent(t), r(s, n, o);
    } else cleanupParent(t);
}
function isAtruleWithinRule$1(e) {
    return s.includes(e.name);
}
function combinationsWithSizeN(e, t) {
    if (t < 2) throw new Error("n must be greater than 1");
    if (e.length < 2) throw new Error("s must be greater than 1");
    if (Math.pow(e.length, t) > 1e4) throw new Error("Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors");
    const n = [];
    for(let e = 0; e < t; e++)n[e] = 0;
    const r = [];
    for(;;){
        const o = [];
        for(let s = t - 1; s >= 0; s--){
            let t = n[s];
            if (t >= e.length) {
                if (t = 0, n[s] = 0, 0 === s) return r;
                n[s - 1] += 1;
            }
            o[s] = e[t].clone();
        }
        r.push(o), n[n.length - 1]++;
    }
}
function nodesAreEquallySpecific(n) {
    const r = n.map((t)=>e().astSync(t)).map((e)=>t.selectorSpecificity(e)), o = r[0];
    for(let e = 1; e < r.length; e++)if (o.a !== r[e].a || o.b !== r[e].b || o.c !== r[e].c) return !1;
    return !0;
}
function mergeSelectors$1(t, n, r) {
    let o = [];
    o = nodesAreEquallySpecific(t) || r.noIsPseudoSelector ? t.map((t)=>e().astSync(t)) : [
        e().astSync(`:is(${t.join(",")})`)
    ];
    const s = [];
    for(let t = 0; t < n.length; t++){
        let i, l = n[t];
        {
            const t = e().astSync(l);
            let n = !1;
            t.walk((e)=>{
                "nesting" === e.type && (n = !0);
            });
            const r = t.nodes[0];
            let o = !1;
            r.each((e)=>"combinator" === e.type && (o = !0, !1)), n ? o && r.insertBefore(r.at(0), e.nesting()) : (r.insertBefore(r.at(0), e.combinator({
                value: " "
            })), r.insertBefore(r.at(0), e.nesting())), l = t.toString();
        }
        let c = [], a = 0;
        if (e().astSync(l).walkNesting(()=>{
            a++;
        }), a > 1 && o.length > 1) c = combinationsWithSizeN(o, a), i = c.length;
        else {
            i = o.length;
            for(let e = 0; e < o.length; e++){
                c.push([]);
                for(let t = 0; t < a; t++)c[e].push(o[e]);
            }
        }
        for(let t = 0; t < i; t++){
            let n = 0;
            const o = e().astSync(l);
            o.walk((o)=>{
                if ("nesting" !== o.type) return;
                let s = c[t][n];
                n++, "root" === s.type && 1 === s.nodes.length && (s = s.nodes[0]);
                const i = e().astSync(`:is(${s.toString()})`), l = isSimpleSelector(s.nodes[0]), a = isCompoundSelector(s.nodes[0]), u = isSimpleSelector(o), p = isCompoundSelector(o);
                if (l && u) return void o.replaceWith(s.clone());
                if ((l || a) && (u || p)) {
                    const e = o.parent;
                    return l && "selector" === s.type ? o.replaceWith(s.clone().nodes[0]) : o.replaceWith(...s.clone().nodes), void (e && e.nodes.length > 1 && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (l) {
                    const e = o.parent;
                    return o.replaceWith(s.clone().nodes[0]), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (a) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(o)) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (nestingIsNotInsideCompoundSelector(o)) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                const d = o.parent;
                r.noIsPseudoSelector ? o.replaceWith(...s.clone().nodes) : o.replaceWith(...i.clone({}).nodes), d && sortCompoundSelectorsInsideComplexSelector(d);
            }), s.push(o.toString());
        }
    }
    return s;
}
function isSimpleSelector(e) {
    return "combinator" !== e.type && !(e.parent && e.parent.nodes.length > 1);
}
function isCompoundSelector(e, t = null) {
    if (isSimpleSelector(e)) return !1;
    if (!e.parent) return !1;
    if (!!e.parent.nodes.find((e)=>"combinator" === e.type)) return !1;
    return !(!!e.parent.nodes.find((e)=>"nesting" === e.type) && t && !isCompoundSelector(t));
}
function nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(e) {
    if (!e.parent) return !1;
    if (0 !== e.parent.nodes.indexOf(e)) return !1;
    for(let t = 1; t < e.parent.nodes.length; t++)if ("combinator" === e.parent.nodes[t].type && " " !== e.parent.nodes[t].value && ">" !== e.parent.nodes[t].value) return !1;
    return !0;
}
function nestingIsNotInsideCompoundSelector(e) {
    if (isSimpleSelector(e)) return !0;
    if (!e.parent) return !1;
    for(let t = 0; t < e.parent.nodes.length; t++)if ("nesting" !== e.parent.nodes[t].type && (e.parent.nodes[t].prev() || e.parent.nodes[t].next())) {
        if (e.parent.nodes[t].prev() && "combinator" !== e.parent.nodes[t].prev().type) return !1;
        if (e.parent.nodes[t].next() && "combinator" !== e.parent.nodes[t].next().type) return !1;
    }
    return !0;
}
function transformNestRuleWithinRule(e, t, n, r, o) {
    let s = [];
    try {
        s = mergeSelectors$1(t.selectors, comma(e.params), o);
    } catch (r) {
        return void e.warn(n, `Failed to parse selectors : "${t.selector}" / "${e.params}" with message: "${r instanceof Error ? r.message : r}"`);
    }
    if (!s.length) return;
    shiftNodesBeforeParent(e, t);
    const i = t.clone().removeAll().append(e.nodes);
    i.raws.semicolon = !0, i.selectors = s, e.replaceWith(i), cleanupParent(t), r(i, n, o);
}
function isValidNestRuleWithinRule(e) {
    return comma(e.params).every((e)=>e.split("&").length >= 2 && -1 === e.indexOf("|"));
}
function transformRuleWithinRule$1(e, t, n, r) {
    let o = [];
    try {
        o = mergeSelectors$1(t.selectors, e.selectors, r);
    } catch (r) {
        return void e.warn(n, `Failed to parse selectors : "${t.selector}" / "${e.selector}" with message: "${r instanceof Error ? r.message : r}"`);
    }
    if (!o.length) return;
    groupDeclarations(t), shiftNodesBeforeParent(e, t), e.selectors = o;
    "rule" === e.type && "rule" === t.type && e.selector === t.selector && e.append(...t.nodes), cleanupParent(t);
}
function isValidRuleWithinRule$1(e) {
    return e.selectors.every((e)=>-1 === e.indexOf("|"));
}
function walk$1(e, t, n) {
    e.each((r)=>{
        const o = r.parent;
        isNestRule(r) && !n.silenceAtNestWarning && e.warn(t, `\`@nest\` was removed from the CSS Nesting specification and will be removed from PostCSS Nesting in the next major version.\nChange \`@nest ${r.params} {}\` to \`${r.params} {}\` to migrate to the latest standard.`), isRule(r) && isRule(o) && isValidRuleWithinRule$1(r) ? transformRuleWithinRule$1(r, o, t, n) : isNestRule(r) && isRule(o) && isValidNestRuleWithinRule(r) ? transformNestRuleWithinRule(r, o, t, walk$1, n) : isAtRule(r) && isRule(o) && isAtruleWithinRule$1(r) ? atruleWithinRule$1(r, o, t, walk$1, n) : isAtRule(r) && isAtRule(o) && isAtruleWithinAtrule(r, o) && transformAtruleWithinAtrule(r, o), "nodes" in r && r.nodes.length && walk$1(r, t, n);
    });
}
const creator$2 = (e)=>{
    const t = Object.assign({
        noIsPseudoSelector: !1,
        silenceAtNestWarning: !1
    }, e);
    return {
        postcssPlugin: "postcss-nesting",
        Rule (e, { result: n }) {
            walk$1(e, n, t), e.selector.includes("&") && ampersandToScope$1(e, n);
        }
    };
};
creator$2.postcss = !0;
const i = e();
function mergeSelectors(e, t, r, o) {
    let s;
    try {
        s = n.resolveNestedSelector(i.astSync(t), i.astSync(r));
    } catch (n) {
        return e.warn(o, `Failed to parse selectors : "${r}" / "${t}" with message: "${n instanceof Error ? n.message : n}"`), !1;
    }
    return !!s && s.toString();
}
function ampersandToScope(t, n) {
    {
        let r = t.parent;
        for(; r;){
            if ("rule" === r.type) return;
            if (isAtRule(r) && "scope" === r.name) return;
            r = r.parent;
        }
        try {
            let n = !1;
            if (e().astSync(t.selector).walkNesting(()=>(n = !0, !1)), !n) return;
        } catch (e) {
            return void t.warn(n, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
        }
    }
    const r = mergeSelectors(t, t.selector, ":scope", n);
    r && (t.selector = r);
}
function atruleWithinRule(e, t, n, r) {
    if (shiftNodesBeforeParent(e, t), e.nodes) {
        const o = t.clone().removeAll().append(e.nodes);
        e.append(o), cleanupParent(t), r(o, n);
    } else cleanupParent(t);
}
function isAtruleWithinRule(e) {
    return s.includes(e.name);
}
function transformRuleWithinRule(e, t, n) {
    const r = mergeSelectors(e, e.selector, t.selector, n);
    if (!r) return;
    shiftNodesBeforeParent(e, t), e.selector = r;
    "rule" === e.type && "rule" === t.type && e.selector === t.selector && e.append(...t.nodes), cleanupParent(t);
}
function isValidRuleWithinRule(e) {
    return e.selectors.every((e)=>-1 === e.indexOf("|"));
}
function walk(e, t) {
    e.each((e)=>{
        const n = e.parent;
        isRule(e) && isRule(n) && isValidRuleWithinRule(e) ? transformRuleWithinRule(e, n, t) : isAtRule(e) && isRule(n) && isAtruleWithinRule(e) && atruleWithinRule(e, n, t, walk), "nodes" in e && e.nodes.length && walk(e, t);
    });
}
const creator$1 = ()=>({
        postcssPlugin: "postcss-nesting",
        Rule (e, { result: t }) {
            walk(e, t), e.selector.includes("&") && ampersandToScope(e, t);
        },
        AtRule: {
            nest (e) {
                throw e.error(`\`@nest\` was removed from the CSS Nesting specification and will be removed from PostCSS Nesting in the next major version.\nChange \`@nest ${e.params} {}\` to \`${e.params} {}\` to migrate to the latest standard.`);
            }
        }
    });
creator$1.postcss = !0;
const creator = (e)=>{
    const t = Object.assign({
        edition: "2024-02"
    }, e);
    switch(t.edition){
        case "2021":
            return creator$2(e);
        case "2024-02":
            return creator$1();
        default:
            throw new Error(`Invalid edition: ${t.edition}`);
    }
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-attribute-case-insensitive/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-attribute-case-insensitive/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function nodeIsInsensitiveAttribute(e) {
    return "attribute" === e.type && (e.insensitive ?? !1);
}
function selectorHasInsensitiveAttribute(e) {
    return e.some(nodeIsInsensitiveAttribute);
}
function transformString(e, t, s) {
    const r = s.charAt(t);
    if ("" === r) return e;
    let n = e.map((e)=>e + r);
    const o = r.toLocaleUpperCase();
    return o !== r && (n = n.concat(e.map((e)=>e + o))), transformString(n, t + 1, s);
}
function createNewSelectors(t) {
    let s = [
        e.selector({
            value: "",
            nodes: []
        })
    ];
    return t.each((e)=>{
        if (!nodeIsInsensitiveAttribute(e)) return void s.forEach((t)=>{
            t.append(e.clone());
        });
        const t = transformString([
            ""
        ], 0, (r = e).value ?? "").map((e)=>{
            const t = r.clone({
                spaces: {
                    after: r.spaces.after,
                    before: r.spaces.before
                },
                insensitive: !1
            });
            return t.setValue(e), t;
        });
        var r;
        const n = [];
        t.forEach((e)=>{
            s.forEach((t)=>{
                const s = t.clone({});
                s.append(e), n.push(s);
            });
        }), s = n;
    }), s;
}
const creator = (t)=>{
    const s = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-attribute-case-insensitive",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "postcss-attribute-case-insensitive",
                Rule (r, { result: n }) {
                    if (t.has(r)) return;
                    if (!/i\s*\]/i.test(r.selector)) return;
                    let o;
                    try {
                        o = e((e)=>{
                            let t = [];
                            e.each((e)=>{
                                selectorHasInsensitiveAttribute(e) && (t = t.concat(createNewSelectors(e)), e.remove());
                            }), t.length && t.forEach((t)=>e.append(t));
                        }).processSync(r.selector);
                    } catch (e) {
                        return void r.warn(n, `Failed to parse selector : "${r.selector}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                    o !== r.selector && (t.add(r), r.cloneBefore({
                        selector: o
                    }), s.preserve || r.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-clamp/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let valueParser = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function parseValue(value) {
    let parsed = value.match(/([\d.-]+)(.*)/);
    if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {
        return undefined;
    }
    return [
        parseFloat(parsed[1]),
        parsed[2]
    ];
}
function compose(first, second, third) {
    if (first && second && third) {
        return `max(${first}, min(${second}, ${third}))`;
    }
    if (first && second) {
        return `max(${first}, ${second})`;
    }
    return first;
}
function updateValue(declaration, value, preserve) {
    let newValue = value;
    let newValueAst = valueParser(value);
    let valueAST = valueParser(declaration.value);
    // Walk can't be interrupted, so we only care about first
    let foundClamp = false;
    valueAST.walk((node, index, nodes)=>{
        let isClamp = node.type === 'function' && node.value === 'clamp';
        if (!isClamp || foundClamp) {
            return;
        }
        foundClamp = true;
        nodes[index] = newValueAst;
    });
    if (foundClamp) {
        newValue = valueAST.toString();
    }
    if (preserve) {
        declaration.cloneBefore({
            value: newValue
        });
    } else {
        declaration.value = newValue;
    }
}
module.exports = (opts)=>{
    opts = opts || {};
    let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false;
    let preserve = opts.preserve ? Boolean(opts.preserve) : false;
    return {
        postcssPlugin: 'postcss-clamp',
        Declaration (decl) {
            if (!decl || !decl.value.includes('clamp')) {
                return;
            }
            valueParser(decl.value).walk((node)=>{
                let nodes = node.nodes;
                if (node.type !== 'function' || node.value !== 'clamp' || nodes.length !== 5) {
                    return;
                }
                let first = nodes[0];
                let second = nodes[2];
                let third = nodes[4];
                let naive = compose(valueParser.stringify(first), valueParser.stringify(second), valueParser.stringify(third));
                if (!precalculate || second.type !== 'word' || third.type !== 'word') {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let parsedSecond = parseValue(second.value);
                let parsedThird = parseValue(third.value);
                if (parsedSecond === undefined || parsedThird === undefined) {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let [secondValue, secondUnit] = parsedSecond;
                let [thirdValue, thirdUnit] = parsedThird;
                if (secondUnit !== thirdUnit) {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let parsedFirst = parseValue(first.value);
                if (parsedFirst === undefined) {
                    let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;
                    updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);
                    return;
                }
                let [firstValue, firstUnit] = parsedFirst;
                if (firstUnit !== secondUnit) {
                    let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;
                    updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);
                    return;
                }
                updateValue(decl, compose(`${firstValue + secondValue + thirdValue}${secondUnit}`), preserve);
            });
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-color-functional-notation/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const r = /^(?:rgb|hsl)a?$/i, n = /\b(?:rgb|hsl)a?\(/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-functional-notation",
        Declaration (l) {
            const i = l.value;
            if (!n.test(i)) return;
            if (t.hasFallback(l)) return;
            if (t.hasSupportsAtRuleAncestor(l, n)) return;
            const c = o.replaceComponentValues(o.parseCommaSeparatedListOfComponentValues(a.tokenize({
                css: i
            })), (s)=>{
                if (!o.isFunctionNode(s) || !r.test(s.getName())) return;
                const t = e.color(s);
                return !t || t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) || (t.syntaxFlags.has(e.SyntaxFlag.LegacyRGB) || t.syntaxFlags.has(e.SyntaxFlag.LegacyHSL)) && !t.syntaxFlags.has(e.SyntaxFlag.HasPercentageAlpha) ? void 0 : t.colorNotation === e.ColorNotation.HSL ? e.serializeHSL(t) : e.serializeRGB(t);
            }), u = o.stringify(c);
            u !== i && (l.cloneBefore({
                value: u
            }), s?.preserve || l.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-color-functional-notation",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-custom-media/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)");
const n = e.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(r) {
    const t = new Map, a = new Map, o = [];
    r.walkAtRules((r)=>{
        if ("layer" !== r.name.toLowerCase()) return;
        {
            let e = r.parent;
            for(; e;){
                if ("atrule" !== e.type || "layer" !== e.name.toLowerCase()) {
                    if (e === r.root()) break;
                    return;
                }
                e = e.parent;
            }
        }
        let s;
        if (r.nodes) s = normalizeLayerName(r.params, 1);
        else {
            if (!r.params.trim()) return;
            s = r.params;
        }
        let i = e.parse(s);
        if (i?.length) {
            {
                let e = r.parent;
                for(; e && "atrule" === e.type && "layer" === e.name.toLowerCase();){
                    const r = a.get(e);
                    r ? (i = i.map((e)=>r.concat(e)), e = e.parent) : e = e.parent;
                }
            }
            if (e.addLayerToModel(o, i), r.nodes) {
                const e = i[0].concat(n);
                t.set(r, e), a.set(r, i[0]);
            }
        }
    });
    for (const r of t.values())e.addLayerToModel(o, [
        r
    ]);
    const s = new WeakMap;
    for (const [e, r] of t)s.set(e, o.findIndex((e)=>r.equal(e)));
    return s;
}
function normalizeLayerName(e, r) {
    return e.trim() ? e : "csstools-anon-layer--" + r++;
}
const a = new Set([
    "scope",
    "container",
    "layer"
]);
function isProcessableCustomMediaRule(e) {
    if ("custom-media" !== e.name.toLowerCase()) return !1;
    if (!e.params || !e.params.includes("--")) return !1;
    if (e.nodes && e.nodes.length > 0) return !1;
    let r = e.parent;
    for(; r;){
        if ("atrule" === r.type && !a.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
function removeCyclicReferences(e, r) {
    const t = new Set;
    for(; e.size > 0;){
        const n = findCyclicNode(Array.from(e.keys()), r);
        if (!n) return t;
        e.delete(n), t.add(n), r = r.filter((e)=>-1 === e.indexOf(n));
    }
    return t;
}
function findCyclicNode(e, r) {
    let t = e.length;
    const n = new Array(t), a = {};
    let o = t;
    const s = makeOutgoingEdges(r), i = makeNodesHash(e);
    for(; o--;)if (!a[o]) {
        const r = visit(e[o], o, new Set);
        if (!r) continue;
        return r;
    }
    function visit(e, r, o) {
        if (o.has(e)) return e;
        if (!i.has(e)) return;
        if (a[r]) return;
        a[r] = !0;
        const l = Array.from(s.get(e) || new Set);
        if (r = l.length) {
            o.add(e);
            do {
                const e = l[--r], t = visit(e, i.get(e), o);
                if (t) return t;
            }while (r)
            o.delete(e);
        }
        n[--t] = e;
    }
}
function makeOutgoingEdges(e) {
    const r = new Map;
    for(let t = 0, n = e.length; t < n; t++){
        const n = e[t];
        r.has(n[0]) || r.set(n[0], new Set), r.has(n[1]) || r.set(n[1], new Set), r.get(n[0]).add(n[1]);
    }
    return r;
}
function makeNodesHash(e) {
    const r = new Map;
    for(let t = 0, n = e.length; t < n; t++)r.set(e[t], t);
    return r;
}
function atMediaParamsTokens(e) {
    const t = r.tokenizer({
        css: e
    }, {
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${e}"`);
        }
    }), n = [];
    for(; !t.endOfFile();)n.push(t.nextToken());
    return n;
}
const o = [
    [
        r.TokenType.Ident,
        "max-color",
        0,
        0,
        {
            value: "max-color"
        }
    ],
    [
        r.TokenType.Colon,
        ":",
        0,
        0,
        void 0
    ],
    [
        r.TokenType.Number,
        "2147477350",
        0,
        0,
        {
            value: 2147477350,
            type: r.NumberType.Integer
        }
    ]
], s = [
    [
        r.TokenType.Ident,
        "color",
        0,
        0,
        {
            value: "color"
        }
    ],
    [
        r.TokenType.Colon,
        ":",
        0,
        0,
        void 0
    ],
    [
        r.TokenType.Number,
        "2147477350",
        0,
        0,
        {
            value: 2147477350,
            type: r.NumberType.Integer
        }
    ]
];
function replaceTrueAndFalseTokens(e) {
    let t, n = [];
    for(let a = 0; a < e.length; a++)if (!r.isTokenWhiteSpaceOrComment(e[a])) {
        if (r.isTokenIdent(e[a])) {
            const r = e[a];
            if ("true" === r[4].value.toLowerCase()) {
                t = "true", n = e.slice(a + 1);
                break;
            }
            if ("false" === r[4].value.toLowerCase()) {
                t = "false", n = e.slice(a + 1);
                break;
            }
        }
        return e;
    }
    if (!t) return e;
    for(let t = 0; t < n.length; t++)if (!r.isTokenWhiteSpaceOrComment(n[t])) return e;
    return "true" === t ? [
        [
            r.TokenType.Whitespace,
            " ",
            0,
            0,
            void 0
        ],
        [
            r.TokenType.OpenParen,
            "(",
            0,
            0,
            void 0
        ],
        ...o,
        [
            r.TokenType.CloseParen,
            ")",
            0,
            0,
            void 0
        ]
    ] : [
        [
            r.TokenType.Whitespace,
            " ",
            0,
            0,
            void 0
        ],
        [
            r.TokenType.OpenParen,
            "(",
            0,
            0,
            void 0
        ],
        ...s,
        [
            r.TokenType.CloseParen,
            ")",
            0,
            0,
            void 0
        ]
    ];
}
function parseCustomMedia(e) {
    const n = atMediaParamsTokens(e), a = new Set;
    let o = "", s = n;
    for(let e = 0; e < n.length; e++)if (!r.isTokenWhiteSpaceOrComment(n[e])) {
        if (r.isTokenIdent(n[e])) {
            const r = n[e];
            if (r[4].value.startsWith("--")) {
                o = r[4].value, s = n.slice(e + 1);
                break;
            }
        }
        return !1;
    }
    for(let e = 0; e < s.length; e++)if (r.isTokenIdent(s[e])) {
        const r = s[e];
        r[4].value.startsWith("--") && a.add(r[4].value);
    }
    s = replaceTrueAndFalseTokens(s);
    const i = t.parseFromTokens(r.cloneTokens(s), {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r.stringify(...s)}"`);
        }
    }), l = t.parseFromTokens(r.cloneTokens(s), {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r.stringify(...s)}"`);
        }
    }).map((e)=>e.negateQuery());
    return {
        name: o,
        truthy: i,
        falsy: l,
        dependencies: Array.from(a).map((e)=>[
                o,
                e
            ])
    };
}
function getCustomMedia(e, r, t) {
    const n = new Map, a = new Map, o = [], s = collectCascadeLayerOrder(e);
    e.walkAtRules((e)=>{
        if (!isProcessableCustomMediaRule(e)) return;
        const r = parseCustomMedia(e.params);
        if (!r) return;
        if (0 === r.truthy.length) return;
        const i = (u = s, (l = e).parent && "atrule" === l.parent.type && "layer" === l.parent.name.toLowerCase() ? u.has(l.parent) ? u.get(l.parent) + 1 : 0 : 1e7);
        var l, u;
        const c = a.get(r.name) ?? -1;
        if (i && i >= c && (a.set(r.name, i), n.set(r.name, {
            truthy: r.truthy,
            falsy: r.falsy
        }), o.push(...r.dependencies)), !t.preserve) {
            const r = e.parent;
            e.remove(), removeEmptyAncestorBlocks(r);
        }
    });
    const i = removeCyclicReferences(n, o);
    for (const t of i.values())e.warn(r, `@custom-media rules have cyclic dependencies for "${t}"`);
    return n;
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (r.nodes && r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function transformAtMediaListTokens(e, r) {
    const n = t.parse(e, {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${e}"`);
        }
    }), a = n.map((e)=>e.toString());
    for(let e = 0; e < n.length; e++){
        const t = n[e], o = a[e];
        {
            const n = transformSimpleMediaQuery(t, r);
            if (n && n.replaceWith !== o) return a.map((r, t)=>t === e ? n : {
                    replaceWith: r
                });
        }
        const s = transformComplexMediaQuery(t, r);
        if (s && 0 !== s.length && s[0].replaceWith !== o) return a.flatMap((r, t)=>t === e ? s : [
                {
                    replaceWith: r
                }
            ]);
    }
    return [];
}
function transformSimpleMediaQuery(e, r) {
    if (!mediaQueryIsSimple(e)) return null;
    let n = null;
    return e.walk((e)=>{
        const a = e.node;
        if (!t.isMediaFeatureBoolean(a)) return;
        const o = a.getName();
        if (!o.startsWith("--")) return;
        const s = r.get(o);
        return s ? (n = {
            replaceWith: s.truthy.map((e)=>e.toString().trim()).join(",")
        }, !1) : void 0;
    }), n;
}
function transformComplexMediaQuery(e, r) {
    let n = [];
    return e.walk((a)=>{
        const i = a.node;
        if (!t.isMediaFeatureBoolean(i)) return;
        const l = a.parent;
        if (!t.isMediaFeature(l)) return;
        const u = i.getName();
        if (!u.startsWith("--")) return;
        const c = r.get(u);
        if (c) {
            if (1 === c.truthy.length && mediaQueryIsSimple(c.truthy[0])) {
                let r = null;
                if (c.truthy[0].walk((e)=>{
                    if (t.isMediaFeature(e.node)) return r = e.node, !1;
                }), r && r.feature) return l.feature = r.feature, n = [
                    {
                        replaceWith: e.toString()
                    }
                ], !1;
            }
            const r = t.newMediaFeaturePlain(o[0][4].value, o[2]);
            l.feature = r.feature;
            const a = e.toString(), i = t.newMediaFeaturePlain(s[0][4].value, s[2]);
            l.feature = i.feature;
            const u = e.toString();
            return n = [
                {
                    replaceWith: a,
                    encapsulateWith: [
                        c.truthy.map((e)=>e.toString().trim()).join(",")
                    ]
                },
                {
                    replaceWith: u,
                    encapsulateWith: c.falsy.map((e)=>e.map((e)=>e.toString().trim()).join(",").toString().trim())
                }
            ], !1;
        }
    }), n;
}
function mediaQueryIsSimple(e) {
    if (t.isMediaQueryInvalid(e)) return !1;
    if (t.isMediaQueryWithType(e)) return !1;
    let r = !0;
    return e.walk((e)=>{
        if (t.isMediaAnd(e.node) || t.isMediaOr(e.node) || t.isMediaNot(e.node) || t.isMediaConditionList(e.node) || t.isGeneralEnclosed(e.node)) return r = !1, !1;
    }), r;
}
const creator = (e)=>{
    const r = e?.preserve ?? !1;
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-media] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-media] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-media",
        prepare () {
            const e = new WeakSet;
            let t = new Map;
            return {
                postcssPlugin: "postcss-custom-media",
                Once (e, { result: n }) {
                    t = getCustomMedia(e, n, {
                        preserve: r
                    });
                },
                AtRule (n, { result: a }) {
                    if (e.has(n)) return;
                    if ("media" !== n.name.toLowerCase()) return;
                    if (!n.params) return;
                    if (!n.params.includes("--")) return;
                    let o = [];
                    try {
                        o = transformAtMediaListTokens(n.params, t);
                    } catch (e) {
                        return void n.warn(a, `Failed to parse @custom-media params with error message: "${e instanceof Error ? e.message : e}"`);
                    }
                    if (!o || 0 === o.length) return;
                    if (1 === o.length) {
                        if (n.params.trim() === o[0].replaceWith.trim()) return;
                        return e.add(n), n.cloneBefore({
                            params: o[0].replaceWith.trim()
                        }), r ? void 0 : void n.remove();
                    }
                    if (!!!o.find((e)=>!!e.encapsulateWith?.length)) return e.add(n), n.cloneBefore({
                        params: o.map((e)=>e.replaceWith).join(",").trim()
                    }), void (r || n.remove());
                    o.forEach((r)=>{
                        if (!r.encapsulateWith?.length) return void n.cloneBefore({
                            params: r.replaceWith.trim()
                        });
                        const t = n.clone({
                            params: r.replaceWith
                        });
                        t.parent = void 0;
                        let a = n.clone({
                            params: r.encapsulateWith[0],
                            nodes: []
                        });
                        a.parent = void 0, a.append(t), r.encapsulateWith.slice(1).forEach((e)=>{
                            const r = n.clone({
                                params: e,
                                nodes: []
                            });
                            r.parent = void 0, r.append(a), a = r;
                        }), e.add(n), n.before(a);
                    }), r || n.remove();
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-custom-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const n = e.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(t) {
    const r = new Map, o = new Map, s = [];
    t.walkAtRules((t)=>{
        if ("layer" !== t.name.toLowerCase()) return;
        {
            let e = t.parent;
            for(; e;){
                if ("atrule" !== e.type || "layer" !== e.name.toLowerCase()) {
                    if (e === t.root()) break;
                    return;
                }
                e = e.parent;
            }
        }
        let a;
        if (t.nodes) a = normalizeLayerName(t.params, 1);
        else {
            if (!t.params.trim()) return;
            a = t.params;
        }
        let i = e.parse(a);
        if (i?.length) {
            {
                let e = t.parent;
                for(; e && "atrule" === e.type && "layer" === e.name.toLowerCase();){
                    const t = o.get(e);
                    t ? (i = i.map((e)=>t.concat(e)), e = e.parent) : e = e.parent;
                }
            }
            if (e.addLayerToModel(s, i), t.nodes) {
                const e = i[0].concat(n);
                r.set(t, e), o.set(t, i[0]);
            }
        }
    });
    for (const t of r.values())e.addLayerToModel(s, [
        t
    ]);
    const a = new WeakMap;
    for (const [e, t] of r)a.set(e, s.findIndex((e)=>t.equal(e)));
    return a;
}
function normalizeLayerName(e, t) {
    return e.trim() ? e : "csstools-anon-layer--" + t++;
}
const o = /(?:!\s*)?postcss-custom-properties:\s*off\b/i, s = new WeakMap;
function isBlockIgnored(e) {
    if (!e || !e.nodes) return !1;
    if (s.has(e)) return s.get(e);
    const t = e.some((e)=>isIgnoreComment(e, o));
    return s.set(e, t), t;
}
const a = /(?:!\s*)?postcss-custom-properties:\s*ignore\s+next\b/i;
function isDeclarationIgnored(e) {
    return !!e && (!!isBlockIgnored(e.parent) || isIgnoreComment(e.prev(), a));
}
function isIgnoreComment(e, t) {
    return !!e && "comment" === e.type && t.test(e.text);
}
const i = new Set([
    "layer"
]);
function isProcessableRule(e) {
    let t = e.parent;
    for(; t;){
        if ("atrule" === t.type && !i.has(t.name.toLowerCase())) return !1;
        t = t.parent;
    }
    return !0;
}
const c = /^html$/i, l = /^:where\(html\)$/i, u = /^:root$/i, p = /^:where\(:root\)$/i, f = /(html|:root)/i, d = /^var$/i;
function isVarFunction(e) {
    return "function" === e.type && d.test(e.value) && e.nodes?.length > 0;
}
const m = /\bvar\(/i;
function parseOrCached(e, r) {
    let n = r.get(e);
    return n || (n = t(e), r.set(e, n), n);
}
function toposort(e, t) {
    let r = e.length;
    const n = new Array(r), o = {};
    let s = r;
    const a = makeOutgoingEdges(t), i = makeNodesHash(e);
    for(; s--;)o[s] || visit(e[s], s, new Set);
    return n;
    "TURBOPACK unreachable";
    function visit(e, t, s) {
        if (s.has(e)) {
            let t;
            try {
                t = ", node was:" + JSON.stringify(e);
            } catch  {
                t = "";
            }
            throw new Error("Cyclic dependency" + t);
        }
        if (!i.has(e)) throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(e));
        if (o[t]) return;
        o[t] = !0;
        const c = Array.from(a.get(e) || new Set);
        if (t = c.length) {
            s.add(e);
            do {
                const e = c[--t];
                visit(e, i.get(e), s);
            }while (t)
            s.delete(e);
        }
        n[--r] = e;
    }
}
function removeCyclicReferences(e, t) {
    const r = new Set;
    for(; e.size > 0;){
        const n = findCyclicNode(Array.from(e.keys()), t);
        if (!n) return r;
        e.delete(n), r.add(n), t = t.filter((e)=>-1 === e.indexOf(n));
    }
    return r;
}
function findCyclicNode(e, t) {
    let r = e.length;
    const n = new Array(r), o = {};
    let s = r;
    const a = makeOutgoingEdges(t), i = makeNodesHash(e);
    for(; s--;)if (!o[s]) {
        const t = visit(e[s], s, new Set);
        if (!t) continue;
        return t;
    }
    function visit(e, t, s) {
        if (s.has(e)) return e;
        if (!i.has(e)) return;
        if (o[t]) return;
        o[t] = !0;
        const c = Array.from(a.get(e) || new Set);
        if (t = c.length) {
            s.add(e);
            do {
                const e = c[--t], r = visit(e, i.get(e), s);
                if (r) return r;
            }while (t)
            s.delete(e);
        }
        n[--r] = e;
    }
}
function makeOutgoingEdges(e) {
    const t = new Map;
    for(let r = 0, n = e.length; r < n; r++){
        const n = e[r];
        t.has(n[0]) || t.set(n[0], new Set), t.has(n[1]) || t.set(n[1], new Set), t.get(n[0]).add(n[1]);
    }
    return t;
}
function makeNodesHash(e) {
    const t = new Map;
    for(let r = 0, n = e.length; r < n; r++)t.set(e[r], r);
    return t;
}
function parseVarFunction(e) {
    let t, r, n = !1;
    for (const o of e.nodes)if (t || "word" !== o.type) if (!t || n || "div" !== o.type || "," !== o.value) {
        if (n && Array.isArray(r)) r.push(o);
        else if ("space" !== o.type && ("div" !== o.type || "" !== o.value.trim())) return;
    } else n = !0, r = [];
    else t = o;
    if (t) return {
        name: t,
        fallback: r
    };
}
function transformValueAST(e, r) {
    return e.nodes?.length ? (walk(e.nodes, (e, n, o)=>{
        if (!isVarFunction(e)) return;
        const s = parseVarFunction(e);
        if (!s) return;
        let a = !1;
        s.fallback && t.walk(s.fallback, (e)=>{
            if (!isVarFunction(e)) return;
            const t = parseVarFunction(e);
            return t ? t.fallback || r.has(t.name.value) ? void 0 : (a = !0, !1) : void 0;
        });
        let i = r.get(s.name.value)?.nodes;
        i || !s.fallback || a || (i = s.fallback), void 0 !== i && (i.length ? o.splice(n, 1, ...i) : o.splice(n, 1, {
            type: "div",
            value: " ",
            before: "",
            after: "",
            sourceIndex: e.sourceIndex,
            sourceEndIndex: e.sourceEndIndex
        }));
    }), t.stringify(e.nodes)) : "";
}
function walk(e, t) {
    let r, n, o;
    for(r = 0, n = e.length; r < n; r += 1)o = e[r], "function" === o.type && Array.isArray(o.nodes) && walk(o.nodes, t), t(o, r, e), n = e.length;
}
const w = /^initial$/i;
function isInitial(e) {
    const t = e.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
    return 1 === t.length && "word" === t[0].type && w.test(t[0].value);
}
function buildCustomPropertiesMap(e, r, n) {
    if (!e.size) return r;
    const o = new Map(r);
    {
        const s = [];
        for (const [a, i] of e.entries()){
            const c = parseOrCached(i, n);
            let l = !1;
            t.walk(c.nodes, (t)=>{
                if (!isVarFunction(t)) return;
                const n = parseVarFunction(t);
                n && (n.fallback || e.has(n.name.value) || r.has(n.name.value) ? s.push([
                    n.name.value,
                    a
                ]) : l = !0);
            }), l || o.set(a, c);
        }
        removeCyclicReferences(o, s);
    }
    {
        const e = [];
        for (const [r, n] of o.entries())t.walk(n.nodes, (t)=>{
            if (!isVarFunction(t)) return;
            const n = parseVarFunction(t);
            n && (n.fallback || o.has(n.name.value) ? e.push([
                n.name.value,
                r
            ]) : o.delete(r));
        });
        for(let t = 0; t < e.length; t++){
            const [r, n] = e[t];
            o.has(r) && o.has(n) || e.splice(t--, 1);
        }
        const r = toposort(Array.from(o.keys()), e);
        for (const e of r){
            const t = o.get(e);
            if (!t) continue;
            const r = parseOrCached(transformValueAST(t, o), n);
            o.set(e, r);
        }
    }
    for (const [e, t] of o.entries())isInitial(t) && o.delete(e);
    return o;
}
function getCustomPropertiesFromRoot(e, t) {
    const r = new Map, n = new Map, o = collectCascadeLayerOrder(e);
    return e.walkRules((e)=>{
        f.test(e.selector) && e.nodes?.length && isProcessableRule(e) && (isBlockIgnored(e) || e.selectors.forEach((t)=>{
            let s = -1;
            if (l.test(t) || p.test(t)) s = 0;
            else if (c.test(t)) s = 1;
            else {
                if (!u.test(t)) return;
                s = 2;
            }
            const a = (f = o, ((i = e).parent && "atrule" === i.parent.type && "layer" === i.parent.name.toLowerCase() ? f.has(i.parent) ? f.get(i.parent) + 1 : 0 : 1e7) + 10 + s);
            var i, f;
            e.each((e)=>{
                if ("decl" !== e.type) return;
                if (!e.variable || isDeclarationIgnored(e)) return;
                if ("initial" === e.value.toLowerCase().trim()) return;
                const t = n.get(e.prop) ?? -1;
                a >= t && (n.set(e.prop, a), r.set(e.prop, e.value));
            });
        }));
    }), buildCustomPropertiesMap(r, new Map, t);
}
function getCustomPropertiesFromSiblings(e, t, r) {
    if (!e.parent) return t;
    const n = new Map;
    return e.parent.each((t)=>{
        "decl" === t.type && t.variable && e !== t && (isDeclarationIgnored(t) || n.set(t.prop, t.value));
    }), n.size ? buildCustomPropertiesMap(n, t, r) : t;
}
function transformProperties(e, r, n) {
    if (isTransformableDecl(e) && !isDeclarationIgnored(e)) {
        const o = e.raws?.value?.raw ?? e.value, s = transformValueAST(t(o), r);
        if (s === o) return;
        if (parentHasExactFallback(e, s)) return void (n.preserve || e.remove());
        const a = e.cloneBefore({
            value: s
        });
        a.raws?.value?.raw && (a.raws.value.raw = ""), n?.preserve || e.remove();
    }
}
const isTransformableDecl = (e)=>!e.variable && e.value.includes("--") && e.value.toLowerCase().includes("var(");
function parentHasExactFallback(e, t) {
    if (!e || !e.parent) return !1;
    let r = !1;
    const n = e.parent.index(e);
    return e.parent.each((o, s)=>o !== e && !(s >= n) && void ("decl" === o.type && o.prop.toLowerCase() === e.prop.toLowerCase() && o.value === t && (r = !0))), r;
}
const v = /\bvar\(|\(top: var\(--f\)/i, creator = (e)=>{
    const t = !("preserve" in Object(e)) || Boolean(e?.preserve);
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-properties] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-properties] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-properties",
        prepare () {
            let e = new Map;
            const n = new WeakMap, o = new Map;
            return {
                postcssPlugin: "postcss-custom-properties",
                Once (t) {
                    e = getCustomPropertiesFromRoot(t, o);
                },
                Declaration (s) {
                    if (!m.test(s.value)) return;
                    if (r.hasSupportsAtRuleAncestor(s, v)) return;
                    let a = e;
                    t && s.parent && (a = n.get(s.parent) ?? getCustomPropertiesFromSiblings(s, e, o), n.set(s.parent, a)), transformProperties(s, a, {
                        preserve: t
                    });
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-custom-selectors/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-custom-selectors/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)");
const t = r.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(e) {
    const s = new Map, o = new Map, n = [];
    e.walkAtRules((e)=>{
        if ("layer" !== e.name.toLowerCase()) return;
        {
            let r = e.parent;
            for(; r;){
                if ("atrule" !== r.type || "layer" !== r.name.toLowerCase()) {
                    if (r === e.root()) break;
                    return;
                }
                r = r.parent;
            }
        }
        let a;
        if (e.nodes) a = normalizeLayerName(e.params, 1);
        else {
            if (!e.params.trim()) return;
            a = e.params;
        }
        let c = r.parse(a);
        if (c?.length) {
            {
                let r = e.parent;
                for(; r && "atrule" === r.type && "layer" === r.name.toLowerCase();){
                    const e = o.get(r);
                    e ? (c = c.map((r)=>e.concat(r)), r = r.parent) : r = r.parent;
                }
            }
            if (r.addLayerToModel(n, c), e.nodes) {
                const r = c[0].concat(t);
                s.set(e, r), o.set(e, c[0]);
            }
        }
    });
    for (const e of s.values())r.addLayerToModel(n, [
        e
    ]);
    const a = new WeakMap;
    for (const [e, r] of s)a.set(e, n.findIndex((e)=>r.equal(e)));
    return a;
}
function normalizeLayerName(e, r) {
    return e.trim() ? e : "csstools-anon-layer--" + r++;
}
const s = new Set([
    "scope",
    "container",
    "layer"
]);
function isProcessableCustomSelectorRule(e) {
    if ("atrule" !== e.type) return !1;
    if ("custom-selector" !== e.name.toLowerCase()) return !1;
    if (!e.params || !e.params.includes(":--")) return !1;
    if (e.nodes && e.nodes.length > 0) return !1;
    let r = e.parent;
    for(; r;){
        if ("rule" === r.type) return !1;
        if ("atrule" === r.type && !s.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
function getCustomSelectors(r, t, s) {
    const o = new Map, n = new Map, a = collectCascadeLayerOrder(r);
    return r.walkAtRules((r)=>{
        var c, l;
        if (isProcessableCustomSelectorRule(r)) try {
            const t = r.params.trim(), p = e().astSync(t), u = p?.nodes?.[0]?.nodes?.[0];
            if (!u || "pseudo" !== u.type || !u.value.startsWith(":--")) return;
            const i = u.toString(), m = (l = a, (c = r).parent && "atrule" === c.parent.type && "layer" === c.parent.name.toLowerCase() ? l.has(c.parent) ? l.get(c.parent) + 1 : 0 : 1e7), f = n.get(i) ?? -1;
            if (m && m >= f && (n.set(i, m), o.set(i, e().astSync(t.slice(i.length).trim()))), !s.preserve) {
                const e = r.parent;
                r.remove(), removeEmptyAncestorBlocks(e);
            }
        } catch (e) {
            r.warn(t, `Failed to parse selector : "${r.params}" with message: "${e instanceof Error ? e.message : e}"`);
        }
    }), o;
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (r.nodes && r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function transformRule(r, t, s) {
    let o = r.selector;
    try {
        o = e((r)=>{
            r.walkPseudos((r)=>{
                if (!s.has(r.value)) return;
                const t = e.pseudo({
                    value: ":is",
                    nodes: []
                }), o = s.get(r.value);
                o && (o.each((e)=>{
                    t.append(e.clone());
                }), r.replaceWith(t));
            });
        }).processSync(r.selector);
    } catch (e) {
        return r.warn(t, `Failed to parse selector : "${o}" with message: "${e instanceof Error ? e.message : e}"`), r.selector;
    }
    return o;
}
const creator = (e)=>{
    const r = e?.preserve ?? !1;
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-selectors] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-selectors] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-selectors",
        prepare () {
            const e = new WeakSet;
            let t = new Map;
            return {
                postcssPlugin: "postcss-custom-selectors",
                Once (e, { result: s }) {
                    t = getCustomSelectors(e, s, {
                        preserve: r
                    });
                },
                Rule (s, { result: o }) {
                    if (e.has(s)) return;
                    if (!s.selector?.includes(":--")) return;
                    const n = transformRule(s, o, t);
                    n !== s.selector && (e.add(s), s.cloneBefore({
                        selector: n
                    }), r || s.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-dir-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-dir-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const creator = (t)=>{
    const r = Object.assign({
        dir: null,
        preserve: !1,
        shadow: !1
    }, t);
    return {
        postcssPlugin: "postcss-dir-pseudo-class",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "postcss-dir-pseudo-class",
                Rule (o, { result: s }) {
                    if (t.has(o)) return;
                    let a, n = !1;
                    if (o.selector.toLowerCase().includes(":dir(")) {
                        try {
                            a = e((t)=>{
                                t.nodes.forEach((t)=>{
                                    t.walk((t)=>{
                                        if ("pseudo" !== t.type) return;
                                        if (":dir" !== t.value.toLowerCase()) return;
                                        if (!t.nodes || !t.nodes.length) return;
                                        const a = t.nodes.toString().toLowerCase();
                                        if ("rtl" !== a && "ltr" !== a) return;
                                        const l = t.parent;
                                        if (!l) return;
                                        l.nodes.filter((e)=>"pseudo" === e.type && ":dir" === e.value.toLowerCase()).length > 1 && !n && (n = !0, o.warn(s, `Hierarchical :dir pseudo class usage can't be transformed correctly to [dir] attributes. This will lead to incorrect selectors for "${o.selector}"`));
                                        const c = t.prev(), p = t.next(), i = c && c.type && "combinator" !== c.type, u = p && p.type && "combinator" !== p.type, d = p && p.type && ("combinator" !== p.type || "combinator" === p.type && " " === p.value);
                                        i || u || 0 === l.nodes.indexOf(t) && d || 1 === l.nodes.length ? t.remove() : t.replaceWith(e.universal());
                                        const v = l.nodes[0], f = v && "combinator" === v.type && " " === v.value, w = v && "tag" === v.type && "html" === v.value.toLowerCase(), y = v && "pseudo" === v.type && ":root" === v.value.toLowerCase();
                                        !v || w || y || f || l.prepend(e.combinator({
                                            value: " "
                                        }));
                                        const h = r.dir === a, b = e.attribute({
                                            attribute: "dir",
                                            operator: "=",
                                            quoteMark: '"',
                                            value: `"${a}"`,
                                            raws: {}
                                        }), m = e.pseudo({
                                            value: ":host-context"
                                        });
                                        m.append(e.selector({
                                            value: "",
                                            nodes: [
                                                b
                                            ]
                                        }));
                                        const g = e.pseudo({
                                            value: (w || y ? "" : "html") + ":not"
                                        });
                                        g.append(e.selector({
                                            value: "",
                                            nodes: [
                                                e.attribute({
                                                    attribute: "dir",
                                                    operator: "=",
                                                    quoteMark: '"',
                                                    value: `"${"ltr" === a ? "rtl" : "ltr"}"`,
                                                    raws: {}
                                                })
                                            ]
                                        })), h ? w ? l.insertAfter(v, g) : l.prepend(g) : w ? l.insertAfter(v, b) : r.shadow && !y ? l.prepend(m) : l.prepend(b);
                                    });
                                });
                            }).processSync(o.selector);
                        } catch  {
                            return void o.warn(s, `Failed to parse selector : ${o.selector}`);
                        }
                        void 0 !== a && a !== o.selector && (t.add(o), o.cloneBefore({
                            selector: a
                        }), r.preserve || o.remove());
                    }
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-double-position-gradients/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const r = /(?:repeating-)?(?:conic|linear|radial)-gradient\(/i, o = /^(?:repeating-)?(?:conic|linear|radial)-gradient$/i, i = [
    "at",
    "bottom",
    "center",
    "circle",
    "closest-corner",
    "closest-side",
    "ellipse",
    "farthest-corner",
    "farthest-side",
    "from",
    "in",
    "left",
    "right",
    "to",
    "top"
];
function isPunctuationCommaNode(e) {
    return !!e && "div" === e.type && "," === e.value;
}
function isNumericNode(e) {
    if (!e) return !1;
    try {
        return !1 !== t.unit(e.value);
    } catch  {
        return !1;
    }
}
const basePlugin = (e)=>({
        postcssPlugin: "postcss-double-position-gradients",
        Declaration (n, { result: a }) {
            if (!r.test(n.value)) return;
            if (s.hasFallback(n)) return;
            if (s.hasSupportsAtRuleAncestor(n, r)) return;
            let u;
            try {
                u = t(n.value);
            } catch  {
                n.warn(a, `Failed to parse value '${n.value}' as a CSS gradient. Leaving the original value intact.`);
            }
            if (void 0 === u) return;
            u.walk((e)=>{
                if ("function" !== e.type || !o.test(e.value)) return;
                const t = e.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
                let s = !1;
                t.forEach((t, r, o)=>{
                    if ("word" === t.type && i.includes(t.value.toLowerCase()) && (s = !0), "div" === t.type && "," === t.value && (s = !1), s) return;
                    const n = o[r - 1], a = o[r - 2], u = o[r + 1];
                    if (a && a.type && isNumericNode(n) && isNumericNode(t)) {
                        const s = a, r = {
                            type: "div",
                            value: ",",
                            before: isPunctuationCommaNode(u) ? u.before : "",
                            after: isPunctuationCommaNode(u) ? "" : " ",
                            sourceIndex: 0,
                            sourceEndIndex: 0
                        };
                        e.nodes.splice(e.nodes.indexOf(t) - 1, 0, r, s);
                    }
                });
            });
            const c = u.toString();
            c !== n.value && (n.cloneBefore({
                value: c
            }), e?.preserve || n.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (t)=>{
    const s = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, t);
    return s.enableProgressiveCustomProperties && s.preserve ? {
        postcssPlugin: "postcss-double-position-gradients",
        plugins: [
            e(),
            basePlugin(s)
        ]
    } : basePlugin(s);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-focus-visible/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-focus-visible/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = "js-focus-visible", o = ":focus-visible", creator = (r)=>{
    const t = Object.assign({
        preserve: !0,
        replaceWith: ".focus-visible",
        disablePolyfillReadyClass: !1
    }, r), n = e().astSync(t.replaceWith);
    return {
        postcssPlugin: "postcss-focus-visible",
        prepare () {
            const r = new WeakSet;
            return {
                postcssPlugin: "postcss-focus-visible",
                Rule (l, { result: a }) {
                    if (r.has(l)) return;
                    if (!l.selector.toLowerCase().includes(o)) return;
                    const i = l.selectors.flatMap((r)=>{
                        if (!r.toLowerCase().includes(o)) return [
                            r
                        ];
                        let i;
                        try {
                            i = e().astSync(r);
                        } catch (e) {
                            return l.warn(a, `Failed to parse selector : "${r}" with message: "${e instanceof Error ? e.message : e}"`), r;
                        }
                        if (void 0 === i) return [
                            r
                        ];
                        let c = !1;
                        if (i.walkPseudos((e)=>{
                            e.value.toLowerCase() === o && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(n.clone({}))));
                        }), !c) return [
                            r
                        ];
                        const d = i.clone();
                        if (!t.disablePolyfillReadyClass) {
                            if (i.nodes?.[0]?.nodes?.length) for(let o = 0; o < i.nodes[0].nodes.length; o++){
                                const r = i.nodes[0].nodes[o];
                                if ("combinator" === r.type || e.isPseudoElement(r)) {
                                    i.nodes[0].insertBefore(r, e.className({
                                        value: s
                                    }));
                                    break;
                                }
                                if (o === i.nodes[0].nodes.length - 1) {
                                    i.nodes[0].append(e.className({
                                        value: s
                                    }));
                                    break;
                                }
                            }
                            return i.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: s
                            }))), [
                                i.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            i.toString()
                        ];
                    });
                    i.join(",") !== l.selectors.join(",") && (r.add(l), l.cloneBefore({
                        selectors: i
                    }), t.preserve || l.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-focus-within/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-focus-within/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = [
    " ",
    ">",
    "~",
    ":",
    "+",
    "@",
    "#",
    "(",
    ")"
];
function isValidReplacement(e) {
    let t = !0;
    for(let n = 0, o = s.length; n < o && t; n++)e.indexOf(s[n]) > -1 && (t = !1);
    return t;
}
const t = "js-focus-within", n = ":focus-within", creator = (s)=>{
    const o = Object.assign({
        preserve: !0,
        replaceWith: "[focus-within]",
        disablePolyfillReadyClass: !1
    }, s), r = e().astSync(o.replaceWith);
    return isValidReplacement(o.replaceWith) ? {
        postcssPlugin: "postcss-focus-within",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "postcss-focus-within",
                Rule (l, { result: i }) {
                    if (s.has(l)) return;
                    if (!l.selector.toLowerCase().includes(n)) return;
                    const a = l.selectors.flatMap((s)=>{
                        if (!s.toLowerCase().includes(n)) return [
                            s
                        ];
                        let a;
                        try {
                            a = e().astSync(s);
                        } catch (e) {
                            return l.warn(i, `Failed to parse selector : "${s}" with message: "${e instanceof Error ? e.message : e}"`), s;
                        }
                        if (void 0 === a) return [
                            s
                        ];
                        let c = !1;
                        if (a.walkPseudos((e)=>{
                            e.value.toLowerCase() === n && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(r.clone({}))));
                        }), !c) return [
                            s
                        ];
                        const d = a.clone();
                        if (!o.disablePolyfillReadyClass) {
                            if (a.nodes?.[0]?.nodes?.length) for(let s = 0; s < a.nodes[0].nodes.length; s++){
                                const n = a.nodes[0].nodes[s];
                                if ("combinator" === n.type || e.isPseudoElement(n)) {
                                    a.nodes[0].insertBefore(n, e.className({
                                        value: t
                                    }));
                                    break;
                                }
                                if (s === a.nodes[0].nodes.length - 1) {
                                    a.nodes[0].append(e.className({
                                        value: t
                                    }));
                                    break;
                                }
                            }
                            return a.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: t
                            }))), [
                                a.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            a.toString()
                        ];
                    });
                    a.join(",") !== l.selectors.join(",") && (s.add(l), l.cloneBefore({
                        selectors: a
                    }), o.preserve || l.remove());
                }
            };
        }
    } : {
        postcssPlugin: "postcss-focus-within",
        Once (e, { result: s }) {
            e.warn(s, `${o.replaceWith} is not a valid replacement since it can't be applied to single elements.`);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-font-variant/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * font variant convertion map
 *
 * @type {Object}
 */ const fontVariantProperties = {
    "font-variant-ligatures": {
        "common-ligatures": "\"liga\", \"clig\"",
        "no-common-ligatures": "\"liga\", \"clig off\"",
        "discretionary-ligatures": "\"dlig\"",
        "no-discretionary-ligatures": "\"dlig\" off",
        "historical-ligatures": "\"hlig\"",
        "no-historical-ligatures": "\"hlig\" off",
        contextual: "\"calt\"",
        "no-contextual": "\"calt\" off"
    },
    "font-variant-position": {
        sub: "\"subs\"",
        "super": "\"sups\"",
        normal: "\"subs\" off, \"sups\" off"
    },
    "font-variant-caps": {
        "small-caps": "\"smcp\"",
        "all-small-caps": "\"smcp\", \"c2sc\"",
        "petite-caps": "\"pcap\"",
        "all-petite-caps": "\"pcap\", \"c2pc\"",
        unicase: "\"unic\"",
        "titling-caps": "\"titl\""
    },
    "font-variant-numeric": {
        "lining-nums": "\"lnum\"",
        "oldstyle-nums": "\"onum\"",
        "proportional-nums": "\"pnum\"",
        "tabular-nums": "\"tnum\"",
        "diagonal-fractions": "\"frac\"",
        "stacked-fractions": "\"afrc\"",
        ordinal: "\"ordn\"",
        "slashed-zero": "\"zero\""
    },
    "font-kerning": {
        normal: "\"kern\"",
        none: "\"kern\" off"
    },
    "font-variant": {
        normal: "normal",
        inherit: "inherit"
    }
};
// The `font-variant` property is a shorthand for all the others.
for(const prop in fontVariantProperties){
    const keys = fontVariantProperties[prop];
    for(const key in keys){
        if (!(key in fontVariantProperties["font-variant"])) {
            fontVariantProperties["font-variant"][key] = keys[key];
        }
    }
}
// Find font-feature-settings declaration before given declaration,
// create if does not exist
function getFontFeatureSettingsPrevTo(decl) {
    let fontFeatureSettings = null;
    decl.parent.walkDecls((decl)=>{
        if (decl.prop === "font-feature-settings") {
            fontFeatureSettings = decl;
        }
    });
    if (fontFeatureSettings === null) {
        fontFeatureSettings = decl.clone();
        fontFeatureSettings.prop = "font-feature-settings";
        fontFeatureSettings.value = "";
        decl.parent.insertBefore(decl, fontFeatureSettings);
    }
    return fontFeatureSettings;
}
function walkRule(rule) {
    let fontFeatureSettings = null;
    // read custom media queries
    rule.walkDecls((decl)=>{
        if (!fontVariantProperties[decl.prop]) {
            return null;
        }
        let newValue = decl.value;
        if (decl.prop === "font-variant") {
            newValue = decl.value.split(/\s+/g).map((val)=>{
                return fontVariantProperties["font-variant"][val];
            }).join(", ");
        } else if (fontVariantProperties[decl.prop][decl.value]) {
            newValue = fontVariantProperties[decl.prop][decl.value];
        }
        if (fontFeatureSettings === null) {
            fontFeatureSettings = getFontFeatureSettingsPrevTo(decl);
        }
        if (fontFeatureSettings.value && fontFeatureSettings.value !== newValue) {
            fontFeatureSettings.value += ", " + newValue;
        } else {
            fontFeatureSettings.value = newValue;
        }
    });
}
/**
 * Expose the font-variant plugin.
 */ module.exports = ()=>{
    return {
        postcssPlugin: "postcss-font-variant",
        Once (root) {
            root.walkRules(walkRule);
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-gap-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = [
    "column-gap",
    "gap",
    "row-gap"
], creator = (o)=>{
    const r = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-gap-properties",
        Declaration (o) {
            if (!e.includes(o.prop.toLowerCase())) return;
            if (!o.parent?.some((e)=>"decl" === e.type && "display" === e.prop.toLowerCase() && "grid" === e.value.toLowerCase())) return;
            const s = `grid-${o.prop.toLowerCase()}`, p = o.parent?.some((e)=>"decl" === e.type && e.prop.toLowerCase() === s);
            p || (o.cloneBefore({
                prop: s
            }), r.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-color-hex-alpha/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const creator = (a)=>{
    const l = Object.assign({
        preserve: !1
    }, a);
    return {
        postcssPlugin: "postcss-color-hex-alpha",
        Declaration (a) {
            if (!t.test(a.value)) return;
            if (s.hasFallback(a)) return;
            const { value: c } = a, n = e(c);
            n.walk((e)=>{
                if ("function" === e.type && "url" === e.value) return !1;
                "word" === e.type && r.test(e.value) && hexa2rgba(e);
            });
            const o = n.toString();
            o !== c && (a.cloneBefore({
                value: o
            }), l.preserve || a.remove());
        }
    };
};
creator.postcss = !0;
const t = /#[0-9a-f]{4}(?:[0-9a-f]{4})?\b/i, r = /^#[0-9a-f]{4}(?:[0-9a-f]{4})?$/i, a = 1e5, l = /[0-9a-f]/gi;
function hexa2rgba(e) {
    const s = e.value, t = `0x${5 === s.length ? s.slice(1).replace(l, "$&$&") : s.slice(1)}`, [r, c, n, o] = [
        parseInt(t.slice(2, 4), 16),
        parseInt(t.slice(4, 6), 16),
        parseInt(t.slice(6, 8), 16),
        Math.round(parseInt(t.slice(8, 10), 16) / 255 * a) / a
    ];
    e.value = `rgba(${r},${c},${n},${o})`;
}
module.exports = creator;
}}),
"[project]/node_modules/postcss-image-set-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const n = /^(?:cross-fade|image|(?:repeating-)?(?:conic|linear|radial)-gradient|url|var)$/i;
function getImage(t) {
    return !(!t || !t.type) && ("string" === t.type ? "url(" + e.stringify(t) + ")" : !("function" !== t.type || !n.test(t.value)) && e.stringify(t));
}
const i = new Map([
    [
        "dpcm",
        2.54
    ],
    [
        "dpi",
        1
    ],
    [
        "dppx",
        96
    ],
    [
        "x",
        96
    ]
]);
function getMedia(e, t, n) {
    if ("boolean" == typeof e) return !1;
    const i = Math.floor(e / 96 * 100) / 100;
    return t.atRule({
        name: "media",
        params: `(-webkit-min-device-pixel-ratio: ${i}), (min-resolution: ${e}dpi)`,
        source: n.source
    });
}
function getMediaDPI(t) {
    if (!t) return !1;
    if ("word" !== t.type) return !1;
    if (!isNumericNode(t)) return !1;
    const n = e.unit(t.value);
    if (!n) return !1;
    const r = i.get(n.unit.toLowerCase());
    return !!r && Number(n.number) * r;
}
function isNumericNode(t) {
    if (!t || !t.value) return !1;
    try {
        return !1 !== e.unit(t.value);
    } catch  {
        return !1;
    }
}
const handleInvalidation = (e, t, n)=>{
    if ("warn" === e.oninvalid) e.decl.warn(e.result, t, {
        word: String(n)
    });
    else if ("throw" === e.oninvalid) throw e.decl.error(t, {
        word: String(n)
    });
}, processImageSet = (t, n, i)=>{
    const r = n.parent;
    if (!r) return;
    const o = new Map, s = n.value;
    for(let r = 0; r < t.length; r++){
        const { imageSetFunction: l, imageSetOptionNodes: u } = t[r], c = new Map, f = u.length;
        let p = -1;
        for(; p < f;){
            const t = p < 0 || !!(a = u[p]) && "div" === a.type && "," === a.value, r = getImage(u[p + 1]), f = getMediaDPI(u[p + 2]), d = getMedia(f, i.postcss, n);
            if (!t) return void handleInvalidation(i, "expected a comma", e.stringify(u));
            if (!r) return void handleInvalidation(i, "unexpected image", e.stringify(u));
            if (!d || !f || c.has(f)) return void handleInvalidation(i, "unexpected resolution", e.stringify(u));
            if (c.set(f, d), o.has(f)) {
                const t = o.get(f);
                t.value = t.value.replace(e.stringify(l), r.trim()), o.set(f, t);
            } else o.set(f, {
                atRule: d,
                value: s.replace(e.stringify(l), r.trim())
            });
            p += 3;
        }
    }
    var a;
    for (const { atRule: e, value: t } of o.values()){
        const i = r.clone().removeAll(), o = n.clone({
            value: t
        });
        i.append(o), e.append(i);
    }
    const l = Array.from(o.keys()).sort((e, t)=>e - t), u = l.map((e)=>o.get(e)?.atRule).filter((e)=>!!e);
    if (!u.length) return;
    const c = o.get(l[0])?.value;
    if (!c) return;
    const f = u.slice(1);
    f.length && r.after(f), n.cloneBefore({
        value: c.trim()
    }), i.preserve || (n.remove(), r.nodes?.length || r.remove());
}, r = /(?:^|[^\w-])(?:-webkit-)?image-set\(/i, o = /^(?:-webkit-)?image-set$/i, creator = (n)=>{
    const i = !("preserve" in Object(n)) || Boolean(n?.preserve), s = "onInvalid" in Object(n) ? n?.onInvalid : "ignore";
    if ("oninvalid" in Object(n)) throw new Error('"oninvalid" was changed to "onInvalid" to match other plugins with similar options');
    return {
        postcssPlugin: "postcss-image-set-function",
        Declaration (n, { result: a, postcss: l }) {
            const u = n.value;
            if (!r.test(u)) return;
            if (t.hasFallback(n)) return;
            let c;
            try {
                c = e(u);
            } catch  {
                n.warn(a, `Failed to parse value '${u}' as an image-set function. Leaving the original value intact.`);
            }
            if (void 0 === c) return;
            const f = [];
            c.walk((t)=>{
                if ("function" !== t.type) return;
                if (!o.test(t.value)) return;
                let i = !1;
                if (e.walk(t.nodes, (e)=>{
                    "function" === e.type && o.test(e.value) && (i = !0);
                }), i) return handleInvalidation({
                    decl: n,
                    oninvalid: s,
                    result: a
                }, "nested image-set functions are not allowed", e.stringify(t)), !1;
                const r = t.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
                f.push({
                    imageSetFunction: t,
                    imageSetOptionNodes: r
                });
            }), processImageSet(f, n, {
                decl: n,
                oninvalid: s,
                preserve: i,
                result: a,
                postcss: l
            });
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-lab-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:lab|lch)\(/i, l = /^(?:lab|lch)$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-lab-function",
        Declaration (n) {
            const i = n.value;
            if (!o.test(i)) return;
            if (t.hasFallback(n)) return;
            if (t.hasSupportsAtRuleAncestor(n, o)) return;
            const u = r.tokenize({
                css: i
            }), c = a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), p = a.stringify(c);
            if (p === i) return;
            let g = p;
            s?.subFeatures.displayP3 && (g = a.stringify(a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.colorDataFitsRGB_Gamut(t) ? e.serializeRGB(t) : e.serializeP3(t) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && g !== p && n.cloneBefore({
                value: g
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return t.subFeatures = Object.assign({
        displayP3: !0
    }, t.subFeatures), t.enableProgressiveCustomProperties && (t.preserve || t.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-lab-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-logical/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var r, e, n = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
!function(r) {
    r.Block = "block", r.Inline = "inline";
}(r || (r = {})), function(r) {
    r.Start = "start", r.End = "end";
}(e || (e = {}));
const o = {
    BlockStart: "block-start",
    BlockEnd: "block-end",
    InlineStart: "inline-start",
    InlineEnd: "inline-end"
};
var t, i;
function directionFlowToAxes(r) {
    switch(r){
        case t.TopToBottom:
            return [
                i.Top,
                i.Bottom
            ];
        case t.BottomToTop:
            return [
                i.Bottom,
                i.Top
            ];
        case t.RightToLeft:
            return [
                i.Right,
                i.Left
            ];
        case t.LeftToRight:
            return [
                i.Left,
                i.Right
            ];
    }
}
function cloneDeclaration(r, e, n) {
    return r.parent && r.parent.some((r)=>"decl" == r.type && r.prop === n && r.value === e) ? [] : [
        r.clone({
            value: e,
            prop: n
        })
    ];
}
function transformTransition(r, e, o) {
    const { prop: t, value: i } = r, l = n(i), a = [];
    let s = [];
    l.nodes.forEach((r)=>{
        if ("div" === r.type && "," === r.value) return a.push(s), void (s = []);
        s.push(r);
    }), a.push(s);
    for(let r = 0; r < a.length; r++){
        const n = a[r];
        for(let t = 0; t < n.length; t++){
            const i = n[t];
            if ("word" !== i.type) continue;
            const l = i.value.toLowerCase(), s = o[l];
            if (!s) continue;
            const d = s(e.decl({
                prop: l,
                value: "initial"
            }));
            if (0 !== d.length) {
                for(let e = d.length - 1; e >= 0; e--){
                    const o = JSON.parse(JSON.stringify(n));
                    o[t].value = d[e].prop, a.splice(r + 1, 0, o);
                }
                a.splice(r, 1), r++;
            }
        }
    }
    const d = [];
    for(let r = 0; r < a.length; r++){
        const e = a[r];
        d.push(...e), r !== a.length - 1 && d.push({
            type: "div",
            value: ",",
            sourceIndex: 0,
            sourceEndIndex: 0,
            before: "",
            after: " "
        });
    }
    const c = n.stringify(d);
    return c !== i ? cloneDeclaration(r, c, t) : [];
}
function parseValueCouple(r) {
    const e = n(r.value).nodes.filter((r)=>"space" !== r.type);
    if (e.length > 2 || 0 === e.length) {
        const n = `[postcss-logical] Invalid number of values for ${r.prop}. Found ${e.length} values, expected 1 or 2.`;
        throw r.error(n);
    }
    let o, t;
    return 1 === e.length ? (o = n.stringify(e[0]), t = o) : (o = n.stringify(e[0]), t = n.stringify(e[1])), [
        o,
        t
    ];
}
function transformBorder(r, e) {
    return (n)=>cloneDeclaration(n, n.value, `border-${e}-${r}`);
}
function transformBorderProperty(r, e) {
    return (n)=>{
        const [o, t] = e, [i, l] = parseValueCouple(n);
        return [
            ...cloneDeclaration(n, i, `border-${o}-${r}`),
            ...cloneDeclaration(n, l, `border-${t}-${r}`)
        ];
    };
}
function transformBorderShorthand(r) {
    return (e)=>r.flatMap((r)=>cloneDeclaration(e, e.value, `border-${r}`));
}
function transformBorderRadius(r) {
    return (e)=>{
        let n;
        switch(e.prop.toLowerCase()){
            case "border-start-start-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[0]}-${r.inline[0]}` : `${r.inline[0]}-${r.block[0]}`}-radius`;
                break;
            case "border-start-end-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[0]}-${r.inline[1]}` : `${r.inline[1]}-${r.block[0]}`}-radius`;
                break;
            case "border-end-start-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[1]}-${r.inline[0]}` : `${r.inline[0]}-${r.block[1]}`}-radius`;
                break;
            case "border-end-end-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[1]}-${r.inline[1]}` : `${r.inline[1]}-${r.block[1]}`}-radius`;
                break;
        }
        return n ? cloneDeclaration(e, e.value, n) : [];
    };
}
function transformLogicalSize(r) {
    return (e)=>{
        const { value: n } = e, o = r.inlineIsHorizontal ? "width" : "height", t = r.inlineIsHorizontal ? "height" : "width", i = e.prop.toLowerCase().replace("inline-size", o).replace("block-size", t);
        return cloneDeclaration(e, n, i);
    };
}
function transformOffset(r) {
    return (e)=>cloneDeclaration(e, e.value, r);
}
function transformOffsetShorthand(r) {
    return (e)=>{
        const [n, o] = r, [t, i] = parseValueCouple(e);
        return [
            ...cloneDeclaration(e, t, n),
            ...cloneDeclaration(e, i, o)
        ];
    };
}
function transformSide(r, e) {
    return (n)=>cloneDeclaration(n, n.value, `${r}-${e}`);
}
function transformSideShorthand(r, e) {
    return (n)=>{
        const [o, t] = e, [i, l] = parseValueCouple(n);
        return [
            ...cloneDeclaration(n, i, `${r}-${o}`),
            ...cloneDeclaration(n, l, `${r}-${t}`)
        ];
    };
}
function logicalToPhysical(r, e) {
    const [n, t] = e.block, [i, l] = e.inline;
    switch(r){
        case o.BlockStart:
            return n;
        case o.BlockEnd:
            return t;
        case o.InlineStart:
            return i;
        case o.InlineEnd:
            return l;
        default:
            throw new Error("Unsupported logical direction");
    }
}
function doTransform(r, e, o) {
    const { prop: t, value: i } = r, l = n(i);
    l.nodes.forEach((r)=>{
        if ("word" === r.type) {
            const n = r.value.toLowerCase();
            e.includes(n) && (r.value = logicalToPhysical(n, o));
        }
    });
    const a = l.toString();
    return a !== i ? cloneDeclaration(r, a, t) : [];
}
function prepareTransforms(r, t, i, l, a) {
    return {
        "caption-side": (d = r, (r)=>doTransform(r, Object.values(o), d)),
        "text-align": r.inlineIsHorizontal ? (s = r.inline, (r)=>{
            const { prop: o, value: t } = r, i = n(t), [l, a] = s;
            i.nodes.forEach((r)=>{
                if ("word" === r.type) {
                    const n = r.value.toLowerCase();
                    if (n === e.End) return void (r.value = a);
                    if (n === e.Start) return void (r.value = l);
                }
            });
            const d = i.toString();
            return d !== t ? cloneDeclaration(r, d, o) : [];
        }) : null,
        "block-size": transformLogicalSize(r),
        "inline-size": transformLogicalSize(r),
        "min-block-size": transformLogicalSize(r),
        "max-block-size": transformLogicalSize(r),
        "min-inline-size": transformLogicalSize(r),
        "max-inline-size": transformLogicalSize(r),
        "margin-block-start": transformSide("margin", t),
        "margin-block-end": transformSide("margin", i),
        "margin-inline-start": transformSide("margin", l),
        "margin-inline-end": transformSide("margin", a),
        "margin-block": transformSideShorthand("margin", r.block),
        "margin-inline": transformSideShorthand("margin", r.inline),
        "inset-block": transformOffsetShorthand(r.block),
        "inset-block-start": transformOffset(t),
        "inset-block-end": transformOffset(i),
        "inset-inline": transformOffsetShorthand(r.inline),
        "inset-inline-start": transformOffset(l),
        "inset-inline-end": transformOffset(a),
        inset: (r)=>{
            const e = n(r.value).nodes.filter((r)=>"space" !== r.type && "comment" !== r.type);
            if (e.length > 4) {
                const n = `[postcss-logical] Invalid number of values for ${r.prop}. Found ${e.length} values, expected up to 4 values.`;
                throw r.error(n);
            }
            let o, t, i, l;
            if (1 === e.length) o = n.stringify(e[0]), t = o, i = o, l = o;
            else if (2 === e.length) o = n.stringify(e[0]), t = n.stringify(e[1]), i = o, l = t;
            else if (3 === e.length) o = n.stringify(e[0]), t = n.stringify(e[1]), l = t, i = n.stringify(e[2]);
            else {
                if (4 !== e.length) return [];
                o = n.stringify(e[0]), t = n.stringify(e[1]), i = n.stringify(e[2]), l = n.stringify(e[3]);
            }
            return [
                ...cloneDeclaration(r, o, "top"),
                ...cloneDeclaration(r, t, "right"),
                ...cloneDeclaration(r, i, "bottom"),
                ...cloneDeclaration(r, l, "left")
            ];
        },
        "padding-block-start": transformSide("padding", t),
        "padding-block-end": transformSide("padding", i),
        "padding-inline-start": transformSide("padding", l),
        "padding-inline-end": transformSide("padding", a),
        "padding-block": transformSideShorthand("padding", r.block),
        "padding-inline": transformSideShorthand("padding", r.inline),
        "border-block-start-width": transformBorder("width", t),
        "border-block-end-width": transformBorder("width", i),
        "border-inline-start-width": transformBorder("width", l),
        "border-inline-end-width": transformBorder("width", a),
        "border-block-width": transformBorderProperty("width", r.block),
        "border-inline-width": transformBorderProperty("width", r.inline),
        "border-block-start-style": transformBorder("style", t),
        "border-block-end-style": transformBorder("style", i),
        "border-inline-start-style": transformBorder("style", l),
        "border-inline-end-style": transformBorder("style", a),
        "border-block-style": transformBorderProperty("style", r.block),
        "border-inline-style": transformBorderProperty("style", r.inline),
        "border-block-start-color": transformBorder("color", t),
        "border-block-end-color": transformBorder("color", i),
        "border-inline-start-color": transformBorder("color", l),
        "border-inline-end-color": transformBorder("color", a),
        "border-block-color": transformBorderProperty("color", r.block),
        "border-inline-color": transformBorderProperty("color", r.inline),
        "border-block": transformBorderShorthand(r.block),
        "border-block-start": transformBorderShorthand([
            t
        ]),
        "border-block-end": transformBorderShorthand([
            i
        ]),
        "border-inline": transformBorderShorthand(r.inline),
        "border-inline-start": transformBorderShorthand([
            l
        ]),
        "border-inline-end": transformBorderShorthand([
            a
        ]),
        "border-start-start-radius": transformBorderRadius(r),
        "border-start-end-radius": transformBorderRadius(r),
        "border-end-start-radius": transformBorderRadius(r),
        "border-end-end-radius": transformBorderRadius(r)
    };
    "TURBOPACK unreachable";
    var s, d;
}
!function(r) {
    r.TopToBottom = "top-to-bottom", r.BottomToTop = "bottom-to-top", r.RightToLeft = "right-to-left", r.LeftToRight = "left-to-right";
}(t || (t = {})), function(r) {
    r.Top = "top", r.Right = "right", r.Bottom = "bottom", r.Left = "left";
}(i || (i = {}));
const l = /var\(/i, creator = (r)=>{
    const e = Object.assign({
        blockDirection: t.TopToBottom,
        inlineDirection: t.LeftToRight
    }, r), n = Object.values(t);
    if (!n.includes(e.blockDirection)) throw new Error(`[postcss-logical] "blockDirection" must be one of ${n.join(", ")}`);
    if (!n.includes(e.inlineDirection)) throw new Error(`[postcss-logical] "inlineDirection" must be one of ${n.join(", ")}`);
    const [o, a] = directionFlowToAxes(e.blockDirection), [s, d] = directionFlowToAxes(e.inlineDirection);
    if (!Object.values(i).every((r)=>[
            o,
            a,
            s,
            d
        ].includes(r))) throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');
    const makeTransform = (r)=>(n, { result: o })=>{
            if (!r) return;
            if (e.ignoreCustomProperties && l.test(n.value)) return;
            let t = [];
            try {
                t = r(n);
            } catch (r) {
                return void n.warn(o, r instanceof Error ? r.message : String(r));
            }
            t?.length && (t.forEach((r)=>{
                n.cloneBefore(r);
            }), n.remove());
        }, c = prepareTransforms({
        block: [
            o,
            a
        ],
        inline: [
            s,
            d
        ],
        inlineIsHorizontal: [
            t.LeftToRight,
            t.RightToLeft
        ].includes(e.inlineDirection)
    }, o, a, s, d);
    return {
        postcssPlugin: "postcss-logical",
        Declaration: {
            "caption-side": makeTransform(c["caption-side"]),
            "text-align": makeTransform(c["text-align"]),
            "block-size": makeTransform(c["block-size"]),
            "inline-size": makeTransform(c["inline-size"]),
            "min-block-size": makeTransform(c["min-block-size"]),
            "max-block-size": makeTransform(c["max-block-size"]),
            "min-inline-size": makeTransform(c["min-inline-size"]),
            "max-inline-size": makeTransform(c["max-inline-size"]),
            "margin-block-start": makeTransform(c["margin-block-start"]),
            "margin-block-end": makeTransform(c["margin-block-end"]),
            "margin-inline-start": makeTransform(c["margin-inline-start"]),
            "margin-inline-end": makeTransform(c["margin-inline-end"]),
            "margin-block": makeTransform(c["margin-block"]),
            "margin-inline": makeTransform(c["margin-inline"]),
            "inset-block": makeTransform(c["inset-block"]),
            "inset-block-start": makeTransform(c["inset-block-start"]),
            "inset-block-end": makeTransform(c["inset-block-end"]),
            "inset-inline": makeTransform(c["inset-inline"]),
            "inset-inline-start": makeTransform(c["inset-inline-start"]),
            "inset-inline-end": makeTransform(c["inset-inline-end"]),
            inset: makeTransform(c.inset),
            "padding-block-start": makeTransform(c["padding-block-start"]),
            "padding-block-end": makeTransform(c["padding-block-end"]),
            "padding-inline-start": makeTransform(c["padding-inline-start"]),
            "padding-inline-end": makeTransform(c["padding-inline-end"]),
            "padding-block": makeTransform(c["padding-block"]),
            "padding-inline": makeTransform(c["padding-inline"]),
            "border-block-start-width": makeTransform(c["border-block-start-width"]),
            "border-block-end-width": makeTransform(c["border-block-end-width"]),
            "border-inline-start-width": makeTransform(c["border-inline-start-width"]),
            "border-inline-end-width": makeTransform(c["border-inline-end-width"]),
            "border-block-width": makeTransform(c["border-block-width"]),
            "border-inline-width": makeTransform(c["border-inline-width"]),
            "border-block-start-style": makeTransform(c["border-block-start-style"]),
            "border-block-end-style": makeTransform(c["border-block-end-style"]),
            "border-inline-start-style": makeTransform(c["border-inline-start-style"]),
            "border-inline-end-style": makeTransform(c["border-inline-end-style"]),
            "border-block-style": makeTransform(c["border-block-style"]),
            "border-inline-style": makeTransform(c["border-inline-style"]),
            "border-block-start-color": makeTransform(c["border-block-start-color"]),
            "border-block-end-color": makeTransform(c["border-block-end-color"]),
            "border-inline-start-color": makeTransform(c["border-inline-start-color"]),
            "border-inline-end-color": makeTransform(c["border-inline-end-color"]),
            "border-block-color": makeTransform(c["border-block-color"]),
            "border-inline-color": makeTransform(c["border-inline-color"]),
            "border-block": makeTransform(c["border-block"]),
            "border-block-start": makeTransform(c["border-block-start"]),
            "border-block-end": makeTransform(c["border-block-end"]),
            "border-inline": makeTransform(c["border-inline"]),
            "border-inline-start": makeTransform(c["border-inline-start"]),
            "border-inline-end": makeTransform(c["border-inline-end"]),
            "border-start-start-radius": makeTransform(c["border-start-start-radius"]),
            "border-start-end-radius": makeTransform(c["border-start-end-radius"]),
            "border-end-start-radius": makeTransform(c["border-end-start-radius"]),
            "border-end-end-radius": makeTransform(c["border-end-end-radius"]),
            transition: (r, { result: n, postcss: o })=>{
                if (e.ignoreCustomProperties && l.test(r.value)) return;
                let t = [];
                try {
                    t = transformTransition(r, o, c);
                } catch (e) {
                    return void r.warn(n, e instanceof Error ? e.message : String(e));
                }
                t?.length && (t.forEach((e)=>{
                    r.cloneBefore(e);
                }), r.remove());
            }
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-selector-not/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-selector-not/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function cleanupWhitespace(e) {
    e.spaces && (e.spaces.after = "", e.spaces.before = ""), e.nodes && e.nodes.length > 0 && (e.nodes[0] && e.nodes[0].spaces && (e.nodes[0].spaces.before = ""), e.nodes[e.nodes.length - 1] && e.nodes[e.nodes.length - 1].spaces && (e.nodes[e.nodes.length - 1].spaces.after = ""));
}
const creator = ()=>({
        postcssPlugin: "postcss-selector-not",
        Rule (s, { result: o }) {
            if (s.selector && s.selector.toLowerCase().includes(":not(")) try {
                const o = e().astSync(s.selector);
                o.walkPseudos((s)=>{
                    if (":not" !== s.value.toLowerCase()) return;
                    if (!s.nodes || s.nodes.length < 2) return;
                    const o = [];
                    s.nodes.forEach((s)=>{
                        cleanupWhitespace(s);
                        const t = e.pseudo({
                            value: ":not",
                            nodes: [
                                s
                            ]
                        });
                        o.push(t);
                    }), s.replaceWith(...o);
                });
                const t = o.toString();
                t !== s.selector && s.replaceWith(s.clone({
                    selector: t
                }));
            } catch (e) {
                s.warn(o, `Failed to parse selector : "${s.selector}" with message: "${e instanceof Error ? e.message : e}"`);
            }
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-opacity-percentage/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const doNothingValues = new Set([
    'inherit',
    'initial',
    'revert',
    'unset'
]);
/**
 * @type {import('postcss').PluginCreator}
 */ module.exports = ({ preserve = false } = {})=>({
        postcssPlugin: 'postcss-opacity-percentage',
        Declaration: {
            opacity (decl) {
                if (!decl.value || decl.value.startsWith('var(') || !decl.value.endsWith('%') || doNothingValues.has(decl.value)) {
                    return;
                }
                decl.cloneBefore({
                    value: String(Number.parseFloat(decl.value) / 100)
                });
                if (!preserve) {
                    decl.remove();
                }
            }
        }
    });
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-overflow-shorthand/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
const creator = (r)=>{
    const o = Object.assign({
        preserve: !0
    }, r);
    return {
        postcssPlugin: "postcss-overflow-shorthand",
        Declaration (r, { result: s }) {
            if ("overflow" !== r.prop.toLowerCase()) return;
            let t = "", a = "";
            const l = r.value;
            try {
                const r = e(l).nodes.slice().filter((e)=>"comment" !== e.type && "space" !== e.type);
                if (r.length < 2) return;
                t = e.stringify(r[0]), a = e.stringify(r[1]);
            } catch  {
                return void r.warn(s, `Failed to parse value '${l}' as a shorthand for "overflow". Leaving the original value intact.`);
            }
            t && a && (t.toLowerCase() === a.toLowerCase() ? r.cloneBefore({
                value: t
            }) : (r.cloneBefore({
                prop: "overflow-x",
                value: t
            }), r.cloneBefore({
                prop: "overflow-y",
                value: a
            })), o.preserve || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-replace-overflow-wrap/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-check
module.exports = function(opts) {
    opts = opts || {};
    var method = opts.method || 'replace';
    return {
        postcssPlugin: 'postcss-replace-overflow-wrap',
        Declaration: {
            'overflow-wrap': (decl)=>{
                decl.cloneBefore({
                    prop: 'word-wrap'
                });
                if (method === 'replace') {
                    decl.remove();
                }
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-place/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function onCSSDeclaration(r, o, s) {
    const n = r.prop.match(t)?.[1].toLowerCase();
    if (!n) return;
    let a;
    try {
        a = e(r.value);
    } catch  {
        r.warn(o, `Failed to parse value '${r.value}'. Leaving the original value intact.`);
    }
    if (void 0 === a) return;
    let i = [];
    i = a.nodes.length ? a.nodes.filter((e)=>"word" === e.type || "function" === e.type).map((t)=>e.stringify(t)) : [
        e.stringify(a.nodes)
    ], r.cloneBefore({
        prop: `align-${n}`,
        value: i[0]
    }), r.cloneBefore({
        prop: `justify-${n}`,
        value: i[1] || i[0]
    }), s.preserve || r.remove();
}
const t = /^place-(content|items|self)/i, creator = (e)=>{
    const r = Object.assign({
        preserve: !0
    }, e);
    return {
        postcssPlugin: "postcss-place",
        Declaration (e, { result: o }) {
            t.test(e.prop) && onCSSDeclaration(e, o, r);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/css-prefers-color-scheme/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = /\(\s*prefers-color-scheme\s*:\s*(dark|light)\s*\)/gi, s = "(color: 48842621)", r = "(color: 70318723)", creator = (o)=>{
    const t = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-prefers-color-scheme",
        prepare () {
            const o = new WeakSet;
            return {
                postcssPlugin: "postcss-prefers-color-scheme",
                AtRule (c) {
                    if (o.has(c)) return;
                    if ("media" !== c.name.toLowerCase()) return;
                    const { params: a } = c, p = a.replace(e, (e, o)=>"dark" === o.toLowerCase() ? s : "light" === o.toLowerCase() ? r : e);
                    a !== p && (o.add(c), c.cloneBefore({
                        params: p
                    }), t.preserve || c.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-color-rebeccapurple/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const s = /rebeccapurple/i, t = /^rebeccapurple$/i, creator = (c)=>{
    const l = Object.assign({
        preserve: !1
    }, c);
    return {
        postcssPlugin: "postcss-color-rebeccapurple",
        Declaration (c) {
            if (!s.test(c.value)) return;
            if (r.hasFallback(c)) return;
            const a = e(c.value);
            a.walk((e)=>{
                "word" === e.type && t.test(e.value) && (e.value = "#639");
            });
            const o = String(a);
            o !== c.value && (c.cloneBefore({
                value: o
            }), l.preserve || c.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-preset-env/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/autoprefixer/lib/autoprefixer.js [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/cssdb/cssdb.json (json)"), o = __turbopack_context__.r("[project]/node_modules/browserslist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-initial/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/postcss-pseudo-class-any-link/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/css-blank-pseudo/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/postcss-page-break/index.js [postcss] (ecmascript)"), c = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/postcss-attribute-case-insensitive/dist/index.cjs [postcss] (ecmascript)"), p = __turbopack_context__.r("[project]/node_modules/postcss-clamp/index.js [postcss] (ecmascript)"), l = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-function/dist/index.cjs [postcss] (ecmascript)"), u = __turbopack_context__.r("[project]/node_modules/postcss-color-functional-notation/dist/index.cjs [postcss] (ecmascript)"), m = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-mix-function/dist/index.cjs [postcss] (ecmascript)"), d = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-mix-variadic-function-arguments/dist/index.cjs [postcss] (ecmascript)"), g = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-content-alt-text/dist/index.cjs [postcss] (ecmascript)"), f = __turbopack_context__.r("[project]/node_modules/postcss-custom-media/dist/index.cjs [postcss] (ecmascript)"), h = __turbopack_context__.r("[project]/node_modules/postcss-custom-properties/dist/index.cjs [postcss] (ecmascript)"), b = __turbopack_context__.r("[project]/node_modules/postcss-custom-selectors/dist/index.cjs [postcss] (ecmascript)"), v = __turbopack_context__.r("[project]/node_modules/postcss-dir-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), N = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-normalize-display-values/dist/index.cjs [postcss] (ecmascript)"), k = __turbopack_context__.r("[project]/node_modules/postcss-double-position-gradients/dist/index.cjs [postcss] (ecmascript)"), y = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-exponential-functions/dist/index.cjs [postcss] (ecmascript)"), w = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-float-and-clear/dist/index.cjs [postcss] (ecmascript)"), q = __turbopack_context__.r("[project]/node_modules/postcss-focus-visible/dist/index.cjs [postcss] (ecmascript)"), x = __turbopack_context__.r("[project]/node_modules/postcss-focus-within/dist/index.cjs [postcss] (ecmascript)"), F = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-font-format-keywords/dist/index.cjs [postcss] (ecmascript)"), $ = __turbopack_context__.r("[project]/node_modules/postcss-font-variant/index.js [postcss] (ecmascript)"), O = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-gamut-mapping/dist/index.cjs [postcss] (ecmascript)"), S = __turbopack_context__.r("[project]/node_modules/postcss-gap-properties/dist/index.cjs [postcss] (ecmascript)"), C = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-gradients-interpolation-method/dist/index.cjs [postcss] (ecmascript)"), P = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/dist/index.cjs [postcss] (ecmascript)"), E = __turbopack_context__.r("[project]/node_modules/postcss-color-hex-alpha/dist/index.cjs [postcss] (ecmascript)"), I = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-hwb-function/dist/index.cjs [postcss] (ecmascript)"), A = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-ic-unit/dist/index.cjs [postcss] (ecmascript)"), B = __turbopack_context__.r("[project]/node_modules/postcss-image-set-function/dist/index.cjs [postcss] (ecmascript)"), L = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), _ = __turbopack_context__.r("[project]/node_modules/postcss-lab-function/dist/index.cjs [postcss] (ecmascript)"), U = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-light-dark-function/dist/index.cjs [postcss] (ecmascript)"), j = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-overflow/dist/index.cjs [postcss] (ecmascript)"), M = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-overscroll-behavior/dist/index.cjs [postcss] (ecmascript)"), z = __turbopack_context__.r("[project]/node_modules/postcss-logical/dist/index.cjs [postcss] (ecmascript)"), D = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-resize/dist/index.cjs [postcss] (ecmascript)"), R = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-viewport-units/dist/index.cjs [postcss] (ecmascript)"), T = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-media-queries-aspect-ratio-number-values/dist/index.cjs [postcss] (ecmascript)"), V = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-media-minmax/dist/index.cjs [postcss] (ecmascript)"), H = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-nested-calc/dist/index.cjs [postcss] (ecmascript)"), W = __turbopack_context__.r("[project]/node_modules/postcss-nesting/dist/index.cjs [postcss] (ecmascript)"), G = __turbopack_context__.r("[project]/node_modules/postcss-selector-not/dist/index.cjs [postcss] (ecmascript)"), K = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-oklab-function/dist/index.cjs [postcss] (ecmascript)"), Z = __turbopack_context__.r("[project]/node_modules/postcss-opacity-percentage/index.js [postcss] (ecmascript)"), Q = __turbopack_context__.r("[project]/node_modules/postcss-overflow-shorthand/dist/index.cjs [postcss] (ecmascript)"), J = __turbopack_context__.r("[project]/node_modules/postcss-replace-overflow-wrap/index.js [postcss] (ecmascript)"), X = __turbopack_context__.r("[project]/node_modules/postcss-place/dist/index.cjs [postcss] (ecmascript)"), Y = __turbopack_context__.r("[project]/node_modules/css-prefers-color-scheme/dist/index.cjs [postcss] (ecmascript)"), ss = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), es = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-random-function/dist/index.cjs [postcss] (ecmascript)"), os = __turbopack_context__.r("[project]/node_modules/postcss-color-rebeccapurple/dist/index.cjs [postcss] (ecmascript)"), ts = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-relative-color-syntax/dist/index.cjs [postcss] (ecmascript)"), is = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-scope-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), rs = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-sign-functions/dist/index.cjs [postcss] (ecmascript)"), as = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-stepped-value-functions/dist/index.cjs [postcss] (ecmascript)"), cs = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-text-decoration-shorthand/dist/index.cjs [postcss] (ecmascript)"), ns = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-trigonometric-functions/dist/index.cjs [postcss] (ecmascript)"), ps = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-unset-value/dist/index.cjs [postcss] (ecmascript)");
const ls = {
    "blank-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-blank-pseudo/README.md#browser",
    "focus-visible-pseudo-class": "https://github.com/WICG/focus-visible",
    "focus-within-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/postcss-focus-within/README.md#browser",
    "has-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-has-pseudo/README.md#browser",
    "prefers-color-scheme-query": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-prefers-color-scheme/README.md#browser"
}, us = [
    "blank-pseudo-class",
    "focus-visible-pseudo-class",
    "focus-within-pseudo-class",
    "has-pseudo-class",
    "prefers-color-scheme-query"
];
function logFeaturesList(s, e, o) {
    if (e.debug) {
        o.log("Enabling the following feature(s):");
        const t = [], i = [];
        !1 !== e.autoprefixer && i.push("  autoprefixer"), s.forEach((s)=>{
            s.id.startsWith("before") || s.id.startsWith("after") ? i.push(`  ${s.id} (injected via options)`) : i.push(`  ${s.id}`), void 0 !== ls[s.id] && t.push(s.id);
        }), i.sort((s, e)=>s.localeCompare(e)), t.sort((s, e)=>s.localeCompare(e)), i.forEach((s)=>o.log(s)), t.length && (o.log("These feature(s) need a browser library to work:"), t.forEach((s)=>o.log(`  ${s}: ${ls[s]}`)));
    }
}
function initializeSharedOptions(s) {
    if ("preserve" in s) {
        const e = {};
        return e.preserve = s.preserve, e;
    }
    return !1;
}
function clamp(s, e, o) {
    return Math.max(s, Math.min(e, o));
}
function stageFromOptions(s, e) {
    let o = 2;
    if (void 0 === s.stage) return e.log("Using features from Stage 2 (default)."), o;
    if (!1 === s.stage) o = 5;
    else {
        let e = parseInt(s.stage, 10);
        Number.isNaN(e) && (e = 0), o = clamp(0, e, 5);
    }
    return 5 === o ? e.log('Stage has been disabled, features will be handled via the "features" option.') : e.log(`Using features from Stage ${o}.`), o;
}
const ms = Symbol("insertBefore"), ds = Symbol("insertAfter"), gs = Symbol("insertOrder"), fs = Symbol("plugin");
function getTransformedInsertions(s, e, o) {
    if ("insertBefore" !== o && "insertAfter" !== o) return [];
    const t = "insertBefore" === o ? ms : ds, i = [];
    for(const o in e){
        if (!Object.hasOwnProperty.call(e, o)) continue;
        if (!s.find((s)=>s.id === o)) continue;
        let r = e[o];
        Array.isArray(r) || (r = [
            r
        ]);
        for(let s = 0; s < r.length; s++)i.push({
            id: o,
            [fs]: r[s],
            [gs]: s,
            [t]: !0
        });
    }
    return i;
}
var hs = [
    "custom-media-queries",
    "environment-variables",
    "image-set-function",
    "media-query-ranges",
    "media-queries-aspect-ratio-number-values",
    "prefers-color-scheme-query",
    "nesting-rules",
    "custom-selectors",
    "any-link-pseudo-class",
    "case-insensitive-attributes",
    "focus-visible-pseudo-class",
    "focus-within-pseudo-class",
    "not-pseudo-class",
    "logical-properties-and-values",
    "float-clear-logical-values",
    "logical-overflow",
    "logical-overscroll-behavior",
    "logical-resize",
    "logical-viewport-units",
    "dir-pseudo-class",
    "all-property",
    "gradients-interpolation-method",
    "color-mix-variadic-function-arguments",
    "color-mix",
    "relative-color-syntax",
    "lab-function",
    "oklab-function",
    "color-function",
    "hwb-function",
    "color-functional-notation",
    "rebeccapurple-color",
    "hexadecimal-alpha-notation",
    "light-dark-function",
    "double-position-gradients",
    "blank-pseudo-class",
    "break-properties",
    "font-variant-property",
    "is-pseudo-class",
    "scope-pseudo-class",
    "has-pseudo-class",
    "gap-properties",
    "overflow-property",
    "overflow-wrap-property",
    "place-properties",
    "system-ui-font-family",
    "font-format-keywords",
    "display-two-values",
    "content-alt-text",
    "ic-unit",
    "opacity-percentage",
    "text-decoration-shorthand",
    "unset-value",
    "random-function",
    "sign-functions",
    "stepped-value-functions",
    "trigonometric-functions",
    "exponential-functions",
    "clamp",
    "nested-calc",
    "custom-properties",
    "cascade-layers",
    "progressive-custom-properties",
    "gamut-mapping"
];
function featureIsLess(s, e) {
    return s.id === e.id ? s[ms] && e[ms] || s[ds] && e[ds] ? clamp(-1, s[gs] - e[gs], 1) : s[ms] || e[ds] ? -1 : s[ds] || e[ms] ? 1 : 0 : clamp(-1, hs.indexOf(s.id) - hs.indexOf(e.id), 1);
}
function postcssSystemUiFont() {
    return {
        postcssPlugin: "postcss-system-ui-font",
        Declaration (s) {
            bs.test(s.prop) && (s.value.includes(ks) || (s.value = s.value.replace(ys, ws)));
        }
    };
}
postcssSystemUiFont.postcss = !0;
const bs = /(?:^(?:-|\\002d){2})|(?:^font(?:-family)?$)/i, vs = "[\\f\\n\\r\\x09\\x20]", Ns = [
    "system-ui",
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Ubuntu",
    "Cantarell",
    "Noto Sans",
    "sans-serif"
], ks = Ns.join(", "), ys = new RegExp(`(^|,|${vs}+)(?:system-ui${vs}*)(?:,${vs}*(?:${Ns.join("|")})${vs}*)?(,|$)`, "i"), ws = `$1${ks}$2`, qs = new Map([
    [
        "all-property",
        t
    ],
    [
        "any-link-pseudo-class",
        i
    ],
    [
        "blank-pseudo-class",
        r
    ],
    [
        "break-properties",
        a
    ],
    [
        "cascade-layers",
        c
    ],
    [
        "case-insensitive-attributes",
        n
    ],
    [
        "clamp",
        p
    ],
    [
        "color-function",
        l
    ],
    [
        "color-functional-notation",
        u
    ],
    [
        "color-mix",
        m
    ],
    [
        "color-mix-variadic-function-arguments",
        d
    ],
    [
        "content-alt-text",
        g
    ],
    [
        "custom-media-queries",
        f
    ],
    [
        "custom-properties",
        h
    ],
    [
        "custom-selectors",
        b
    ],
    [
        "dir-pseudo-class",
        v
    ],
    [
        "display-two-values",
        N
    ],
    [
        "double-position-gradients",
        k
    ],
    [
        "exponential-functions",
        y
    ],
    [
        "float-clear-logical-values",
        w
    ],
    [
        "focus-visible-pseudo-class",
        q
    ],
    [
        "focus-within-pseudo-class",
        x
    ],
    [
        "font-format-keywords",
        F
    ],
    [
        "font-variant-property",
        $
    ],
    [
        "gamut-mapping",
        O
    ],
    [
        "gap-properties",
        S
    ],
    [
        "gradients-interpolation-method",
        C
    ],
    [
        "has-pseudo-class",
        P
    ],
    [
        "hexadecimal-alpha-notation",
        E
    ],
    [
        "hwb-function",
        I
    ],
    [
        "ic-unit",
        A
    ],
    [
        "image-set-function",
        B
    ],
    [
        "is-pseudo-class",
        L
    ],
    [
        "lab-function",
        _
    ],
    [
        "light-dark-function",
        U
    ],
    [
        "logical-overflow",
        j
    ],
    [
        "logical-overscroll-behavior",
        M
    ],
    [
        "logical-properties-and-values",
        z
    ],
    [
        "logical-resize",
        D
    ],
    [
        "logical-viewport-units",
        R
    ],
    [
        "media-queries-aspect-ratio-number-values",
        T
    ],
    [
        "media-query-ranges",
        V
    ],
    [
        "nested-calc",
        H
    ],
    [
        "nesting-rules",
        W
    ],
    [
        "not-pseudo-class",
        G
    ],
    [
        "oklab-function",
        K
    ],
    [
        "opacity-percentage",
        Z
    ],
    [
        "overflow-property",
        Q
    ],
    [
        "overflow-wrap-property",
        J
    ],
    [
        "place-properties",
        X
    ],
    [
        "prefers-color-scheme-query",
        Y
    ],
    [
        "progressive-custom-properties",
        ss
    ],
    [
        "random-function",
        es
    ],
    [
        "rebeccapurple-color",
        os
    ],
    [
        "relative-color-syntax",
        ts
    ],
    [
        "scope-pseudo-class",
        is
    ],
    [
        "sign-functions",
        rs
    ],
    [
        "stepped-value-functions",
        as
    ],
    [
        "system-ui-font-family",
        postcssSystemUiFont
    ],
    [
        "text-decoration-shorthand",
        cs
    ],
    [
        "trigonometric-functions",
        ns
    ],
    [
        "unset-value",
        ps
    ]
]);
function featureIsInsertedOrHasAPlugin(s) {
    return !!s[ms] || !!s[ds] || !!qs.has(s.id);
}
function prepareFeaturesList(s, e, o) {
    return s.concat(getTransformedInsertions(s, e, "insertBefore"), getTransformedInsertions(s, o, "insertAfter")).filter((s)=>featureIsInsertedOrHasAPlugin(s)).sort((s, e)=>featureIsLess(s, e));
}
function getOptionsForBrowsersByFeature(s, e, o, t) {
    switch(e.id){
        case "is-pseudo-class":
            return {
                onComplexSelector: "warning"
            };
        case "any-link-pseudo-class":
            if (s.find((s)=>s.startsWith("ie ") || "edge 12" === s || "edge 13" === s || "edge 14" === s || "edge 15" === s || "edge 16" === s || "edge 17" === s || "edge 18" === s)) return t.log("- 'any-link-pseudo-class' setting 'subFeatures: { areaHrefNeedsFixing: true }' due to lack of browser support for area[href] in Edge and IE."), {
                subFeatures: {
                    areaHrefNeedsFixing: !0
                }
            };
            return {};
        case "logical-properties-and-values":
        case "float-clear-logical-values":
        case "logical-resize":
        case "logical-viewport-units":
        case "logical-overflow":
        case "logical-overscroll-behavior":
            return "logical" in o ? o.logical : {};
        default:
            return {};
    }
}
const xs = [
    "and_chr",
    "and_ff",
    "android",
    "chrome",
    "edge",
    "firefox",
    "ie",
    "ios_saf",
    "op_mini",
    "op_mob",
    "opera",
    "safari",
    "samsung"
];
function getUnsupportedBrowsersByFeature(s) {
    if (!s) return [];
    if (!("browser_support" in s)) return [
        "> 0%"
    ];
    const e = [];
    return xs.forEach((o)=>{
        if ("op_mini" === o && void 0 === s.browser_support[o]) return void e.push("op_mini all");
        const t = s.browser_support[o];
        "string" == typeof t && Fs.test(t) ? e.push(`${o} < ${s.browser_support[o]}`) : e.push(`${o} >= 1`);
    }), e;
}
const Fs = /^[0-9|.]+$/;
function formatPolyfillableFeature(s) {
    const e = getUnsupportedBrowsersByFeature(s);
    if (s[ms] || s[ds]) {
        let o = s.id;
        return o = s.insertBefore ? `before-${o}` : `after-${o}`, {
            browsers: e,
            vendors_implementations: s.vendors_implementations,
            plugin: s[fs],
            id: o,
            stage: 6
        };
    }
    return {
        browsers: e,
        vendors_implementations: s.vendors_implementations,
        plugin: qs.get(s.id),
        id: s.id,
        stage: s.stage
    };
}
function formatStagedFeature(s, e, o, t, i, r) {
    let a, c;
    return a = getOptionsForBrowsersByFeature(s, o, i, r), a = t ? Object.assign({}, a, t, featureOptions(e, o.id)) : Object.assign({}, a, featureOptions(e, o.id)), "progressive-custom-properties" !== o.id && (a.enableProgressiveCustomProperties = !1), "overflow-wrap-property" === o.id && "preserve" in a && (a.method = a.preserve ? "copy" : "replace"), c = o.plugin.postcss && "function" == typeof o.plugin ? o.plugin(a) : o.plugin && o.plugin.default && "function" == typeof o.plugin.default && o.plugin.default.postcss ? o.plugin.default(a) : o.plugin, {
        browsers: o.browsers,
        vendors_implementations: o.vendors_implementations,
        plugin: c,
        pluginOptions: a,
        id: o.id
    };
}
function featureOptions(s, e) {
    if (!(e in s)) return;
    const o = s[e];
    return Array.isArray(o) ? o[1] : o;
}
function intOrZero(s) {
    const e = parseInt(s, 10);
    return Number.isNaN(e) ? 0 : e;
}
const $s = new Set([
    "progressive-custom-properties"
]);
function listFeatures(s, e, t, i) {
    const r = Object(e.features), a = "enableClientSidePolyfills" in e && e.enableClientSidePolyfills, c = Object(e.insertBefore), n = Object(e.insertAfter), p = e.browsers ? void 0 : e.env, l = e.browsers, u = clamp(0, intOrZero(e.minimumVendorImplementations), 3);
    u > 0 && i.log(`Using features with ${u} or more vendor implementations.`);
    const m = stageFromOptions(e, i), d = prepareFeaturesList([
        ...s,
        {
            id: "progressive-custom-properties"
        }
    ], c, n).map((s)=>formatPolyfillableFeature(s)).filter((s)=>!!$s.has(s.id) || 0 === u || !(!s[ms] && !s[ds]) || u <= s.vendors_implementations || (!0 === featureEnabledByOptions(r, s.id) ? (i.log(`- '${s.id}' enabled manually even when it lacks the required interop (${s.vendors_implementations} out of ${u}).`), !0) : (i.log(`- '${s.id}' disabled because it lacks the required interop (${s.vendors_implementations} out of ${u}).`), !1))), g = o(l, {
        env: p,
        ignoreUnknownVersions: !0
    }).filter((s)=>xs.includes(s.split(" ")[0]));
    return d.filter((s)=>{
        if ($s.has(s.id)) return !0;
        const e = s.stage >= m, o = a || !us.includes(s.id), t = featureEnabledByOptions(r, s.id), c = !1 === t, n = !0 === t || e && o;
        return c ? i.log(`- '${s.id}' disabled manually`) : e ? o || i.log(`- '${s.id}' disabled because 'enableClientSidePolyfills' is 'false'.`) : n ? i.log(`- '${s.id}' enabled manually even when it lacks the required stage (${s.stage} out of ${m}).`) : i.log(`- '${s.id}' disabled because it lacks the required stage (${s.stage} out of ${m}).`), !c && n;
    }).map((s)=>formatStagedFeature(g, r, s, t, e, i)).filter((s)=>{
        if ($s.has(s.id)) return !0;
        const e = featureEnabledByOptions(r, s.id);
        if (!0 === e || !1 === e) return e;
        const t = o(s.browsers, {
            ignoreUnknownVersions: !0
        }), a = g.filter((s)=>t.some((e)=>e === s));
        return a.length > 0 ? i.log(`- '${s.id}' enabled for:\n    ${a.join("\n    ")}`) : i.log(`- '${s.id}' disabled because all targeted browsers support it.`), a.length > 0;
    });
}
function featureEnabledByOptions(s, e) {
    if (!(e in s)) return "auto";
    const o = s[e];
    return Array.isArray(o) ? !0 === o[0] || !1 !== o[0] && "auto" : Boolean(o);
}
class Logger {
    constructor(){
        this.logs = [];
    }
    log(s) {
        this.logs.push(s);
    }
    resetLogger() {
        this.logs.length = 0;
    }
    emitLogs(s) {
        s && s.warn(this.logs.join("\n")), this.resetLogger();
    }
}
var Os = [
    {
        packageName: "css-blank-pseudo",
        id: "blank-pseudo-class",
        importName: "postcssBlankPseudo"
    },
    {
        packageName: "css-has-pseudo",
        id: "has-pseudo-class",
        importName: "postcssHasPseudo"
    },
    {
        packageName: "css-prefers-color-scheme",
        id: "prefers-color-scheme-query",
        importName: "postcssPrefersColorScheme"
    },
    {
        packageName: "postcss-attribute-case-insensitive",
        id: "case-insensitive-attributes",
        importName: "postcssAttributeCaseInsensitive"
    },
    {
        packageName: "postcss-clamp",
        id: "clamp",
        importName: "postcssClamp"
    },
    {
        packageName: "@csstools/postcss-color-mix-variadic-function-arguments",
        id: "color-mix-variadic-function-arguments",
        importName: "postcssColorMixVariadicFunctionArguments"
    },
    {
        packageName: "@csstools/postcss-color-mix-function",
        id: "color-mix",
        importName: "postcssColorMixFunction"
    },
    {
        packageName: "@csstools/postcss-color-function",
        id: "color-function",
        importName: "postcssColorFunction"
    },
    {
        packageName: "postcss-color-functional-notation",
        id: "color-functional-notation",
        importName: "postcssColorFunctionalNotation"
    },
    {
        packageName: "postcss-color-hex-alpha",
        id: "hexadecimal-alpha-notation",
        importName: "postcssColorHexAlpha"
    },
    {
        packageName: "@csstools/postcss-content-alt-text",
        id: "content-alt-text",
        importName: "postcssContentAltText"
    },
    {
        packageName: "postcss-color-rebeccapurple",
        id: "rebeccapurple-color",
        importName: "postcssColorRebeccapurple"
    },
    {
        packageName: "postcss-custom-media",
        id: "custom-media-queries",
        importName: "postcssCustomMedia"
    },
    {
        packageName: "postcss-custom-properties",
        id: "custom-properties",
        importName: "postcssCustomProperties"
    },
    {
        packageName: "postcss-custom-selectors",
        id: "custom-selectors",
        importName: "postcssCustomSelectors"
    },
    {
        packageName: "postcss-dir-pseudo-class",
        id: "dir-pseudo-class",
        importName: "postcssDirPseudoClass"
    },
    {
        packageName: "postcss-double-position-gradients",
        id: "double-position-gradients",
        importName: "postcssDoublePositionGradients"
    },
    {
        packageName: "@csstools/postcss-exponential-functions",
        id: "exponential-functions",
        importName: "postcssExponentialFunctions"
    },
    {
        packageName: "postcss-focus-visible",
        id: "focus-visible-pseudo-class",
        importName: "postcssFocusVisible"
    },
    {
        packageName: "postcss-focus-within",
        id: "focus-within-pseudo-class",
        importName: "postcssFocusWithin"
    },
    {
        packageName: "@csstools/postcss-font-format-keywords",
        id: "font-format-keywords",
        importName: "postcssFontFormatKeywords"
    },
    {
        packageName: "postcss-font-variant",
        id: "font-variant-property",
        importName: "postcssFontVariant"
    },
    {
        packageName: "@csstools/postcss-gamut-mapping",
        id: "gamut-mapping",
        importName: "postcssGamutMapping"
    },
    {
        packageName: "postcss-gap-properties",
        id: "gap-properties",
        importName: "postcssGapProperties"
    },
    {
        packageName: "@csstools/postcss-gradients-interpolation-method",
        id: "gradients-interpolation-method",
        importName: "postcssGradientsInterpolationMethod"
    },
    {
        packageName: "@csstools/postcss-hwb-function",
        id: "hwb-function",
        importName: "postcssHWBFunction"
    },
    {
        packageName: "@csstools/postcss-ic-unit",
        id: "ic-unit",
        importName: "postcssICUnit"
    },
    {
        packageName: "postcss-image-set-function",
        id: "image-set-function",
        importName: "postcssImageSetFunction"
    },
    {
        packageName: "@csstools/postcss-initial",
        id: "all-property",
        importName: "postcssInitial"
    },
    {
        packageName: "@csstools/postcss-is-pseudo-class",
        id: "is-pseudo-class",
        importName: "postcssIsPseudoClass"
    },
    {
        packageName: "@csstools/postcss-scope-pseudo-class",
        id: "scope-pseudo-class",
        importName: "postcssScopePseudoClass"
    },
    {
        packageName: "postcss-lab-function",
        id: "lab-function",
        importName: "postcssLabFunction"
    },
    {
        packageName: "@csstools/postcss-light-dark-function",
        id: "light-dark-function",
        importName: "postcssLightDarkFunction"
    },
    {
        packageName: "postcss-logical",
        id: "logical-properties-and-values",
        importName: "postcssLogical"
    },
    {
        packageName: "@csstools/postcss-logical-float-and-clear",
        id: "float-clear-logical-values",
        importName: "postcssLogicalFloatAndClear"
    },
    {
        packageName: "@csstools/postcss-logical-overflow",
        id: "logical-overflow",
        importName: "postcssLogicalOverflow"
    },
    {
        packageName: "@csstools/postcss-logical-overscroll-behavior",
        id: "logical-overscroll-behavior",
        importName: "postcssLogicalOverscrollBehavor"
    },
    {
        packageName: "@csstools/postcss-logical-resize",
        id: "logical-resize",
        importName: "postcssLogicalResize"
    },
    {
        packageName: "@csstools/postcss-logical-viewport-units",
        id: "logical-viewport-units",
        importName: "postcssLogicalViewportUnits"
    },
    {
        packageName: "@csstools/postcss-media-minmax",
        id: "media-query-ranges",
        importName: "postcssMediaMinmax"
    },
    {
        packageName: "@csstools/postcss-media-queries-aspect-ratio-number-values",
        id: "media-queries-aspect-ratio-number-values",
        importName: "postcssMediaQueriesAspectRatioNumberValues"
    },
    {
        packageName: "postcss-nesting",
        id: "nesting-rules",
        importName: "postcssNesting"
    },
    {
        packageName: "@csstools/postcss-normalize-display-values",
        id: "display-two-values",
        importName: "postcssNormalizeDisplayValues"
    },
    {
        packageName: "@csstools/postcss-oklab-function",
        id: "oklab-function",
        importName: "postcssOKLabFunction"
    },
    {
        packageName: "@csstools/postcss-relative-color-syntax",
        id: "relative-color-syntax",
        importName: "postcssRelativeColorSyntax"
    },
    {
        packageName: "postcss-opacity-percentage",
        id: "opacity-percentage",
        importName: "postcssOpacityPercentage"
    },
    {
        packageName: "postcss-overflow-shorthand",
        id: "overflow-property",
        importName: "postcssOverflowShorthand"
    },
    {
        packageName: "postcss-page-break",
        id: "break-properties",
        importName: "postcssPageBreak"
    },
    {
        packageName: "postcss-place",
        id: "place-properties",
        importName: "postcssPlace"
    },
    {
        packageName: "postcss-pseudo-class-any-link",
        id: "any-link-pseudo-class",
        importName: "postcssPseudoClassAnyLink"
    },
    {
        packageName: "postcss-replace-overflow-wrap",
        id: "overflow-wrap-property",
        importName: "postcssReplaceOverflowWrap"
    },
    {
        packageName: "postcss-selector-not",
        id: "not-pseudo-class",
        importName: "postcssSelectorNot"
    },
    {
        packageName: "@csstools/postcss-stepped-value-functions",
        id: "stepped-value-functions",
        importName: "postcssSteppedValueFunctions"
    },
    {
        packageName: "postcss-system-ui-font-family",
        importedPackage: "../patch/postcss-system-ui-font-family.mjs",
        id: "system-ui-font-family",
        importName: "postcssFontFamilySystemUI"
    },
    {
        packageName: "@csstools/postcss-unset-value",
        id: "unset-value",
        importName: "postcssUnsetValue"
    },
    {
        packageName: "@csstools/postcss-cascade-layers",
        id: "cascade-layers",
        importName: "postcssCascadeLayers"
    },
    {
        packageName: "@csstools/postcss-trigonometric-functions",
        id: "trigonometric-functions",
        importName: "postcssTrigonometricFunctions"
    },
    {
        packageName: "@csstools/postcss-nested-calc",
        id: "nested-calc",
        importName: "postcssNestedCalc"
    },
    {
        packageName: "@csstools/postcss-text-decoration-shorthand",
        id: "text-decoration-shorthand",
        importName: "postcssTextDecorationShorthand"
    },
    {
        packageName: "@csstools/postcss-sign-functions",
        id: "sign-functions",
        importName: "postcssSignFunctions"
    },
    {
        packageName: "@csstools/postcss-random-function",
        id: "random-function",
        importName: "postcssRandomFunction"
    },
    {
        packageName: "@csstools/postcss-progressive-custom-properties",
        id: "progressive-custom-properties",
        importName: "postcssProgressiveCustomProperties",
        omitTypedOptions: !0,
        omitDocs: !0
    }
];
function getPackageNamesToIds() {
    const s = {};
    return Os.forEach((e)=>{
        s[e.packageName] = e.id;
    }), s;
}
function pluginIdHelp(s, e, o) {
    const t = Os.map((s)=>s.id), i = Os.map((s)=>s.packageName), r = getPackageNamesToIds();
    s.forEach((s)=>{
        if (t.includes(s)) return;
        const a = [
            ...t.map((e)=>[
                    e,
                    levenshteinDistance(s, e)
                ]),
            ...i.map((e)=>[
                    r[e],
                    levenshteinDistance(s, e)
                ])
        ].sort((s, e)=>s[1] - e[1]).filter((s)=>s[1] < 10), c = new Set;
        for(let s = 0; s < a.length && (c.add(a[s][0]), !(c.size >= 3)); s++);
        if (!c.size) return void e.warn(o, `Unknown feature: "${s}", see the list of features https://github.com/csstools/postcss-plugins/blob/main/plugin-packs/postcss-preset-env/FEATURES.md`);
        let n = '"';
        n += Array.from(c).join('", "'), n += '"', e.warn(o, `Unknown feature: "${s}", did you mean one of: ${n}`);
    });
}
function levenshteinDistance(s, e) {
    if (!s.length) return e.length;
    if (!e.length) return s.length;
    const o = [];
    for(let t = 0; t <= e.length; t++){
        o[t] = [
            t
        ];
        for(let i = 1; i <= s.length; i++)o[t][i] = 0 === t ? i : Math.min(o[t - 1][i] + 1, o[t][i - 1] + 1, o[t - 1][i - 1] + (s[i - 1] === e[t - 1] ? 0 : 1));
    }
    return o[e.length][s.length];
}
const creator = (o)=>{
    const t = new Logger, i = Object(o), r = Object.keys(Object(i.features)), a = i.browsers ? void 0 : i.env, c = i.browsers, n = initializeSharedOptions(i), p = listFeatures(e, i, n, t), l = p.map((s)=>s.plugin);
    !1 !== i.autoprefixer && l.push(s(Object.assign({
        env: a,
        overrideBrowserslist: c
    }, i.autoprefixer))), logFeaturesList(p, i, t);
    const internalPlugin = ()=>({
            postcssPlugin: "postcss-preset-env",
            OnceExit (s, { result: e }) {
                pluginIdHelp(r, s, e), i.debug && t.emitLogs(e), t.resetLogger();
            }
        });
    return internalPlugin.postcss = !0, {
        postcssPlugin: "postcss-preset-env",
        plugins: [
            ...l,
            internalPlugin()
        ]
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
class QuickLRU {
    constructor(options = {}){
        if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        if (typeof options.maxAge === 'number' && options.maxAge === 0) {
            throw new TypeError('`maxAge` must be a number greater than 0');
        }
        this.maxSize = options.maxSize;
        this.maxAge = options.maxAge || Infinity;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
    }
    _emitEvictions(cache) {
        if (typeof this.onEviction !== 'function') {
            return;
        }
        for (const [key, item] of cache){
            this.onEviction(key, item.value);
        }
    }
    _deleteIfExpired(key, item) {
        if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
            if (typeof this.onEviction === 'function') {
                this.onEviction(key, item.value);
            }
            return this.delete(key);
        }
        return false;
    }
    _getOrDeleteIfExpired(key, item) {
        const deleted = this._deleteIfExpired(key, item);
        if (deleted === false) {
            return item.value;
        }
    }
    _getItemValue(key, item) {
        return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache) {
        const item = cache.get(key);
        return this._getItemValue(key, item);
    }
    _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    }
    _moveToRecent(key, item) {
        this.oldCache.delete(key);
        this._set(key, item);
    }
    *_entriesAscending() {
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield item;
                }
            }
        }
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield item;
            }
        }
    }
    get(key) {
        if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
        }
        if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
                this._moveToRecent(key, item);
                return item.value;
            }
        }
    }
    set(key, value, { maxAge = this.maxAge === Infinity ? undefined : Date.now() + this.maxAge } = {}) {
        if (this.cache.has(key)) {
            this.cache.set(key, {
                value,
                maxAge
            });
        } else {
            this._set(key, {
                value,
                expiry: maxAge
            });
        }
    }
    has(key) {
        if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
        }
        if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
        }
        return false;
    }
    peek(key) {
        if (this.cache.has(key)) {
            return this._peek(key, this.cache);
        }
        if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
        }
    }
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            this._size--;
        }
        return this.oldCache.delete(key) || deleted;
    }
    clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
    }
    resize(newSize) {
        if (!(newSize && newSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        const items = [
            ...this._entriesAscending()
        ];
        const removeCount = items.length - newSize;
        if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = new Map();
            this._size = items.length;
        } else {
            if (removeCount > 0) {
                this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = new Map();
            this._size = 0;
        }
        this.maxSize = newSize;
    }
    *keys() {
        for (const [key] of this){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesDescending() {
        let items = [
            ...this.cache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        items = [
            ...this.oldCache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesAscending() {
        for (const [key, value] of this._entriesAscending()){
            yield [
                key,
                value.value
            ];
        }
    }
    get size() {
        if (!this._size) {
            return this.oldCache.size;
        }
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()){
            if (!this.cache.has(key)) {
                oldCacheSize++;
            }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
    }
}
module.exports = QuickLRU;
}}),
"[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var constants = __turbopack_context__.r("[externals]/constants [external] (constants, cjs)");
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === 'function') {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}
}}),
"[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    "TURBOPACK unreachable";
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ('number' !== typeof this.end) {
                throw TypeError('end must be a Number');
            }
            if (this.start > this.end) {
                throw new Error('start must be <= end');
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit('error', err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit('open', fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.start < 0) {
                throw new Error('start must be >= zero');
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}
}}),
"[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}
}}),
"[project]/node_modules/graceful-fs/graceful-fs.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var polyfills = __turbopack_context__.r("[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)");
var legacy = __turbopack_context__.r("[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)");
var clone = __turbopack_context__.r("[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
} else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === 'function') cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
            debug(fs[gracefulQueue]);
            __turbopack_context__.r("[externals]/assert [external] (assert, cjs)").equal(fs[gracefulQueue].length, 0);
        });
    }
}
if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$readFile(path, options, cb);
        "TURBOPACK unreachable";
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        "TURBOPACK unreachable";
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        "TURBOPACK unreachable";
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        "TURBOPACK unreachable";
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        "TURBOPACK unreachable";
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === 'function') cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === 'function') cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        "TURBOPACK unreachable";
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now // startTime
            ;
            fs[gracefulQueue][i][4] = now // lastTime
            ;
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}
}}),
"[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deprecateContext = util.deprecate(()=>{}, "Hook.context is deprecated and will be removed");
const CALL_DELEGATE = function(...args) {
    this.call = this._createCall("sync");
    return this.call(...args);
};
const CALL_ASYNC_DELEGATE = function(...args) {
    this.callAsync = this._createCall("async");
    return this.callAsync(...args);
};
const PROMISE_DELEGATE = function(...args) {
    this.promise = this._createCall("promise");
    return this.promise(...args);
};
class Hook {
    constructor(args = [], name = undefined){
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = undefined;
        this.compile = this.compile;
        this.tap = this.tap;
        this.tapAsync = this.tapAsync;
        this.tapPromise = this.tapPromise;
    }
    compile(options) {
        throw new Error("Abstract: should be overridden");
    }
    _createCall(type) {
        return this.compile({
            taps: this.taps,
            interceptors: this.interceptors,
            args: this._args,
            type: type
        });
    }
    _tap(type, options, fn) {
        if (typeof options === "string") {
            options = {
                name: options.trim()
            };
        } else if (typeof options !== "object" || options === null) {
            throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
            throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
            deprecateContext();
        }
        options = Object.assign({
            type,
            fn
        }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    tapAsync(options, fn) {
        this._tap("async", options, fn);
    }
    tapPromise(options, fn) {
        this._tap("promise", options, fn);
    }
    _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors){
            if (interceptor.register) {
                const newOptions = interceptor.register(options);
                if (newOptions !== undefined) {
                    options = newOptions;
                }
            }
        }
        return options;
    }
    withOptions(options) {
        const mergeOptions = (opt)=>Object.assign({}, options, typeof opt === "string" ? {
                name: opt
            } : opt);
        return {
            name: this.name,
            tap: (opt, fn)=>this.tap(mergeOptions(opt), fn),
            tapAsync: (opt, fn)=>this.tapAsync(mergeOptions(opt), fn),
            tapPromise: (opt, fn)=>this.tapPromise(mergeOptions(opt), fn),
            intercept: (interceptor)=>this.intercept(interceptor),
            isUsed: ()=>this.isUsed(),
            withOptions: (opt)=>this.withOptions(mergeOptions(opt))
        };
    }
    isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
            for(let i = 0; i < this.taps.length; i++){
                this.taps[i] = interceptor.register(this.taps[i]);
            }
        }
    }
    _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
    }
    _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
            before = new Set([
                item.before
            ]);
        } else if (Array.isArray(item.before)) {
            before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
            stage = item.stage;
        }
        let i = this.taps.length;
        while(i > 0){
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) {
                    continue;
                }
            }
            if (xStage > stage) {
                continue;
            }
            i++;
            break;
        }
        this.taps[i] = item;
    }
}
Object.setPrototypeOf(Hook.prototype, null);
module.exports = Hook;
}}),
"[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
class HookCodeFactory {
    constructor(config){
        this.config = config;
        this.options = undefined;
        this._args = undefined;
    }
    create(options) {
        this.init(options);
        let fn;
        switch(this.options.type){
            case "sync":
                fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`throw ${err};\n`,
                    onResult: (result)=>`return ${result};\n`,
                    resultReturns: true,
                    onDone: ()=>"",
                    rethrowIfPossible: true
                }));
                break;
            case "async":
                fn = new Function(this.args({
                    after: "_callback"
                }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`_callback(${err});\n`,
                    onResult: (result)=>`_callback(null, ${result});\n`,
                    onDone: ()=>"_callback();\n"
                }));
                break;
            case "promise":
                let errorHelperUsed = false;
                const content = this.contentWithInterceptors({
                    onError: (err)=>{
                        errorHelperUsed = true;
                        return `_error(${err});\n`;
                    },
                    onResult: (result)=>`_resolve(${result});\n`,
                    onDone: ()=>"_resolve();\n"
                });
                let code = "";
                code += '"use strict";\n';
                code += this.header();
                code += "return new Promise((function(_resolve, _reject) {\n";
                if (errorHelperUsed) {
                    code += "var _sync = true;\n";
                    code += "function _error(_err) {\n";
                    code += "if(_sync)\n";
                    code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
                    code += "else\n";
                    code += "_reject(_err);\n";
                    code += "};\n";
                }
                code += content;
                if (errorHelperUsed) {
                    code += "_sync = false;\n";
                }
                code += "}));\n";
                fn = new Function(this.args(), code);
                break;
        }
        this.deinit();
        return fn;
    }
    setup(instance, options) {
        instance._x = options.taps.map((t)=>t.fn);
    }
    /**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */ init(options) {
        this.options = options;
        this._args = options.args.slice();
    }
    deinit() {
        this.options = undefined;
        this._args = undefined;
    }
    contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
            const onError = options.onError;
            const onResult = options.onResult;
            const onDone = options.onDone;
            let code = "";
            for(let i = 0; i < this.options.interceptors.length; i++){
                const interceptor = this.options.interceptors[i];
                if (interceptor.call) {
                    code += `${this.getInterceptor(i)}.call(${this.args({
                        before: interceptor.context ? "_context" : undefined
                    })});\n`;
                }
            }
            code += this.content(Object.assign(options, {
                onError: onError && ((err)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.error) {
                            code += `${this.getInterceptor(i)}.error(${err});\n`;
                        }
                    }
                    code += onError(err);
                    return code;
                }),
                onResult: onResult && ((result)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.result) {
                            code += `${this.getInterceptor(i)}.result(${result});\n`;
                        }
                    }
                    code += onResult(result);
                    return code;
                }),
                onDone: onDone && (()=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.done) {
                            code += `${this.getInterceptor(i)}.done();\n`;
                        }
                    }
                    code += onDone();
                    return code;
                })
            }));
            return code;
        } else {
            return this.content(options);
        }
    }
    header() {
        let code = "";
        if (this.needContext()) {
            code += "var _context = {};\n";
        } else {
            code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
            code += "var _taps = this.taps;\n";
            code += "var _interceptors = this.interceptors;\n";
        }
        return code;
    }
    needContext() {
        for (const tap of this.options.taps)if (tap.context) return true;
        return false;
    }
    callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.tap) {
                if (!hasTapCached) {
                    code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
                    hasTapCached = true;
                }
                code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`;
            }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
        const tap = this.options.taps[tapIndex];
        switch(tap.type){
            case "sync":
                if (!rethrowIfPossible) {
                    code += `var _hasError${tapIndex} = false;\n`;
                    code += "try {\n";
                }
                if (onResult) {
                    code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                } else {
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                }
                if (!rethrowIfPossible) {
                    code += "} catch(_err) {\n";
                    code += `_hasError${tapIndex} = true;\n`;
                    code += onError("_err");
                    code += "}\n";
                    code += `if(!_hasError${tapIndex}) {\n`;
                }
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                if (!rethrowIfPossible) {
                    code += "}\n";
                }
                break;
            case "async":
                let cbCode = "";
                if (onResult) cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\n`;
                else cbCode += `(function(_err${tapIndex}) {\n`;
                cbCode += `if(_err${tapIndex}) {\n`;
                cbCode += onError(`_err${tapIndex}`);
                cbCode += "} else {\n";
                if (onResult) {
                    cbCode += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    cbCode += onDone();
                }
                cbCode += "}\n";
                cbCode += "})";
                code += `_fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined,
                    after: cbCode
                })});\n`;
                break;
            case "promise":
                code += `var _hasResult${tapIndex} = false;\n`;
                code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined
                })});\n`;
                code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
                code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
                code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
                code += `_hasResult${tapIndex} = true;\n`;
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                code += `}), function(_err${tapIndex}) {\n`;
                code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
                code += onError(`_err${tapIndex}`);
                code += "});\n";
                break;
        }
        return code;
    }
    callTapsSeries({ onError, onResult, resultReturns, onDone, doneReturns, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const firstAsync = this.options.taps.findIndex((t)=>t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for(let j = this.options.taps.length - 1; j >= 0; j--){
            const i = j;
            const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
            if (unroll) {
                unrollCounter = 0;
                code += `function _next${i}() {\n`;
                code += current();
                code += `}\n`;
                current = ()=>`${somethingReturns ? "return " : ""}_next${i}();\n`;
            }
            const done = current;
            const doneBreak = (skipDone)=>{
                if (skipDone) return "";
                return onDone();
            };
            const content = this.callTap(i, {
                onError: (error)=>onError(i, error, done, doneBreak),
                onResult: onResult && ((result)=>{
                    return onResult(i, result, done, doneBreak);
                }),
                onDone: !onResult && done,
                rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
            });
            current = ()=>content;
        }
        code += current();
        return code;
    }
    callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const syncOnly = this.options.taps.every((t)=>t.type === "sync");
        let code = "";
        if (!syncOnly) {
            code += "var _looper = (function() {\n";
            code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.loop) {
                code += `${this.getInterceptor(i)}.loop(${this.args({
                    before: interceptor.context ? "_context" : undefined
                })});\n`;
            }
        }
        code += this.callTapsSeries({
            onError,
            onResult: (i, result, next, doneBreak)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += "_loop = true;\n";
                if (!syncOnly) code += "if(_loopAsync) _looper();\n";
                code += doneBreak(true);
                code += `} else {\n`;
                code += next();
                code += `}\n`;
                return code;
            },
            onDone: onDone && (()=>{
                let code = "";
                code += "if(!_loop) {\n";
                code += onDone();
                code += "}\n";
                return code;
            }),
            rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
            code += "_loopAsync = true;\n";
            code += "});\n";
            code += "_looper();\n";
        }
        return code;
    }
    callTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run)=>run() }) {
        if (this.options.taps.length <= 1) {
            return this.callTapsSeries({
                onError,
                onResult,
                onDone,
                rethrowIfPossible
            });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};\n`;
        if (onDone) {
            code += "var _done = (function() {\n";
            code += onDone();
            code += "});\n";
        }
        for(let i = 0; i < this.options.taps.length; i++){
            const done = ()=>{
                if (onDone) return "if(--_counter === 0) _done();\n";
                else return "--_counter;";
            };
            const doneBreak = (skipDone)=>{
                if (skipDone || !onDone) return "_counter = 0;\n";
                else return "_counter = 0;\n_done();\n";
            };
            code += "if(_counter <= 0) break;\n";
            code += onTap(i, ()=>this.callTap(i, {
                    onError: (error)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onError(i, error, done, doneBreak);
                        code += "}\n";
                        return code;
                    },
                    onResult: onResult && ((result)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onResult(i, result, done, doneBreak);
                        code += "}\n";
                        return code;
                    }),
                    onDone: !onResult && (()=>{
                        return done();
                    }),
                    rethrowIfPossible
                }), done, doneBreak);
        }
        code += "} while(false);\n";
        return code;
    }
    args({ before, after } = {}) {
        let allArgs = this._args;
        if (before) allArgs = [
            before
        ].concat(allArgs);
        if (after) allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
            return "";
        } else {
            return allArgs.join(", ");
        }
    }
    getTapFn(idx) {
        return `_x[${idx}]`;
    }
    getTap(idx) {
        return `_taps[${idx}]`;
    }
    getInterceptor(idx) {
        return `_interceptors[${idx}]`;
    }
}
module.exports = HookCodeFactory;
}}),
"[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncHook.prototype = null;
module.exports = SyncHook;
}}),
"[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
            resultReturns,
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncBailHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncBailHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncBailHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncBailHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncBailHook.prototype = null;
module.exports = SyncBailHook;
}}),
"[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0]),
            doneReturns: resultReturns,
            rethrowIfPossible
        });
    }
}
const factory = new SyncWaterfallHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = SyncWaterfallHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncWaterfallHook.prototype = null;
module.exports = SyncWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncLoopHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncLoopHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncLoopHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncLoopHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncLoopHook.prototype = null;
module.exports = SyncLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncParallelHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelHook.prototype = null;
module.exports = AsyncParallelHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});\n`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onResult: (i, result, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onTap: (i, run, done, doneBreak)=>{
                let code = "";
                if (i > 0) {
                    code += `if(${i} >= _results.length) {\n`;
                    code += done();
                    code += "} else {\n";
                }
                code += run();
                if (i > 0) code += "}\n";
                return code;
            },
            onDone
        });
        return code;
    }
}
const factory = new AsyncParallelBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelBailHook.prototype = null;
module.exports = AsyncParallelBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesHook.prototype = null;
module.exports = AsyncSeriesHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)}\n} else {\n${next()}}\n`,
            resultReturns,
            onDone
        });
    }
}
const factory = new AsyncSeriesBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesBailHook.prototype = null;
module.exports = AsyncSeriesBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsLooping({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesLoopHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesLoopHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesLoopHook.prototype = null;
module.exports = AsyncSeriesLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0])
        });
    }
}
const factory = new AsyncSeriesWaterfallHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesWaterfallHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesWaterfallHook.prototype = null;
module.exports = AsyncSeriesWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const defaultFactory = (key, hook)=>hook;
class HookMap {
    constructor(factory, name = undefined){
        this._map = new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
    }
    get(key) {
        return this._map.get(key);
    }
    for(key) {
        const hook = this.get(key);
        if (hook !== undefined) {
            return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for(let i = 0; i < interceptors.length; i++){
            newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
    }
    intercept(interceptor) {
        this._interceptors.push(Object.assign({
            factory: defaultFactory
        }, interceptor));
    }
}
HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
    return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");
HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
    return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");
HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
    return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");
module.exports = HookMap;
}}),
"[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
class MultiHook {
    constructor(hooks, name = undefined){
        this.hooks = hooks;
        this.name = name;
    }
    tap(options, fn) {
        for (const hook of this.hooks){
            hook.tap(options, fn);
        }
    }
    tapAsync(options, fn) {
        for (const hook of this.hooks){
            hook.tapAsync(options, fn);
        }
    }
    tapPromise(options, fn) {
        for (const hook of this.hooks){
            hook.tapPromise(options, fn);
        }
    }
    isUsed() {
        for (const hook of this.hooks){
            if (hook.isUsed()) return true;
        }
        return false;
    }
    intercept(interceptor) {
        for (const hook of this.hooks){
            hook.intercept(interceptor);
        }
    }
    withOptions(options) {
        return new MultiHook(this.hooks.map((h)=>h.withOptions(options)), this.name);
    }
}
module.exports = MultiHook;
}}),
"[project]/node_modules/tapable/lib/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
exports.__esModule = true;
exports.SyncHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)");
exports.SyncBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)");
exports.SyncWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)");
exports.SyncLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)");
exports.AsyncParallelHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)");
exports.AsyncParallelBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)");
exports.AsyncSeriesBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)");
exports.AsyncSeriesWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)");
exports.HookMap = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)");
exports.MultiHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)");
}}),
"[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports) : ("TURBOPACK unreachable", undefined);
})(this, function(exports1) {
    'use strict';
    const comma = ','.charCodeAt(0);
    const semicolon = ';'.charCodeAt(0);
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const intToChar = new Uint8Array(64); // 64 possible chars.
    const charToInt = new Uint8Array(128); // z is 122 in ASCII
    for(let i = 0; i < chars.length; i++){
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
    }
    function decodeInteger(reader, relative) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
            const c = reader.next();
            integer = charToInt[c];
            value |= (integer & 31) << shift;
            shift += 5;
        }while (integer & 32)
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
            value = -0x80000000 | -value;
        }
        return relative + value;
    }
    function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
            let clamped = delta & 0b011111;
            delta >>>= 5;
            if (delta > 0) clamped |= 0b100000;
            builder.write(intToChar[clamped]);
        }while (delta > 0)
        return num;
    }
    function hasMoreVlq(reader, max) {
        if (reader.pos >= max) return false;
        return reader.peek() !== comma;
    }
    const bufLength = 1024 * 16;
    // Provide a fallback for older environments.
    const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */ new TextDecoder() : typeof Buffer !== 'undefined' ? {
        decode (buf) {
            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
            return out.toString();
        }
    } : {
        decode (buf) {
            let out = '';
            for(let i = 0; i < buf.length; i++){
                out += String.fromCharCode(buf[i]);
            }
            return out;
        }
    };
    class StringWriter {
        constructor(){
            this.pos = 0;
            this.out = '';
            this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
            const { buffer } = this;
            buffer[this.pos++] = v;
            if (this.pos === bufLength) {
                this.out += td.decode(buffer);
                this.pos = 0;
            }
        }
        flush() {
            const { buffer, out, pos } = this;
            return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
    }
    class StringReader {
        constructor(buffer){
            this.pos = 0;
            this.buffer = buffer;
        }
        next() {
            return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
            return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
            const { buffer, pos } = this;
            const idx = buffer.indexOf(char, pos);
            return idx === -1 ? buffer.length : idx;
        }
    }
    const EMPTY = [];
    function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for(; reader.pos < length; reader.pos++){
            line = decodeInteger(reader, line);
            const column = decodeInteger(reader, 0);
            if (!hasMoreVlq(reader, length)) {
                const last = stack.pop();
                last[2] = line;
                last[3] = column;
                continue;
            }
            const kind = decodeInteger(reader, 0);
            const fields = decodeInteger(reader, 0);
            const hasName = fields & 0b0001;
            const scope = hasName ? [
                line,
                column,
                0,
                0,
                kind,
                decodeInteger(reader, 0)
            ] : [
                line,
                column,
                0,
                0,
                kind
            ];
            let vars = EMPTY;
            if (hasMoreVlq(reader, length)) {
                vars = [];
                do {
                    const varsIndex = decodeInteger(reader, 0);
                    vars.push(varsIndex);
                }while (hasMoreVlq(reader, length))
            }
            scope.vars = vars;
            scopes.push(scope);
            stack.push(scope);
        }
        return scopes;
    }
    function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for(let i = 0; i < scopes.length;){
            i = _encodeOriginalScopes(scopes, i, writer, [
                0
            ]);
        }
        return writer.flush();
    }
    function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0) writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 0b0001 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6) encodeInteger(writer, scope[5], 0);
        for (const v of vars){
            encodeInteger(writer, v, 0);
        }
        for(index++; index < scopes.length;){
            const next = scopes[index];
            const { 0: l, 1: c } = next;
            if (l > endLine || l === endLine && c >= endColumn) {
                break;
            }
            index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
    }
    function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
            const semi = reader.indexOf(';');
            let genColumn = 0;
            for(; reader.pos < semi; reader.pos++){
                genColumn = decodeInteger(reader, genColumn);
                if (!hasMoreVlq(reader, semi)) {
                    const last = stack.pop();
                    last[2] = genLine;
                    last[3] = genColumn;
                    continue;
                }
                const fields = decodeInteger(reader, 0);
                const hasDefinition = fields & 0b0001;
                const hasCallsite = fields & 0b0010;
                const hasScope = fields & 0b0100;
                let callsite = null;
                let bindings = EMPTY;
                let range;
                if (hasDefinition) {
                    const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
                    definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
                    definitionSourcesIndex = defSourcesIndex;
                    range = [
                        genLine,
                        genColumn,
                        0,
                        0,
                        defSourcesIndex,
                        definitionScopeIndex
                    ];
                } else {
                    range = [
                        genLine,
                        genColumn,
                        0,
                        0
                    ];
                }
                range.isScope = !!hasScope;
                if (hasCallsite) {
                    const prevCsi = callsiteSourcesIndex;
                    const prevLine = callsiteLine;
                    callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
                    const sameSource = prevCsi === callsiteSourcesIndex;
                    callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
                    callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
                    callsite = [
                        callsiteSourcesIndex,
                        callsiteLine,
                        callsiteColumn
                    ];
                }
                range.callsite = callsite;
                if (hasMoreVlq(reader, semi)) {
                    bindings = [];
                    do {
                        bindingLine = genLine;
                        bindingColumn = genColumn;
                        const expressionsCount = decodeInteger(reader, 0);
                        let expressionRanges;
                        if (expressionsCount < -1) {
                            expressionRanges = [
                                [
                                    decodeInteger(reader, 0)
                                ]
                            ];
                            for(let i = -1; i > expressionsCount; i--){
                                const prevBl = bindingLine;
                                bindingLine = decodeInteger(reader, bindingLine);
                                bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                                const expression = decodeInteger(reader, 0);
                                expressionRanges.push([
                                    expression,
                                    bindingLine,
                                    bindingColumn
                                ]);
                            }
                        } else {
                            expressionRanges = [
                                [
                                    expressionsCount
                                ]
                            ];
                        }
                        bindings.push(expressionRanges);
                    }while (hasMoreVlq(reader, semi))
                }
                range.bindings = bindings;
                ranges.push(range);
                stack.push(range);
            }
            genLine++;
            reader.pos = semi + 1;
        }while (reader.pos < length)
        return ranges;
    }
    function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return '';
        const writer = new StringWriter();
        for(let i = 0; i < ranges.length;){
            i = _encodeGeneratedRanges(ranges, i, writer, [
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]);
        }
        return writer.flush();
    }
    function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
        if (state[0] < startLine) {
            catchupLine(writer, state[0], startLine);
            state[0] = startLine;
            state[1] = 0;
        } else if (index > 0) {
            writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
            const { 4: sourcesIndex, 5: scopesIndex } = range;
            if (sourcesIndex !== state[2]) {
                state[3] = 0;
            }
            state[2] = encodeInteger(writer, sourcesIndex, state[2]);
            state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
            const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
            if (sourcesIndex !== state[4]) {
                state[5] = 0;
                state[6] = 0;
            } else if (callLine !== state[5]) {
                state[6] = 0;
            }
            state[4] = encodeInteger(writer, sourcesIndex, state[4]);
            state[5] = encodeInteger(writer, callLine, state[5]);
            state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
            for (const binding of bindings){
                if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
                const expression = binding[0][0];
                encodeInteger(writer, expression, 0);
                let bindingStartLine = startLine;
                let bindingStartColumn = startColumn;
                for(let i = 1; i < binding.length; i++){
                    const expRange = binding[i];
                    bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
                    bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
                    encodeInteger(writer, expRange[0], 0);
                }
            }
        }
        for(index++; index < ranges.length;){
            const next = ranges[index];
            const { 0: l, 1: c } = next;
            if (l > endLine || l === endLine && c >= endColumn) {
                break;
            }
            index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
            catchupLine(writer, state[0], endLine);
            state[0] = endLine;
            state[1] = 0;
        } else {
            writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
    }
    function catchupLine(writer, lastLine, line) {
        do {
            writer.write(semicolon);
        }while (++lastLine < line)
    }
    function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
            const semi = reader.indexOf(';');
            const line = [];
            let sorted = true;
            let lastCol = 0;
            genColumn = 0;
            while(reader.pos < semi){
                let seg;
                genColumn = decodeInteger(reader, genColumn);
                if (genColumn < lastCol) sorted = false;
                lastCol = genColumn;
                if (hasMoreVlq(reader, semi)) {
                    sourcesIndex = decodeInteger(reader, sourcesIndex);
                    sourceLine = decodeInteger(reader, sourceLine);
                    sourceColumn = decodeInteger(reader, sourceColumn);
                    if (hasMoreVlq(reader, semi)) {
                        namesIndex = decodeInteger(reader, namesIndex);
                        seg = [
                            genColumn,
                            sourcesIndex,
                            sourceLine,
                            sourceColumn,
                            namesIndex
                        ];
                    } else {
                        seg = [
                            genColumn,
                            sourcesIndex,
                            sourceLine,
                            sourceColumn
                        ];
                    }
                } else {
                    seg = [
                        genColumn
                    ];
                }
                line.push(seg);
                reader.pos++;
            }
            if (!sorted) sort(line);
            decoded.push(line);
            reader.pos = semi + 1;
        }while (reader.pos <= length)
        return decoded;
    }
    function sort(line) {
        line.sort(sortComparator);
    }
    function sortComparator(a, b) {
        return a[0] - b[0];
    }
    function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for(let i = 0; i < decoded.length; i++){
            const line = decoded[i];
            if (i > 0) writer.write(semicolon);
            if (line.length === 0) continue;
            let genColumn = 0;
            for(let j = 0; j < line.length; j++){
                const segment = line[j];
                if (j > 0) writer.write(comma);
                genColumn = encodeInteger(writer, segment[0], genColumn);
                if (segment.length === 1) continue;
                sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
                sourceLine = encodeInteger(writer, segment[2], sourceLine);
                sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
                if (segment.length === 4) continue;
                namesIndex = encodeInteger(writer, segment[4], namesIndex);
            }
        }
        return writer.flush();
    }
    exports1.decode = decode;
    exports1.decodeGeneratedRanges = decodeGeneratedRanges;
    exports1.decodeOriginalScopes = decodeOriginalScopes;
    exports1.encode = encode;
    exports1.encodeGeneratedRanges = encodeGeneratedRanges;
    exports1.encodeOriginalScopes = encodeOriginalScopes;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=sourcemap-codec.umd.js.map
}}),
"[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : ("TURBOPACK unreachable", undefined);
})(this, function() {
    'use strict';
    // Matches the scheme of a URL, eg "http://"
    const schemeRegex = /^[\w+.-]+:\/\//;
    /**
     * Matches the parts of a URL:
     * 1. Scheme, including ":", guaranteed.
     * 2. User/password, including "@", optional.
     * 3. Host, guaranteed.
     * 4. Port, including ":", optional.
     * 5. Path, including "/", optional.
     * 6. Query, including "?", optional.
     * 7. Hash, including "#", optional.
     */ const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    /**
     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
     *
     * 1. Host, optional.
     * 2. Path, which may include "/", guaranteed.
     * 3. Query, including "?", optional.
     * 4. Hash, including "#", optional.
     */ const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
        return input.startsWith('//');
    }
    function isAbsolutePath(input) {
        return input.startsWith('/');
    }
    function isFileUrl(input) {
        return input.startsWith('file:');
    }
    function isRelative(input) {
        return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
    }
    function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: 7 /* Absolute */ 
        };
    }
    function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
            const url = parseAbsoluteUrl('http:' + input);
            url.scheme = '';
            url.type = 6 /* SchemeRelative */ ;
            return url;
        }
        if (isAbsolutePath(input)) {
            const url = parseAbsoluteUrl('http://foo.com' + input);
            url.scheme = '';
            url.host = '';
            url.type = 5 /* AbsolutePath */ ;
            return url;
        }
        if (isFileUrl(input)) return parseFileUrl(input);
        if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl('http://foo.com/' + input);
        url.scheme = '';
        url.host = '';
        url.type = input ? input.startsWith('?') ? 3 /* Query */  : input.startsWith('#') ? 2 /* Hash */  : 4 /* RelativePath */  : 1 /* Empty */ ;
        return url;
    }
    function stripPathFilename(path) {
        // If a path ends with a parent directory "..", then it's a relative path with excess parent
        // paths. It's not a file, so we can't strip it.
        if (path.endsWith('/..')) return path;
        const index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
        // path).
        if (url.path === '/') {
            url.path = base.path;
        } else {
            // Resolution happens relative to the base path's directory, not the file.
            url.path = stripPathFilename(base.path) + url.path;
        }
    }
    /**
     * The path can have empty directories "//", unneeded parents "foo/..", or current directory
     * "foo/.". We need to normalize to a standard representation.
     */ function normalizePath(url, type) {
        const rel = type <= 4 /* RelativePath */ ;
        const pieces = url.path.split('/');
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        let pointer = 1;
        // Positive is the number of real directories we've output, used for popping a parent directory.
        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
        let positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won't need to append, unless the other conditions happen again.
        let addTrailingSlash = false;
        for(let i = 1; i < pieces.length; i++){
            const piece = pieces[i];
            // An empty directory, could be a trailing slash, or just a double "//" in the path.
            if (!piece) {
                addTrailingSlash = true;
                continue;
            }
            // If we encounter a real directory, then we don't need to append anymore.
            addTrailingSlash = false;
            // A current directory, which we can always drop.
            if (piece === '.') continue;
            // A parent directory, we need to see if there are any real directories we can pop. Else, we
            // have an excess of parents, and we'll need to keep the "..".
            if (piece === '..') {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                } else if (rel) {
                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                    pieces[pointer++] = piece;
                }
                continue;
            }
            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
            // any popped or dropped directories.
            pieces[pointer++] = piece;
            positive++;
        }
        let path = '';
        for(let i = 1; i < pointer; i++){
            path += '/' + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith('/..')) {
            path += '/';
        }
        url.path = path;
    }
    /**
     * Attempts to resolve `input` URL/path relative to `base`.
     */ function resolve(input, base) {
        if (!input && !base) return '';
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7 /* Absolute */ ) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch(inputType){
                case 1 /* Empty */ :
                    url.hash = baseUrl.hash;
                // fall through
                case 2 /* Hash */ :
                    url.query = baseUrl.query;
                // fall through
                case 3 /* Query */ :
                case 4 /* RelativePath */ :
                    mergePaths(url, baseUrl);
                // fall through
                case 5 /* AbsolutePath */ :
                    // The host, user, and port are joined, you can't copy one without the others.
                    url.user = baseUrl.user;
                    url.host = baseUrl.host;
                    url.port = baseUrl.port;
                // fall through
                case 6 /* SchemeRelative */ :
                    // The input doesn't have a schema at least, so we need to copy at least that over.
                    url.scheme = baseUrl.scheme;
            }
            if (baseType > inputType) inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch(inputType){
            // This is impossible, because of the empty checks at the start of the function.
            // case UrlType.Empty:
            case 2 /* Hash */ :
            case 3 /* Query */ :
                return queryHash;
            case 4 /* RelativePath */ :
                {
                    // The first char is always a "/", and we need it to be relative.
                    const path = url.path.slice(1);
                    if (!path) return queryHash || '.';
                    if (isRelative(base || input) && !isRelative(path)) {
                        // If base started with a leading ".", or there is no base and input started with a ".",
                        // then we need to ensure that the relative path starts with a ".". We don't know if
                        // relative starts with a "..", though, so check before prepending.
                        return './' + path + queryHash;
                    }
                    return path + queryHash;
                }
            case 5 /* AbsolutePath */ :
                return url.path + queryHash;
            default:
                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
        }
    }
    return resolve;
}); //# sourceMappingURL=resolve-uri.umd.js.map
}}),
"[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports, __turbopack_context__.r("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js [postcss] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js [postcss] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
})(this, function(exports1, sourcemapCodec, resolveUri) {
    'use strict';
    function resolve(input, base) {
        // The base is always treated as a directory, if it's not empty.
        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
        if (base && !base.endsWith('/')) base += '/';
        return resolveUri(input, base);
    }
    /**
     * Removes everything after the last "/", but leaves the slash.
     */ function stripFilename(path) {
        if (!path) return '';
        const index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
    }
    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;
    const REV_GENERATED_LINE = 1;
    const REV_GENERATED_COLUMN = 2;
    function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
        // not, we do not want to modify the consumer's input array.
        if (!owned) mappings = mappings.slice();
        for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)){
            mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start) {
        for(let i = start; i < mappings.length; i++){
            if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
    }
    function isSorted(line) {
        for(let j = 1; j < line.length; j++){
            if (line[j][COLUMN] < line[j - 1][COLUMN]) {
                return false;
            }
        }
        return true;
    }
    function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
    }
    function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
    }
    let found = false;
    /**
     * A binary search implementation that returns the index if a match is found.
     * If no match is found, then the left-index (the index associated with the item that comes just
     * before the desired index) is returned. To maintain proper sort order, a splice would happen at
     * the next index:
     *
     * ```js
     * const array = [1, 3];
     * const needle = 2;
     * const index = binarySearch(array, needle, (item, needle) => item - needle);
     *
     * assert.equal(index, 0);
     * array.splice(index + 1, 0, needle);
     * assert.deepEqual(array, [1, 2, 3]);
     * ```
     */ function binarySearch(haystack, needle, low, high) {
        while(low <= high){
            const mid = low + (high - low >> 1);
            const cmp = haystack[mid][COLUMN] - needle;
            if (cmp === 0) {
                found = true;
                return mid;
            }
            if (cmp < 0) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        found = false;
        return low - 1;
    }
    function upperBound(haystack, needle, index) {
        for(let i = index + 1; i < haystack.length; index = i++){
            if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
    }
    function lowerBound(haystack, needle, index) {
        for(let i = index - 1; i >= 0; index = i--){
            if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
    }
    function memoizedState() {
        return {
            lastKey: -1,
            lastNeedle: -1,
            lastIndex: -1
        };
    }
    /**
     * This overly complicated beast is just to record the last tested line/column and the resulting
     * index, allowing us to skip a few tests if mappings are monotonically increasing.
     */ function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
            if (needle === lastNeedle) {
                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
                return lastIndex;
            }
            if (needle >= lastNeedle) {
                // lastIndex may be -1 if the previous needle was not found.
                low = lastIndex === -1 ? 0 : lastIndex;
            } else {
                high = lastIndex;
            }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    // Rebuilds the original source files, with mappings that are ordered by source line/column instead
    // of generated line/column.
    function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for(let i = 0; i < decoded.length; i++){
            const line = decoded[i];
            for(let j = 0; j < line.length; j++){
                const seg = line[j];
                if (seg.length === 1) continue;
                const sourceIndex = seg[SOURCES_INDEX];
                const sourceLine = seg[SOURCE_LINE];
                const sourceColumn = seg[SOURCE_COLUMN];
                const originalSource = sources[sourceIndex];
                const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
                const memo = memos[sourceIndex];
                // The binary search either found a match, or it found the left-index just before where the
                // segment should go. Either way, we want to insert after that. And there may be multiple
                // generated segments associated with an original location, so there may need to move several
                // indexes before we find where we need to insert.
                let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
                memo.lastIndex = ++index;
                insert(originalLine, index, [
                    sourceColumn,
                    i,
                    seg[COLUMN]
                ]);
            }
        }
        return sources;
    }
    function insert(array, index, value) {
        for(let i = array.length; i > index; i--){
            array[i] = array[i - 1];
        }
        array[index] = value;
    }
    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of
    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
    // order when iterating with for-in.
    function buildNullArray() {
        return {
            __proto__: null
        };
    }
    const AnyMap = function(map, mapUrl) {
        const parsed = parse(map);
        if (!('sections' in parsed)) {
            return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
            version: 3,
            file: parsed.file,
            names,
            sources,
            sourcesContent,
            mappings,
            ignoreList
        };
        return presortedDecodedMap(joined);
    };
    function parse(map) {
        return typeof map === 'string' ? JSON.parse(map) : map;
    }
    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for(let i = 0; i < sections.length; i++){
            const { map, offset } = sections[i];
            let sl = stopLine;
            let sc = stopColumn;
            if (i + 1 < sections.length) {
                const nextOffset = sections[i + 1].offset;
                sl = Math.min(stopLine, lineOffset + nextOffset.line);
                if (sl === stopLine) {
                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);
                } else if (sl < stopLine) {
                    sc = columnOffset + nextOffset.column;
                }
            }
            addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
    }
    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse(input);
        if ('sections' in parsed) return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents) append(sourcesContent, contents);
        else for(let i = 0; i < resolvedSources.length; i++)sourcesContent.push(null);
        if (ignores) for(let i = 0; i < ignores.length; i++)ignoreList.push(ignores[i] + sourcesOffset);
        for(let i = 0; i < decoded.length; i++){
            const lineI = lineOffset + i;
            // We can only add so many lines before we step into the range that the next section's map
            // controls. When we get to the last line, then we'll start checking the segments to see if
            // they've crossed into the column range. But it may not have any columns that overstep, so we
            // still need to check that we don't overstep lines, too.
            if (lineI > stopLine) return;
            // The out line may already exist in mappings (if we're continuing the line started by a
            // previous section). Or, we may have jumped ahead several lines to start this section.
            const out = getLine(mappings, lineI);
            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
            // map can be multiple lines), it doesn't.
            const cOffset = i === 0 ? columnOffset : 0;
            const line = decoded[i];
            for(let j = 0; j < line.length; j++){
                const seg = line[j];
                const column = cOffset + seg[COLUMN];
                // If this segment steps into the column range that the next section's map controls, we need
                // to stop early.
                if (lineI === stopLine && column >= stopColumn) return;
                if (seg.length === 1) {
                    out.push([
                        column
                    ]);
                    continue;
                }
                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
                const sourceLine = seg[SOURCE_LINE];
                const sourceColumn = seg[SOURCE_COLUMN];
                out.push(seg.length === 4 ? [
                    column,
                    sourcesIndex,
                    sourceLine,
                    sourceColumn
                ] : [
                    column,
                    sourcesIndex,
                    sourceLine,
                    sourceColumn,
                    namesOffset + seg[NAMES_INDEX]
                ]);
            }
        }
    }
    function append(arr, other) {
        for(let i = 0; i < other.length; i++)arr.push(other[i]);
    }
    function getLine(arr, index) {
        for(let i = arr.length; i <= index; i++)arr[i] = [];
        return arr[index];
    }
    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
    const LEAST_UPPER_BOUND = -1;
    const GREATEST_LOWER_BOUND = 1;
    class TraceMap {
        constructor(map, mapUrl){
            const isString = typeof map === 'string';
            if (!isString && map._decodedMemo) return map;
            const parsed = isString ? JSON.parse(map) : map;
            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
            this.version = version;
            this.file = file;
            this.names = names || [];
            this.sourceRoot = sourceRoot;
            this.sources = sources;
            this.sourcesContent = sourcesContent;
            this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
            const from = resolve(sourceRoot || '', stripFilename(mapUrl));
            this.resolvedSources = sources.map((s)=>resolve(s || '', from));
            const { mappings } = parsed;
            if (typeof mappings === 'string') {
                this._encoded = mappings;
                this._decoded = undefined;
            } else {
                this._encoded = undefined;
                this._decoded = maybeSort(mappings, isString);
            }
            this._decodedMemo = memoizedState();
            this._bySources = undefined;
            this._bySourceMemos = undefined;
        }
    }
    /**
     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
     * with public access modifiers.
     */ function cast(map) {
        return map;
    }
    /**
     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
     */ function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
    }
    /**
     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
     */ function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
    }
    /**
     * A low-level API to find the segment associated with a generated line/column (think, from a
     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
     */ function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        // It's common for parent source maps to have pointers to lines that have no
        // mapping (like a "//# sourceMappingURL=") at the end of the child file.
        if (line >= decoded.length) return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
    }
    /**
     * A higher-level API to find the source/line/column associated with a generated line/column
     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
     * `source-map` library.
     */ function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        // It's common for parent source maps to have pointers to lines that have no
        // mapping (like a "//# sourceMappingURL=") at the end of the child file.
        if (line >= decoded.length) return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1) return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
    }
    /**
     * Finds the generated line/column position of the provided source/line/column source position.
     */ function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
    }
    /**
     * Finds all generated line/column positions of the provided source/line/column source position.
     */ function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
    }
    /**
     * Iterates each mapping in generated position order.
     */ function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for(let i = 0; i < decoded.length; i++){
            const line = decoded[i];
            for(let j = 0; j < line.length; j++){
                const seg = line[j];
                const generatedLine = i + 1;
                const generatedColumn = seg[0];
                let source = null;
                let originalLine = null;
                let originalColumn = null;
                let name = null;
                if (seg.length !== 1) {
                    source = resolvedSources[seg[1]];
                    originalLine = seg[2] + 1;
                    originalColumn = seg[3];
                }
                if (seg.length === 5) name = names[seg[4]];
                cb({
                    generatedLine,
                    generatedColumn,
                    source,
                    originalLine,
                    originalColumn,
                    name
                });
            }
        }
    }
    function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1) index = resolvedSources.indexOf(source);
        return index;
    }
    /**
     * Retrieves the source content for a particular source, if its found. Returns null if not.
     */ function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null) return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
    }
    /**
     * Determines if the source is marked to ignore by the source map.
     */ function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null) return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
    }
    /**
     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
     * maps.
     */ function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
    }
    /**
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */ function decodedMap(map) {
        return clone(map, decodedMappings(map));
    }
    /**
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */ function encodedMap(map) {
        return clone(map, encodedMappings(map));
    }
    function clone(map, mappings) {
        return {
            version: map.version,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings,
            ignoreList: map.ignoreList || map.x_google_ignoreList
        };
    }
    function OMapping(source, line, column, name) {
        return {
            source,
            line,
            column,
            name
        };
    }
    function GMapping(line, column) {
        return {
            line,
            column
        };
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
    }
    function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in
        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would
        // still need to call `lowerBound()` to find the first segment, which is slower than just looking
        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the
        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to
        // match LEAST_UPPER_BOUND.
        if (!found && bias === LEAST_UPPER_BOUND) min++;
        if (min === -1 || min === segments.length) return [];
        // We may have found the segment that started at an earlier column. If this is the case, then we
        // need to slice all generated segments that match _that_ column, because all such segments span
        // to our desired column.
        const matchedColumn = found ? column : segments[min][COLUMN];
        // The binary search is not guaranteed to find the lower bound when a match wasn't found.
        if (!found) min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for(; min <= max; min++){
            const segment = segments[min];
            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
    }
    function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1) return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
    }
    exports1.AnyMap = AnyMap;
    exports1.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
    exports1.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
    exports1.TraceMap = TraceMap;
    exports1.allGeneratedPositionsFor = allGeneratedPositionsFor;
    exports1.decodedMap = decodedMap;
    exports1.decodedMappings = decodedMappings;
    exports1.eachMapping = eachMapping;
    exports1.encodedMap = encodedMap;
    exports1.encodedMappings = encodedMappings;
    exports1.generatedPositionFor = generatedPositionFor;
    exports1.isIgnored = isIgnored;
    exports1.originalPositionFor = originalPositionFor;
    exports1.presortedDecodedMap = presortedDecodedMap;
    exports1.sourceContentFor = sourceContentFor;
    exports1.traceSegment = traceSegment;
}); //# sourceMappingURL=trace-mapping.umd.js.map
}}),
"[project]/node_modules/@jridgewell/set-array/dist/set-array.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports) : ("TURBOPACK unreachable", undefined);
})(this, function(exports1) {
    'use strict';
    /**
     * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
     * index of the `key` in the backing array.
     *
     * This is designed to allow synchronizing a second array with the contents of the backing array,
     * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
     * and there are never duplicates.
     */ class SetArray {
        constructor(){
            this._indexes = {
                __proto__: null
            };
            this.array = [];
        }
    }
    /**
     * Typescript doesn't allow friend access to private fields, so this just casts the set into a type
     * with public access modifiers.
     */ function cast(set) {
        return set;
    }
    /**
     * Gets the index associated with `key` in the backing array, if it is already present.
     */ function get(setarr, key) {
        return cast(setarr)._indexes[key];
    }
    /**
     * Puts `key` into the backing array, if it is not already present. Returns
     * the index of the `key` in the backing array.
     */ function put(setarr, key) {
        // The key may or may not be present. If it is present, it's a number.
        const index = get(setarr, key);
        if (index !== undefined) return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key);
        return indexes[key] = length - 1;
    }
    /**
     * Pops the last added item out of the SetArray.
     */ function pop(setarr) {
        const { array, _indexes: indexes } = cast(setarr);
        if (array.length === 0) return;
        const last = array.pop();
        indexes[last] = undefined;
    }
    /**
     * Removes the key, if it exists in the set.
     */ function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === undefined) return;
        const { array, _indexes: indexes } = cast(setarr);
        for(let i = index + 1; i < array.length; i++){
            const k = array[i];
            array[i - 1] = k;
            indexes[k]--;
        }
        indexes[key] = undefined;
        array.pop();
    }
    exports1.SetArray = SetArray;
    exports1.get = get;
    exports1.pop = pop;
    exports1.put = put;
    exports1.remove = remove;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=set-array.umd.js.map
}}),
"[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports, __turbopack_context__.r("[project]/node_modules/@jridgewell/set-array/dist/set-array.umd.js [postcss] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js [postcss] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js [postcss] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
})(this, function(exports1, setArray, sourcemapCodec, traceMapping) {
    'use strict';
    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;
    const NO_NAME = -1;
    /**
     * Provides the state to generate a sourcemap.
     */ class GenMapping {
        constructor({ file, sourceRoot } = {}){
            this._names = new setArray.SetArray();
            this._sources = new setArray.SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
            this._ignoreList = new setArray.SetArray();
        }
    }
    /**
     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
     * with public access modifiers.
     */ function cast(map) {
        return map;
    }
    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    }
    function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
    }
    /**
     * Same as `addSegment`, but will only add the segment if it generates useful information in the
     * resulting map. This only works correctly if segments are added **in order**, meaning you should
     * not add a segment with a lower generated line/column than one that came before.
     */ const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    /**
     * Same as `addMapping`, but will only add the mapping if it generates useful information in the
     * resulting map. This only works correctly if mappings are added **in order**, meaning you should
     * not add a mapping with a lower generated line/column than one that came before.
     */ const maybeAddMapping = (map, mapping)=>{
        return addMappingInternal(true, map, mapping);
    };
    /**
     * Adds/removes the content of the source file to the source map.
     */ function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source);
        sourcesContent[index] = content;
    }
    function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source);
        if (index === sourcesContent.length) sourcesContent[index] = null;
        if (ignore) setArray.put(ignoreList, index);
        else setArray.remove(ignoreList, index);
    }
    /**
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */ function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
            version: 3,
            file: map.file || undefined,
            names: names.array,
            sourceRoot: map.sourceRoot || undefined,
            sources: sources.array,
            sourcesContent,
            mappings,
            ignoreList: ignoreList.array
        };
    }
    /**
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */ function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), {
            mappings: sourcemapCodec.encode(decoded.mappings)
        });
    }
    /**
     * Constructs a new GenMapping, using the already present mappings of the input.
     */ function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({
            file: map.file,
            sourceRoot: map.sourceRoot
        });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(()=>null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
    }
    /**
     * Returns an array of high-level mapping objects for every recorded segment, which could then be
     * passed to the `source-map` library.
     */ function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for(let i = 0; i < mappings.length; i++){
            const line = mappings[i];
            for(let j = 0; j < line.length; j++){
                const seg = line[j];
                const generated = {
                    line: i + 1,
                    column: seg[COLUMN]
                };
                let source = undefined;
                let original = undefined;
                let name = undefined;
                if (seg.length !== 1) {
                    source = sources.array[seg[SOURCES_INDEX]];
                    original = {
                        line: seg[SOURCE_LINE] + 1,
                        column: seg[SOURCE_COLUMN]
                    };
                    if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
                }
                out.push({
                    generated,
                    source,
                    original,
                    name
                });
            }
        }
        return out;
    }
    // This split declaration is only so that terser can elminiate the static initialization block.
    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
            if (skipable && skipSourceless(line, index)) return;
            return insert(line, index, [
                genColumn
            ]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
        }
        return insert(line, index, name ? [
            genColumn,
            sourcesIndex,
            sourceLine,
            sourceColumn,
            namesIndex
        ] : [
            genColumn,
            sourcesIndex,
            sourceLine,
            sourceColumn
        ]);
    }
    function getLine(mappings, index) {
        for(let i = mappings.length; i <= index; i++){
            mappings[i] = [];
        }
        return mappings[index];
    }
    function getColumnIndex(line, genColumn) {
        let index = line.length;
        for(let i = index - 1; i >= 0; index = i--){
            const current = line[i];
            if (genColumn >= current[COLUMN]) break;
        }
        return index;
    }
    function insert(array, index, value) {
        for(let i = array.length; i > index; i--){
            array[i] = array[i - 1];
        }
        array[index] = value;
    }
    function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for(let i = len - 1; i >= 0; len = i, i--){
            if (mappings[i].length > 0) break;
        }
        if (len < length) mappings.length = len;
    }
    function putAll(setarr, array) {
        for(let i = 0; i < array.length; i++)setArray.put(setarr, array[i]);
    }
    function skipSourceless(line, index) {
        // The start of a line is already sourceless, so adding a sourceless segment to the beginning
        // doesn't generate any useful information.
        if (index === 0) return true;
        const prev = line[index - 1];
        // If the previous segment is also sourceless, then adding another sourceless segment doesn't
        // genrate any new information. Else, this segment will end the source/named segment and point to
        // a sourceless position, which is useful.
        return prev.length === 1;
    }
    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        // A source/named segment at the start of a line gives position at that genColumn
        if (index === 0) return false;
        const prev = line[index - 1];
        // If the previous segment is sourceless, then we're transitioning to a source.
        if (prev.length === 1) return false;
        // If the previous segment maps to the exact same source position, then this segment doesn't
        // provide any new position information.
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
    }
    function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
    }
    exports1.GenMapping = GenMapping;
    exports1.addMapping = addMapping;
    exports1.addSegment = addSegment;
    exports1.allMappings = allMappings;
    exports1.fromMap = fromMap;
    exports1.maybeAddMapping = maybeAddMapping;
    exports1.maybeAddSegment = maybeAddSegment;
    exports1.setIgnore = setIgnore;
    exports1.setSourceContent = setSourceContent;
    exports1.toDecodedMap = toDecodedMap;
    exports1.toEncodedMap = toEncodedMap;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=gen-mapping.umd.js.map
}}),
"[project]/node_modules/@ampproject/remapping/dist/remapping.umd.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory(__turbopack_context__.r("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js [postcss] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js [postcss] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
})(this, function(traceMapping, genMapping) {
    'use strict';
    const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null, false);
    const EMPTY_SOURCES = [];
    function SegmentObject(source, line, column, name, content, ignore) {
        return {
            source,
            line,
            column,
            name,
            content,
            ignore
        };
    }
    function Source(map, sources, source, content, ignore) {
        return {
            map,
            sources,
            source,
            content,
            ignore
        };
    }
    /**
     * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
     * (which may themselves be SourceMapTrees).
     */ function MapSource(map, sources) {
        return Source(map, sources, '', null, false);
    }
    /**
     * A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
     * segment tracing ends at the `OriginalSource`.
     */ function OriginalSource(source, content, ignore) {
        return Source(null, EMPTY_SOURCES, source, content, ignore);
    }
    /**
     * traceMappings is only called on the root level SourceMapTree, and begins the process of
     * resolving each mapping in terms of the original source files.
     */ function traceMappings(tree) {
        // TODO: Eventually support sourceRoot, which has to be removed because the sources are already
        // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.
        const gen = new genMapping.GenMapping({
            file: tree.map.file
        });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for(let i = 0; i < rootMappings.length; i++){
            const segments = rootMappings[i];
            for(let j = 0; j < segments.length; j++){
                const segment = segments[j];
                const genCol = segment[0];
                let traced = SOURCELESS_MAPPING;
                // 1-length segments only move the current generated column, there's no source information
                // to gather from it.
                if (segment.length !== 1) {
                    const source = rootSources[segment[1]];
                    traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');
                    // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a
                    // respective segment into an original source.
                    if (traced == null) continue;
                }
                const { column, line, name, content, source, ignore } = traced;
                genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name);
                if (source && content != null) genMapping.setSourceContent(gen, source, content);
                if (ignore) genMapping.setIgnore(gen, source, true);
            }
        }
        return gen;
    }
    /**
     * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
     * child SourceMapTrees, until we find the original source map.
     */ function originalPositionFor(source, line, column, name) {
        if (!source.map) {
            return SegmentObject(source.source, line, column, name, source.content, source.ignore);
        }
        const segment = traceMapping.traceSegment(source.map, line, column);
        // If we couldn't find a segment, then this doesn't exist in the sourcemap.
        if (segment == null) return null;
        // 1-length segments only move the current generated column, there's no source information
        // to gather from it.
        if (segment.length === 1) return SOURCELESS_MAPPING;
        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
    }
    function asArray(value) {
        if (Array.isArray(value)) return value;
        return [
            value
        ];
    }
    /**
     * Recursively builds a tree structure out of sourcemap files, with each node
     * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
     * `OriginalSource`s and `SourceMapTree`s.
     *
     * Every sourcemap is composed of a collection of source files and mappings
     * into locations of those source files. When we generate a `SourceMapTree` for
     * the sourcemap, we attempt to load each source file's own sourcemap. If it
     * does not have an associated sourcemap, it is considered an original,
     * unmodified source file.
     */ function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m)=>new traceMapping.TraceMap(m, ''));
        const map = maps.pop();
        for(let i = 0; i < maps.length; i++){
            if (maps[i].sources.length > 1) {
                throw new Error(`Transformation map ${i} must have exactly one source file.\n` + 'Did you specify these with the most recent transformation maps first?');
            }
        }
        let tree = build(map, loader, '', 0);
        for(let i = maps.length - 1; i >= 0; i--){
            tree = MapSource(maps[i], [
                tree
            ]);
        }
        return tree;
    }
    function build(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent, ignoreList } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i)=>{
            // The loading context gives the loader more information about why this file is being loaded
            // (eg, from which importer). It also allows the loader to override the location of the loaded
            // sourcemap/original source, or to override the content in the sourcesContent field if it's
            // an unmodified source file.
            const ctx = {
                importer,
                depth,
                source: sourceFile || '',
                content: undefined,
                ignore: undefined
            };
            // Use the provided loader callback to retrieve the file's sourcemap.
            // TODO: We should eventually support async loading of sourcemap files.
            const sourceMap = loader(ctx.source, ctx);
            const { source, content, ignore } = ctx;
            // If there is a sourcemap, then we need to recurse into it to load its source files.
            if (sourceMap) return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);
            // Else, it's an unmodified source file.
            // The contents of this unmodified source file can be overridden via the loader context,
            // allowing it to be explicitly null or a string. If it remains undefined, we fall back to
            // the importing sourcemap's `sourcesContent` field.
            const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;
            const ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : false;
            return OriginalSource(source, sourceContent, ignored);
        });
        return MapSource(map, children);
    }
    /**
     * A SourceMap v3 compatible sourcemap, which only includes fields that were
     * provided to it.
     */ class SourceMap {
        constructor(map, options){
            const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
            this.version = out.version; // SourceMap spec says this should be first.
            this.file = out.file;
            this.mappings = out.mappings;
            this.names = out.names;
            this.ignoreList = out.ignoreList;
            this.sourceRoot = out.sourceRoot;
            this.sources = out.sources;
            if (!options.excludeContent) {
                this.sourcesContent = out.sourcesContent;
            }
        }
        toString() {
            return JSON.stringify(this);
        }
    }
    /**
     * Traces through all the mappings in the root sourcemap, through the sources
     * (and their sourcemaps), all the way back to the original source location.
     *
     * `loader` will be called every time we encounter a source file. If it returns
     * a sourcemap, we will recurse into that sourcemap to continue the trace. If
     * it returns a falsey value, that source file is treated as an original,
     * unmodified source file.
     *
     * Pass `excludeContent` to exclude any self-containing source file content
     * from the output sourcemap.
     *
     * Pass `decodedMappings` to receive a SourceMap with decoded (instead of
     * VLQ encoded) mappings.
     */ function remapping(input, loader, options) {
        const opts = typeof options === 'object' ? options : {
            excludeContent: !!options,
            decodedMappings: false
        };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap(traceMappings(tree), opts);
    }
    return remapping;
}); //# sourceMappingURL=remapping.umd.js.map
}}),
"[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const BROWSER_MAPPING = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    and_qq: null,
    and_uc: null,
    baidu: null,
    bb: null,
    kaios: null,
    op_mini: null
};
function browserslistToTargets(browserslist) {
    let targets = {};
    for (let browser of browserslist){
        let [name, v] = browser.split(' ');
        if (BROWSER_MAPPING[name] === null) {
            continue;
        }
        let version = parseVersion(v);
        if (version == null) {
            continue;
        }
        if (targets[name] == null || version < targets[name]) {
            targets[name] = version;
        }
    }
    return targets;
}
function parseVersion(version) {
    let [major, minor = 0, patch = 0] = version.split('-')[0].split('.').map((v)=>parseInt(v, 10));
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
    }
    return major << 16 | minor << 8 | patch;
}
module.exports = browserslistToTargets;
}}),
"[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-check
/** @typedef {import('./index').Visitor} Visitor */ /**
 * Composes multiple visitor objects into a single one.
 * @param {Visitor[]} visitors 
 * @return {Visitor}
 */ function composeVisitors(visitors) {
    if (visitors.length === 1) {
        return visitors[0];
    }
    /** @type Visitor */ let res = {};
    composeSimpleVisitors(res, visitors, 'StyleSheet');
    composeSimpleVisitors(res, visitors, 'StyleSheetExit');
    composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);
    composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);
    composeSimpleVisitors(res, visitors, 'Url');
    composeSimpleVisitors(res, visitors, 'Color');
    composeSimpleVisitors(res, visitors, 'Image');
    composeSimpleVisitors(res, visitors, 'ImageExit');
    composeSimpleVisitors(res, visitors, 'Length');
    composeSimpleVisitors(res, visitors, 'Angle');
    composeSimpleVisitors(res, visitors, 'Ratio');
    composeSimpleVisitors(res, visitors, 'Resolution');
    composeSimpleVisitors(res, visitors, 'Time');
    composeSimpleVisitors(res, visitors, 'CustomIdent');
    composeSimpleVisitors(res, visitors, 'DashedIdent');
    composeArrayFunctions(res, visitors, 'MediaQuery');
    composeArrayFunctions(res, visitors, 'MediaQueryExit');
    composeSimpleVisitors(res, visitors, 'SupportsCondition');
    composeSimpleVisitors(res, visitors, 'SupportsConditionExit');
    composeArrayFunctions(res, visitors, 'Selector');
    composeTokenVisitors(res, visitors, 'Token', 'token', false);
    composeTokenVisitors(res, visitors, 'Function', 'function', false);
    composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);
    composeTokenVisitors(res, visitors, 'Variable', 'var', false);
    composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);
    composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);
    composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);
    return res;
}
module.exports = composeVisitors;
function wrapCustomAndUnknownAtRule(k, f) {
    if (k === 'unknown') {
        return (value)=>f({
                type: 'unknown',
                value
            });
    }
    if (k === 'custom') {
        return (value)=>f({
                type: 'custom',
                value
            });
    }
    return f;
}
function wrapCustomProperty(k, f) {
    return k === 'custom' ? (value)=>f({
            property: 'custom',
            value
        }) : f;
}
/**
 * @param {import('./index').Visitor['Rule']} f 
 * @param {import('./ast').Rule} item 
 */ function ruleVisitor(f, item) {
    if (typeof f === 'object') {
        if (item.type === 'unknown') {
            let v = f.unknown;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        if (item.type === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[item.type]?.(item);
    }
    return f?.(item);
}
/**
 * @param {import('./index').Visitor['Declaration']} f 
 * @param {import('./ast').Declaration} item 
 */ function declarationVisitor(f, item) {
    if (typeof f === 'object') {
        /** @type {string} */ let name = item.property;
        if (item.property === 'unparsed') {
            name = item.value.propertyId.property;
        } else if (item.property === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[name]?.(item);
    }
    return f?.(item);
}
/**
 * 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @returns {[any[], boolean, Set<string>]}
 */ function extractObjectsOrFunctions(visitors, key) {
    let values = [];
    let hasFunction = false;
    let allKeys = new Set();
    for (let visitor of visitors){
        let v = visitor[key];
        if (v) {
            if (typeof v === 'function') {
                hasFunction = true;
            } else {
                for(let key in v){
                    allKeys.add(key);
                }
            }
            values.push(v);
        }
    }
    return [
        values,
        hasFunction,
        allKeys
    ];
}
/**
 * @template {keyof Visitor} K
 * @param {Visitor} res
 * @param {Visitor[]} visitors
 * @param {K} key
 * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply 
 * @param {(k: string, f: any) => any} wrapKey 
 */ function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createArrayVisitor(visitors, (visitor, item)=>apply(visitor[key], item));
    if (hasFunction) {
        res[key] = f;
    } else {
        /** @type {any} */ let v = {};
        for (let k of allKeys){
            v[k] = wrapKey(k, f);
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @param {import('./ast').TokenOrValue['type']} type 
 * @param {boolean} isExit 
 */ function composeTokenVisitors(res, visitors, key, type, isExit) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createTokenVisitor(visitors, type, isExit);
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let key of allKeys){
            v[key] = f;
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor[]} visitors 
 * @param {import('./ast').TokenOrValue['type']} type 
 */ function createTokenVisitor(visitors, type, isExit) {
    let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */ item)=>{
        let f;
        switch(item.type){
            case 'token':
                f = visitor.Token;
                if (typeof f === 'object') {
                    f = f[item.value.type];
                }
                break;
            case 'function':
                f = isExit ? visitor.FunctionExit : visitor.Function;
                if (typeof f === 'object') {
                    f = f[item.value.name];
                }
                break;
            case 'var':
                f = isExit ? visitor.VariableExit : visitor.Variable;
                break;
            case 'env':
                f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
                if (typeof f === 'object') {
                    let name;
                    switch(item.value.name.type){
                        case 'ua':
                        case 'unknown':
                            name = item.value.name.value;
                            break;
                        case 'custom':
                            name = item.value.name.ident;
                            break;
                    }
                    f = f[name];
                }
                break;
            case 'color':
                f = visitor.Color;
                break;
            case 'url':
                f = visitor.Url;
                break;
            case 'length':
                f = visitor.Length;
                break;
            case 'angle':
                f = visitor.Angle;
                break;
            case 'time':
                f = visitor.Time;
                break;
            case 'resolution':
                f = visitor.Resolution;
                break;
            case 'dashed-ident':
                f = visitor.DashedIdent;
                break;
        }
        if (!f) {
            return;
        }
        let res = f(item.value);
        switch(item.type){
            case 'color':
            case 'url':
            case 'length':
            case 'angle':
            case 'time':
            case 'resolution':
            case 'dashed-ident':
                if (Array.isArray(res)) {
                    res = res.map((value)=>({
                            type: item.type,
                            value
                        }));
                } else if (res) {
                    res = {
                        type: item.type,
                        value: res
                    };
                }
                break;
        }
        return res;
    });
    return (value)=>v({
            type,
            value
        });
}
/**
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function extractFunctions(visitors, key) {
    let functions = [];
    for (let visitor of visitors){
        let f = visitor[key];
        if (f) {
            functions.push(f);
        }
    }
    return functions;
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeSimpleVisitors(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = (arg)=>{
        let mutated = false;
        for (let f of functions){
            let res = f(arg);
            if (res) {
                arg = res;
                mutated = true;
            }
        }
        return mutated ? arg : undefined;
    };
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeArrayFunctions(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = createArrayVisitor(functions, (f, item)=>f(item));
}
/**
 * @template T
 * @template V
 * @param {T[]} visitors 
 * @param {(visitor: T, item: V) => V | V[] | void} apply 
 * @returns {(item: V) => V | V[] | void}
 */ function createArrayVisitor(visitors, apply) {
    let seen = new Bitset(visitors.length);
    return (arg)=>{
        let arr = [
            arg
        ];
        let mutated = false;
        seen.clear();
        for(let i = 0; i < arr.length; i++){
            // For each value, call all visitors. If a visitor returns a new value,
            // we start over, but skip the visitor that generated the value or saw
            // it before (to avoid cycles). This way, visitors can be composed in any order. 
            for(let v = 0; v < visitors.length;){
                if (seen.get(v)) {
                    v++;
                    continue;
                }
                let item = arr[i];
                let visitor = visitors[v];
                let res = apply(visitor, item);
                if (Array.isArray(res)) {
                    if (res.length === 0) {
                        arr.splice(i, 1);
                    } else if (res.length === 1) {
                        arr[i] = res[0];
                    } else {
                        arr.splice(i, 1, ...res);
                    }
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else if (res) {
                    arr[i] = res;
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else {
                    v++;
                }
            }
        }
        if (!mutated) {
            return;
        }
        return arr.length === 1 ? arr[0] : arr;
    };
}
class Bitset {
    constructor(maxBits = 32){
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
    }
    /** @param {number} bit */ get(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            return Boolean(this.more[i] & 1 << b);
        } else {
            return Boolean(this.bits & 1 << bit);
        }
    }
    /** @param {number} bit */ set(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            this.more[i] |= 1 << b;
        } else {
            this.bits |= 1 << bit;
        }
    }
    clear() {
        this.bits = 0;
        if (this.more) {
            this.more.fill(0);
        }
    }
}
}}),
"[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This file is autogenerated by build-prefixes.js. DO NOT EDIT!
exports.Features = {
    Nesting: 1,
    NotSelectorList: 2,
    DirSelector: 4,
    LangSelectorList: 8,
    IsSelector: 16,
    TextDecorationThicknessPercent: 32,
    MediaIntervalSyntax: 64,
    MediaRangeSyntax: 128,
    CustomMediaQueries: 256,
    ClampFunction: 512,
    ColorFunction: 1024,
    OklabColors: 2048,
    LabColors: 4096,
    P3Colors: 8192,
    HexAlphaColors: 16384,
    SpaceSeparatedColorNotation: 32768,
    FontFamilySystemUi: 65536,
    DoublePositionGradients: 131072,
    VendorPrefixes: 262144,
    LogicalProperties: 524288,
    LightDark: 1048576,
    Selectors: 31,
    MediaQueries: 448,
    Colors: 1113088
};
}}),
"[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let parts = [
    process.platform,
    process.arch
];
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else if ("TURBOPACK compile-time truthy", 1) {
    parts.push('msvc');
}
if (process.env.CSS_TRANSFORMER_WASM) {
    module.exports = (()=>{
        const e = new Error("Cannot find module '../pkg'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
} else {
    try {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (err) {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    }
}
module.exports.browserslistToTargets = __turbopack_context__.r("[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)");
module.exports.composeVisitors = __turbopack_context__.r("[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)");
module.exports.Features = __turbopack_context__.r("[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)").Features;
}}),
"[project]/node_modules/magic-string/dist/magic-string.cjs.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var sourcemapCodec = __turbopack_context__.r("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js [postcss] (ecmascript)");
class BitSet {
    constructor(arg){
        this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
    }
    add(n) {
        this.bits[n >> 5] |= 1 << (n & 31);
    }
    has(n) {
        return !!(this.bits[n >> 5] & 1 << (n & 31));
    }
}
class Chunk {
    constructor(start, end, content){
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = '';
        this.outro = '';
        this.content = content;
        this.storeName = false;
        this.edited = false;
        {
            this.previous = null;
            this.next = null;
        }
    }
    appendLeft(content) {
        this.outro += content;
    }
    appendRight(content) {
        this.intro = this.intro + content;
    }
    clone() {
        const chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
    }
    contains(index) {
        return this.start < index && index < this.end;
    }
    eachNext(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.next;
        }
    }
    eachPrevious(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.previous;
        }
    }
    edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
            this.intro = '';
            this.outro = '';
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
    }
    prependLeft(content) {
        this.outro = content + this.outro;
    }
    prependRight(content) {
        this.intro = content + this.intro;
    }
    reset() {
        this.intro = '';
        this.outro = '';
        if (this.edited) {
            this.content = this.original;
            this.storeName = false;
            this.edited = false;
        }
    }
    split(index) {
        const sliceIndex = index - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = '';
        this.end = index;
        if (this.edited) {
            // after split we should save the edit content record into the correct chunk
            // to make sure sourcemap correct
            // For example:
            // '  test'.trim()
            //     split   -> '  ' + 'test'
            //   ✔️ edit    -> '' + 'test'
            //   ✖️ edit    -> 'test' + ''
            // TODO is this block necessary?...
            newChunk.edit('', false);
            this.content = '';
        } else {
            this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
    }
    toString() {
        return this.intro + this.content + this.outro;
    }
    trimEnd(rx) {
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                this.split(this.start + trimmed.length).edit('', undefined, true);
                if (this.edited) {
                    // save the change, if it has been edited
                    this.edit(trimmed, this.storeName, true);
                }
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.intro = this.intro.replace(rx, '');
            if (this.intro.length) return true;
        }
    }
    trimStart(rx) {
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                const newChunk = this.split(this.end - trimmed.length);
                if (this.edited) {
                    // save the change, if it has been edited
                    newChunk.edit(trimmed, this.storeName, true);
                }
                this.edit('', undefined, true);
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.outro = this.outro.replace(rx, '');
            if (this.outro.length) return true;
        }
    }
}
function getBtoa() {
    if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
        return (str)=>globalThis.btoa(unescape(encodeURIComponent(str)));
    } else if (typeof Buffer === 'function') {
        return (str)=>Buffer.from(str, 'utf-8').toString('base64');
    } else {
        return ()=>{
            throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
        };
    }
}
const btoa = /*#__PURE__*/ getBtoa();
class SourceMap {
    constructor(properties){
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = sourcemapCodec.encode(properties.mappings);
        if (typeof properties.x_google_ignoreList !== 'undefined') {
            this.x_google_ignoreList = properties.x_google_ignoreList;
        }
        if (typeof properties.debugId !== 'undefined') {
            this.debugId = properties.debugId;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
    toUrl() {
        return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
    }
}
function guessIndent(code) {
    const lines = code.split('\n');
    const tabbed = lines.filter((line)=>/^\t+/.test(line));
    const spaced = lines.filter((line)=>/^ {2,}/.test(line));
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    const min = spaced.reduce((previous, current)=>{
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
    const fromParts = from.split(/[/\\]/);
    const toParts = to.split(/[/\\]/);
    fromParts.pop(); // get dirname
    while(fromParts[0] === toParts[0]){
        fromParts.shift();
        toParts.shift();
    }
    if (fromParts.length) {
        let i = fromParts.length;
        while(i--)fromParts[i] = '..';
    }
    return fromParts.concat(toParts).join('/');
}
const toString = Object.prototype.toString;
function isObject(thing) {
    return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
    const originalLines = source.split('\n');
    const lineOffsets = [];
    for(let i = 0, pos = 0; i < originalLines.length; i++){
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
    }
    return function locate(index) {
        let i = 0;
        let j = lineOffsets.length;
        while(i < j){
            const m = i + j >> 1;
            if (index < lineOffsets[m]) {
                j = m;
            } else {
                i = m + 1;
            }
        }
        const line = i - 1;
        const column = index - lineOffsets[line];
        return {
            line,
            column
        };
    };
}
const wordRegex = /\w/;
class Mappings {
    constructor(hires){
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
    }
    addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
            const contentLengthMinusOne = content.length - 1;
            let contentLineEnd = content.indexOf('\n', 0);
            let previousContentLineEnd = -1;
            // Loop through each line in the content and add a segment, but stop if the last line is empty,
            // else code afterwards would fill one line too many
            while(contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd){
                const segment = [
                    this.generatedCodeColumn,
                    sourceIndex,
                    loc.line,
                    loc.column
                ];
                if (nameIndex >= 0) {
                    segment.push(nameIndex);
                }
                this.rawSegments.push(segment);
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                previousContentLineEnd = contentLineEnd;
                contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
            }
            const segment = [
                this.generatedCodeColumn,
                sourceIndex,
                loc.line,
                loc.column
            ];
            if (nameIndex >= 0) {
                segment.push(nameIndex);
            }
            this.rawSegments.push(segment);
            this.advance(content.slice(previousContentLineEnd + 1));
        } else if (this.pending) {
            this.rawSegments.push(this.pending);
            this.advance(content);
        }
        this.pending = null;
    }
    addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk.start;
        let first = true;
        // when iterating each char, check if it's in a word boundary
        let charInHiresBoundary = false;
        while(originalCharIndex < chunk.end){
            if (original[originalCharIndex] === '\n') {
                loc.line += 1;
                loc.column = 0;
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                first = true;
                charInHiresBoundary = false;
            } else {
                if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
                    const segment = [
                        this.generatedCodeColumn,
                        sourceIndex,
                        loc.line,
                        loc.column
                    ];
                    if (this.hires === 'boundary') {
                        // in hires "boundary", group segments per word boundary than per char
                        if (wordRegex.test(original[originalCharIndex])) {
                            // for first char in the boundary found, start the boundary by pushing a segment
                            if (!charInHiresBoundary) {
                                this.rawSegments.push(segment);
                                charInHiresBoundary = true;
                            }
                        } else {
                            // for non-word char, end the boundary by pushing a segment
                            this.rawSegments.push(segment);
                            charInHiresBoundary = false;
                        }
                    } else {
                        this.rawSegments.push(segment);
                    }
                }
                loc.column += 1;
                this.generatedCodeColumn += 1;
                first = false;
            }
            originalCharIndex += 1;
        }
        this.pending = null;
    }
    advance(str) {
        if (!str) return;
        const lines = str.split('\n');
        if (lines.length > 1) {
            for(let i = 0; i < lines.length - 1; i++){
                this.generatedCodeLine++;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
            }
            this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
    }
}
const n = '\n';
const warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
};
class MagicString {
    constructor(string, options = {}){
        const chunk = new Chunk(0, string.length, string);
        Object.defineProperties(this, {
            original: {
                writable: true,
                value: string
            },
            outro: {
                writable: true,
                value: ''
            },
            intro: {
                writable: true,
                value: ''
            },
            firstChunk: {
                writable: true,
                value: chunk
            },
            lastChunk: {
                writable: true,
                value: chunk
            },
            lastSearchedChunk: {
                writable: true,
                value: chunk
            },
            byStart: {
                writable: true,
                value: {}
            },
            byEnd: {
                writable: true,
                value: {}
            },
            filename: {
                writable: true,
                value: options.filename
            },
            indentExclusionRanges: {
                writable: true,
                value: options.indentExclusionRanges
            },
            sourcemapLocations: {
                writable: true,
                value: new BitSet()
            },
            storedNames: {
                writable: true,
                value: {}
            },
            indentStr: {
                writable: true,
                value: undefined
            },
            ignoreList: {
                writable: true,
                value: options.ignoreList
            },
            offset: {
                writable: true,
                value: options.offset || 0
            }
        });
        this.byStart[0] = chunk;
        this.byEnd[string.length] = chunk;
    }
    addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
    }
    append(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.outro += content;
        return this;
    }
    appendLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.appendLeft(content);
        } else {
            this.intro += content;
        }
        return this;
    }
    appendRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.appendRight(content);
        } else {
            this.outro += content;
        }
        return this;
    }
    clone() {
        const cloned = new MagicString(this.original, {
            filename: this.filename,
            offset: this.offset
        });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while(originalChunk){
            cloned.byStart[clonedChunk.start] = clonedChunk;
            cloned.byEnd[clonedChunk.end] = clonedChunk;
            const nextOriginalChunk = originalChunk.next;
            const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
            if (nextClonedChunk) {
                clonedChunk.next = nextClonedChunk;
                nextClonedChunk.previous = clonedChunk;
                clonedChunk = nextClonedChunk;
            }
            originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
            cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
    }
    generateDecodedMap(options) {
        options = options || {};
        const sourceIndex = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings(options.hires);
        const locate = getLocator(this.original);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk)=>{
            const loc = locate(chunk.start);
            if (chunk.intro.length) mappings.advance(chunk.intro);
            if (chunk.edited) {
                mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
            } else {
                mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
            }
            if (chunk.outro.length) mappings.advance(chunk.outro);
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: [
                options.source ? getRelativePath(options.file || '', options.source) : options.file || ''
            ],
            sourcesContent: options.includeContent ? [
                this.original
            ] : undefined,
            names,
            mappings: mappings.raw,
            x_google_ignoreList: this.ignoreList ? [
                sourceIndex
            ] : undefined
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    _ensureindentStr() {
        if (this.indentStr === undefined) {
            this.indentStr = guessIndent(this.original);
        }
    }
    _getRawIndentString() {
        this._ensureindentStr();
        return this.indentStr;
    }
    getIndentString() {
        this._ensureindentStr();
        return this.indentStr === null ? '\t' : this.indentStr;
    }
    indent(indentStr, options) {
        const pattern = /^[^\r\n]/gm;
        if (isObject(indentStr)) {
            options = indentStr;
            indentStr = undefined;
        }
        if (indentStr === undefined) {
            this._ensureindentStr();
            indentStr = this.indentStr || '\t';
        }
        if (indentStr === '') return this; // noop
        options = options || {};
        // Process exclusion ranges
        const isExcluded = {};
        if (options.exclude) {
            const exclusions = typeof options.exclude[0] === 'number' ? [
                options.exclude
            ] : options.exclude;
            exclusions.forEach((exclusion)=>{
                for(let i = exclusion[0]; i < exclusion[1]; i += 1){
                    isExcluded[i] = true;
                }
            });
        }
        let shouldIndentNextCharacter = options.indentStart !== false;
        const replacer = (match)=>{
            if (shouldIndentNextCharacter) return `${indentStr}${match}`;
            shouldIndentNextCharacter = true;
            return match;
        };
        this.intro = this.intro.replace(pattern, replacer);
        let charIndex = 0;
        let chunk = this.firstChunk;
        while(chunk){
            const end = chunk.end;
            if (chunk.edited) {
                if (!isExcluded[charIndex]) {
                    chunk.content = chunk.content.replace(pattern, replacer);
                    if (chunk.content.length) {
                        shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
                    }
                }
            } else {
                charIndex = chunk.start;
                while(charIndex < end){
                    if (!isExcluded[charIndex]) {
                        const char = this.original[charIndex];
                        if (char === '\n') {
                            shouldIndentNextCharacter = true;
                        } else if (char !== '\r' && shouldIndentNextCharacter) {
                            shouldIndentNextCharacter = false;
                            if (charIndex === chunk.start) {
                                chunk.prependRight(indentStr);
                            } else {
                                this._splitChunk(chunk, charIndex);
                                chunk = chunk.next;
                                chunk.prependRight(indentStr);
                            }
                        }
                    }
                    charIndex += 1;
                }
            }
            charIndex = chunk.end;
            chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern, replacer);
        return this;
    }
    insert() {
        throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
    }
    insertLeft(index, content) {
        if (!warned.insertLeft) {
            console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead');
            warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
    }
    insertRight(index, content) {
        if (!warned.insertRight) {
            console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead');
            warned.insertRight = true;
        }
        return this.prependRight(index, content);
    }
    move(start, end, index) {
        start = start + this.offset;
        end = end + this.offset;
        index = index + this.offset;
        if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
        this._split(start);
        this._split(end);
        this._split(index);
        const first = this.byStart[start];
        const last = this.byEnd[end];
        const oldLeft = first.previous;
        const oldRight = last.next;
        const newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk) return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;
        if (newLeft) newLeft.next = first;
        if (newRight) newRight.previous = last;
        if (!first.previous) this.firstChunk = last.next;
        if (!last.next) {
            this.lastChunk = first.previous;
            this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft) this.firstChunk = first;
        if (!newRight) this.lastChunk = last;
        return this;
    }
    overwrite(start, end, content, options) {
        options = options || {};
        return this.update(start, end, content, {
            ...options,
            overwrite: !options.contentOnly
        });
    }
    update(start, end, content, options) {
        start = start + this.offset;
        end = end + this.offset;
        if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (end > this.original.length) throw new Error('end is out of bounds');
        if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
        this._split(start);
        this._split(end);
        if (options === true) {
            if (!warned.storeName) {
                console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string');
                warned.storeName = true;
            }
            options = {
                storeName: true
            };
        }
        const storeName = options !== undefined ? options.storeName : false;
        const overwrite = options !== undefined ? options.overwrite : false;
        if (storeName) {
            const original = this.original.slice(start, end);
            Object.defineProperty(this.storedNames, original, {
                writable: true,
                value: true,
                enumerable: true
            });
        }
        const first = this.byStart[start];
        const last = this.byEnd[end];
        if (first) {
            let chunk = first;
            while(chunk !== last){
                if (chunk.next !== this.byStart[chunk.end]) {
                    throw new Error('Cannot overwrite across a split point');
                }
                chunk = chunk.next;
                chunk.edit('', false);
            }
            first.edit(content, storeName, !overwrite);
        } else {
            // must be inserting at the end
            const newChunk = new Chunk(start, end, '').edit(content, storeName);
            // TODO last chunk in the array may not be the last chunk, if it's moved...
            last.next = newChunk;
            newChunk.previous = last;
        }
        return this;
    }
    prepend(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.intro = content + this.intro;
        return this;
    }
    prependLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.prependLeft(content);
        } else {
            this.intro = content + this.intro;
        }
        return this;
    }
    prependRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.prependRight(content);
        } else {
            this.outro = content + this.outro;
        }
        return this;
    }
    remove(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.intro = '';
            chunk.outro = '';
            chunk.edit('');
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    reset(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.reset();
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    lastChar() {
        if (this.outro.length) return this.outro[this.outro.length - 1];
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
            if (chunk.content.length) return chunk.content[chunk.content.length - 1];
            if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
        }while (chunk = chunk.previous)
        if (this.intro.length) return this.intro[this.intro.length - 1];
        return '';
    }
    lastLine() {
        let lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length > 0) {
                lineIndex = chunk.outro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.outro + lineStr;
            }
            if (chunk.content.length > 0) {
                lineIndex = chunk.content.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.content + lineStr;
            }
            if (chunk.intro.length > 0) {
                lineIndex = chunk.intro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.intro + lineStr;
            }
        }while (chunk = chunk.previous)
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
    }
    slice(start = 0, end = this.original.length - this.offset) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        let result = '';
        // find start chunk
        let chunk = this.firstChunk;
        while(chunk && (chunk.start > start || chunk.end <= start)){
            // found end chunk before start
            if (chunk.start < end && chunk.end >= end) {
                return result;
            }
            chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
        const startChunk = chunk;
        while(chunk){
            if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
                result += chunk.intro;
            }
            const containsEnd = chunk.start < end && chunk.end >= end;
            if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
            const sliceStart = startChunk === chunk ? start - chunk.start : 0;
            const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
            result += chunk.content.slice(sliceStart, sliceEnd);
            if (chunk.outro && (!containsEnd || chunk.end === end)) {
                result += chunk.outro;
            }
            if (containsEnd) {
                break;
            }
            chunk = chunk.next;
        }
        return result;
    }
    // TODO deprecate this? not really very useful
    snip(start, end) {
        const clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
    }
    _split(index) {
        if (this.byStart[index] || this.byEnd[index]) return;
        let chunk = this.lastSearchedChunk;
        const searchForward = index > chunk.end;
        while(chunk){
            if (chunk.contains(index)) return this._splitChunk(chunk, index);
            chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
    }
    _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
            // zero-length edited chunks are a special case (overlapping replacements)
            const loc = getLocator(this.original)(index);
            throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
        }
        const newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
    }
    toString() {
        let str = this.intro;
        let chunk = this.firstChunk;
        while(chunk){
            str += chunk.toString();
            chunk = chunk.next;
        }
        return str + this.outro;
    }
    isEmpty() {
        let chunk = this.firstChunk;
        do {
            if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
        }while (chunk = chunk.next)
        return true;
    }
    length() {
        let chunk = this.firstChunk;
        let length = 0;
        do {
            length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        }while (chunk = chunk.next)
        return length;
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimEndAborted(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        let chunk = this.lastChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimEnd(rx);
            // if chunk was trimmed, we have a new lastChunk
            if (chunk.end !== end) {
                if (this.lastChunk === chunk) {
                    this.lastChunk = chunk.next;
                }
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.previous;
        }while (chunk)
        return false;
    }
    trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
    }
    trimStartAborted(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        let chunk = this.firstChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimStart(rx);
            if (chunk.end !== end) {
                // special case...
                if (chunk === this.lastChunk) this.lastChunk = chunk.next;
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.next;
        }while (chunk)
        return false;
    }
    trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
    }
    hasChanged() {
        return this.original !== this.toString();
    }
    _replaceRegexp(searchValue, replacement) {
        function getReplacement(match, str) {
            if (typeof replacement === 'string') {
                return replacement.replace(/\$(\$|&|\d+)/g, (_, i)=>{
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
                    if (i === '$') return '$';
                    if (i === '&') return match[0];
                    const num = +i;
                    if (num < match.length) return match[+i];
                    return `$${i}`;
                });
            } else {
                return replacement(...match, match.index, str, match.groups);
            }
        }
        function matchAll(re, str) {
            let match;
            const matches = [];
            while(match = re.exec(str)){
                matches.push(match);
            }
            return matches;
        }
        if (searchValue.global) {
            const matches = matchAll(searchValue, this.original);
            matches.forEach((match)=>{
                if (match.index != null) {
                    const replacement = getReplacement(match, this.original);
                    if (replacement !== match[0]) {
                        this.overwrite(match.index, match.index + match[0].length, replacement);
                    }
                }
            });
        } else {
            const match = this.original.match(searchValue);
            if (match && match.index != null) {
                const replacement = getReplacement(match, this.original);
                if (replacement !== match[0]) {
                    this.overwrite(match.index, match.index + match[0].length, replacement);
                }
            }
        }
        return this;
    }
    _replaceString(string, replacement) {
        const { original } = this;
        const index = original.indexOf(string);
        if (index !== -1) {
            this.overwrite(index, index + string.length, replacement);
        }
        return this;
    }
    replace(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceString(searchValue, replacement);
        }
        return this._replaceRegexp(searchValue, replacement);
    }
    _replaceAllString(string, replacement) {
        const { original } = this;
        const stringLength = string.length;
        for(let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)){
            const previous = original.slice(index, index + stringLength);
            if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
        }
        return this;
    }
    replaceAll(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceAllString(searchValue, replacement);
        }
        if (!searchValue.global) {
            throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');
        }
        return this._replaceRegexp(searchValue, replacement);
    }
}
const hasOwnProp = Object.prototype.hasOwnProperty;
class Bundle {
    constructor(options = {}){
        this.intro = options.intro || '';
        this.separator = options.separator !== undefined ? options.separator : '\n';
        this.sources = [];
        this.uniqueSources = [];
        this.uniqueSourceIndexByFilename = {};
    }
    addSource(source) {
        if (source instanceof MagicString) {
            return this.addSource({
                content: source,
                filename: source.filename,
                separator: this.separator
            });
        }
        if (!isObject(source) || !source.content) {
            throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
        }
        [
            'filename',
            'ignoreList',
            'indentExclusionRanges',
            'separator'
        ].forEach((option)=>{
            if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
        });
        if (source.separator === undefined) {
            // TODO there's a bunch of this sort of thing, needs cleaning up
            source.separator = this.separator;
        }
        if (source.filename) {
            if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
                this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
                this.uniqueSources.push({
                    filename: source.filename,
                    content: source.content.original
                });
            } else {
                const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
                if (source.content.original !== uniqueSource.content) {
                    throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
                }
            }
        }
        this.sources.push(source);
        return this;
    }
    append(str, options) {
        this.addSource({
            content: new MagicString(str),
            separator: options && options.separator || ''
        });
        return this;
    }
    clone() {
        const bundle = new Bundle({
            intro: this.intro,
            separator: this.separator
        });
        this.sources.forEach((source)=>{
            bundle.addSource({
                filename: source.filename,
                content: source.content.clone(),
                separator: source.separator
            });
        });
        return bundle;
    }
    generateDecodedMap(options = {}) {
        const names = [];
        let x_google_ignoreList = undefined;
        this.sources.forEach((source)=>{
            Object.keys(source.content.storedNames).forEach((name)=>{
                if (!~names.indexOf(name)) names.push(name);
            });
        });
        const mappings = new Mappings(options.hires);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.sources.forEach((source, i)=>{
            if (i > 0) {
                mappings.advance(this.separator);
            }
            const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
            const magicString = source.content;
            const locate = getLocator(magicString.original);
            if (magicString.intro) {
                mappings.advance(magicString.intro);
            }
            magicString.firstChunk.eachNext((chunk)=>{
                const loc = locate(chunk.start);
                if (chunk.intro.length) mappings.advance(chunk.intro);
                if (source.filename) {
                    if (chunk.edited) {
                        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
                    } else {
                        mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
                    }
                } else {
                    mappings.advance(chunk.content);
                }
                if (chunk.outro.length) mappings.advance(chunk.outro);
            });
            if (magicString.outro) {
                mappings.advance(magicString.outro);
            }
            if (source.ignoreList && sourceIndex !== -1) {
                if (x_google_ignoreList === undefined) {
                    x_google_ignoreList = [];
                }
                x_google_ignoreList.push(sourceIndex);
            }
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: this.uniqueSources.map((source)=>{
                return options.file ? getRelativePath(options.file, source.filename) : source.filename;
            }),
            sourcesContent: this.uniqueSources.map((source)=>{
                return options.includeContent ? source.content : null;
            }),
            names,
            mappings: mappings.raw,
            x_google_ignoreList
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    getIndentString() {
        const indentStringCounts = {};
        this.sources.forEach((source)=>{
            const indentStr = source.content._getRawIndentString();
            if (indentStr === null) return;
            if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
            indentStringCounts[indentStr] += 1;
        });
        return Object.keys(indentStringCounts).sort((a, b)=>{
            return indentStringCounts[a] - indentStringCounts[b];
        })[0] || '\t';
    }
    indent(indentStr) {
        if (!arguments.length) {
            indentStr = this.getIndentString();
        }
        if (indentStr === '') return this; // noop
        let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
        this.sources.forEach((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
            source.content.indent(indentStr, {
                exclude: source.indentExclusionRanges,
                indentStart
            });
            trailingNewline = source.content.lastChar() === '\n';
        });
        if (this.intro) {
            this.intro = indentStr + this.intro.replace(/^[^\n]/gm, (match, index)=>{
                return index > 0 ? indentStr + match : match;
            });
        }
        return this;
    }
    prepend(str) {
        this.intro = str + this.intro;
        return this;
    }
    toString() {
        const body = this.sources.map((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const str = (i > 0 ? separator : '') + source.content.toString();
            return str;
        }).join('');
        return this.intro + body;
    }
    isEmpty() {
        if (this.intro.length && this.intro.trim()) return false;
        if (this.sources.some((source)=>!source.content.isEmpty())) return false;
        return true;
    }
    length() {
        return this.sources.reduce((length, source)=>length + source.content.length(), this.intro.length);
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimStart(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (!this.intro) {
            let source;
            let i = 0;
            do {
                source = this.sources[i++];
                if (!source) {
                    break;
                }
            }while (!source.content.trimStartAborted(charType))
        }
        return this;
    }
    trimEnd(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        let source;
        let i = this.sources.length - 1;
        do {
            source = this.sources[i--];
            if (!source) {
                this.intro = this.intro.replace(rx, '');
                break;
            }
        }while (!source.content.trimEndAborted(charType))
        return this;
    }
}
MagicString.Bundle = Bundle;
MagicString.SourceMap = SourceMap;
MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121
module.exports = MagicString; //# sourceMappingURL=magic-string.cjs.js.map
}}),

};

//# sourceMappingURL=node_modules_3bd8058a._.js.map