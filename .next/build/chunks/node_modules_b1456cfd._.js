module.exports = {

"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let result = "", cursor = 0;
    do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }while (~index)
    return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported)=>{
    let f = enabled ? formatter : ()=>String;
    return {
        isColorSupported: enabled,
        reset: f("\x1b[0m", "\x1b[0m"),
        bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
        dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
        italic: f("\x1b[3m", "\x1b[23m"),
        underline: f("\x1b[4m", "\x1b[24m"),
        inverse: f("\x1b[7m", "\x1b[27m"),
        hidden: f("\x1b[8m", "\x1b[28m"),
        strikethrough: f("\x1b[9m", "\x1b[29m"),
        black: f("\x1b[30m", "\x1b[39m"),
        red: f("\x1b[31m", "\x1b[39m"),
        green: f("\x1b[32m", "\x1b[39m"),
        yellow: f("\x1b[33m", "\x1b[39m"),
        blue: f("\x1b[34m", "\x1b[39m"),
        magenta: f("\x1b[35m", "\x1b[39m"),
        cyan: f("\x1b[36m", "\x1b[39m"),
        white: f("\x1b[37m", "\x1b[39m"),
        gray: f("\x1b[90m", "\x1b[39m"),
        bgBlack: f("\x1b[40m", "\x1b[49m"),
        bgRed: f("\x1b[41m", "\x1b[49m"),
        bgGreen: f("\x1b[42m", "\x1b[49m"),
        bgYellow: f("\x1b[43m", "\x1b[49m"),
        bgBlue: f("\x1b[44m", "\x1b[49m"),
        bgMagenta: f("\x1b[45m", "\x1b[49m"),
        bgCyan: f("\x1b[46m", "\x1b[49m"),
        bgWhite: f("\x1b[47m", "\x1b[49m"),
        blackBright: f("\x1b[90m", "\x1b[39m"),
        redBright: f("\x1b[91m", "\x1b[39m"),
        greenBright: f("\x1b[92m", "\x1b[39m"),
        yellowBright: f("\x1b[93m", "\x1b[39m"),
        blueBright: f("\x1b[94m", "\x1b[39m"),
        magentaBright: f("\x1b[95m", "\x1b[39m"),
        cyanBright: f("\x1b[96m", "\x1b[39m"),
        whiteBright: f("\x1b[97m", "\x1b[39m"),
        bgBlackBright: f("\x1b[100m", "\x1b[49m"),
        bgRedBright: f("\x1b[101m", "\x1b[49m"),
        bgGreenBright: f("\x1b[102m", "\x1b[49m"),
        bgYellowBright: f("\x1b[103m", "\x1b[49m"),
        bgBlueBright: f("\x1b[104m", "\x1b[49m"),
        bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
        bgCyanBright: f("\x1b[106m", "\x1b[49m"),
        bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
};
module.exports = createColors();
module.exports.createColors = createColors;
}}),
"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = '';
        // A compact alternative for `for (var i = 0; i < step; i++)`.
        let i = size | 0;
        while(i--){
            // `| 0` is more compact and faster than `Math.floor()`.
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
let nanoid = (size = 21)=>{
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while(i--){
        // `| 0` is more compact and faster than `Math.floor()`.
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
module.exports = {
    nanoid,
    customAlphabet
};
}}),
"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */ exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */ exports.decode = function(charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
}}),
"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var base64 = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)");
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */ function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */ function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */ exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }while (vlq > 0)
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    }while (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}}),
"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */ function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
        return aArgs[aName];
    } else if (arguments.length === 3) {
        return aDefaultValue;
    } else {
        throw new Error('"' + aName + '" is a required argument.');
    }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
        return null;
    }
    return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
    };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;
/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */ function lruMemoize(f) {
    var cache = [];
    return function(input) {
        for(var i = 0; i < cache.length; i++){
            if (cache[i].input === input) {
                var temp = cache[0];
                cache[0] = cache[i];
                cache[i] = temp;
                return cache[0].result;
            }
        }
        var result = f(input);
        cache.unshift({
            input,
            result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
        }
        return result;
    };
}
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */ var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
        if (!url.path) {
            return aPath;
        }
        path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while(true){
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
            parts.push(path.slice(start));
            break;
        } else {
            parts.push(path.slice(start, i));
            while(i < path.length && path[i] === "/"){
                i++;
            }
        }
    }
    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
        part = parts[i];
        if (part === '.') {
            parts.splice(i, 1);
        } else if (part === '..') {
            up++;
        } else if (up > 0) {
            if (part === '') {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
            } else {
                parts.splice(i, 2);
                up--;
            }
        }
    }
    path = parts.join('/');
    if (path === '') {
        path = isAbsolute ? '/' : '.';
    }
    if (url) {
        url.path = path;
        return urlGenerate(url);
    }
    return path;
});
exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */ function join(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    if (aPath === "") {
        aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
    }
    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
    }
    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
    }
    return joined;
}
exports.join = join;
exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */ function relative(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, '');
    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while(aPath.indexOf(aRoot + '/') !== 0){
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
            return aPath;
        }
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
        }
        ++level;
    }
    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function() {
    var obj = Object.create(null);
    return !('__proto__' in obj);
}();
function identity(s) {
    return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */ function toSetString(aStr) {
    if (isProtoString(aStr)) {
        return '$' + aStr;
    }
    return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
    if (isProtoString(aStr)) {
        return aStr.slice(1);
    }
    return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
    if (!s) {
        return false;
    }
    var length = s.length;
    if (length < 9 /* "__proto__".length */ ) {
        return false;
    }
    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {
        return false;
    }
    for(var i = length - 10; i >= 0; i--){
        if (s.charCodeAt(i) !== 36 /* '$' */ ) {
            return false;
        }
    }
    return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
        return 0;
    }
    if (aStr1 === null) {
        return 1; // aStr2 !== null
    }
    if (aStr2 === null) {
        return -1; // aStr1 !== null
    }
    if (aStr1 > aStr2) {
        return 1;
    }
    return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */ function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';
    if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
    }
    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}}),
"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */ function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for(var i = 0, len = aArray.length; i < len; i++){
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
exports.ArraySet = ArraySet;
}}),
"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */ function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */ function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
        generatedLine: -1,
        generatedColumn: 0
    };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */ MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    } else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */ MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
exports.MappingList = MappingList;
}}),
"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var MappingList = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */ function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
            generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
            }
        };
        if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
            };
            if (mapping.name != null) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
            return;
        }
    }
    if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
            this._sources.add(source);
        }
    }
    if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
            this._names.add(name);
        }
    }
    this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    });
};
/**
 * Set the source content for a source file.
 */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
        }
    }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
            });
            if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                    mapping.name = original.name;
                }
            }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
            newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
            newNames.add(name);
        }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
        }
    }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        // Cases 2 and 3.
        return;
    } else {
        var message = 'Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
        });
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for(var i = 0, len = mappings.length; i < len; i++){
        mapping = mappings[i];
        next = '';
        if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while(mapping.generatedLine !== previousGeneratedLine){
                next += ';';
                previousGeneratedLine++;
            }
        } else {
            if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                    continue;
                }
                next += ',';
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
        if (!this._sourcesContents) {
            return null;
        }
        if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
};
/**
 * Externalize the source map.
 */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
    };
    if (this._file != null) {
        map.file = this._file;
    }
    if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
};
/**
 * Render the source map being generated to a string.
 */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}}),
"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
    } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
        } else {
            return mid;
        }
    } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
        } else {
            return aLow < 0 ? -1 : aLow;
        }
    }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
        return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
        return -1;
    }
    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while(index - 1 >= 0){
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
        }
        --index;
    }
    return index;
};
}}),
"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
function SortTemplate(comparator) {
    /**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */ function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
    }
    /**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */ function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
    }
    /**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */ function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
        if (p < r) {
            // (1) Partitioning.
            //
            // The partitioning chooses a pivot between `p` and `r` and moves all
            // elements that are less than or equal to the pivot to the before it, and
            // all the elements that are greater than it after it. The effect is that
            // once partition is done, the pivot is in the exact place it will be when
            // the array is put in sorted order, and it will not need to be moved
            // again. This runs in O(n) time.
            // Always choose a random pivot so that an input array which is reverse
            // sorted does not cause O(n^2) running time.
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            // Immediately after `j` is incremented in this loop, the following hold
            // true:
            //
            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
            //
            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
            for(var j = p; j < r; j++){
                if (comparator(ary[j], pivot, false) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            // (2) Recurse on each half.
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
        }
    }
    return doQuickSort;
}
function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */ let sortCache = new WeakMap();
exports.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
};
}}),
"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var binarySearch = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var quickSort = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)").quickSort;
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */ SourceMapConsumer.prototype._version = 3;
// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch(order){
        case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
        case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
        default:
            throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;
    for(var i = 0, n = mappings.length; i < n; i++){
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        if (source !== null) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
        });
    }
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
        return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while(mapping && mapping.originalLine === originalLine){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        } else {
            var originalColumn = mapping.originalColumn;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        }
    }
    return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);
    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
    }
    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for(i = 0; i < this._absoluteSources.length; ++i){
        if (this._absoluteSources[i] == aSource) {
            return i;
        }
    }
    return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for(var i = 0, length = generatedMappings.length; i < length; i++){
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */ BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function() {
        return this._absoluteSources.slice();
    }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */ function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;
    if (n <= 1) {
        return;
    } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
            array[start] = b;
            array[start + 1] = a;
        }
    } else if (n < 20) {
        for(let i = start; i < l; i++){
            for(let j = i; j > start; j--){
                let a = array[j - 1];
                let b = array[j];
                if (compareGenerated(a, b) <= 0) {
                    break;
                }
                array[j - 1] = b;
                array[j] = a;
            }
        }
    } else {
        quickSort(array, compareGenerated, start);
    }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while(index < length){
        if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ',') {
            index++;
        } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for(end = index; end < length; end++){
                if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                }
            }
            str = aStr.slice(index, end);
            segment = [];
            while(index < end){
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
            }
            if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
            }
            if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
            }
            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
                let currentSource = mapping.source;
                while(originalMappings.length <= currentSource){
                    originalMappings.push(null);
                }
                if (originalMappings[currentSource] === null) {
                    originalMappings[currentSource] = [];
                }
                originalMappings[currentSource].push(mapping);
            }
        }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for(var i = 0; i < originalMappings.length; i++){
        if (originalMappings[i] != null) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
    }
    this.__originalMappings = [].concat(...originalMappings);
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for(var index = 0; index < this._generatedMappings.length; ++index){
        var mapping = this._generatedMappings[index];
        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
            }
        }
        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
    }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
                name = this._names.at(name);
            }
            return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
            };
        }
    }
    return {
        source: null,
        line: null,
        column: null,
        name: null
    };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
        return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
        return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
        return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
    }
    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
        return {
            line: null,
            column: null,
            lastColumn: null
        };
    }
    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
            return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
        }
    }
    return {
        line: null,
        column: null,
        lastColumn: null
    };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
        line: -1,
        column: 0
    };
    this._sections = sections.map(function(s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        };
    });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */ IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function() {
        var sources = [];
        for(var i = 0; i < this._sections.length; i++){
            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
            return cmp;
        }
        return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
        return {
            source: null,
            line: null,
            column: null,
            name: null
        };
    }
    return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
    });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === '') {
            return content;
        }
    }
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
            var ret = {
                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
        }
    }
    return {
        line: null,
        column: null
    };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for(var j = 0; j < sectionMappings.length; j++){
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            if (source !== null) {
                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            }
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
            }
            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
            }
        }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}}),
"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;
// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;
// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();
    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        "TURBOPACK unreachable";
        function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
    };
    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
            // The remaining code is added without mapping
            } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[remainingLinesIndex] || '';
                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
            }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while(lastGeneratedLine < mapping.generatedLine){
            node.add(shiftNextLine());
            lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
        }
    });
    return node;
    "TURBOPACK unreachable";
    function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
            node.add(code);
        } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
    }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
            this.add(chunk);
        }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
            this.children.push(aChunk);
        }
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
        for(var i = aChunk.length - 1; i >= 0; i--){
            this.prepend(aChunk[i]);
        }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for(var i = 0, len = this.children.length; i < len; i++){
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
            chunk.walk(aFn);
        } else {
            if (chunk !== '') {
                aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }
        }
    }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */ SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
        newChildren = [];
        for(i = 0; i < len - 1; i++){
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
    }
    return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
        this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for(var i = 0, len = this.children.length; i < len; i++){
        if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
        }
    }
    var sources = Object.keys(this.sourceContents);
    for(var i = 0, len = sources.length; i < len; i++){
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */ SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
        str += chunk;
    });
    return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({
                    source: original.source,
                    original: {
                        line: original.line,
                        column: original.column
                    },
                    generated: {
                        line: generated.line,
                        column: generated.column
                    },
                    name: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
        } else if (sourceMappingActive) {
            map.addMapping({
                generated: {
                    line: generated.line,
                    column: generated.column
                }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
        }
        for(var idx = 0, length = chunk.length; idx < length; idx++){
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                // Mappings end at eol
                if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                } else if (sourceMappingActive) {
                    map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                }
            } else {
                generated.column++;
            }
        }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
    });
    return {
        code: generated.code,
        map: map
    };
};
exports.SourceNode = SourceNode;
}}),
"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
exports.SourceMapConsumer = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)").SourceMapConsumer;
exports.SourceNode = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)").SourceNode;
}}),
"[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
class QuickLRU {
    constructor(options = {}){
        if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        if (typeof options.maxAge === 'number' && options.maxAge === 0) {
            throw new TypeError('`maxAge` must be a number greater than 0');
        }
        this.maxSize = options.maxSize;
        this.maxAge = options.maxAge || Infinity;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
    }
    _emitEvictions(cache) {
        if (typeof this.onEviction !== 'function') {
            return;
        }
        for (const [key, item] of cache){
            this.onEviction(key, item.value);
        }
    }
    _deleteIfExpired(key, item) {
        if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
            if (typeof this.onEviction === 'function') {
                this.onEviction(key, item.value);
            }
            return this.delete(key);
        }
        return false;
    }
    _getOrDeleteIfExpired(key, item) {
        const deleted = this._deleteIfExpired(key, item);
        if (deleted === false) {
            return item.value;
        }
    }
    _getItemValue(key, item) {
        return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache) {
        const item = cache.get(key);
        return this._getItemValue(key, item);
    }
    _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    }
    _moveToRecent(key, item) {
        this.oldCache.delete(key);
        this._set(key, item);
    }
    *_entriesAscending() {
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield item;
                }
            }
        }
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield item;
            }
        }
    }
    get(key) {
        if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
        }
        if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
                this._moveToRecent(key, item);
                return item.value;
            }
        }
    }
    set(key, value, { maxAge = this.maxAge === Infinity ? undefined : Date.now() + this.maxAge } = {}) {
        if (this.cache.has(key)) {
            this.cache.set(key, {
                value,
                maxAge
            });
        } else {
            this._set(key, {
                value,
                expiry: maxAge
            });
        }
    }
    has(key) {
        if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
        }
        if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
        }
        return false;
    }
    peek(key) {
        if (this.cache.has(key)) {
            return this._peek(key, this.cache);
        }
        if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
        }
    }
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            this._size--;
        }
        return this.oldCache.delete(key) || deleted;
    }
    clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
    }
    resize(newSize) {
        if (!(newSize && newSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        const items = [
            ...this._entriesAscending()
        ];
        const removeCount = items.length - newSize;
        if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = new Map();
            this._size = items.length;
        } else {
            if (removeCount > 0) {
                this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = new Map();
            this._size = 0;
        }
        this.maxSize = newSize;
    }
    *keys() {
        for (const [key] of this){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesDescending() {
        let items = [
            ...this.cache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        items = [
            ...this.oldCache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesAscending() {
        for (const [key, value] of this._entriesAscending()){
            yield [
                key,
                value.value
            ];
        }
    }
    get size() {
        if (!this._size) {
            return this.oldCache.size;
        }
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()){
            if (!this.cache.has(key)) {
                oldCacheSize++;
            }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
    }
}
module.exports = QuickLRU;
}}),
"[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var constants = __turbopack_context__.r("[externals]/constants [external] (constants, cjs)");
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === 'function') {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}
}}),
"[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    "TURBOPACK unreachable";
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ('number' !== typeof this.end) {
                throw TypeError('end must be a Number');
            }
            if (this.start > this.end) {
                throw new Error('start must be <= end');
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit('error', err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit('open', fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.start < 0) {
                throw new Error('start must be >= zero');
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}
}}),
"[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}
}}),
"[project]/node_modules/graceful-fs/graceful-fs.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var polyfills = __turbopack_context__.r("[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)");
var legacy = __turbopack_context__.r("[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)");
var clone = __turbopack_context__.r("[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
} else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === 'function') cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
            debug(fs[gracefulQueue]);
            __turbopack_context__.r("[externals]/assert [external] (assert, cjs)").equal(fs[gracefulQueue].length, 0);
        });
    }
}
if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$readFile(path, options, cb);
        "TURBOPACK unreachable";
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        "TURBOPACK unreachable";
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        "TURBOPACK unreachable";
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        "TURBOPACK unreachable";
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        "TURBOPACK unreachable";
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === 'function') cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === 'function') cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        "TURBOPACK unreachable";
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now // startTime
            ;
            fs[gracefulQueue][i][4] = now // lastTime
            ;
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}
}}),
"[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deprecateContext = util.deprecate(()=>{}, "Hook.context is deprecated and will be removed");
const CALL_DELEGATE = function(...args) {
    this.call = this._createCall("sync");
    return this.call(...args);
};
const CALL_ASYNC_DELEGATE = function(...args) {
    this.callAsync = this._createCall("async");
    return this.callAsync(...args);
};
const PROMISE_DELEGATE = function(...args) {
    this.promise = this._createCall("promise");
    return this.promise(...args);
};
class Hook {
    constructor(args = [], name = undefined){
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = undefined;
        this.compile = this.compile;
        this.tap = this.tap;
        this.tapAsync = this.tapAsync;
        this.tapPromise = this.tapPromise;
    }
    compile(options) {
        throw new Error("Abstract: should be overridden");
    }
    _createCall(type) {
        return this.compile({
            taps: this.taps,
            interceptors: this.interceptors,
            args: this._args,
            type: type
        });
    }
    _tap(type, options, fn) {
        if (typeof options === "string") {
            options = {
                name: options.trim()
            };
        } else if (typeof options !== "object" || options === null) {
            throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
            throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
            deprecateContext();
        }
        options = Object.assign({
            type,
            fn
        }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    tapAsync(options, fn) {
        this._tap("async", options, fn);
    }
    tapPromise(options, fn) {
        this._tap("promise", options, fn);
    }
    _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors){
            if (interceptor.register) {
                const newOptions = interceptor.register(options);
                if (newOptions !== undefined) {
                    options = newOptions;
                }
            }
        }
        return options;
    }
    withOptions(options) {
        const mergeOptions = (opt)=>Object.assign({}, options, typeof opt === "string" ? {
                name: opt
            } : opt);
        return {
            name: this.name,
            tap: (opt, fn)=>this.tap(mergeOptions(opt), fn),
            tapAsync: (opt, fn)=>this.tapAsync(mergeOptions(opt), fn),
            tapPromise: (opt, fn)=>this.tapPromise(mergeOptions(opt), fn),
            intercept: (interceptor)=>this.intercept(interceptor),
            isUsed: ()=>this.isUsed(),
            withOptions: (opt)=>this.withOptions(mergeOptions(opt))
        };
    }
    isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
            for(let i = 0; i < this.taps.length; i++){
                this.taps[i] = interceptor.register(this.taps[i]);
            }
        }
    }
    _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
    }
    _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
            before = new Set([
                item.before
            ]);
        } else if (Array.isArray(item.before)) {
            before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
            stage = item.stage;
        }
        let i = this.taps.length;
        while(i > 0){
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) {
                    continue;
                }
            }
            if (xStage > stage) {
                continue;
            }
            i++;
            break;
        }
        this.taps[i] = item;
    }
}
Object.setPrototypeOf(Hook.prototype, null);
module.exports = Hook;
}}),
"[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
class HookCodeFactory {
    constructor(config){
        this.config = config;
        this.options = undefined;
        this._args = undefined;
    }
    create(options) {
        this.init(options);
        let fn;
        switch(this.options.type){
            case "sync":
                fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`throw ${err};\n`,
                    onResult: (result)=>`return ${result};\n`,
                    resultReturns: true,
                    onDone: ()=>"",
                    rethrowIfPossible: true
                }));
                break;
            case "async":
                fn = new Function(this.args({
                    after: "_callback"
                }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`_callback(${err});\n`,
                    onResult: (result)=>`_callback(null, ${result});\n`,
                    onDone: ()=>"_callback();\n"
                }));
                break;
            case "promise":
                let errorHelperUsed = false;
                const content = this.contentWithInterceptors({
                    onError: (err)=>{
                        errorHelperUsed = true;
                        return `_error(${err});\n`;
                    },
                    onResult: (result)=>`_resolve(${result});\n`,
                    onDone: ()=>"_resolve();\n"
                });
                let code = "";
                code += '"use strict";\n';
                code += this.header();
                code += "return new Promise((function(_resolve, _reject) {\n";
                if (errorHelperUsed) {
                    code += "var _sync = true;\n";
                    code += "function _error(_err) {\n";
                    code += "if(_sync)\n";
                    code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
                    code += "else\n";
                    code += "_reject(_err);\n";
                    code += "};\n";
                }
                code += content;
                if (errorHelperUsed) {
                    code += "_sync = false;\n";
                }
                code += "}));\n";
                fn = new Function(this.args(), code);
                break;
        }
        this.deinit();
        return fn;
    }
    setup(instance, options) {
        instance._x = options.taps.map((t)=>t.fn);
    }
    /**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */ init(options) {
        this.options = options;
        this._args = options.args.slice();
    }
    deinit() {
        this.options = undefined;
        this._args = undefined;
    }
    contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
            const onError = options.onError;
            const onResult = options.onResult;
            const onDone = options.onDone;
            let code = "";
            for(let i = 0; i < this.options.interceptors.length; i++){
                const interceptor = this.options.interceptors[i];
                if (interceptor.call) {
                    code += `${this.getInterceptor(i)}.call(${this.args({
                        before: interceptor.context ? "_context" : undefined
                    })});\n`;
                }
            }
            code += this.content(Object.assign(options, {
                onError: onError && ((err)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.error) {
                            code += `${this.getInterceptor(i)}.error(${err});\n`;
                        }
                    }
                    code += onError(err);
                    return code;
                }),
                onResult: onResult && ((result)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.result) {
                            code += `${this.getInterceptor(i)}.result(${result});\n`;
                        }
                    }
                    code += onResult(result);
                    return code;
                }),
                onDone: onDone && (()=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.done) {
                            code += `${this.getInterceptor(i)}.done();\n`;
                        }
                    }
                    code += onDone();
                    return code;
                })
            }));
            return code;
        } else {
            return this.content(options);
        }
    }
    header() {
        let code = "";
        if (this.needContext()) {
            code += "var _context = {};\n";
        } else {
            code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
            code += "var _taps = this.taps;\n";
            code += "var _interceptors = this.interceptors;\n";
        }
        return code;
    }
    needContext() {
        for (const tap of this.options.taps)if (tap.context) return true;
        return false;
    }
    callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.tap) {
                if (!hasTapCached) {
                    code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
                    hasTapCached = true;
                }
                code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`;
            }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
        const tap = this.options.taps[tapIndex];
        switch(tap.type){
            case "sync":
                if (!rethrowIfPossible) {
                    code += `var _hasError${tapIndex} = false;\n`;
                    code += "try {\n";
                }
                if (onResult) {
                    code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                } else {
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                }
                if (!rethrowIfPossible) {
                    code += "} catch(_err) {\n";
                    code += `_hasError${tapIndex} = true;\n`;
                    code += onError("_err");
                    code += "}\n";
                    code += `if(!_hasError${tapIndex}) {\n`;
                }
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                if (!rethrowIfPossible) {
                    code += "}\n";
                }
                break;
            case "async":
                let cbCode = "";
                if (onResult) cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\n`;
                else cbCode += `(function(_err${tapIndex}) {\n`;
                cbCode += `if(_err${tapIndex}) {\n`;
                cbCode += onError(`_err${tapIndex}`);
                cbCode += "} else {\n";
                if (onResult) {
                    cbCode += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    cbCode += onDone();
                }
                cbCode += "}\n";
                cbCode += "})";
                code += `_fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined,
                    after: cbCode
                })});\n`;
                break;
            case "promise":
                code += `var _hasResult${tapIndex} = false;\n`;
                code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined
                })});\n`;
                code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
                code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
                code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
                code += `_hasResult${tapIndex} = true;\n`;
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                code += `}), function(_err${tapIndex}) {\n`;
                code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
                code += onError(`_err${tapIndex}`);
                code += "});\n";
                break;
        }
        return code;
    }
    callTapsSeries({ onError, onResult, resultReturns, onDone, doneReturns, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const firstAsync = this.options.taps.findIndex((t)=>t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for(let j = this.options.taps.length - 1; j >= 0; j--){
            const i = j;
            const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
            if (unroll) {
                unrollCounter = 0;
                code += `function _next${i}() {\n`;
                code += current();
                code += `}\n`;
                current = ()=>`${somethingReturns ? "return " : ""}_next${i}();\n`;
            }
            const done = current;
            const doneBreak = (skipDone)=>{
                if (skipDone) return "";
                return onDone();
            };
            const content = this.callTap(i, {
                onError: (error)=>onError(i, error, done, doneBreak),
                onResult: onResult && ((result)=>{
                    return onResult(i, result, done, doneBreak);
                }),
                onDone: !onResult && done,
                rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
            });
            current = ()=>content;
        }
        code += current();
        return code;
    }
    callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const syncOnly = this.options.taps.every((t)=>t.type === "sync");
        let code = "";
        if (!syncOnly) {
            code += "var _looper = (function() {\n";
            code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.loop) {
                code += `${this.getInterceptor(i)}.loop(${this.args({
                    before: interceptor.context ? "_context" : undefined
                })});\n`;
            }
        }
        code += this.callTapsSeries({
            onError,
            onResult: (i, result, next, doneBreak)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += "_loop = true;\n";
                if (!syncOnly) code += "if(_loopAsync) _looper();\n";
                code += doneBreak(true);
                code += `} else {\n`;
                code += next();
                code += `}\n`;
                return code;
            },
            onDone: onDone && (()=>{
                let code = "";
                code += "if(!_loop) {\n";
                code += onDone();
                code += "}\n";
                return code;
            }),
            rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
            code += "_loopAsync = true;\n";
            code += "});\n";
            code += "_looper();\n";
        }
        return code;
    }
    callTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run)=>run() }) {
        if (this.options.taps.length <= 1) {
            return this.callTapsSeries({
                onError,
                onResult,
                onDone,
                rethrowIfPossible
            });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};\n`;
        if (onDone) {
            code += "var _done = (function() {\n";
            code += onDone();
            code += "});\n";
        }
        for(let i = 0; i < this.options.taps.length; i++){
            const done = ()=>{
                if (onDone) return "if(--_counter === 0) _done();\n";
                else return "--_counter;";
            };
            const doneBreak = (skipDone)=>{
                if (skipDone || !onDone) return "_counter = 0;\n";
                else return "_counter = 0;\n_done();\n";
            };
            code += "if(_counter <= 0) break;\n";
            code += onTap(i, ()=>this.callTap(i, {
                    onError: (error)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onError(i, error, done, doneBreak);
                        code += "}\n";
                        return code;
                    },
                    onResult: onResult && ((result)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onResult(i, result, done, doneBreak);
                        code += "}\n";
                        return code;
                    }),
                    onDone: !onResult && (()=>{
                        return done();
                    }),
                    rethrowIfPossible
                }), done, doneBreak);
        }
        code += "} while(false);\n";
        return code;
    }
    args({ before, after } = {}) {
        let allArgs = this._args;
        if (before) allArgs = [
            before
        ].concat(allArgs);
        if (after) allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
            return "";
        } else {
            return allArgs.join(", ");
        }
    }
    getTapFn(idx) {
        return `_x[${idx}]`;
    }
    getTap(idx) {
        return `_taps[${idx}]`;
    }
    getInterceptor(idx) {
        return `_interceptors[${idx}]`;
    }
}
module.exports = HookCodeFactory;
}}),
"[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncHook.prototype = null;
module.exports = SyncHook;
}}),
"[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
            resultReturns,
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncBailHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncBailHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncBailHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncBailHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncBailHook.prototype = null;
module.exports = SyncBailHook;
}}),
"[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0]),
            doneReturns: resultReturns,
            rethrowIfPossible
        });
    }
}
const factory = new SyncWaterfallHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = SyncWaterfallHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncWaterfallHook.prototype = null;
module.exports = SyncWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncLoopHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncLoopHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncLoopHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncLoopHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncLoopHook.prototype = null;
module.exports = SyncLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncParallelHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelHook.prototype = null;
module.exports = AsyncParallelHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});\n`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onResult: (i, result, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onTap: (i, run, done, doneBreak)=>{
                let code = "";
                if (i > 0) {
                    code += `if(${i} >= _results.length) {\n`;
                    code += done();
                    code += "} else {\n";
                }
                code += run();
                if (i > 0) code += "}\n";
                return code;
            },
            onDone
        });
        return code;
    }
}
const factory = new AsyncParallelBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelBailHook.prototype = null;
module.exports = AsyncParallelBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesHook.prototype = null;
module.exports = AsyncSeriesHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)}\n} else {\n${next()}}\n`,
            resultReturns,
            onDone
        });
    }
}
const factory = new AsyncSeriesBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesBailHook.prototype = null;
module.exports = AsyncSeriesBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsLooping({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesLoopHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesLoopHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesLoopHook.prototype = null;
module.exports = AsyncSeriesLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0])
        });
    }
}
const factory = new AsyncSeriesWaterfallHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesWaterfallHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesWaterfallHook.prototype = null;
module.exports = AsyncSeriesWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const defaultFactory = (key, hook)=>hook;
class HookMap {
    constructor(factory, name = undefined){
        this._map = new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
    }
    get(key) {
        return this._map.get(key);
    }
    for(key) {
        const hook = this.get(key);
        if (hook !== undefined) {
            return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for(let i = 0; i < interceptors.length; i++){
            newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
    }
    intercept(interceptor) {
        this._interceptors.push(Object.assign({
            factory: defaultFactory
        }, interceptor));
    }
}
HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
    return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");
HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
    return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");
HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
    return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");
module.exports = HookMap;
}}),
"[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
class MultiHook {
    constructor(hooks, name = undefined){
        this.hooks = hooks;
        this.name = name;
    }
    tap(options, fn) {
        for (const hook of this.hooks){
            hook.tap(options, fn);
        }
    }
    tapAsync(options, fn) {
        for (const hook of this.hooks){
            hook.tapAsync(options, fn);
        }
    }
    tapPromise(options, fn) {
        for (const hook of this.hooks){
            hook.tapPromise(options, fn);
        }
    }
    isUsed() {
        for (const hook of this.hooks){
            if (hook.isUsed()) return true;
        }
        return false;
    }
    intercept(interceptor) {
        for (const hook of this.hooks){
            hook.intercept(interceptor);
        }
    }
    withOptions(options) {
        return new MultiHook(this.hooks.map((h)=>h.withOptions(options)), this.name);
    }
}
module.exports = MultiHook;
}}),
"[project]/node_modules/tapable/lib/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
exports.__esModule = true;
exports.SyncHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)");
exports.SyncBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)");
exports.SyncWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)");
exports.SyncLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)");
exports.AsyncParallelHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)");
exports.AsyncParallelBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)");
exports.AsyncSeriesBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)");
exports.AsyncSeriesWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)");
exports.HookMap = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)");
exports.MultiHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)");
}}),
"[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const BROWSER_MAPPING = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    and_qq: null,
    and_uc: null,
    baidu: null,
    bb: null,
    kaios: null,
    op_mini: null
};
function browserslistToTargets(browserslist) {
    let targets = {};
    for (let browser of browserslist){
        let [name, v] = browser.split(' ');
        if (BROWSER_MAPPING[name] === null) {
            continue;
        }
        let version = parseVersion(v);
        if (version == null) {
            continue;
        }
        if (targets[name] == null || version < targets[name]) {
            targets[name] = version;
        }
    }
    return targets;
}
function parseVersion(version) {
    let [major, minor = 0, patch = 0] = version.split('-')[0].split('.').map((v)=>parseInt(v, 10));
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
    }
    return major << 16 | minor << 8 | patch;
}
module.exports = browserslistToTargets;
}}),
"[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-check
/** @typedef {import('./index').Visitor} Visitor */ /**
 * Composes multiple visitor objects into a single one.
 * @param {Visitor[]} visitors 
 * @return {Visitor}
 */ function composeVisitors(visitors) {
    if (visitors.length === 1) {
        return visitors[0];
    }
    /** @type Visitor */ let res = {};
    composeSimpleVisitors(res, visitors, 'StyleSheet');
    composeSimpleVisitors(res, visitors, 'StyleSheetExit');
    composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);
    composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);
    composeSimpleVisitors(res, visitors, 'Url');
    composeSimpleVisitors(res, visitors, 'Color');
    composeSimpleVisitors(res, visitors, 'Image');
    composeSimpleVisitors(res, visitors, 'ImageExit');
    composeSimpleVisitors(res, visitors, 'Length');
    composeSimpleVisitors(res, visitors, 'Angle');
    composeSimpleVisitors(res, visitors, 'Ratio');
    composeSimpleVisitors(res, visitors, 'Resolution');
    composeSimpleVisitors(res, visitors, 'Time');
    composeSimpleVisitors(res, visitors, 'CustomIdent');
    composeSimpleVisitors(res, visitors, 'DashedIdent');
    composeArrayFunctions(res, visitors, 'MediaQuery');
    composeArrayFunctions(res, visitors, 'MediaQueryExit');
    composeSimpleVisitors(res, visitors, 'SupportsCondition');
    composeSimpleVisitors(res, visitors, 'SupportsConditionExit');
    composeArrayFunctions(res, visitors, 'Selector');
    composeTokenVisitors(res, visitors, 'Token', 'token', false);
    composeTokenVisitors(res, visitors, 'Function', 'function', false);
    composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);
    composeTokenVisitors(res, visitors, 'Variable', 'var', false);
    composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);
    composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);
    composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);
    return res;
}
module.exports = composeVisitors;
function wrapCustomAndUnknownAtRule(k, f) {
    if (k === 'unknown') {
        return (value)=>f({
                type: 'unknown',
                value
            });
    }
    if (k === 'custom') {
        return (value)=>f({
                type: 'custom',
                value
            });
    }
    return f;
}
function wrapCustomProperty(k, f) {
    return k === 'custom' ? (value)=>f({
            property: 'custom',
            value
        }) : f;
}
/**
 * @param {import('./index').Visitor['Rule']} f 
 * @param {import('./ast').Rule} item 
 */ function ruleVisitor(f, item) {
    if (typeof f === 'object') {
        if (item.type === 'unknown') {
            let v = f.unknown;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        if (item.type === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[item.type]?.(item);
    }
    return f?.(item);
}
/**
 * @param {import('./index').Visitor['Declaration']} f 
 * @param {import('./ast').Declaration} item 
 */ function declarationVisitor(f, item) {
    if (typeof f === 'object') {
        /** @type {string} */ let name = item.property;
        if (item.property === 'unparsed') {
            name = item.value.propertyId.property;
        } else if (item.property === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[name]?.(item);
    }
    return f?.(item);
}
/**
 * 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @returns {[any[], boolean, Set<string>]}
 */ function extractObjectsOrFunctions(visitors, key) {
    let values = [];
    let hasFunction = false;
    let allKeys = new Set();
    for (let visitor of visitors){
        let v = visitor[key];
        if (v) {
            if (typeof v === 'function') {
                hasFunction = true;
            } else {
                for(let key in v){
                    allKeys.add(key);
                }
            }
            values.push(v);
        }
    }
    return [
        values,
        hasFunction,
        allKeys
    ];
}
/**
 * @template {keyof Visitor} K
 * @param {Visitor} res
 * @param {Visitor[]} visitors
 * @param {K} key
 * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply 
 * @param {(k: string, f: any) => any} wrapKey 
 */ function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createArrayVisitor(visitors, (visitor, item)=>apply(visitor[key], item));
    if (hasFunction) {
        res[key] = f;
    } else {
        /** @type {any} */ let v = {};
        for (let k of allKeys){
            v[k] = wrapKey(k, f);
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @param {import('./ast').TokenOrValue['type']} type 
 * @param {boolean} isExit 
 */ function composeTokenVisitors(res, visitors, key, type, isExit) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createTokenVisitor(visitors, type, isExit);
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let key of allKeys){
            v[key] = f;
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor[]} visitors 
 * @param {import('./ast').TokenOrValue['type']} type 
 */ function createTokenVisitor(visitors, type, isExit) {
    let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */ item)=>{
        let f;
        switch(item.type){
            case 'token':
                f = visitor.Token;
                if (typeof f === 'object') {
                    f = f[item.value.type];
                }
                break;
            case 'function':
                f = isExit ? visitor.FunctionExit : visitor.Function;
                if (typeof f === 'object') {
                    f = f[item.value.name];
                }
                break;
            case 'var':
                f = isExit ? visitor.VariableExit : visitor.Variable;
                break;
            case 'env':
                f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
                if (typeof f === 'object') {
                    let name;
                    switch(item.value.name.type){
                        case 'ua':
                        case 'unknown':
                            name = item.value.name.value;
                            break;
                        case 'custom':
                            name = item.value.name.ident;
                            break;
                    }
                    f = f[name];
                }
                break;
            case 'color':
                f = visitor.Color;
                break;
            case 'url':
                f = visitor.Url;
                break;
            case 'length':
                f = visitor.Length;
                break;
            case 'angle':
                f = visitor.Angle;
                break;
            case 'time':
                f = visitor.Time;
                break;
            case 'resolution':
                f = visitor.Resolution;
                break;
            case 'dashed-ident':
                f = visitor.DashedIdent;
                break;
        }
        if (!f) {
            return;
        }
        let res = f(item.value);
        switch(item.type){
            case 'color':
            case 'url':
            case 'length':
            case 'angle':
            case 'time':
            case 'resolution':
            case 'dashed-ident':
                if (Array.isArray(res)) {
                    res = res.map((value)=>({
                            type: item.type,
                            value
                        }));
                } else if (res) {
                    res = {
                        type: item.type,
                        value: res
                    };
                }
                break;
        }
        return res;
    });
    return (value)=>v({
            type,
            value
        });
}
/**
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function extractFunctions(visitors, key) {
    let functions = [];
    for (let visitor of visitors){
        let f = visitor[key];
        if (f) {
            functions.push(f);
        }
    }
    return functions;
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeSimpleVisitors(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = (arg)=>{
        let mutated = false;
        for (let f of functions){
            let res = f(arg);
            if (res) {
                arg = res;
                mutated = true;
            }
        }
        return mutated ? arg : undefined;
    };
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeArrayFunctions(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = createArrayVisitor(functions, (f, item)=>f(item));
}
/**
 * @template T
 * @template V
 * @param {T[]} visitors 
 * @param {(visitor: T, item: V) => V | V[] | void} apply 
 * @returns {(item: V) => V | V[] | void}
 */ function createArrayVisitor(visitors, apply) {
    let seen = new Bitset(visitors.length);
    return (arg)=>{
        let arr = [
            arg
        ];
        let mutated = false;
        seen.clear();
        for(let i = 0; i < arr.length; i++){
            // For each value, call all visitors. If a visitor returns a new value,
            // we start over, but skip the visitor that generated the value or saw
            // it before (to avoid cycles). This way, visitors can be composed in any order. 
            for(let v = 0; v < visitors.length;){
                if (seen.get(v)) {
                    v++;
                    continue;
                }
                let item = arr[i];
                let visitor = visitors[v];
                let res = apply(visitor, item);
                if (Array.isArray(res)) {
                    if (res.length === 0) {
                        arr.splice(i, 1);
                    } else if (res.length === 1) {
                        arr[i] = res[0];
                    } else {
                        arr.splice(i, 1, ...res);
                    }
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else if (res) {
                    arr[i] = res;
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else {
                    v++;
                }
            }
        }
        if (!mutated) {
            return;
        }
        return arr.length === 1 ? arr[0] : arr;
    };
}
class Bitset {
    constructor(maxBits = 32){
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
    }
    /** @param {number} bit */ get(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            return Boolean(this.more[i] & 1 << b);
        } else {
            return Boolean(this.bits & 1 << bit);
        }
    }
    /** @param {number} bit */ set(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            this.more[i] |= 1 << b;
        } else {
            this.bits |= 1 << bit;
        }
    }
    clear() {
        this.bits = 0;
        if (this.more) {
            this.more.fill(0);
        }
    }
}
}}),
"[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This file is autogenerated by build-prefixes.js. DO NOT EDIT!
exports.Features = {
    Nesting: 1,
    NotSelectorList: 2,
    DirSelector: 4,
    LangSelectorList: 8,
    IsSelector: 16,
    TextDecorationThicknessPercent: 32,
    MediaIntervalSyntax: 64,
    MediaRangeSyntax: 128,
    CustomMediaQueries: 256,
    ClampFunction: 512,
    ColorFunction: 1024,
    OklabColors: 2048,
    LabColors: 4096,
    P3Colors: 8192,
    HexAlphaColors: 16384,
    SpaceSeparatedColorNotation: 32768,
    FontFamilySystemUi: 65536,
    DoublePositionGradients: 131072,
    VendorPrefixes: 262144,
    LogicalProperties: 524288,
    LightDark: 1048576,
    Selectors: 31,
    MediaQueries: 448,
    Colors: 1113088
};
}}),
"[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let parts = [
    process.platform,
    process.arch
];
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else if ("TURBOPACK compile-time truthy", 1) {
    parts.push('msvc');
}
if (process.env.CSS_TRANSFORMER_WASM) {
    module.exports = (()=>{
        const e = new Error("Cannot find module '../pkg'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
} else {
    try {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (err) {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    }
}
module.exports.browserslistToTargets = __turbopack_context__.r("[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)");
module.exports.composeVisitors = __turbopack_context__.r("[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)");
module.exports.Features = __turbopack_context__.r("[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)").Features;
}}),
"[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Features": (()=>Features),
    "browserslistToTargets": (()=>browserslistToTargets),
    "bundle": (()=>bundle),
    "bundleAsync": (()=>bundleAsync),
    "composeVisitors": (()=>composeVisitors),
    "transform": (()=>transform),
    "transformStyleAttribute": (()=>transformStyleAttribute)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)");
;
const { transform, transformStyleAttribute, bundle, bundleAsync, browserslistToTargets, composeVisitors, Features } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"];
;
}}),
"[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Instrumentation": (()=>nt),
    "__unstable__loadDesignSystem": (()=>ra),
    "compile": (()=>ta),
    "compileAst": (()=>ea),
    "env": (()=>te),
    "loadModule": (()=>rt),
    "normalizePath": (()=>me),
    "optimize": (()=>aa)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:module [external] (node:module, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jiti/lib/jiti.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$lib$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/lib.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-NZOSKIBJ.mjs [postcss] (ecmascript) <export e as __unstable__loadDesignSystem>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-NZOSKIBJ.mjs [postcss] (ecmascript) <export d as compile>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-NZOSKIBJ.mjs [postcss] (ecmascript) <export c as compileAst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@tailwindcss/node/dist/index.mjs")}`;
    }
};
var lt = Object.defineProperty;
var at = (e, r)=>{
    for(var t in r)lt(e, t, {
        get: r[t],
        enumerable: !0
    });
};
;
;
var te = {};
at(te, {
    DEBUG: ()=>ee
});
var ee = st(process.env.DEBUG);
function st(e) {
    if (e === void 0) return !1;
    if (e === "true" || e === "1") return !0;
    if (e === "false" || e === "0") return !1;
    if (e === "*") return !0;
    let r = e.split(",").map((t)=>t.split(":")[0]);
    return r.includes("-tailwindcss") ? !1 : !!r.includes("tailwindcss");
}
;
;
;
;
;
;
;
;
;
var ut = [
    /import[\s\S]*?['"](.{3,}?)['"]/gi,
    /import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /export[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /require\(['"`](.+)['"`]\)/gi
], ft = [
    ".js",
    ".cjs",
    ".mjs"
], ct = [
    "",
    ".js",
    ".cjs",
    ".mjs",
    ".ts",
    ".cts",
    ".mts",
    ".jsx",
    ".tsx"
], pt = [
    "",
    ".ts",
    ".cts",
    ".mts",
    ".tsx",
    ".js",
    ".cjs",
    ".mjs",
    ".jsx"
];
async function dt(e, r) {
    for (let t of r){
        let i = `${e}${t}`;
        if ((await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(i).catch(()=>null))?.isFile()) return i;
    }
    for (let t of r){
        let i = `${e}/index${t}`;
        if (await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].access(i).then(()=>!0, ()=>!1)) return i;
    }
    return null;
}
async function be(e, r, t, i) {
    let n = ft.includes(i) ? ct : pt, o = await dt(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(t, r), n);
    if (o === null || e.has(o)) return;
    e.add(o), t = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(o), i = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].extname(o);
    let l = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(o, "utf-8"), s = [];
    for (let a of ut)for (let u of l.matchAll(a))u[1].startsWith(".") && s.push(be(e, u[1], t, i));
    await Promise.all(s);
}
async function xe(e) {
    let r = new Set;
    return await be(r, e, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(e), __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].extname(e)), Array.from(r);
}
;
function ie(e) {
    return {
        kind: "word",
        value: e
    };
}
function mt(e, r) {
    return {
        kind: "function",
        value: e,
        nodes: r
    };
}
function gt(e) {
    return {
        kind: "separator",
        value: e
    };
}
function R(e, r, t = null) {
    for(let i = 0; i < e.length; i++){
        let n = e[i], o = !1, l = 0, s = r(n, {
            parent: t,
            replaceWith (a) {
                o || (o = !0, Array.isArray(a) ? a.length === 0 ? (e.splice(i, 1), l = 0) : a.length === 1 ? (e[i] = a[0], l = 1) : (e.splice(i, 1, ...a), l = a.length) : e[i] = a);
            }
        }) ?? 0;
        if (o) {
            s === 0 ? i-- : i += l - 1;
            continue;
        }
        if (s === 2) return 2;
        if (s !== 1 && n.kind === "function" && R(n.nodes, r, n) === 2) return 2;
    }
}
function N(e) {
    let r = "";
    for (let t of e)switch(t.kind){
        case "word":
        case "separator":
            {
                r += t.value;
                break;
            }
        case "function":
            r += t.value + "(" + N(t.nodes) + ")";
    }
    return r;
}
var Ae = 92, ht = 41, Ce = 58, $e = 44, vt = 34, Ne = 61, Se = 62, Te = 60, Ve = 10, wt = 40, kt = 39, Ee = 47, Re = 32, _e = 9;
function S(e) {
    e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], i = null, n = "", o;
    for(let l = 0; l < e.length; l++){
        let s = e.charCodeAt(l);
        switch(s){
            case Ae:
                {
                    n += e[l] + e[l + 1], l++;
                    break;
                }
            case Ce:
            case $e:
            case Ne:
            case Se:
            case Te:
            case Ve:
            case Ee:
            case Re:
            case _e:
                {
                    if (n.length > 0) {
                        let c = ie(n);
                        i ? i.nodes.push(c) : r.push(c), n = "";
                    }
                    let a = l, u = l + 1;
                    for(; u < e.length && (o = e.charCodeAt(u), !(o !== Ce && o !== $e && o !== Ne && o !== Se && o !== Te && o !== Ve && o !== Ee && o !== Re && o !== _e)); u++);
                    l = u - 1;
                    let f = gt(e.slice(a, u));
                    i ? i.nodes.push(f) : r.push(f);
                    break;
                }
            case kt:
            case vt:
                {
                    let a = l;
                    for(let u = l + 1; u < e.length; u++)if (o = e.charCodeAt(u), o === Ae) u += 1;
                    else if (o === s) {
                        l = u;
                        break;
                    }
                    n += e.slice(a, l + 1);
                    break;
                }
            case wt:
                {
                    let a = mt(n, []);
                    n = "", i ? i.nodes.push(a) : r.push(a), t.push(a), i = a;
                    break;
                }
            case ht:
                {
                    let a = t.pop();
                    if (n.length > 0) {
                        let u = ie(n);
                        a.nodes.push(u), n = "";
                    }
                    t.length > 0 ? i = t[t.length - 1] : i = null;
                    break;
                }
            default:
                n += String.fromCharCode(s);
        }
    }
    return n.length > 0 && r.push(ie(n)), r;
}
var yt = [
    "anchor-size"
], Tr = new RegExp(`(${yt.join("|")})\\(`, "g");
var Or = new Uint8Array(256);
var W = new Uint8Array(256);
function g(e, r) {
    let t = 0, i = [], n = 0, o = e.length, l = r.charCodeAt(0);
    for(let s = 0; s < o; s++){
        let a = e.charCodeAt(s);
        if (t === 0 && a === l) {
            i.push(e.slice(n, s)), n = s + 1;
            continue;
        }
        switch(a){
            case 92:
                s += 1;
                break;
            case 39:
            case 34:
                for(; ++s < o;){
                    let u = e.charCodeAt(s);
                    if (u === 92) {
                        s += 1;
                        continue;
                    }
                    if (u === a) break;
                }
                break;
            case 40:
                W[t] = 41, t++;
                break;
            case 91:
                W[t] = 93, t++;
                break;
            case 123:
                W[t] = 125, t++;
                break;
            case 93:
            case 125:
            case 41:
                t > 0 && a === W[t - 1] && t--;
                break;
        }
    }
    return i.push(e.slice(n)), i;
}
var v = class extends Map {
    constructor(t){
        super();
        this.factory = t;
    }
    get(t) {
        let i = super.get(t);
        return i === void 0 && (i = this.factory(t, this), this.set(t, i)), i;
    }
};
var x = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, Yr = new RegExp(`^${x.source}$`);
var Qr = new RegExp(`^${x.source}%$`);
var Zr = new RegExp(`^${x.source}s*/s*${x.source}$`);
var bt = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], Xr = new RegExp(`^${x.source}(${bt.join("|")})$`);
var xt = [
    "deg",
    "rad",
    "grad",
    "turn"
], ei = new RegExp(`^${x.source}(${xt.join("|")})$`);
var ti = new RegExp(`^${x.source} +${x.source} +${x.source}$`);
function k(e) {
    let r = Number(e);
    return Number.isInteger(r) && r >= 0 && String(r) === String(e);
}
function K(e, r) {
    if (r === null) return e;
    let t = Number(r);
    return Number.isNaN(t) || (r = `${t * 100}%`), r === "100%" ? e : `color-mix(in oklab, ${e} ${r}, transparent)`;
}
var $t = {
    "--alpha": Nt,
    "--spacing": St,
    "--theme": Tt,
    theme: Vt
};
function Nt(e, r, t, ...i) {
    let [n, o] = g(t, "/").map((l)=>l.trim());
    if (!n || !o) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${n || "var(--my-color)"} / ${o || "50%"})\``);
    if (i.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${n || "var(--my-color)"} / ${o || "50%"})\``);
    return K(n, o);
}
function St(e, r, t, ...i) {
    if (!t) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (i.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${i.length + 1}.`);
    let n = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!n) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${n} * ${t})`;
}
function Tt(e, r, t, ...i) {
    if (!t.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let n = !1;
    t.endsWith(" inline") && (n = !0, t = t.slice(0, -7)), r.kind === "at-rule" && (n = !0);
    let o = e.resolveThemeValue(t, n);
    if (!o) {
        if (i.length > 0) return i.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (i.length === 0) return o;
    let l = i.join(", ");
    if (l === "initial") return o;
    if (o === "initial") return l;
    if (o.startsWith("var(") || o.startsWith("theme(") || o.startsWith("--theme(")) {
        let s = S(o);
        return Rt(s, l), N(s);
    }
    return o;
}
function Vt(e, r, t, ...i) {
    t = Et(t);
    let n = e.resolveThemeValue(t);
    if (!n && i.length > 0) return i.join(", ");
    if (!n) throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return n;
}
var yi = new RegExp(Object.keys($t).map((e)=>`${e}\\(`).join("|"));
function Et(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let r = "", t = e[0];
    for(let i = 1; i < e.length - 1; i++){
        let n = e[i], o = e[i + 1];
        n === "\\" && (o === t || o === "\\") ? (r += o, i++) : r += n;
    }
    return r;
}
function Rt(e, r) {
    R(e, (t)=>{
        if (t.kind === "function" && !(t.value !== "var" && t.value !== "theme" && t.value !== "--theme")) if (t.nodes.length === 1) t.nodes.push({
            kind: "word",
            value: `, ${r}`
        });
        else {
            let i = t.nodes[t.nodes.length - 1];
            i.kind === "word" && i.value === "initial" && (i.value = r);
        }
    });
}
var I = 92, H = 47, q = 42, Kt = 34, Ft = 39, It = 58, G = 59, T = 10, z = 32, J = 9, Ke = 123, ae = 125, fe = 40, Fe = 41, zt = 91, jt = 93, Ie = 45, se = 64, Lt = 33;
function L(e) {
    e[0] === "\uFEFF" && (e = e.slice(1)), e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], i = [], n = null, o = null, l = "", s = "", a;
    for(let u = 0; u < e.length; u++){
        let f = e.charCodeAt(u);
        if (f === I) l += e.slice(u, u + 2), u += 1;
        else if (f === H && e.charCodeAt(u + 1) === q) {
            let c = u;
            for(let h = u + 2; h < e.length; h++)if (a = e.charCodeAt(h), a === I) h += 1;
            else if (a === q && e.charCodeAt(h + 1) === H) {
                u = h + 1;
                break;
            }
            let p = e.slice(c, u + 1);
            p.charCodeAt(2) === Lt && t.push(pe(p.slice(2, -2)));
        } else if (f === Ft || f === Kt) {
            let c = u;
            for(let p = u + 1; p < e.length; p++)if (a = e.charCodeAt(p), a === I) p += 1;
            else if (a === f) {
                u = p;
                break;
            } else {
                if (a === G && e.charCodeAt(p + 1) === T) throw new Error(`Unterminated string: ${e.slice(c, p + 1) + String.fromCharCode(f)}`);
                if (a === T) throw new Error(`Unterminated string: ${e.slice(c, p) + String.fromCharCode(f)}`);
            }
            l += e.slice(c, u + 1);
        } else {
            if ((f === z || f === T || f === J) && (a = e.charCodeAt(u + 1)) && (a === z || a === T || a === J)) continue;
            if (f === T) {
                if (l.length === 0) continue;
                a = l.charCodeAt(l.length - 1), a !== z && a !== T && a !== J && (l += " ");
            } else if (f === Ie && e.charCodeAt(u + 1) === Ie && l.length === 0) {
                let c = "", p = u, h = -1;
                for(let m = u + 2; m < e.length; m++)if (a = e.charCodeAt(m), a === I) m += 1;
                else if (a === H && e.charCodeAt(m + 1) === q) {
                    for(let E = m + 2; E < e.length; E++)if (a = e.charCodeAt(E), a === I) E += 1;
                    else if (a === q && e.charCodeAt(E + 1) === H) {
                        m = E + 1;
                        break;
                    }
                } else if (h === -1 && a === It) h = l.length + m - p;
                else if (a === G && c.length === 0) {
                    l += e.slice(p, m), u = m;
                    break;
                } else if (a === fe) c += ")";
                else if (a === zt) c += "]";
                else if (a === Ke) c += "}";
                else if ((a === ae || e.length - 1 === m) && c.length === 0) {
                    u = m - 1, l += e.slice(p, m);
                    break;
                } else (a === Fe || a === jt || a === ae) && c.length > 0 && e[m] === c[c.length - 1] && (c = c.slice(0, -1));
                let X = ue(l, h);
                if (!X) throw new Error("Invalid custom property, expected a value");
                n ? n.nodes.push(X) : r.push(X), l = "";
            } else if (f === G && l.charCodeAt(0) === se) o = j(l), n ? n.nodes.push(o) : r.push(o), l = "", o = null;
            else if (f === G && s[s.length - 1] !== ")") {
                let c = ue(l);
                if (!c) throw l.length === 0 ? new Error("Unexpected semicolon") : new Error(`Invalid declaration: \`${l.trim()}\``);
                n ? n.nodes.push(c) : r.push(c), l = "";
            } else if (f === Ke && s[s.length - 1] !== ")") s += "}", o = C(l.trim()), n && n.nodes.push(o), i.push(n), n = o, l = "", o = null;
            else if (f === ae && s[s.length - 1] !== ")") {
                if (s === "") throw new Error("Missing opening {");
                if (s = s.slice(0, -1), l.length > 0) if (l.charCodeAt(0) === se) o = j(l), n ? n.nodes.push(o) : r.push(o), l = "", o = null;
                else {
                    let p = l.indexOf(":");
                    if (n) {
                        let h = ue(l, p);
                        if (!h) throw new Error(`Invalid declaration: \`${l.trim()}\``);
                        n.nodes.push(h);
                    }
                }
                let c = i.pop() ?? null;
                c === null && n && r.push(n), n = c, l = "", o = null;
            } else if (f === fe) s += ")", l += "(";
            else if (f === Fe) {
                if (s[s.length - 1] !== ")") throw new Error("Missing opening (");
                s = s.slice(0, -1), l += ")";
            } else {
                if (l.length === 0 && (f === z || f === T || f === J)) continue;
                l += String.fromCharCode(f);
            }
        }
    }
    if (l.charCodeAt(0) === se && r.push(j(l)), s.length > 0 && n) {
        if (n.kind === "rule") throw new Error(`Missing closing } at ${n.selector}`);
        if (n.kind === "at-rule") throw new Error(`Missing closing } at ${n.name} ${n.params}`);
    }
    return t.length > 0 ? t.concat(r) : r;
}
function j(e, r = []) {
    for(let t = 5; t < e.length; t++){
        let i = e.charCodeAt(t);
        if (i === z || i === fe) {
            let n = e.slice(0, t).trim(), o = e.slice(t).trim();
            return y(n, o, r);
        }
    }
    return y(e.trim(), "", r);
}
function ue(e, r = e.indexOf(":")) {
    if (r === -1) return null;
    let t = e.indexOf("!important", r + 1);
    return A(e.slice(0, r).trim(), e.slice(r + 1, t === -1 ? e.length : t).trim(), t !== -1);
}
var de = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function V(e) {
    return {
        __BARE_VALUE__: e
    };
}
var b = V((e)=>{
    if (k(e.value)) return e.value;
}), d = V((e)=>{
    if (k(e.value)) return `${e.value}%`;
}), $ = V((e)=>{
    if (k(e.value)) return `${e.value}px`;
}), je = V((e)=>{
    if (k(e.value)) return `${e.value}ms`;
}), Y = V((e)=>{
    if (k(e.value)) return `${e.value}deg`;
}), Yt = V((e)=>{
    if (e.fraction === null) return;
    let [r, t] = g(e.fraction, "/");
    if (!(!k(r) || !k(t))) return e.fraction;
}), Le = V((e)=>{
    if (k(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), Qt = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ...Yt
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...d
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...d
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...d
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...Y
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...d
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...d
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...d
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...d
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...d
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...de
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...b
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...d
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...$
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...b
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...b
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...d
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...b
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...b
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...b
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...b
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Le
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Le
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...Y
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...b
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...d
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...b
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...Y
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...d
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...d
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...Y
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...b
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...$
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...je
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...je
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...b
    }
};
var Zt = 64;
function O(e, r = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: r
    };
}
function y(e, r = "", t = []) {
    return {
        kind: "at-rule",
        name: e,
        params: r,
        nodes: t
    };
}
function C(e, r = []) {
    return e.charCodeAt(0) === Zt ? j(e, r) : O(e, r);
}
function A(e, r, t = !1) {
    return {
        kind: "declaration",
        property: e,
        value: r,
        important: t
    };
}
function pe(e) {
    return {
        kind: "comment",
        value: e
    };
}
function w(e, r, t = [], i = {}) {
    for(let n = 0; n < e.length; n++){
        let o = e[n], l = t[t.length - 1] ?? null;
        if (o.kind === "context") {
            if (w(o.nodes, r, t, {
                ...i,
                ...o.context
            }) === 2) return 2;
            continue;
        }
        t.push(o);
        let s = !1, a = 0, u = r(o, {
            parent: l,
            context: i,
            path: t,
            replaceWith (f) {
                s || (s = !0, Array.isArray(f) ? f.length === 0 ? (e.splice(n, 1), a = 0) : f.length === 1 ? (e[n] = f[0], a = 1) : (e.splice(n, 1, ...f), a = f.length) : (e[n] = f, a = 1));
            }
        }) ?? 0;
        if (t.pop(), s) {
            u === 0 ? n-- : n += a - 1;
            continue;
        }
        if (u === 2) return 2;
        if (u !== 1 && "nodes" in o) {
            t.push(o);
            let f = w(o.nodes, r, t, i);
            if (t.pop(), f === 2) return 2;
        }
    }
}
function P(e) {
    function r(i, n = 0) {
        let o = "", l = "  ".repeat(n);
        if (i.kind === "declaration") o += `${l}${i.property}: ${i.value}${i.important ? " !important" : ""};
`;
        else if (i.kind === "rule") {
            o += `${l}${i.selector} {
`;
            for (let s of i.nodes)o += r(s, n + 1);
            o += `${l}}
`;
        } else if (i.kind === "at-rule") {
            if (i.nodes.length === 0) return `${l}${i.name} ${i.params};
`;
            o += `${l}${i.name}${i.params ? ` ${i.params} ` : " "}{
`;
            for (let s of i.nodes)o += r(s, n + 1);
            o += `${l}}
`;
        } else if (i.kind === "comment") o += `${l}/*${i.value}*/
`;
        else if (i.kind === "context" || i.kind === "at-root") return "";
        return o;
    }
    let t = "";
    for (let i of e){
        let n = r(i);
        n !== "" && (t += n);
    }
    return t;
}
function Xt(e, r) {
    if (typeof e != "string") throw new TypeError("expected path to be a string");
    if (e === "\\" || e === "/") return "/";
    var t = e.length;
    if (t <= 1) return e;
    var i = "";
    if (t > 4 && e[3] === "\\") {
        var n = e[2];
        (n === "?" || n === ".") && e.slice(0, 2) === "\\\\" && (e = e.slice(2), i = "//");
    }
    var o = e.split(/[/\\]+/);
    return r !== !1 && o[o.length - 1] === "" && o.pop(), i + o.join("/");
}
function me(e) {
    let r = Xt(e);
    return e.startsWith("\\\\") && r.startsWith("/") && !r.startsWith("//") ? `/${r}` : r;
}
var he = /(?<!@import\s+)(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/, Me = /(?<=image-set\()((?:[\w-]{1,256}\([^)]*\)|[^)])*)(?=\))/, er = /(?:gradient|element|cross-fade|image)\(/, tr = /^\s*data:/i, rr = /^([a-z]+:)?\/\//, ir = /^[A-Z_][.\w-]*\(/i, nr = /(?:^|\s)(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g, or = /(?<!\\)"/g, lr = /(?: |\\t|\\n|\\f|\\r)+/g, ar = (e)=>tr.test(e), sr = (e)=>rr.test(e);
async function We({ css: e, base: r, root: t }) {
    if (!e.includes("url(") && !e.includes("image-set(")) return e;
    let i = L(e), n = [];
    function o(l) {
        if (l[0] === "/") return l;
        let s = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["posix"].join(me(r), l), a = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["posix"].relative(me(t), s);
        return a.startsWith(".") || (a = "./" + a), a;
    }
    return w(i, (l)=>{
        if (l.kind !== "declaration" || !l.value) return;
        let s = he.test(l.value), a = Me.test(l.value);
        if (s || a) {
            let u = a ? ur : Be;
            n.push(u(l.value, o).then((f)=>{
                l.value = f;
            }));
        }
    }), n.length && await Promise.all(n), P(i);
}
function Be(e, r) {
    return qe(e, he, async (t)=>{
        let [i, n] = t;
        return await He(n.trim(), i, r);
    });
}
async function ur(e, r) {
    return await qe(e, Me, async (t)=>{
        let [, i] = t;
        return await cr(i, async ({ url: o })=>he.test(o) ? await Be(o, r) : er.test(o) ? o : await He(o, o, r));
    });
}
async function He(e, r, t, i = "url") {
    let n = "", o = e[0];
    if ((o === '"' || o === "'") && (n = o, e = e.slice(1, -1)), fr(e)) return r;
    let l = await t(e);
    return n === "" && l !== encodeURI(l) && (n = '"'), n === "'" && l.includes("'") && (n = '"'), n === '"' && l.includes('"') && (l = l.replace(or, '\\"')), `${i}(${n}${l}${n})`;
}
function fr(e, r) {
    return sr(e) || ar(e) || !e[0].match(/[\.a-zA-Z0-9_]/) || ir.test(e);
}
function cr(e, r) {
    return Promise.all(pr(e).map(async ({ url: t, descriptor: i })=>({
            url: await r({
                url: t,
                descriptor: i
            }),
            descriptor: i
        }))).then(dr);
}
function pr(e) {
    let r = e.trim().replace(lr, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(nr);
    return Array.from(r, ({ groups: t })=>({
            url: t?.url?.trim() ?? "",
            descriptor: t?.descriptor?.trim() ?? ""
        })).filter(({ url: t })=>!!t);
}
function dr(e) {
    return e.map(({ url: r, descriptor: t })=>r + (t ? ` ${t}` : "")).join(", ");
}
async function qe(e, r, t) {
    let i, n = e, o = "";
    for(; i = r.exec(n);)o += n.slice(0, i.index), o += await t(i), n = n.slice(i.index + i[0].length);
    return o += n, o;
}
function et({ base: e, polyfills: r, onDependency: t, shouldRewriteUrls: i, customCssResolver: n, customJsResolver: o }) {
    return {
        base: e,
        polyfills: r,
        async loadModule (l, s) {
            return rt(l, s, t, o);
        },
        async loadStylesheet (l, s) {
            let a = await it(l, s, t, n);
            return i && (a.content = await We({
                css: a.content,
                root: e,
                base: a.base
            })), a;
        }
    };
}
async function tt(e, r) {
    if (e.root && e.root !== "none") {
        let t = /[*{]/, i = [];
        for (let o of e.root.pattern.split("/")){
            if (t.test(o)) break;
            i.push(o);
        }
        if (!await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(r, i.join("/"))).then((o)=>o.isDirectory()).catch(()=>!1)) throw new Error(`The \`source(${e.root.pattern})\` does not exist`);
    }
}
async function ea(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__["compileAst"])(e, et(r));
    return await tt(t, r.base), t;
}
async function ta(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__["compile"])(e, et(r));
    return await tt(t, r.base), t;
}
async function ra(e, { base: r }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__["__unstable__loadDesignSystem"])(e, {
        base: r,
        async loadModule (t, i) {
            return rt(t, i, ()=>{});
        },
        async loadStylesheet (t, i) {
            return it(t, i, ()=>{});
        }
    });
}
async function rt(e, r, t, i) {
    if (e[0] !== ".") {
        let s = await Ze(e, r, i);
        if (!s) throw new Error(`Could not resolve '${e}' from '${r}'`);
        let a = await Qe((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(s).href);
        return {
            base: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["dirname"])(s),
            module: a.default ?? a
        };
    }
    let n = await Ze(e, r, i);
    if (!n) throw new Error(`Could not resolve '${e}' from '${r}'`);
    let [o, l] = await Promise.all([
        Qe((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(n).href + "?id=" + Date.now()),
        xe(n)
    ]);
    for (let s of l)t(s);
    return {
        base: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["dirname"])(n),
        module: o.default ?? o
    };
}
async function it(e, r, t, i) {
    let n = await kr(e, r, i);
    if (!n) throw new Error(`Could not resolve '${e}' from '${r}'`);
    if (t(n), typeof globalThis.__tw_readFile == "function") {
        let l = await globalThis.__tw_readFile(n, "utf-8");
        if (l) return {
            base: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(n),
            content: l
        };
    }
    let o = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(n, "utf-8");
    return {
        base: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(n),
        content: o
    };
}
var Ye = null;
async function Qe(e) {
    if (typeof globalThis.__tw_load == "function") {
        let r = await globalThis.__tw_load(e);
        if (r) return r;
    }
    try {
        return await Promise.resolve().then(()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        });
    } catch  {
        return Ye ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["createJiti"])(__TURBOPACK__import$2e$meta__.url, {
            moduleCache: !1,
            fsCache: !1
        }), await Ye.import(e);
    }
}
var ye = [
    "node_modules",
    ...process.env.NODE_PATH ? [
        process.env.NODE_PATH
    ] : []
], wr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".css"
    ],
    mainFields: [
        "style"
    ],
    conditionNames: [
        "style"
    ],
    modules: ye
});
async function kr(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return we(wr, e, r);
}
var yr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "import"
    ],
    modules: ye
}), br = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "require"
    ],
    modules: ye
});
async function Ze(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return we(yr, e, r).catch(()=>we(br, e, r));
}
function we(e, r, t) {
    return new Promise((i, n)=>e.resolve({}, t, r, {}, (o, l)=>{
            if (o) return n(o);
            i(l);
        }));
}
Symbol.dispose ??= Symbol("Symbol.dispose");
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
var nt = class {
    constructor(r = (t)=>void process.stderr.write(`${t}
`)){
        this.defaultFlush = r;
    }
    #r = new v(()=>({
            value: 0
        }));
    #t = new v(()=>({
            value: 0n
        }));
    #e = [];
    hit(r) {
        this.#r.get(r).value++;
    }
    start(r) {
        let t = this.#e.map((n)=>n.label).join("//"), i = `${t}${t.length === 0 ? "" : "//"}${r}`;
        this.#r.get(i).value++, this.#t.get(i), this.#e.push({
            id: i,
            label: r,
            namespace: t,
            value: process.hrtime.bigint()
        });
    }
    end(r) {
        let t = process.hrtime.bigint();
        if (this.#e[this.#e.length - 1].label !== r) throw new Error(`Mismatched timer label: \`${r}\`, expected \`${this.#e[this.#e.length - 1].label}\``);
        let i = this.#e.pop(), n = t - i.value;
        this.#t.get(i.id).value += n;
    }
    reset() {
        this.#r.clear(), this.#t.clear(), this.#e.splice(0);
    }
    report(r = this.defaultFlush) {
        let t = [], i = !1;
        for(let l = this.#e.length - 1; l >= 0; l--)this.end(this.#e[l].label);
        for (let [l, { value: s }] of this.#r.entries()){
            if (this.#t.has(l)) continue;
            t.length === 0 && (i = !0, t.push("Hits:"));
            let a = l.split("//").length;
            t.push(`${"  ".repeat(a)}${l} ${Q(ot(`\xD7 ${s}`))}`);
        }
        this.#t.size > 0 && i && t.push(`
Timers:`);
        let n = -1 / 0, o = new Map;
        for (let [l, { value: s }] of this.#t){
            let a = `${(Number(s) / 1e6).toFixed(2)}ms`;
            o.set(l, a), n = Math.max(n, a.length);
        }
        for (let l of this.#t.keys()){
            let s = l.split("//").length;
            t.push(`${Q(`[${o.get(l).padStart(n, " ")}]`)}${"  ".repeat(s - 1)}${s === 1 ? " " : Q(" \u21B3 ")}${l.split("//").pop()} ${this.#r.get(l).value === 1 ? "" : Q(ot(`\xD7 ${this.#r.get(l).value}`))}`.trimEnd());
        }
        r(`
${t.join(`
`)}
`), this.reset();
    }
    [Symbol.dispose]() {
        ee && this.report();
    }
};
function Q(e) {
    return `\x1B[2m${e}\x1B[22m`;
}
function ot(e) {
    return `\x1B[34m${e}\x1B[39m`;
}
;
function aa(e, { file: r = "input.css", minify: t = !1 } = {}) {
    function i(o) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["transform"])({
            filename: r,
            code: o,
            minify: t,
            sourceMap: !1,
            drafts: {
                customMedia: !0
            },
            nonStandard: {
                deepSelectorCombinator: !0
            },
            include: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].Nesting | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].MediaQueries,
            exclude: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LogicalProperties | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].DirSelector | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LightDark,
            targets: {
                safari: 16 << 16 | 1024,
                ios_saf: 16 << 16 | 1024,
                firefox: 8388608,
                chrome: 7274496
            },
            errorRecovery: !0
        }).code;
    }
    let n = i(i(Buffer.from(e))).toString();
    return n = n.replaceAll("@media not (", "@media not all and ("), n;
}
if (!process.versions.bun) {
    let e = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["createRequire"])(__TURBOPACK__import$2e$meta__.url);
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["register"]?.((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["pathToFileURL"])(e.resolve("@tailwindcss/node/esm-cache-loader")));
}
;
}}),
"[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:module [external] (node:module, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jiti/lib/jiti.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$lib$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/lib.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>");
}}),
"[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var i = Object.defineProperty;
var a = Object.getOwnPropertyDescriptor;
var f = Object.getOwnPropertyNames;
var l = Object.prototype.hasOwnProperty;
var n = (r, e)=>{
    for(var t in e)i(r, t, {
        get: e[t],
        enumerable: !0
    });
}, u = (r, e, t, o)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let c of f(e))!l.call(r, c) && c !== t && i(r, c, {
        get: ()=>e[c],
        enumerable: !(o = a(e, c)) || o.enumerable
    });
    return r;
};
var h = (r)=>u(i({}, "__esModule", {
        value: !0
    }), r);
var d = {};
n(d, {
    clearRequireCache: ()=>q
});
module.exports = h(d);
function q(r) {
    for (let e of r)delete __turbopack_context__.c[e];
}
0 && (module.exports = {
    clearRequireCache
});
}}),
"[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// prettier-ignore
/* eslint-disable */ // @ts-nocheck
/* auto-generated by NAPI-RS */ const { createRequire } = __turbopack_context__.r("[externals]/node:module [external] (node:module, cjs)");
"TURBOPACK member replacement", __turbopack_context__.t;
const { readFileSync } = __turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)");
let nativeBinding = null;
const loadErrors = [];
const isMusl = ()=>{
    let musl = false;
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    return musl;
};
const isFileMusl = (f)=>f.includes('libc.musl-') || f.includes('ld-musl-');
const isMuslFromFilesystem = ()=>{
    try {
        return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl');
    } catch  {
        return null;
    }
};
const isMuslFromReport = ()=>{
    let report = null;
    if (typeof process.report?.getReport === 'function') {
        process.report.excludeNetwork = true;
        report = process.report.getReport();
    }
    if (!report) {
        return null;
    }
    if (report.header && report.header.glibcVersionRuntime) {
        return false;
    }
    if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
            return true;
        }
    }
    return false;
};
const isMuslFromChildProcess = ()=>{
    try {
        return __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)").execSync('ldd --version', {
            encoding: 'utf8'
        }).includes('musl');
    } catch (e) {
        // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
        return false;
    }
};
function requireNative() {
    if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
        try {
            nativeBinding = (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            loadErrors.push(err);
        }
    } else if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    } else if ("TURBOPACK compile-time truthy", 1) {
        if ("TURBOPACK compile-time truthy", 1) {
            try {
                return (()=>{
                    const e = new Error("Cannot find module './tailwindcss-oxide.win32-x64-msvc.node'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch (e) {
                loadErrors.push(e);
            }
            try {
                return (()=>{
                    throw new Error('could not resolve "' + '@tailwindcss/oxide-win32-x64-msvc' + '" into a module');
                })();
            } catch (e) {
                loadErrors.push(e);
            }
        } else {
            "TURBOPACK unreachable";
        }
    } else {
        "TURBOPACK unreachable";
    }
}
nativeBinding = requireNative();
if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
    try {
        nativeBinding = (()=>{
            const e = new Error("Cannot find module './tailwindcss-oxide.wasi.cjs'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (err) {
        if (process.env.NAPI_RS_FORCE_WASI) {
            loadErrors.push(err);
        }
    }
    if (!nativeBinding) {
        try {
            nativeBinding = (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-wasm32-wasi'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            if (process.env.NAPI_RS_FORCE_WASI) {
                loadErrors.push(err);
            }
        }
    }
}
if (!nativeBinding) {
    if (loadErrors.length > 0) {
        // TODO Link to documentation with potential fixes
        //  - The package owner could build/publish bindings for this arch
        //  - The user may need to bundle the correct files
        //  - The user may need to re-install node_modules to get new packages
        throw new Error('Failed to load native binding', {
            cause: loadErrors
        });
    }
    throw new Error(`Failed to load native binding`);
}
module.exports.Scanner = nativeBinding.Scanner;
}}),
"[project]/node_modules/@tailwindcss/postcss/dist/index.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>il)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-NZOSKIBJ.mjs [postcss] (ecmascript) <export b as Features>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-NZOSKIBJ.mjs [postcss] (ecmascript) <export a as Polyfills>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/postcss/lib/postcss.mjs [postcss] (ecmascript)");
var ae = (e, o)=>(o = Symbol[e]) ? o : Symbol.for("Symbol." + e), se = (e)=>{
    throw TypeError(e);
};
var ue = (e, o, i)=>{
    if (o != null) {
        typeof o != "object" && typeof o != "function" && se("Object expected");
        var t, n;
        i && (t = o[ae("asyncDispose")]), t === void 0 && (t = o[ae("dispose")], i && (n = t)), typeof t != "function" && se("Object not disposable"), n && (t = function() {
            try {
                n.call(this);
            } catch (r) {
                return Promise.reject(r);
            }
        }), e.push([
            i,
            t,
            o
        ]);
    } else i && e.push([
        i
    ]);
    return o;
}, fe = (e, o, i)=>{
    var t = typeof SuppressedError == "function" ? SuppressedError : function(l, s, a, f) {
        return f = Error(a), f.name = "SuppressedError", f.error = l, f.suppressed = s, f;
    }, n = (l)=>o = i ? new t(l, o, "An error was suppressed during disposal") : (i = !0, l), r = (l)=>{
        for(; l = e.pop();)try {
            var s = l[1] && l[1].call(l[2]);
            if (l[0]) return Promise.resolve(s).then(r, (a)=>(n(a), r()));
        } catch (a) {
            n(a);
        }
        if (i) throw o;
    };
    return r();
};
;
;
;
;
;
;
;
function q(e) {
    return {
        kind: "word",
        value: e
    };
}
function De(e, o) {
    return {
        kind: "function",
        value: e,
        nodes: o
    };
}
function ze(e) {
    return {
        kind: "separator",
        value: e
    };
}
function O(e, o, i = null) {
    for(let t = 0; t < e.length; t++){
        let n = e[t], r = !1, l = 0, s = o(n, {
            parent: i,
            replaceWith (a) {
                r || (r = !0, Array.isArray(a) ? a.length === 0 ? (e.splice(t, 1), l = 0) : a.length === 1 ? (e[t] = a[0], l = 1) : (e.splice(t, 1, ...a), l = a.length) : e[t] = a);
            }
        }) ?? 0;
        if (r) {
            s === 0 ? t-- : t += l - 1;
            continue;
        }
        if (s === 2) return 2;
        if (s !== 1 && n.kind === "function" && O(n.nodes, o, n) === 2) return 2;
    }
}
function V(e) {
    let o = "";
    for (let i of e)switch(i.kind){
        case "word":
        case "separator":
            {
                o += i.value;
                break;
            }
        case "function":
            o += i.value + "(" + V(i.nodes) + ")";
    }
    return o;
}
var ce = 92, Ie = 41, pe = 58, de = 44, Fe = 34, me = 61, ge = 62, he = 60, ve = 10, Le = 40, je = 39, we = 47, ke = 32, ye = 9;
function E(e) {
    e = e.replaceAll(`\r
`, `
`);
    let o = [], i = [], t = null, n = "", r;
    for(let l = 0; l < e.length; l++){
        let s = e.charCodeAt(l);
        switch(s){
            case ce:
                {
                    n += e[l] + e[l + 1], l++;
                    break;
                }
            case pe:
            case de:
            case me:
            case ge:
            case he:
            case ve:
            case we:
            case ke:
            case ye:
                {
                    if (n.length > 0) {
                        let k = q(n);
                        t ? t.nodes.push(k) : o.push(k), n = "";
                    }
                    let a = l, f = l + 1;
                    for(; f < e.length && (r = e.charCodeAt(f), !(r !== pe && r !== de && r !== me && r !== ge && r !== he && r !== ve && r !== we && r !== ke && r !== ye)); f++);
                    l = f - 1;
                    let T = ze(e.slice(a, f));
                    t ? t.nodes.push(T) : o.push(T);
                    break;
                }
            case je:
            case Fe:
                {
                    let a = l;
                    for(let f = l + 1; f < e.length; f++)if (r = e.charCodeAt(f), r === ce) f += 1;
                    else if (r === s) {
                        l = f;
                        break;
                    }
                    n += e.slice(a, l + 1);
                    break;
                }
            case Le:
                {
                    let a = De(n, []);
                    n = "", t ? t.nodes.push(a) : o.push(a), i.push(a), t = a;
                    break;
                }
            case Ie:
                {
                    let a = i.pop();
                    if (n.length > 0) {
                        let f = q(n);
                        a.nodes.push(f), n = "";
                    }
                    i.length > 0 ? t = i[i.length - 1] : t = null;
                    break;
                }
            default:
                n += String.fromCharCode(s);
        }
    }
    return n.length > 0 && o.push(q(n)), o;
}
var Me = [
    "anchor-size"
], Rt = new RegExp(`(${Me.join("|")})\\(`, "g");
var Ut = new Uint8Array(256);
var L = new Uint8Array(256);
function m(e, o) {
    let i = 0, t = [], n = 0, r = e.length, l = o.charCodeAt(0);
    for(let s = 0; s < r; s++){
        let a = e.charCodeAt(s);
        if (i === 0 && a === l) {
            t.push(e.slice(n, s)), n = s + 1;
            continue;
        }
        switch(a){
            case 92:
                s += 1;
                break;
            case 39:
            case 34:
                for(; ++s < r;){
                    let f = e.charCodeAt(s);
                    if (f === 92) {
                        s += 1;
                        continue;
                    }
                    if (f === a) break;
                }
                break;
            case 40:
                L[i] = 41, i++;
                break;
            case 91:
                L[i] = 93, i++;
                break;
            case 123:
                L[i] = 125, i++;
                break;
            case 93:
            case 125:
            case 41:
                i > 0 && a === L[i - 1] && i--;
                break;
        }
    }
    return t.push(e.slice(n)), t;
}
var x = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, Xt = new RegExp(`^${x.source}$`);
var er = new RegExp(`^${x.source}%$`);
var tr = new RegExp(`^${x.source}s*/s*${x.source}$`);
var We = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], rr = new RegExp(`^${x.source}(${We.join("|")})$`);
var Be = [
    "deg",
    "rad",
    "grad",
    "turn"
], ir = new RegExp(`^${x.source}(${Be.join("|")})$`);
var nr = new RegExp(`^${x.source} +${x.source} +${x.source}$`);
function h(e) {
    let o = Number(e);
    return Number.isInteger(o) && o >= 0 && String(o) === String(e);
}
function D(e, o) {
    if (o === null) return e;
    let i = Number(o);
    return Number.isNaN(i) || (o = `${i * 100}%`), o === "100%" ? e : `color-mix(in oklab, ${e} ${o}, transparent)`;
}
var Ge = {
    "--alpha": Ye,
    "--spacing": Je,
    "--theme": Qe,
    theme: Ze
};
function Ye(e, o, i, ...t) {
    let [n, r] = m(i, "/").map((l)=>l.trim());
    if (!n || !r) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${n || "var(--my-color)"} / ${r || "50%"})\``);
    if (t.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${n || "var(--my-color)"} / ${r || "50%"})\``);
    return D(n, r);
}
function Je(e, o, i, ...t) {
    if (!i) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (t.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${t.length + 1}.`);
    let n = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!n) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${n} * ${i})`;
}
function Qe(e, o, i, ...t) {
    if (!i.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let n = !1;
    i.endsWith(" inline") && (n = !0, i = i.slice(0, -7)), o.kind === "at-rule" && (n = !0);
    let r = e.resolveThemeValue(i, n);
    if (!r) {
        if (t.length > 0) return t.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${i})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (t.length === 0) return r;
    let l = t.join(", ");
    if (l === "initial") return r;
    if (r === "initial") return l;
    if (r.startsWith("var(") || r.startsWith("theme(") || r.startsWith("--theme(")) {
        let s = E(r);
        return et(s, l), V(s);
    }
    return r;
}
function Ze(e, o, i, ...t) {
    i = Xe(i);
    let n = e.resolveThemeValue(i);
    if (!n && t.length > 0) return t.join(", ");
    if (!n) throw new Error(`Could not resolve value for theme function: \`theme(${i})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return n;
}
var Ar = new RegExp(Object.keys(Ge).map((e)=>`${e}\\(`).join("|"));
function Xe(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let o = "", i = e[0];
    for(let t = 1; t < e.length - 1; t++){
        let n = e[t], r = e[t + 1];
        n === "\\" && (r === i || r === "\\") ? (o += r, t++) : o += n;
    }
    return o;
}
function et(e, o) {
    O(e, (i)=>{
        if (i.kind === "function" && !(i.value !== "var" && i.value !== "theme" && i.value !== "--theme")) if (i.nodes.length === 1) i.nodes.push({
            kind: "word",
            value: `, ${o}`
        });
        else {
            let t = i.nodes[i.nodes.length - 1];
            t.kind === "word" && t.value === "initial" && (t.value = o);
        }
    });
}
var lt = 32;
var at = 40;
function Ne(e, o = []) {
    for(let i = 5; i < e.length; i++){
        let t = e.charCodeAt(i);
        if (t === lt || t === at) {
            let n = e.slice(0, i).trim(), r = e.slice(i).trim();
            return g(n, r, o);
        }
    }
    return g(e.trim(), "", o);
}
var Z = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function P(e) {
    return {
        __BARE_VALUE__: e
    };
}
var w = P((e)=>{
    if (h(e.value)) return e.value;
}), d = P((e)=>{
    if (h(e.value)) return `${e.value}%`;
}), S = P((e)=>{
    if (h(e.value)) return `${e.value}px`;
}), Te = P((e)=>{
    if (h(e.value)) return `${e.value}ms`;
}), W = P((e)=>{
    if (h(e.value)) return `${e.value}deg`;
}), gt = P((e)=>{
    if (e.fraction === null) return;
    let [o, i] = m(e.fraction, "/");
    if (!(!h(o) || !h(i))) return e.fraction;
}), Ve = P((e)=>{
    if (h(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), ht = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ...gt
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...d
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...d
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...d
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...W
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...d
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...d
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...d
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...d
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...d
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...Z
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...w
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...d
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...S
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...w
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...w
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...d
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...w
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...w
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...w
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...w
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Ve
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Ve
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...W
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...w
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...d
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...w
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...W
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...d
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...d
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...d
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...W
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...w
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...S
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Te
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Te
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...w
    }
};
var vt = 64;
function K(e, o = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: o
    };
}
function g(e, o = "", i = []) {
    return {
        kind: "at-rule",
        name: e,
        params: o,
        nodes: i
    };
}
function A(e, o = []) {
    return e.charCodeAt(0) === vt ? Ne(e, o) : K(e, o);
}
function b(e, o, i = !1) {
    return {
        kind: "declaration",
        property: e,
        value: o,
        important: i
    };
}
function M(e) {
    return {
        kind: "comment",
        value: e
    };
}
function U(e) {
    function o(t, n = 0) {
        let r = "", l = "  ".repeat(n);
        if (t.kind === "declaration") r += `${l}${t.property}: ${t.value}${t.important ? " !important" : ""};
`;
        else if (t.kind === "rule") {
            r += `${l}${t.selector} {
`;
            for (let s of t.nodes)r += o(s, n + 1);
            r += `${l}}
`;
        } else if (t.kind === "at-rule") {
            if (t.nodes.length === 0) return `${l}${t.name} ${t.params};
`;
            r += `${l}${t.name}${t.params ? ` ${t.params} ` : " "}{
`;
            for (let s of t.nodes)r += o(s, n + 1);
            r += `${l}}
`;
        } else if (t.kind === "comment") r += `${l}/*${t.value}*/
`;
        else if (t.kind === "context" || t.kind === "at-root") return "";
        return r;
    }
    let i = "";
    for (let t of e){
        let n = o(t);
        n !== "" && (i += n);
    }
    return i;
}
;
var wt = 33;
function Ee(e, o) {
    let i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root();
    i.source = o;
    function t(n, r) {
        if (n.kind === "declaration") {
            let l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].decl({
                prop: n.property,
                value: n.value ?? "",
                important: n.important
            });
            l.source = o, r.append(l);
        } else if (n.kind === "rule") {
            let l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].rule({
                selector: n.selector
            });
            l.source = o, l.raws.semicolon = !0, r.append(l);
            for (let s of n.nodes)t(s, l);
        } else if (n.kind === "at-rule") {
            let l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].atRule({
                name: n.name.slice(1),
                params: n.params
            });
            l.source = o, l.raws.semicolon = !0, r.append(l);
            for (let s of n.nodes)t(s, l);
        } else if (n.kind === "comment") {
            let l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].comment({
                text: n.value
            });
            l.raws.left = "", l.raws.right = "", l.source = o, r.append(l);
        } else n.kind === "at-root" || n.kind;
    }
    for (let n of e)t(n, i);
    return i;
}
function Re(e) {
    function o(t, n) {
        if (t.type === "decl") n.push(b(t.prop, t.value, t.important));
        else if (t.type === "rule") {
            let r = A(t.selector);
            t.each((l)=>o(l, r.nodes)), n.push(r);
        } else if (t.type === "atrule") {
            let r = g(`@${t.name}`, t.params);
            t.each((l)=>o(l, r.nodes)), n.push(r);
        } else if (t.type === "comment") {
            if (t.text.charCodeAt(0) !== wt) return;
            n.push(M(t.text));
        }
    }
    let i = [];
    return e.each((t)=>o(t, i)), i;
}
;
;
var X = "'", ee = '"';
function te() {
    let e = new WeakSet;
    function o(i) {
        let t = i.root().source?.input.file;
        if (!t) return;
        let n = i.source?.input.file;
        if (!n || e.has(i)) return;
        let r = i.params[0], l = r[0] === ee && r[r.length - 1] === ee ? ee : r[0] === X && r[r.length - 1] === X ? X : null;
        if (!l) return;
        let s = i.params.slice(1, -1), a = "";
        if (s.startsWith("!") && (s = s.slice(1), a = "!"), !s.startsWith("./") && !s.startsWith("../")) return;
        let f = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].posix.join((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(n)), s), T = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].posix.dirname((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(t)), k = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].posix.relative(T, f);
        k.startsWith(".") || (k = "./" + k), i.params = l + a + k + l, e.add(i);
    }
    return {
        postcssPlugin: "tailwindcss-postcss-fix-relative-paths",
        Once (i) {
            i.walkAtRules(/source|plugin|config/, o);
        }
    };
}
var u = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["env"].DEBUG, ne = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"]({
    maxSize: 50
});
function $t(e, o) {
    let i = `${e}:${o.base ?? ""}:${JSON.stringify(o.optimize)}`;
    if (ne.has(i)) return ne.get(i);
    let t = {
        mtimes: new Map,
        compiler: null,
        scanner: null,
        tailwindCssAst: [],
        cachedPostCssAst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root(),
        optimizedPostCssAst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root(),
        fullRebuildPaths: []
    };
    return ne.set(i, t), t;
}
function Tt(e = {}) {
    let o = e.base ?? process.cwd(), i = e.optimize ?? process.env.NODE_ENV === "production";
    return {
        postcssPlugin: "@tailwindcss/postcss",
        plugins: [
            te(),
            {
                postcssPlugin: "tailwindcss",
                async Once (t, { result: n }) {
                    var le = [];
                    try {
                        let r = ue(le, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Instrumentation"]);
                        let l = n.opts.from ?? "";
                        let s = l.endsWith(".module.css");
                        u && r.start(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["relative"])(o, l)}`);
                        {
                            u && r.start("Quick bail check");
                            let v = !0;
                            if (t.walkAtRules((c)=>{
                                if (c.name === "import" || c.name === "reference" || c.name === "theme" || c.name === "variant" || c.name === "config" || c.name === "plugin" || c.name === "apply" || c.name === "tailwind") return v = !1, !1;
                            }), v) return;
                            u && r.end("Quick bail check");
                        }
                        let a = $t(l, e);
                        let f = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(l));
                        let T = a.compiler === null;
                        async function k() {
                            u && r.start("Setup compiler"), a.fullRebuildPaths.length > 0 && !T && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["clearRequireCache"])(a.fullRebuildPaths), a.fullRebuildPaths = [], u && r.start("PostCSS AST -> Tailwind CSS AST");
                            let v = Re(t);
                            u && r.end("PostCSS AST -> Tailwind CSS AST"), u && r.start("Create compiler");
                            let c = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["compileAst"])(v, {
                                base: f,
                                shouldRewriteUrls: !0,
                                onDependency: (H)=>a.fullRebuildPaths.push(H),
                                polyfills: s ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].AtProperty : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All
                            });
                            return u && r.end("Create compiler"), u && r.end("Setup compiler"), c;
                        }
                        try {
                            if (a.compiler ??= k(), (await a.compiler).features === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].None) return;
                            let v = "incremental";
                            u && r.start("Register full rebuild paths");
                            {
                                for (let p of a.fullRebuildPaths)n.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(p),
                                    parent: n.opts.from
                                });
                                let C = n.messages.flatMap((p)=>p.type !== "dependency" ? [] : p.file);
                                C.push(l);
                                for (let p of C){
                                    let y = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].statSync(p, {
                                        throwIfNoEntry: !1
                                    })?.mtimeMs ?? null;
                                    if (y === null) {
                                        p === l && (v = "full");
                                        continue;
                                    }
                                    a.mtimes.get(p) !== y && (v = "full", a.mtimes.set(p, y));
                                }
                            }
                            u && r.end("Register full rebuild paths"), v === "full" && !T && (a.compiler = k());
                            let c = await a.compiler;
                            if (a.scanner === null || v === "full") {
                                u && r.start("Setup scanner");
                                let C = (c.root === "none" ? [] : c.root === null ? [
                                    {
                                        base: o,
                                        pattern: "**/*",
                                        negated: !1
                                    }
                                ] : [
                                    {
                                        ...c.root,
                                        negated: !1
                                    }
                                ]).concat(c.sources);
                                a.scanner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["Scanner"]({
                                    sources: C
                                }), u && r.end("Setup scanner");
                            }
                            u && r.start("Scan for candidates");
                            let H = c.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities ? a.scanner.scan() : [];
                            if (u && r.end("Scan for candidates"), c.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$NZOSKIBJ$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities) {
                                u && r.start("Register dependency messages");
                                let C = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(o, l);
                                for (let p of a.scanner.files){
                                    let y = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(p);
                                    y !== C && n.messages.push({
                                        type: "dependency",
                                        plugin: "@tailwindcss/postcss",
                                        file: y,
                                        parent: n.opts.from
                                    });
                                }
                                for (let { base: p, pattern: y } of a.scanner.globs)y === "*" && o === p || (y === "" ? n.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(p),
                                    parent: n.opts.from
                                }) : n.messages.push({
                                    type: "dir-dependency",
                                    plugin: "@tailwindcss/postcss",
                                    dir: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(p),
                                    glob: y,
                                    parent: n.opts.from
                                }));
                                u && r.end("Register dependency messages");
                            }
                            u && r.start("Build utilities");
                            let F = c.build(H);
                            if (u && r.end("Build utilities"), a.tailwindCssAst !== F) if (i) {
                                u && r.start("Optimization"), u && r.start("AST -> CSS");
                                let C = U(F);
                                u && r.end("AST -> CSS"), u && r.start("Lightning CSS");
                                let p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["optimize"])(C, {
                                    minify: typeof i == "object" ? i.minify : !0
                                });
                                u && r.end("Lightning CSS"), u && r.start("CSS -> PostCSS AST"), a.optimizedPostCssAst = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].parse(p, n.opts), u && r.end("CSS -> PostCSS AST"), u && r.end("Optimization");
                            } else u && r.start("Transform Tailwind CSS AST into PostCSS AST"), a.cachedPostCssAst = Ee(F, t.source), u && r.end("Transform Tailwind CSS AST into PostCSS AST");
                            a.tailwindCssAst = F, u && r.start("Update PostCSS AST"), t.removeAll(), t.append(i ? a.optimizedPostCssAst.clone().nodes : a.cachedPostCssAst.clone().nodes), t.raws.indent = "  ", u && r.end("Update PostCSS AST"), u && r.end(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["relative"])(o, l)}`);
                        } catch (v) {
                            a.compiler = null;
                            for (let c of a.fullRebuildPaths)n.messages.push({
                                type: "dependency",
                                plugin: "@tailwindcss/postcss",
                                file: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(c),
                                parent: n.opts.from
                            });
                            console.error(v), t.removeAll();
                        }
                    } catch (_e) {
                        var Ke = _e, Ue = !0;
                    } finally{
                        fe(le, Ke, Ue);
                    }
                }
            }
        ]
    };
}
var il = Object.assign(Tt, {
    postcss: !0
});
;
}}),

};

//# sourceMappingURL=node_modules_b1456cfd._.js.map