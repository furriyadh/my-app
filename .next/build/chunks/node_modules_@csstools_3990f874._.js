module.exports = {

"[project]/node_modules/@csstools/postcss-initial/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const o = new Map([
    [
        "animation",
        "none 0s ease 0s 1 normal none running"
    ],
    [
        "animation-delay",
        "0s"
    ],
    [
        "animation-direction",
        "normal"
    ],
    [
        "animation-duration",
        "0s"
    ],
    [
        "animation-fill-mode",
        "none"
    ],
    [
        "animation-iteration-count",
        "1"
    ],
    [
        "animation-name",
        "none"
    ],
    [
        "animation-play-state",
        "running"
    ],
    [
        "animation-timing-function",
        "ease"
    ],
    [
        "backface-visibility",
        "visible"
    ],
    [
        "background",
        "transparent none repeat 0 0 / auto auto padding-box border-box scroll"
    ],
    [
        "background-attachment",
        "scroll"
    ],
    [
        "background-clip",
        "border-box"
    ],
    [
        "background-color",
        "transparent"
    ],
    [
        "background-image",
        "none"
    ],
    [
        "background-origin",
        "padding-box"
    ],
    [
        "background-position",
        "0 0"
    ],
    [
        "background-position-x",
        "0"
    ],
    [
        "background-position-y",
        "0"
    ],
    [
        "background-repeat",
        "repeat"
    ],
    [
        "background-size",
        "auto auto"
    ],
    [
        "border",
        "medium none currentcolor"
    ],
    [
        "border-style",
        "none"
    ],
    [
        "border-width",
        "medium"
    ],
    [
        "border-color",
        "currentcolor"
    ],
    [
        "border-bottom",
        "0"
    ],
    [
        "border-bottom-color",
        "currentcolor"
    ],
    [
        "border-bottom-left-radius",
        "0"
    ],
    [
        "border-bottom-right-radius",
        "0"
    ],
    [
        "border-bottom-style",
        "none"
    ],
    [
        "border-bottom-width",
        "medium"
    ],
    [
        "border-collapse",
        "separate"
    ],
    [
        "border-image",
        "none"
    ],
    [
        "border-left",
        "0"
    ],
    [
        "border-left-color",
        "currentcolor"
    ],
    [
        "border-left-style",
        "none"
    ],
    [
        "border-left-width",
        "medium"
    ],
    [
        "border-radius",
        "0"
    ],
    [
        "border-right",
        "0"
    ],
    [
        "border-right-color",
        "currentcolor"
    ],
    [
        "border-right-style",
        "none"
    ],
    [
        "border-right-width",
        "medium"
    ],
    [
        "border-spacing",
        "0"
    ],
    [
        "border-top",
        "0"
    ],
    [
        "border-top-color",
        "currentcolor"
    ],
    [
        "border-top-left-radius",
        "0"
    ],
    [
        "border-top-right-radius",
        "0"
    ],
    [
        "border-top-style",
        "none"
    ],
    [
        "border-top-width",
        "medium"
    ],
    [
        "bottom",
        "auto"
    ],
    [
        "box-shadow",
        "none"
    ],
    [
        "box-sizing",
        "content-box"
    ],
    [
        "caption-side",
        "top"
    ],
    [
        "clear",
        "none"
    ],
    [
        "clip",
        "auto"
    ],
    [
        "color",
        "#000"
    ],
    [
        "columns",
        "auto"
    ],
    [
        "column-count",
        "auto"
    ],
    [
        "column-fill",
        "balance"
    ],
    [
        "column-gap",
        "normal"
    ],
    [
        "column-rule",
        "medium none currentcolor"
    ],
    [
        "column-rule-color",
        "currentcolor"
    ],
    [
        "column-rule-style",
        "none"
    ],
    [
        "column-rule-width",
        "medium"
    ],
    [
        "column-span",
        "1"
    ],
    [
        "column-width",
        "auto"
    ],
    [
        "content",
        "normal"
    ],
    [
        "counter-increment",
        "none"
    ],
    [
        "counter-reset",
        "none"
    ],
    [
        "cursor",
        "auto"
    ],
    [
        "direction",
        "ltr"
    ],
    [
        "display",
        "inline"
    ],
    [
        "empty-cells",
        "show"
    ],
    [
        "float",
        "none"
    ],
    [
        "font-family",
        "serif"
    ],
    [
        "font-size",
        "medium"
    ],
    [
        "font-style",
        "normal"
    ],
    [
        "font-variant",
        "normal"
    ],
    [
        "font-weight",
        "normal"
    ],
    [
        "font-stretch",
        "normal"
    ],
    [
        "line-height",
        "normal"
    ],
    [
        "height",
        "auto"
    ],
    [
        "hyphens",
        "none"
    ],
    [
        "left",
        "auto"
    ],
    [
        "letter-spacing",
        "normal"
    ],
    [
        "list-style",
        "disc outside none"
    ],
    [
        "list-style-image",
        "none"
    ],
    [
        "list-style-position",
        "outside"
    ],
    [
        "list-style-type",
        "disc"
    ],
    [
        "margin",
        "0"
    ],
    [
        "margin-bottom",
        "0"
    ],
    [
        "margin-left",
        "0"
    ],
    [
        "margin-right",
        "0"
    ],
    [
        "margin-top",
        "0"
    ],
    [
        "max-height",
        "none"
    ],
    [
        "max-width",
        "none"
    ],
    [
        "min-height",
        "0"
    ],
    [
        "min-width",
        "0"
    ],
    [
        "opacity",
        "1"
    ],
    [
        "orphans",
        "2"
    ],
    [
        "outline",
        "medium none currentcolor"
    ],
    [
        "outline-color",
        "currentcolor"
    ],
    [
        "outline-style",
        "none"
    ],
    [
        "outline-width",
        "medium"
    ],
    [
        "overflow",
        "visible"
    ],
    [
        "overflow-x",
        "visible"
    ],
    [
        "overflow-y",
        "visible"
    ],
    [
        "padding",
        "0"
    ],
    [
        "padding-bottom",
        "0"
    ],
    [
        "padding-left",
        "0"
    ],
    [
        "padding-right",
        "0"
    ],
    [
        "padding-top",
        "0"
    ],
    [
        "page-break-after",
        "auto"
    ],
    [
        "page-break-before",
        "auto"
    ],
    [
        "page-break-inside",
        "auto"
    ],
    [
        "perspective",
        "none"
    ],
    [
        "perspective-origin",
        "50% 50%"
    ],
    [
        "position",
        "static"
    ],
    [
        "quotes",
        '"“" "”" "‘" "’"'
    ],
    [
        "right",
        "auto"
    ],
    [
        "tab-size",
        "8"
    ],
    [
        "table-layout",
        "auto"
    ],
    [
        "text-align",
        "left"
    ],
    [
        "text-align-last",
        "auto"
    ],
    [
        "text-decoration",
        "none"
    ],
    [
        "text-decoration-color",
        "currentcolor"
    ],
    [
        "text-decoration-line",
        "none"
    ],
    [
        "text-decoration-style",
        "solid"
    ],
    [
        "text-indent",
        "0"
    ],
    [
        "text-shadow",
        "none"
    ],
    [
        "text-transform",
        "none"
    ],
    [
        "top",
        "auto"
    ],
    [
        "transform",
        "none"
    ],
    [
        "transform-origin",
        "50% 50% 0"
    ],
    [
        "transform-style",
        "flat"
    ],
    [
        "transition",
        "none 0s ease 0s"
    ],
    [
        "transition-delay",
        "0s"
    ],
    [
        "transition-duration",
        "0s"
    ],
    [
        "transition-property",
        "none"
    ],
    [
        "transition-timing-function",
        "ease"
    ],
    [
        "unicode-bidi",
        "normal"
    ],
    [
        "vertical-align",
        "baseline"
    ],
    [
        "visibility",
        "visible"
    ],
    [
        "white-space",
        "normal"
    ],
    [
        "widows",
        "2"
    ],
    [
        "width",
        "auto"
    ],
    [
        "word-spacing",
        "normal"
    ],
    [
        "z-index",
        "auto"
    ]
]), t = [
    "animation",
    "backface-visibility",
    "background",
    "border",
    "border-collapse",
    "border-image",
    "border-radius",
    "border-spacing",
    "bottom",
    "box-shadow",
    "box-sizing",
    "caption-side",
    "clear",
    "clip",
    "color",
    "columns",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-span",
    "column-width",
    "content",
    "counter-increment",
    "counter-reset",
    "cursor",
    "display",
    "empty-cells",
    "float",
    "font-family",
    "font-size",
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "line-height",
    "font",
    "height",
    "hyphens",
    "left",
    "letter-spacing",
    "list-style",
    "margin",
    "max-height",
    "max-width",
    "min-height",
    "min-width",
    "opacity",
    "orphans",
    "outline",
    "overflow",
    "overflow-x",
    "overflow-y",
    "padding",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "perspective",
    "perspective-origin",
    "position",
    "right",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-last",
    "text-decoration",
    "text-indent",
    "text-shadow",
    "text-transform",
    "top",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "vertical-align",
    "visibility",
    "white-space",
    "widows",
    "width",
    "word-spacing",
    "z-index"
];
function hasExactFallback(o, t) {
    const e = o.parent;
    if (!e) return !1;
    const n = o.prop.toLowerCase();
    for(let r = e.index(o) - 1; r >= 0; r--){
        const o = e.nodes[r];
        if ("decl" === o.type && o.prop.toLowerCase() === n) return o.value === t;
    }
    return !1;
}
const e = /^\s?initial\s?$/i, n = /^font$/i, r = /^all$/i, i = [
    "font-family",
    "font-size",
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "line-height"
], creator = (a)=>{
    const l = Object.assign({
        preserve: !0
    }, a);
    return {
        postcssPlugin: "postcss-initial",
        Declaration (a) {
            if (a.variable) return;
            if (!e.test(a.value)) return;
            let s;
            s = n.test(a.prop) ? i : r.test(a.prop) ? t : [
                a.prop.toLowerCase()
            ];
            let c = !1;
            s.forEach((t)=>{
                const e = o.get(t);
                e && (hasExactFallback(a, e) || (c = !0, a.cloneBefore({
                    prop: t,
                    value: e
                })));
            }), !l.preserve && c && a.remove();
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/@csstools/postcss-cascade-layers/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
const t = "csstools-invalid-layer", a = "csstools-layer-with-selector-rules", s = "6efdb677-bb05-44e5-840f-29d2175862fd", n = "b147acf6-11a6-4338-a4d0-80aef4cd1a2f", o = [
    "media",
    "supports"
], l = [
    "keyframes"
], i = /^revert-layer$/i, c = /^import$/i, u = /^layer$/i, m = /layer/i, y = new Set([
    "layer",
    "supports",
    "media",
    "container",
    "scope"
]);
function isProcessableLayerRule(e) {
    if ("atrule" !== e.type) return !1;
    if (!u.test(e.name)) return !1;
    let r = e.parent;
    for(; r;){
        if ("rule" === r.type) return !1;
        if ("atrule" === r.type && !y.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
class Model {
    anonymousLayerCount = 0;
    layerCount = 0;
    layerOrder;
    layerParamsParsed;
    layerNameParts;
    constructor(){
        this.anonymousLayerCount = 0, this.layerCount = 0, this.layerOrder = new Map, this.layerParamsParsed = new Map, this.layerNameParts = new Map;
    }
    createAnonymousLayerName() {
        const e = `anonymous-${this.anonymousLayerCount}-${s}`;
        return this.addLayerNameParts(e), this.layerParamsParsed.set(e, [
            e
        ]), this.anonymousLayerCount++, e;
    }
    createImplicitLayerName(e) {
        const r = this.layerNameParts.get(e) ?? [], t = `implicit-${r[r.length - 1]}-${n}`;
        return this.addLayerNameParts([
            ...r,
            t
        ]), this.layerParamsParsed.set(t, [
            t
        ]), t;
    }
    addLayerParams(e, r) {
        r ? "string" != typeof r ? this.layerParamsParsed.set(e, r) : this.layerParamsParsed.set(e, [
            r
        ]) : this.layerParamsParsed.set(e, [
            e
        ]);
    }
    addLayerNameParts(e) {
        "string" != typeof e ? this.layerNameParts.set(e.join("."), e) : this.layerNameParts.set(e, [
            e
        ]);
    }
    getLayerParams(e) {
        const r = [
            ...this.layerParamsParsed.get(e.params) ?? []
        ];
        let t = e.parent;
        for(; t;)"atrule" === t.type ? (isProcessableLayerRule(t) && r.push(...this.layerParamsParsed.get(t.params) ?? []), t = t.parent) : t = t.parent;
        return r.reverse(), r.flatMap((e)=>this.layerNameParts.get(e) ?? []);
    }
    getLayerNameList(e) {
        const r = this.layerNameParts.get(e) ?? [], t = [];
        for(let e = 0; e < r.length; e++){
            const a = r.slice(0, e + 1).join(".");
            this.layerParamsParsed.has(a) || this.layerParamsParsed.set(a, [
                a
            ]), this.layerNameParts.has(a) || this.layerNameParts.set(a, r.slice(0, e + 1)), t.push(r.slice(0, e + 1).join("."));
        }
        return t;
    }
    sortLayerNames() {
        for (const [e, r] of this.layerOrder){
            const t = this.layerNameParts.get(e) ?? [];
            for(let e = 1; e < t.length; e++){
                const a = t.slice(0, e).join(".");
                this.layerOrder.has(a) || this.layerOrder.set(a, r);
            }
        }
        let e = Array.from(this.layerOrder.entries());
        e = e.sort((e, r)=>{
            const t = this.layerNameParts.get(e[0]) ?? [], a = this.layerNameParts.get(r[0]) ?? [];
            if (t[0] !== a[0]) return (this.layerOrder.get(t[0]) ?? 0) - (this.layerOrder.get(a[0]) ?? 0);
            const s = Math.max(t.length, a.length);
            for(let e = 0; e < s; e++){
                const r = t[e], s = a[e];
                if (r !== s) return r ? s ? (this.layerOrder.get(t.slice(0, e).join(".")) ?? 0) - (this.layerOrder.get(a.slice(0, e).join(".")) ?? 0) : -1 : 1;
            }
            return 0;
        }), this.layerOrder.clear(), e.forEach((e, r)=>{
            this.layerOrder.set(e[0], r);
        });
    }
}
function adjustSelectorSpecificity(r, t) {
    const a = e().astSync(r), s = e().astSync(generateNot(t));
    let n = !1;
    for(let r = 0; r < a.nodes[0].nodes.length; r++)if ("combinator" === a.nodes[0].nodes[r].type || e.isPseudoElement(a.nodes[0].nodes[r])) {
        a.nodes[0].insertBefore(a.nodes[0].nodes[r], s), n = !0;
        break;
    }
    return n || a.nodes[0].insertAfter(a.nodes[0].nodes[a.nodes[0].nodes.length - 1], s), a.toString();
}
function generateNot(e) {
    if (0 === e) return "";
    let r = "";
    for(let t = 0; t < e; t++)r += ":not(#\\#)";
    return r;
}
function someInTree(e, r) {
    let t = !1;
    return e.walk((e)=>{
        if (r(e)) return t = !0, !1;
    }), t;
}
function someAtRuleInTree(e, r) {
    let t = !1;
    return e.walkAtRules((e)=>{
        if (r(e)) return t = !0, !1;
    }), t;
}
function getLayerAtRuleAncestor(e) {
    let r = e.parent;
    for(; r;)if ("atrule" === r.type) {
        if (isProcessableLayerRule(r)) return r;
        r = r.parent;
    } else r = r.parent;
    return null;
}
function removeEmptyDescendantBlocks(e) {
    e && (e.walk((e)=>{
        ("rule" === e.type || "atrule" === e.type && [
            "layer",
            ...o
        ].includes(e.name.toLowerCase())) && 0 === e.nodes?.length && e.remove();
    }), 0 === e.nodes?.length && e.remove());
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (void 0 === r.nodes) return;
        if (r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function desugarAndParseLayerNames(r, a) {
    r.walkAtRules((r)=>{
        if (!isProcessableLayerRule(r)) return;
        if (r.params) {
            const s = [];
            let n = !1;
            if (e().astSync(r.params).each((e)=>{
                const r = [];
                e.walk((e)=>{
                    switch(e.type){
                        case "class":
                        case "tag":
                            r.push(e.value);
                            break;
                        default:
                            n = !0;
                    }
                }), n || (s.push(r.join(".")), a.addLayerNameParts(r));
            }), a.addLayerParams(r.params, s), r.nodes && s.length > 1 && (n = !0), n) return void (r.name = t);
            if (!r.nodes || 0 === r.nodes.length) {
                if (s.length <= 1) return;
                return s.slice(0, -1).forEach((e)=>{
                    a.addLayerParams(e, e), r.cloneBefore({
                        params: e
                    });
                }), a.addLayerParams(s[s.length - 1], s[s.length - 1]), void (r.params = s[s.length - 1]);
            }
        }
        r.params || (r.raws.afterName = " ", r.params = a.createAnonymousLayerName());
        const s = someAtRuleInTree(r, (e)=>isProcessableLayerRule(e)), n = someInTree(r, (e)=>{
            if ("rule" !== e.type) return !1;
            return getLayerAtRuleAncestor(e) === r;
        });
        if (s && n) {
            const e = a.createImplicitLayerName(r.params), t = r.clone({
                params: e
            });
            t.walkAtRules((e)=>{
                isProcessableLayerRule(e) && e.remove();
            }), r.walk((e)=>{
                if ("atrule" === e.type && isProcessableLayerRule(e)) return;
                if ("atrule" === e.type && o.includes(e.name.toLowerCase())) return;
                getLayerAtRuleAncestor(e) === r && e.remove();
            }), r.append(t), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }
    });
}
function desugarNestedLayers(e, r) {
    for(; someAtRuleInTree(e, (e)=>!!e.nodes && someAtRuleInTree(e, (e)=>isProcessableLayerRule(e)));){
        let t = !1;
        if (e.walkAtRules((a)=>{
            if (isProcessableLayerRule(a) && a.parent !== e) {
                if ("atrule" === a.parent?.type && isProcessableLayerRule(a.parent)) {
                    const e = a.parent;
                    {
                        const t = r.layerNameParts.get(e.params), s = r.layerNameParts.get(a.params);
                        if (!t || !s) return;
                        r.layerNameParts.set(`${e.params}.${a.params}`, [
                            ...t,
                            ...s
                        ]), r.layerParamsParsed.set(`${e.params}.${a.params}`, [
                            `${e.params}.${a.params}`
                        ]);
                    }
                    return a.params = `${e.params}.${a.params}`, e.before(a), removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
                }
                if ("atrule" === a.parent?.type) {
                    const e = a.parent, r = e.clone(), t = a.clone();
                    return r.removeAll(), t.removeAll(), r.append(a.nodes), t.append(r), e.before(t), a.remove(), removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
                }
                t = !0;
            }
        }), t) break;
    }
}
function sortRootNodes(e, r) {
    e.nodes && (e.walkAtRules((e)=>{
        if (!isProcessableLayerRule(e)) return;
        const r = e.clone(), t = e.clone();
        r.walkAtRules((e)=>{
            if (l.includes(e.name.toLowerCase())) {
                const r = e.parent;
                return e.remove(), removeEmptyDescendantBlocks(r), void removeEmptyAncestorBlocks(r);
            }
            if (someInTree(e, (e)=>"rule" === e.type)) return;
            const r = e.parent;
            e.remove(), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }), t.walkRules((e)=>{
            if (e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase())) return;
            const r = e.parent;
            e.remove(), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }), t.walkAtRules((e)=>{
            if (o.includes(e.name.toLowerCase())) return removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
        }), r.name = a, e.replaceWith(r, t), r.nodes?.length || r.remove(), t.nodes?.length || t.remove();
    }), e.nodes.sort((e, t)=>{
        const a = "atrule" === e.type && u.test(e.name), s = "atrule" === t.type && u.test(t.name);
        if (a && s) {
            return (r.layerOrder.get(e.params) ?? 0) - (r.layerOrder.get(t.params) ?? 0);
        }
        return a !== s ? a ? -1 : 1 : 0;
    }), e.walkAtRules(a, (e)=>{
        e.name = "layer";
    }));
}
function getConditionalAtRuleAncestor(e) {
    let r = e.parent;
    for(; r;)if ("atrule" === r.type) {
        if (o.includes(r.name.toLowerCase())) return r;
        r = r.parent;
    } else r = r.parent;
    return null;
}
function recordLayerOrder(e, r, { result: t, options: a }) {
    e.walkAtRules((e)=>{
        if (!isProcessableLayerRule(e)) return;
        const o = r.getLayerParams(e), l = o.join(".");
        r.layerOrder.has(l) || (a.onConditionalRulesChangingLayerOrder && getConditionalAtRuleAncestor(e) && !e.params.endsWith(n) && !e.params.endsWith(s) && e.warn(t, "handling different layer orders in conditional rules is unsupported by this plugin and will cause style differences between browser versions."), r.layerParamsParsed.has(l) || r.layerParamsParsed.set(l, [
            l
        ]), r.layerNameParts.has(l) || r.layerNameParts.set(l, [
            ...o
        ]), r.getLayerNameList(l).forEach((e)=>{
            r.layerOrder.has(e) || (r.layerOrder.set(e, r.layerCount), r.layerCount += 1);
        })), e.nodes && 0 !== e.nodes.length || e.remove();
    });
}
function splitImportantStyles(e) {
    e.walkDecls((e)=>{
        if (!e.important) return;
        const r = e.parent;
        if (!r) return;
        if ("atrule" === r?.parent?.type && l.includes(r.parent.name.toLowerCase())) return;
        const t = r.clone();
        t.each((e)=>{
            "decl" === e.type && e.important || e.remove();
        }), r.each((e)=>{
            "decl" === e.type && e.important && e.remove();
        }), r.before(t), removeEmptyDescendantBlocks(r);
    });
}
const creator = (a)=>{
    const s = Object.assign({
        onRevertLayerKeyword: "warn",
        onConditionalRulesChangingLayerOrder: "warn",
        onImportLayerRule: "warn"
    }, a);
    return {
        postcssPlugin: "postcss-cascade-layers",
        OnceExit (a, { result: n }) {
            let o = !1;
            if ((s.onRevertLayerKeyword || s.onImportLayerRule) && a.walk((e)=>"decl" === e.type ? i.test(e.value) ? void e.warn(n, 'handling "revert-layer" is unsupported by this plugin and will cause style differences between browser versions.') : void 0 : "atrule" === e.type ? c.test(e.name) && m.test(e.params) ? void e.warn(n, "To use @import with layers, the postcss-import plugin is also required. This plugin alone will not support using the @import at-rule.") : u.test(e.name) ? void (o = !0) : void 0 : void 0), !o) return;
            splitImportantStyles(a);
            const y = new Model;
            if (desugarAndParseLayerNames(a, y), recordLayerOrder(a, y, {
                result: n,
                options: s
            }), !y.layerCount) return void a.walkAtRules(t, (e)=>{
                e.name = "layer";
            });
            let d = 0;
            for(a.walkRules((t)=>{
                t.selectors.forEach((a)=>{
                    try {
                        const t = r.selectorSpecificity(e().astSync(a));
                        d = Math.max(d, t.a + 1);
                    } catch (e) {
                        t.warn(n, `Failed to parse selector : "${a}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                });
            }), a.walkRules((e)=>{
                e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase()) || getLayerAtRuleAncestor(e) || e.some((e)=>"decl" === e.type && e.important) || (e.selectors = e.selectors.map((r)=>{
                    try {
                        return adjustSelectorSpecificity(r, y.layerCount * d);
                    } catch (t) {
                        e.warn(n, `Failed to parse selector : "${r}" with message: "${t instanceof Error ? t.message : t}"`);
                    }
                    return r;
                }));
            }), y.sortLayerNames(), desugarNestedLayers(a, y), sortRootNodes(a, y), a.walkRules((e)=>{
                if (e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase())) return;
                const r = getLayerAtRuleAncestor(e);
                if (!r) return;
                const t = y.getLayerParams(r).join(".");
                let a = (y.layerOrder.get(t) ?? 0) * d;
                e.some((e)=>"decl" === e.type && e.important) && (a = y.layerCount - a), e.selectors = e.selectors.map((e)=>adjustSelectorSpecificity(e, a));
            }); someAtRuleInTree(a, (e)=>isProcessableLayerRule(e));)a.walkAtRules((e)=>{
                isProcessableLayerRule(e) && (e.nodes ? e.replaceWith(e.nodes) : e.remove());
            });
            a.walkAtRules(t, (e)=>{
                e.name = "layer";
            });
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
const a = [
    "at",
    "bottom",
    "center",
    "circle",
    "closest-corner",
    "closest-side",
    "ellipse",
    "farthest-corner",
    "farthest-side",
    "from",
    "in",
    "left",
    "right",
    "to",
    "top"
];
function doublePositionGradients(e) {
    const p = [], r = e.value.toLowerCase();
    if ("function" === e.type && ("conic-gradient" === r || "linear-gradient" === r || "radial-gradient" === r || "repeating-conic-gradient" === r || "repeating-linear-gradient" === r || "repeating-radial-gradient" === r)) {
        let r = 0, t = !1, i = !1;
        e: for(let o = 0; o < e.nodes.length; o++){
            const s = e.nodes[o];
            if ("word" === s.type && a.includes(s.value.toLowerCase()) && (t = !0), "div" !== s.type || "," !== s.value.trim()) if ("word" !== s.type || "in" !== s.value.toLowerCase()) {
                if ("word" !== s.type && "function" !== s.type || r++, i) switch(e.value.toLowerCase()){
                    case "conic-gradient":
                        p.push("(background: conic-gradient(in oklch, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "linear-gradient":
                        p.push("(background: linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "radial-gradient":
                        p.push("(background: radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                        break e;
                    case "repeating-conic-gradient":
                        p.push("(background: repeating-conic-gradient(in oklch from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "repeating-linear-gradient":
                        p.push("(background: repeating-linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "repeating-radial-gradient":
                        p.push("(background: repeating-radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                        break e;
                }
                if (!t && 3 === r) switch(e.value.toLowerCase()){
                    case "conic-gradient":
                        p.push("(background: conic-gradient(red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "linear-gradient":
                        p.push("(background: linear-gradient(red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "radial-gradient":
                        p.push("(background: radial-gradient(red, red 1px 2px, red 3px))");
                        break e;
                    case "repeating-conic-gradient":
                        p.push("(background: repeating-conic-gradient(from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "repeating-linear-gradient":
                        p.push("(background: repeating-linear-gradient(red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "repeating-radial-gradient":
                        p.push("(background: repeating-radial-gradient(red, red 1px 2px, red 3px))");
                        break e;
                }
            } else i = !0;
            else r = 0, t = !1;
        }
    }
    return p;
}
const p = [
    {
        supports: "color-mix(in lch, red, blue)",
        property: "color",
        sniff: "color-mix",
        matchers: [
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color-mix(in lch, red)",
        property: "color",
        sniff: "color-mix",
        matchers: [
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(from red l 1 1% / calc(alpha + 0.1))",
        property: "color",
        sniff: "from ",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(display-p3 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(display-p3 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "display-p3"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "display-p3"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb-linear"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb-linear"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "a98-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "a98-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "prophoto-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "prophoto-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "rec2020"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "rec2020"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d50"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d50"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d65"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d65"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsl(0, 0%, 0%)",
        property: "color",
        sniff: "hsl",
        matchers: [
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsl(0 0% 0% / 0)",
        property: "color",
        sniff: "hsl",
        matchers: [
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsla(0 0% 0% / 0)",
        property: "color",
        sniff: "hsla",
        matchers: [
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hwb(0 0% 0%)",
        property: "color",
        sniff: "hwb",
        matchers: [
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(0% 0 0%)",
        property: "color",
        sniff: "lab",
        matchers: [
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(0% 0 0%)",
        property: "color",
        sniff: "lch",
        matchers: [
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "oklab(0% 0 0%)",
        property: "color",
        sniff: "oklab",
        matchers: [
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "oklab(0% 0 0%)",
        property: "color",
        sniff: "oklch",
        matchers: [
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgb(0, 0, 0, 0)",
        property: "color",
        sniff: "rgb",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgb(0 0 0 / 0)",
        property: "color",
        sniff: "rgb",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgba(0 0 0 / 0)",
        property: "color",
        sniff: "rgba",
        matchers: [
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "light-dark(red, red)",
        property: "color",
        sniff: "light-dark",
        matchers: [
            {
                type: "function",
                value: "light-dark",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "contrast-color(red)",
        property: "color",
        sniff: "contrast-color",
        matchers: [
            {
                type: "function",
                value: "contrast-color",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "contrast-color",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "1ic",
        property: "font-size",
        sniff: "ic",
        matchers: [
            {
                type: "word",
                value: "1ic",
                dimension: {
                    unit: "ic"
                }
            }
        ]
    },
    {
        supports: '"a" / "a"',
        property: "content",
        only_on_property: "content",
        sniff: "/",
        matchers: [
            {
                type: "div",
                value: "/"
            }
        ]
    }
];
function matches(e, a) {
    if (e.isVariable && a && ("word" === a.type || "string" === a.type || "function" === a.type)) return !0;
    if (e.type !== a.type) return !1;
    if (doesNotMatchValue(e, a)) return !1;
    if (e.nodes && a.nodes) {
        for(let p = 0; p < Math.max(e.nodes.length, a.nodes.length); p++){
            let r = p, t = p;
            for(; e.nodes[r] && "space" === e.nodes[r].type;)r++;
            for(; a.nodes[t] && "space" === a.nodes[t].type;)t++;
            if (!!e.nodes[r] != !!a.nodes[t]) return !1;
            if (e.nodes[r].anyRemainingArguments && a.nodes[t]) return !0;
            if (!matches(e.nodes[r], a.nodes[t])) return !1;
        }
        return !0;
    }
    return !0;
}
function doesNotMatchValue(e, a) {
    return ("space" !== e.type || "space" !== a.type || e.value?.trim() !== a.value?.trim()) && (e.dimension && a.dimension ? e.dimension.unit !== a.dimension.unit : "string" === e.type ? e.value !== a.value : e.value?.toLowerCase() !== a.value?.toLowerCase());
}
const r = /^var$/i;
function conditionsFromValue(a, t = !1) {
    const i = a.value, o = [], s = p.filter((e)=>i.includes(e.sniff) && (e.only_on_property ?? a.prop) === a.prop);
    let y = !1;
    try {
        e(i).walk((a)=>{
            "function" === a.type && r.test(a.value) && (y = !0);
            try {
                const p = e.unit(a.value);
                !1 !== p && (a.dimension = p);
            } catch  {}
            for(let e = 0; e < s.length; e++){
                const p = s[e];
                for(let e = 0; e < p.matchers.length; e++){
                    if (matches(p.matchers[e], a)) return void o.push(`(${p.property}: ${p.supports})`);
                }
            }
            o.push(...doublePositionGradients(a));
        });
    } catch  {}
    return t && !y ? {
        support: []
    } : {
        support: Array.from(new Set(o)).sort()
    };
}
const t = /var\(/i, i = /^initial$/i, o = /^\s*$/, creator = ()=>({
        postcssPlugin: "postcss-progressive-custom-properties",
        prepare () {
            const e = new WeakMap;
            return {
                postcssPlugin: "postcss-progressive-custom-properties",
                OnceExit (a, { postcss: p }) {
                    a.walkDecls((a)=>{
                        if (!a.parent) return;
                        const r = e.get(a.parent) || {
                            conditionalRules: [],
                            propNames: new Set,
                            lastConditionParams: {
                                support: void 0
                            },
                            lastConditionalRule: void 0
                        };
                        if (e.set(a.parent, r), a.variable) {
                            if (!r.propNames.has(a.prop)) return void r.propNames.add(a.prop);
                        } else {
                            const e = a.prop.toLowerCase();
                            if (!r.propNames.has(e)) return void r.propNames.add(e);
                        }
                        if (!a.variable && !t.test(a.value)) return;
                        if (i.test(a.value)) return;
                        if (o.test(a.value)) return;
                        const s = conditionsFromValue(a, !a.variable).support.join(" and ");
                        if (!s) return;
                        if (r.lastConditionParams.support !== s && (r.lastConditionalRule = void 0), r.lastConditionalRule) return r.lastConditionalRule.append(a.clone()), void a.remove();
                        const y = [];
                        if (s && y.push(p.atRule({
                            name: "supports",
                            params: s,
                            source: a.parent.source,
                            raws: {
                                before: "\n\n",
                                after: "\n"
                            }
                        })), !y.length) return;
                        for(let e = 0; e < y.length - 1; e++){
                            const a = y[e], p = y[e + 1];
                            a.append(p);
                        }
                        const l = y[0], d = y[y.length - 1], n = a.parent.clone();
                        n.removeAll(), n.raws.before = "\n", n.append(a.clone()), a.remove(), r.lastConditionParams.support = s, r.lastConditionalRule = n, d.append(n), r.conditionalRules.push(l);
                    }), a.walk((a)=>{
                        const p = e.get(a);
                        p && 0 !== p.conditionalRules.length && p.conditionalRules.reverse().forEach((e)=>{
                            a.after(e);
                        });
                    });
                }
            };
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
class ParseError extends Error {
    sourceStart;
    sourceEnd;
    parserState;
    constructor(e, n, o, t){
        super(e), this.name = "ParseError", this.sourceStart = n, this.sourceEnd = o, this.parserState = t;
    }
}
class ParseErrorWithToken extends ParseError {
    token;
    constructor(e, n, o, t, r){
        super(e, n, o, t), this.token = r;
    }
}
const e = {
    UnexpectedNewLineInString: "Unexpected newline while consuming a string token.",
    UnexpectedEOFInString: "Unexpected EOF while consuming a string token.",
    UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.",
    UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.",
    UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.",
    UnexpectedCharacterInURL: "Unexpected character while consuming a url token.",
    InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.",
    InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"'
}, n = "undefined" != typeof globalThis && "structuredClone" in globalThis;
const o = 13, t = 45, r = 10, s = 43, i = 65533;
function checkIfFourCodePointsWouldStartCDO(e) {
    return 60 === e.source.codePointAt(e.cursor) && 33 === e.source.codePointAt(e.cursor + 1) && e.source.codePointAt(e.cursor + 2) === t && e.source.codePointAt(e.cursor + 3) === t;
}
function isDigitCodePoint(e) {
    return e >= 48 && e <= 57;
}
function isUppercaseLetterCodePoint(e) {
    return e >= 65 && e <= 90;
}
function isLowercaseLetterCodePoint(e) {
    return e >= 97 && e <= 122;
}
function isHexDigitCodePoint(e) {
    return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function isLetterCodePoint(e) {
    return isLowercaseLetterCodePoint(e) || isUppercaseLetterCodePoint(e);
}
function isIdentStartCodePoint(e) {
    return isLetterCodePoint(e) || isNonASCII_IdentCodePoint(e) || 95 === e;
}
function isIdentCodePoint(e) {
    return isIdentStartCodePoint(e) || isDigitCodePoint(e) || e === t;
}
function isNonASCII_IdentCodePoint(e) {
    return 183 === e || 8204 === e || 8205 === e || 8255 === e || 8256 === e || 8204 === e || 192 <= e && e <= 214 || 216 <= e && e <= 246 || 248 <= e && e <= 893 || 895 <= e && e <= 8191 || 8304 <= e && e <= 8591 || 11264 <= e && e <= 12271 || 12289 <= e && e <= 55295 || 63744 <= e && e <= 64975 || 65008 <= e && e <= 65533 || 0 === e || !!isSurrogate(e) || e >= 65536;
}
function isNewLine(e) {
    return e === r || e === o || 12 === e;
}
function isWhitespace(e) {
    return 32 === e || e === r || 9 === e || e === o || 12 === e;
}
function isSurrogate(e) {
    return e >= 55296 && e <= 57343;
}
function checkIfTwoCodePointsAreAValidEscape(e) {
    return 92 === e.source.codePointAt(e.cursor) && !isNewLine(e.source.codePointAt(e.cursor + 1) ?? -1);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e, n) {
    return n.source.codePointAt(n.cursor) === t ? n.source.codePointAt(n.cursor + 1) === t || !!isIdentStartCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1) || 92 === n.source.codePointAt(n.cursor + 1) && !isNewLine(n.source.codePointAt(n.cursor + 2) ?? -1) : !!isIdentStartCodePoint(n.source.codePointAt(n.cursor) ?? -1) || checkIfTwoCodePointsAreAValidEscape(n);
}
function checkIfThreeCodePointsWouldStartANumber(e) {
    return e.source.codePointAt(e.cursor) === s || e.source.codePointAt(e.cursor) === t ? !!isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) || 46 === e.source.codePointAt(e.cursor + 1) && isDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1) : 46 === e.source.codePointAt(e.cursor) ? isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) : isDigitCodePoint(e.source.codePointAt(e.cursor) ?? -1);
}
function checkIfTwoCodePointsStartAComment(e) {
    return 47 === e.source.codePointAt(e.cursor) && 42 === e.source.codePointAt(e.cursor + 1);
}
function checkIfThreeCodePointsWouldStartCDC(e) {
    return e.source.codePointAt(e.cursor) === t && e.source.codePointAt(e.cursor + 1) === t && 62 === e.source.codePointAt(e.cursor + 2);
}
var c, a, u;
function consumeComment(n, o) {
    for(o.advanceCodePoint(2);;){
        const t = o.readCodePoint();
        if (void 0 === t) {
            const t = [
                exports.TokenType.Comment,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInComment, o.representationStart, o.representationEnd, [
                "4.3.2. Consume comments",
                "Unexpected EOF"
            ], t)), t;
        }
        if (42 === t && void 0 !== o.source.codePointAt(o.cursor) && 47 === o.source.codePointAt(o.cursor)) {
            o.advanceCodePoint();
            break;
        }
    }
    return [
        exports.TokenType.Comment,
        o.source.slice(o.representationStart, o.representationEnd + 1),
        o.representationStart,
        o.representationEnd,
        void 0
    ];
}
function consumeEscapedCodePoint(n, t) {
    const s = t.readCodePoint();
    if (void 0 === s) return n.onParseError(new ParseError(e.UnexpectedEOFInEscapedCodePoint, t.representationStart, t.representationEnd, [
        "4.3.7. Consume an escaped code point",
        "Unexpected EOF"
    ])), i;
    if (isHexDigitCodePoint(s)) {
        const e = [
            s
        ];
        let n;
        for(; void 0 !== (n = t.source.codePointAt(t.cursor)) && isHexDigitCodePoint(n) && e.length < 6;)e.push(n), t.advanceCodePoint();
        isWhitespace(t.source.codePointAt(t.cursor) ?? -1) && (t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r && t.advanceCodePoint(), t.advanceCodePoint());
        const c = parseInt(String.fromCodePoint(...e), 16);
        return 0 === c || isSurrogate(c) || c > 1114111 ? i : c;
    }
    return 0 === s || isSurrogate(s) ? i : s;
}
function consumeIdentSequence(e, n) {
    const o = [];
    for(;;){
        const t = n.source.codePointAt(n.cursor) ?? -1;
        if (0 === t || isSurrogate(t)) o.push(i), n.advanceCodePoint(+(t > 65535) + 1);
        else if (isIdentCodePoint(t)) o.push(t), n.advanceCodePoint(+(t > 65535) + 1);
        else {
            if (!checkIfTwoCodePointsAreAValidEscape(n)) return o;
            n.advanceCodePoint(), o.push(consumeEscapedCodePoint(e, n));
        }
    }
}
function consumeHashToken(e, n) {
    n.advanceCodePoint();
    const o = n.source.codePointAt(n.cursor);
    if (void 0 !== o && (isIdentCodePoint(o) || checkIfTwoCodePointsAreAValidEscape(n))) {
        let o = exports.HashType.Unrestricted;
        checkIfThreeCodePointsWouldStartAnIdentSequence(0, n) && (o = exports.HashType.ID);
        const t = consumeIdentSequence(e, n);
        return [
            exports.TokenType.Hash,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: String.fromCodePoint(...t),
                type: o
            }
        ];
    }
    return [
        exports.TokenType.Delim,
        "#",
        n.representationStart,
        n.representationEnd,
        {
            value: "#"
        }
    ];
}
function consumeNumber(e, n) {
    let o = exports.NumberType.Integer;
    for(n.source.codePointAt(n.cursor) !== s && n.source.codePointAt(n.cursor) !== t || n.advanceCodePoint(); isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (46 === n.source.codePointAt(n.cursor) && isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(2), o = exports.NumberType.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (101 === n.source.codePointAt(n.cursor) || 69 === n.source.codePointAt(n.cursor)) {
        if (isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) n.advanceCodePoint(2);
        else {
            if (n.source.codePointAt(n.cursor + 1) !== t && n.source.codePointAt(n.cursor + 1) !== s || !isDigitCodePoint(n.source.codePointAt(n.cursor + 2) ?? -1)) return o;
            n.advanceCodePoint(3);
        }
        for(o = exports.NumberType.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    }
    return o;
}
function consumeNumericToken(e, n) {
    let o;
    {
        const e = n.source.codePointAt(n.cursor);
        e === t ? o = "-" : e === s && (o = "+");
    }
    const r = consumeNumber(0, n), i = parseFloat(n.source.slice(n.representationStart, n.representationEnd + 1));
    if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, n)) {
        const t = consumeIdentSequence(e, n);
        return [
            exports.TokenType.Dimension,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: i,
                signCharacter: o,
                type: r,
                unit: String.fromCodePoint(...t)
            }
        ];
    }
    return 37 === n.source.codePointAt(n.cursor) ? (n.advanceCodePoint(), [
        exports.TokenType.Percentage,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: i,
            signCharacter: o
        }
    ]) : [
        exports.TokenType.Number,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: i,
            signCharacter: o,
            type: r
        }
    ];
}
function consumeWhiteSpace(e) {
    for(; isWhitespace(e.source.codePointAt(e.cursor) ?? -1);)e.advanceCodePoint();
    return [
        exports.TokenType.Whitespace,
        e.source.slice(e.representationStart, e.representationEnd + 1),
        e.representationStart,
        e.representationEnd,
        void 0
    ];
}
exports.TokenType = void 0, (c = exports.TokenType || (exports.TokenType = {})).Comment = "comment", c.AtKeyword = "at-keyword-token", c.BadString = "bad-string-token", c.BadURL = "bad-url-token", c.CDC = "CDC-token", c.CDO = "CDO-token", c.Colon = "colon-token", c.Comma = "comma-token", c.Delim = "delim-token", c.Dimension = "dimension-token", c.EOF = "EOF-token", c.Function = "function-token", c.Hash = "hash-token", c.Ident = "ident-token", c.Number = "number-token", c.Percentage = "percentage-token", c.Semicolon = "semicolon-token", c.String = "string-token", c.URL = "url-token", c.Whitespace = "whitespace-token", c.OpenParen = "(-token", c.CloseParen = ")-token", c.OpenSquare = "[-token", c.CloseSquare = "]-token", c.OpenCurly = "{-token", c.CloseCurly = "}-token", c.UnicodeRange = "unicode-range-token", exports.NumberType = void 0, (a = exports.NumberType || (exports.NumberType = {})).Integer = "integer", a.Number = "number", exports.HashType = void 0, (u = exports.HashType || (exports.HashType = {})).Unrestricted = "unrestricted", u.ID = "id";
class Reader {
    cursor = 0;
    source = "";
    representationStart = 0;
    representationEnd = -1;
    constructor(e){
        this.source = e;
    }
    advanceCodePoint(e = 1) {
        this.cursor = this.cursor + e, this.representationEnd = this.cursor - 1;
    }
    readCodePoint() {
        const e = this.source.codePointAt(this.cursor);
        if (void 0 !== e) return this.cursor = this.cursor + 1, this.representationEnd = this.cursor - 1, e;
    }
    unreadCodePoint(e = 1) {
        this.cursor = this.cursor - e, this.representationEnd = this.cursor - 1;
    }
    resetRepresentation() {
        this.representationStart = this.cursor, this.representationEnd = -1;
    }
}
function consumeStringToken(n, t) {
    let s = "";
    const c = t.readCodePoint();
    for(;;){
        const a = t.readCodePoint();
        if (void 0 === a) {
            const o = [
                exports.TokenType.String,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                {
                    value: s
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInString, t.representationStart, t.representationEnd, [
                "4.3.5. Consume a string token",
                "Unexpected EOF"
            ], o)), o;
        }
        if (isNewLine(a)) {
            t.unreadCodePoint();
            const s = [
                exports.TokenType.BadString,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedNewLineInString, t.representationStart, t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r ? t.representationEnd + 2 : t.representationEnd + 1, [
                "4.3.5. Consume a string token",
                "Unexpected newline"
            ], s)), s;
        }
        if (a === c) return [
            exports.TokenType.String,
            t.source.slice(t.representationStart, t.representationEnd + 1),
            t.representationStart,
            t.representationEnd,
            {
                value: s
            }
        ];
        if (92 !== a) 0 === a || isSurrogate(a) ? s += String.fromCodePoint(i) : s += String.fromCodePoint(a);
        else {
            if (void 0 === t.source.codePointAt(t.cursor)) continue;
            if (isNewLine(t.source.codePointAt(t.cursor) ?? -1)) {
                t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r && t.advanceCodePoint(), t.advanceCodePoint();
                continue;
            }
            s += String.fromCodePoint(consumeEscapedCodePoint(n, t));
        }
    }
}
function checkIfCodePointsMatchURLIdent(e) {
    return !(3 !== e.length || 117 !== e[0] && 85 !== e[0] || 114 !== e[1] && 82 !== e[1] || 108 !== e[2] && 76 !== e[2]);
}
function consumeBadURL(e, n) {
    for(;;){
        const o = n.source.codePointAt(n.cursor);
        if (void 0 === o) return;
        if (41 === o) return void n.advanceCodePoint();
        checkIfTwoCodePointsAreAValidEscape(n) ? (n.advanceCodePoint(), consumeEscapedCodePoint(e, n)) : n.advanceCodePoint();
    }
}
function consumeUrlToken(n, o) {
    for(; isWhitespace(o.source.codePointAt(o.cursor) ?? -1);)o.advanceCodePoint();
    let t = "";
    for(;;){
        if (void 0 === o.source.codePointAt(o.cursor)) {
            const r = [
                exports.TokenType.URL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                {
                    value: t
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected EOF"
            ], r)), r;
        }
        if (41 === o.source.codePointAt(o.cursor)) return o.advanceCodePoint(), [
            exports.TokenType.URL,
            o.source.slice(o.representationStart, o.representationEnd + 1),
            o.representationStart,
            o.representationEnd,
            {
                value: t
            }
        ];
        if (isWhitespace(o.source.codePointAt(o.cursor) ?? -1)) {
            for(o.advanceCodePoint(); isWhitespace(o.source.codePointAt(o.cursor) ?? -1);)o.advanceCodePoint();
            if (void 0 === o.source.codePointAt(o.cursor)) {
                const r = [
                    exports.TokenType.URL,
                    o.source.slice(o.representationStart, o.representationEnd + 1),
                    o.representationStart,
                    o.representationEnd,
                    {
                        value: t
                    }
                ];
                return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, o.representationStart, o.representationEnd, [
                    "4.3.6. Consume a url token",
                    "Consume as much whitespace as possible",
                    "Unexpected EOF"
                ], r)), r;
            }
            return 41 === o.source.codePointAt(o.cursor) ? (o.advanceCodePoint(), [
                exports.TokenType.URL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                {
                    value: t
                }
            ]) : (consumeBadURL(n, o), [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ]);
        }
        const s = o.source.codePointAt(o.cursor);
        if (34 === s || 39 === s || 40 === s || 11 === (r = s ?? -1) || 127 === r || 0 <= r && r <= 8 || 14 <= r && r <= 31) {
            consumeBadURL(n, o);
            const t = [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedCharacterInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point"
            ], t)), t;
        }
        if (92 === s) {
            if (checkIfTwoCodePointsAreAValidEscape(o)) {
                o.advanceCodePoint(), t += String.fromCodePoint(consumeEscapedCodePoint(n, o));
                continue;
            }
            consumeBadURL(n, o);
            const r = [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "U+005C REVERSE SOLIDUS (\\)",
                "The input stream does not start with a valid escape sequence"
            ], r)), r;
        }
        0 === o.source.codePointAt(o.cursor) || isSurrogate(o.source.codePointAt(o.cursor) ?? -1) ? (t += String.fromCodePoint(i), o.advanceCodePoint()) : (t += o.source[o.cursor], o.advanceCodePoint());
    }
    var r;
}
function consumeIdentLikeToken(e, n) {
    const o = consumeIdentSequence(e, n);
    if (40 !== n.source.codePointAt(n.cursor)) return [
        exports.TokenType.Ident,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...o)
        }
    ];
    if (checkIfCodePointsMatchURLIdent(o)) {
        n.advanceCodePoint();
        let t = 0;
        for(;;){
            const e = isWhitespace(n.source.codePointAt(n.cursor) ?? -1), r = isWhitespace(n.source.codePointAt(n.cursor + 1) ?? -1);
            if (e && r) {
                t += 1, n.advanceCodePoint(1);
                continue;
            }
            const s = e ? n.source.codePointAt(n.cursor + 1) : n.source.codePointAt(n.cursor);
            if (34 === s || 39 === s) return t > 0 && n.unreadCodePoint(t), [
                exports.TokenType.Function,
                n.source.slice(n.representationStart, n.representationEnd + 1),
                n.representationStart,
                n.representationEnd,
                {
                    value: String.fromCodePoint(...o)
                }
            ];
            break;
        }
        return consumeUrlToken(e, n);
    }
    return n.advanceCodePoint(), [
        exports.TokenType.Function,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...o)
        }
    ];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e) {
    return !(117 !== e.source.codePointAt(e.cursor) && 85 !== e.source.codePointAt(e.cursor) || e.source.codePointAt(e.cursor + 1) !== s || 63 !== e.source.codePointAt(e.cursor + 2) && !isHexDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1));
}
function consumeUnicodeRangeToken(e, n) {
    n.advanceCodePoint(2);
    const o = [], r = [];
    let s;
    for(; void 0 !== (s = n.source.codePointAt(n.cursor)) && o.length < 6 && isHexDigitCodePoint(s);)o.push(s), n.advanceCodePoint();
    for(; void 0 !== (s = n.source.codePointAt(n.cursor)) && o.length < 6 && 63 === s;)0 === r.length && r.push(...o), o.push(48), r.push(70), n.advanceCodePoint();
    if (!r.length && n.source.codePointAt(n.cursor) === t && isHexDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(); void 0 !== (s = n.source.codePointAt(n.cursor)) && r.length < 6 && isHexDigitCodePoint(s);)r.push(s), n.advanceCodePoint();
    if (!r.length) {
        const e = parseInt(String.fromCodePoint(...o), 16);
        return [
            exports.TokenType.UnicodeRange,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                startOfRange: e,
                endOfRange: e
            }
        ];
    }
    const i = parseInt(String.fromCodePoint(...o), 16), c = parseInt(String.fromCodePoint(...r), 16);
    return [
        exports.TokenType.UnicodeRange,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            startOfRange: i,
            endOfRange: c
        }
    ];
}
function tokenizer(n, i) {
    const c = n.css.valueOf(), a = n.unicodeRangesAllowed ?? !1, u = new Reader(c), d = {
        onParseError: i?.onParseError ?? noop
    };
    return {
        nextToken: function nextToken() {
            u.resetRepresentation();
            const n = u.source.codePointAt(u.cursor);
            if (void 0 === n) return [
                exports.TokenType.EOF,
                "",
                -1,
                -1,
                void 0
            ];
            if (47 === n && checkIfTwoCodePointsStartAComment(u)) return consumeComment(d, u);
            if (a && (117 === n || 85 === n) && checkIfThreeCodePointsWouldStartAUnicodeRange(u)) return consumeUnicodeRangeToken(0, u);
            if (isIdentStartCodePoint(n)) return consumeIdentLikeToken(d, u);
            if (isDigitCodePoint(n)) return consumeNumericToken(d, u);
            switch(n){
                case 44:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Comma,
                        ",",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 58:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Colon,
                        ":",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 59:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Semicolon,
                        ";",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 40:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenParen,
                        "(",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 41:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseParen,
                        ")",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 91:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenSquare,
                        "[",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 93:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseSquare,
                        "]",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 123:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenCurly,
                        "{",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 125:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseCurly,
                        "}",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 39:
                case 34:
                    return consumeStringToken(d, u);
                case 35:
                    return consumeHashToken(d, u);
                case s:
                case 46:
                    return checkIfThreeCodePointsWouldStartANumber(u) ? consumeNumericToken(d, u) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        u.source[u.representationStart],
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: u.source[u.representationStart]
                        }
                    ]);
                case r:
                case o:
                case 12:
                case 9:
                case 32:
                    return consumeWhiteSpace(u);
                case t:
                    return checkIfThreeCodePointsWouldStartANumber(u) ? consumeNumericToken(d, u) : checkIfThreeCodePointsWouldStartCDC(u) ? (u.advanceCodePoint(3), [
                        exports.TokenType.CDC,
                        "--\x3e",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, u) ? consumeIdentLikeToken(d, u) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        "-",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "-"
                        }
                    ]);
                case 60:
                    return checkIfFourCodePointsWouldStartCDO(u) ? (u.advanceCodePoint(4), [
                        exports.TokenType.CDO,
                        "\x3c!--",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ]) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        "<",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "<"
                        }
                    ]);
                case 64:
                    if (u.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, u)) {
                        const e = consumeIdentSequence(d, u);
                        return [
                            exports.TokenType.AtKeyword,
                            u.source.slice(u.representationStart, u.representationEnd + 1),
                            u.representationStart,
                            u.representationEnd,
                            {
                                value: String.fromCodePoint(...e)
                            }
                        ];
                    }
                    return [
                        exports.TokenType.Delim,
                        "@",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "@"
                        }
                    ];
                case 92:
                    {
                        if (checkIfTwoCodePointsAreAValidEscape(u)) return consumeIdentLikeToken(d, u);
                        u.advanceCodePoint();
                        const n = [
                            exports.TokenType.Delim,
                            "\\",
                            u.representationStart,
                            u.representationEnd,
                            {
                                value: "\\"
                            }
                        ];
                        return d.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceAfterBackslash, u.representationStart, u.representationEnd, [
                            "4.3.1. Consume a token",
                            "U+005C REVERSE SOLIDUS (\\)",
                            "The input stream does not start with a valid escape sequence"
                        ], n)), n;
                    }
            }
            return u.advanceCodePoint(), [
                exports.TokenType.Delim,
                u.source[u.representationStart],
                u.representationStart,
                u.representationEnd,
                {
                    value: u.source[u.representationStart]
                }
            ];
        },
        endOfFile: function endOfFile() {
            return void 0 === u.source.codePointAt(u.cursor);
        }
    };
}
function noop() {}
function serializeIdent(e) {
    let n = 0;
    if (0 === e[0]) e.splice(0, 1, i), n = 1;
    else if (e[0] === t && e[1] === t) n = 2;
    else if (e[0] === t && e[1]) n = 2, isIdentStartCodePoint(e[1]) || (n += insertEscapedCodePoint(e, 1, e[1]));
    else {
        if (e[0] === t && !e[1]) return [
            92,
            e[0]
        ];
        isIdentStartCodePoint(e[0]) ? n = 1 : (n = 1, n += insertEscapedCodePoint(e, 0, e[0]));
    }
    for(let o = n; o < e.length; o++)0 !== e[o] ? isIdentCodePoint(e[o]) || (o += insertEscapedCharacter(e, o, e[o])) : (e.splice(o, 1, i), o++);
    return e;
}
function insertEscapedCharacter(e, n, o) {
    return e.splice(n, 1, 92, o), 1;
}
function insertEscapedCodePoint(e, n, o) {
    const t = o.toString(16), r = [];
    for (const e of t)r.push(e.codePointAt(0));
    return e.splice(n, 1, 92, ...r, 32), 1 + r.length;
}
const d = Object.values(exports.TokenType);
exports.ParseError = ParseError, exports.ParseErrorMessage = e, exports.ParseErrorWithToken = ParseErrorWithToken, exports.cloneTokens = function cloneTokens(e) {
    return n ? structuredClone(e) : JSON.parse(JSON.stringify(e));
}, exports.isToken = function isToken(e) {
    return !!Array.isArray(e) && !(e.length < 4) && !!d.includes(e[0]) && "string" == typeof e[1] && "number" == typeof e[2] && "number" == typeof e[3];
}, exports.isTokenAtKeyword = function isTokenAtKeyword(e) {
    return !!e && e[0] === exports.TokenType.AtKeyword;
}, exports.isTokenBadString = function isTokenBadString(e) {
    return !!e && e[0] === exports.TokenType.BadString;
}, exports.isTokenBadURL = function isTokenBadURL(e) {
    return !!e && e[0] === exports.TokenType.BadURL;
}, exports.isTokenCDC = function isTokenCDC(e) {
    return !!e && e[0] === exports.TokenType.CDC;
}, exports.isTokenCDO = function isTokenCDO(e) {
    return !!e && e[0] === exports.TokenType.CDO;
}, exports.isTokenCloseCurly = function isTokenCloseCurly(e) {
    return !!e && e[0] === exports.TokenType.CloseCurly;
}, exports.isTokenCloseParen = function isTokenCloseParen(e) {
    return !!e && e[0] === exports.TokenType.CloseParen;
}, exports.isTokenCloseSquare = function isTokenCloseSquare(e) {
    return !!e && e[0] === exports.TokenType.CloseSquare;
}, exports.isTokenColon = function isTokenColon(e) {
    return !!e && e[0] === exports.TokenType.Colon;
}, exports.isTokenComma = function isTokenComma(e) {
    return !!e && e[0] === exports.TokenType.Comma;
}, exports.isTokenComment = function isTokenComment(e) {
    return !!e && e[0] === exports.TokenType.Comment;
}, exports.isTokenDelim = function isTokenDelim(e) {
    return !!e && e[0] === exports.TokenType.Delim;
}, exports.isTokenDimension = function isTokenDimension(e) {
    return !!e && e[0] === exports.TokenType.Dimension;
}, exports.isTokenEOF = function isTokenEOF(e) {
    return !!e && e[0] === exports.TokenType.EOF;
}, exports.isTokenFunction = function isTokenFunction(e) {
    return !!e && e[0] === exports.TokenType.Function;
}, exports.isTokenHash = function isTokenHash(e) {
    return !!e && e[0] === exports.TokenType.Hash;
}, exports.isTokenIdent = function isTokenIdent(e) {
    return !!e && e[0] === exports.TokenType.Ident;
}, exports.isTokenNumber = function isTokenNumber(e) {
    return !!e && e[0] === exports.TokenType.Number;
}, exports.isTokenNumeric = function isTokenNumeric(e) {
    if (!e) return !1;
    switch(e[0]){
        case exports.TokenType.Dimension:
        case exports.TokenType.Number:
        case exports.TokenType.Percentage:
            return !0;
        default:
            return !1;
    }
}, exports.isTokenOpenCurly = function isTokenOpenCurly(e) {
    return !!e && e[0] === exports.TokenType.OpenCurly;
}, exports.isTokenOpenParen = function isTokenOpenParen(e) {
    return !!e && e[0] === exports.TokenType.OpenParen;
}, exports.isTokenOpenSquare = function isTokenOpenSquare(e) {
    return !!e && e[0] === exports.TokenType.OpenSquare;
}, exports.isTokenPercentage = function isTokenPercentage(e) {
    return !!e && e[0] === exports.TokenType.Percentage;
}, exports.isTokenSemicolon = function isTokenSemicolon(e) {
    return !!e && e[0] === exports.TokenType.Semicolon;
}, exports.isTokenString = function isTokenString(e) {
    return !!e && e[0] === exports.TokenType.String;
}, exports.isTokenURL = function isTokenURL(e) {
    return !!e && e[0] === exports.TokenType.URL;
}, exports.isTokenUnicodeRange = function isTokenUnicodeRange(e) {
    return !!e && e[0] === exports.TokenType.UnicodeRange;
}, exports.isTokenWhiteSpaceOrComment = function isTokenWhiteSpaceOrComment(e) {
    if (!e) return !1;
    switch(e[0]){
        case exports.TokenType.Whitespace:
        case exports.TokenType.Comment:
            return !0;
        default:
            return !1;
    }
}, exports.isTokenWhitespace = function isTokenWhitespace(e) {
    return !!e && e[0] === exports.TokenType.Whitespace;
}, exports.mirrorVariant = function mirrorVariant(e) {
    switch(e[0]){
        case exports.TokenType.OpenParen:
            return [
                exports.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseParen:
            return [
                exports.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.OpenCurly:
            return [
                exports.TokenType.CloseCurly,
                "}",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseCurly:
            return [
                exports.TokenType.OpenCurly,
                "{",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.OpenSquare:
            return [
                exports.TokenType.CloseSquare,
                "]",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseSquare:
            return [
                exports.TokenType.OpenSquare,
                "[",
                -1,
                -1,
                void 0
            ];
        default:
            return null;
    }
}, exports.mirrorVariantType = function mirrorVariantType(e) {
    switch(e){
        case exports.TokenType.OpenParen:
            return exports.TokenType.CloseParen;
        case exports.TokenType.CloseParen:
            return exports.TokenType.OpenParen;
        case exports.TokenType.OpenCurly:
            return exports.TokenType.CloseCurly;
        case exports.TokenType.CloseCurly:
            return exports.TokenType.OpenCurly;
        case exports.TokenType.OpenSquare:
            return exports.TokenType.CloseSquare;
        case exports.TokenType.CloseSquare:
            return exports.TokenType.OpenSquare;
        default:
            return null;
    }
}, exports.mutateIdent = function mutateIdent(e, n) {
    const o = [];
    for (const e of n)o.push(e.codePointAt(0));
    const t = String.fromCodePoint(...serializeIdent(o));
    e[1] = t, e[4].value = n;
}, exports.mutateUnit = function mutateUnit(e, n) {
    const o = [];
    for (const e of n)o.push(e.codePointAt(0));
    const t = serializeIdent(o);
    101 === t[0] && insertEscapedCodePoint(t, 0, t[0]);
    const r = String.fromCodePoint(...t), s = "+" === e[4].signCharacter ? e[4].signCharacter : "", i = e[4].value.toString();
    e[1] = `${s}${i}${r}`, e[4].unit = n;
}, exports.stringify = function stringify(...e) {
    let n = "";
    for(let o = 0; o < e.length; o++)n += e[o][1];
    return n;
}, exports.tokenize = function tokenize(e, n) {
    const o = tokenizer(e, n), t = [];
    for(; !o.endOfFile();)t.push(o.nextToken());
    return t.push(o.nextToken()), t;
}, exports.tokenizer = tokenizer;
}}),
"[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function multiplyMatrices(t, n) {
    return [
        t[0] * n[0] + t[1] * n[1] + t[2] * n[2],
        t[3] * n[0] + t[4] * n[1] + t[5] * n[2],
        t[6] * n[0] + t[7] * n[1] + t[8] * n[2]
    ];
}
const t = [
    .955473421488075,
    -.02309845494876471,
    .06325924320057072,
    -.0283697093338637,
    1.0099953980813041,
    .021041441191917323,
    .012314014864481998,
    -.020507649298898964,
    1.330365926242124
];
/**
 * Bradford chromatic adaptation from D50 to D65
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function D50_to_D65(n) {
    return multiplyMatrices(t, n);
}
const n = [
    1.0479297925449969,
    .022946870601609652,
    -.05019226628920524,
    .02962780877005599,
    .9904344267538799,
    -.017073799063418826,
    -.009243040646204504,
    .015055191490298152,
    .7518742814281371
];
/**
 * Bradford chromatic adaptation from D65 to D50
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html
 */ function D65_to_D50(t) {
    return multiplyMatrices(n, t);
}
/**
 * @param {number} hue - Hue as degrees 0..360
 * @param {number} sat - Saturation as percentage 0..100
 * @param {number} light - Lightness as percentage 0..100
 * @return {number[]} Array of sRGB components; in-gamut colors in range [0..1]
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js
 */ function HSL_to_sRGB(t) {
    let n = t[0] % 360;
    const _ = t[1] / 100, o = t[2] / 100;
    return n < 0 && (n += 360), [
        HSL_to_sRGB_channel(0, n, _, o),
        HSL_to_sRGB_channel(8, n, _, o),
        HSL_to_sRGB_channel(4, n, _, o)
    ];
}
function HSL_to_sRGB_channel(t, n, _, o) {
    const e = (t + n / 30) % 12;
    return o - _ * Math.min(o, 1 - o) * Math.max(-1, Math.min(e - 3, 9 - e, 1));
}
/**
 * @param {number} hue -  Hue as degrees 0..360
 * @param {number} white -  Whiteness as percentage 0..100
 * @param {number} black -  Blackness as percentage 0..100
 * @return {number[]} Array of RGB components 0..1
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js
 */ function HWB_to_sRGB(t) {
    const n = t[0], _ = t[1] / 100, o = t[2] / 100;
    if (_ + o >= 1) {
        const t = _ / (_ + o);
        return [
            t,
            t,
            t
        ];
    }
    const e = HSL_to_sRGB([
        n,
        100,
        50
    ]), r = 1 - _ - o;
    return [
        e[0] * r + _,
        e[1] * r + _,
        e[2] * r + _
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function LCH_to_Lab(t) {
    const n = t[2] * Math.PI / 180;
    return [
        t[0],
        t[1] * Math.cos(n),
        t[1] * Math.sin(n)
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function Lab_to_LCH(t) {
    const n = 180 * Math.atan2(t[2], t[1]) / Math.PI;
    return [
        t[0],
        Math.sqrt(Math.pow(t[1], 2) + Math.pow(t[2], 2)),
        n >= 0 ? n : n + 360
    ];
}
const _ = [
    .3457 / .3585,
    1,
    .2958 / .3585
];
/**
 * Convert Lab to D50-adapted XYZ
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ function Lab_to_XYZ(t) {
    const n = 24389 / 27, o = 216 / 24389, e = (t[0] + 16) / 116, r = t[1] / 500 + e, a = e - t[2] / 200;
    return [
        (Math.pow(r, 3) > o ? Math.pow(r, 3) : (116 * r - 16) / n) * _[0],
        (t[0] > 8 ? Math.pow((t[0] + 16) / 116, 3) : t[0] / n) * _[1],
        (Math.pow(a, 3) > o ? Math.pow(a, 3) : (116 * a - 16) / n) * _[2]
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLCH_to_OKLab(t) {
    const n = t[2] * Math.PI / 180;
    return [
        t[0],
        t[1] * Math.cos(n),
        t[1] * Math.sin(n)
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLab_to_OKLCH(t) {
    const n = 180 * Math.atan2(t[2], t[1]) / Math.PI;
    return [
        t[0],
        Math.sqrt(t[1] ** 2 + t[2] ** 2),
        n >= 0 ? n : n + 360
    ];
}
const o = [
    1.2268798758459243,
    -.5578149944602171,
    .2813910456659647,
    -.0405757452148008,
    1.112286803280317,
    -.0717110580655164,
    -.0763729366746601,
    -.4214933324022432,
    1.5869240198367816
], e = [
    1,
    .3963377773761749,
    .2158037573099136,
    1,
    -.1055613458156586,
    -.0638541728258133,
    1,
    -.0894841775298119,
    -1.2914855480194092
];
/**
 * Given OKLab, convert to XYZ relative to D65
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLab_to_XYZ(t) {
    const n = multiplyMatrices(e, t);
    return multiplyMatrices(o, [
        n[0] ** 3,
        n[1] ** 3,
        n[2] ** 3
    ]);
}
/**
 * Assuming XYZ is relative to D50, convert to CIE Lab
 * from CIE standard, which now defines these as a rational fraction
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_Lab(t) {
    const n = compute_f(t[0] / _[0]), o = compute_f(t[1] / _[1]);
    return [
        116 * o - 16,
        500 * (n - o),
        200 * (o - compute_f(t[2] / _[2]))
    ];
}
const r = 216 / 24389, a = 24389 / 27;
function compute_f(t) {
    return t > r ? Math.cbrt(t) : (a * t + 16) / 116;
}
const i = [
    .819022437996703,
    .3619062600528904,
    -.1288737815209879,
    .0329836539323885,
    .9292868615863434,
    .0361446663506424,
    .0481771893596242,
    .2642395317527308,
    .6335478284694309
], l = [
    .210454268309314,
    .7936177747023054,
    -.0040720430116193,
    1.9779985324311684,
    -2.42859224204858,
    .450593709617411,
    .0259040424655478,
    .7827717124575296,
    -.8086757549230774
];
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 *
 * XYZ <-> LMS matrices recalculated for consistent reference white
 * @see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
 */ function XYZ_to_OKLab(t) {
    const n = multiplyMatrices(i, t);
    return multiplyMatrices(l, [
        Math.cbrt(n[0]),
        Math.cbrt(n[1]),
        Math.cbrt(n[2])
    ]);
}
const s = [
    30757411 / 17917100,
    -6372589 / 17917100,
    -4539589 / 17917100,
    -.666684351832489,
    1.616481236634939,
    467509 / 29648200,
    792561 / 44930125,
    -1921689 / 44930125,
    .942103121235474
];
/**
 * Convert XYZ to linear-light rec2020
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const c = [
    446124 / 178915,
    -333277 / 357830,
    -72051 / 178915,
    -14852 / 17905,
    63121 / 35810,
    423 / 17905,
    11844 / 330415,
    -50337 / 660830,
    316169 / 330415
];
/**
 * Convert XYZ to linear-light P3
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_lin_P3(t) {
    return multiplyMatrices(c, t);
}
const u = [
    1.3457868816471583,
    -.25557208737979464,
    -.05110186497554526,
    -.5446307051249019,
    1.5082477428451468,
    .02052744743642139,
    0,
    0,
    1.2119675456389452
];
/**
 * Convert D50 XYZ to linear-light prophoto-rgb
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ const h = [
    1829569 / 896150,
    -506331 / 896150,
    -308931 / 896150,
    -851781 / 878810,
    1648619 / 878810,
    36519 / 878810,
    16779 / 1248040,
    -147721 / 1248040,
    1266979 / 1248040
];
/**
 * Convert XYZ to linear-light a98-rgb
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const m = [
    12831 / 3959,
    -329 / 214,
    -1974 / 3959,
    -851781 / 878810,
    1648619 / 878810,
    36519 / 878810,
    705 / 12673,
    -2585 / 12673,
    705 / 667
];
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_lin_sRGB(t) {
    return multiplyMatrices(m, t);
}
/**
 * Convert an array of linear-light rec2020 RGB  in the range 0.0-1.0
 * to gamma corrected form ITU-R BT.2020-2 p.4
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const p = 1.09929682680944, D = .018053968510807;
function gam_2020_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ > D ? n * (p * Math.pow(_, .45) - (p - 1)) : 4.5 * t;
}
/**
 * Convert an array of linear-light sRGB values in the range 0.0-1.0 to gamma corrected form
 * Extended transfer function:
 *  For negative values, linear portion extends on reflection
 *  of axis, then uses reflected pow below that
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://en.wikipedia.org/wiki/SRGB
 */ function gam_sRGB(t) {
    return [
        gam_sRGB_channel(t[0]),
        gam_sRGB_channel(t[1]),
        gam_sRGB_channel(t[2])
    ];
}
function gam_sRGB_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ > .0031308 ? n * (1.055 * Math.pow(_, 1 / 2.4) - .055) : 12.92 * t;
}
/**
 * Convert an array of linear-light display-p3 RGB in the range 0.0-1.0
 * to gamma corrected form
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function gam_P3(t) {
    return gam_sRGB(t);
}
/**
 * Convert an array of linear-light prophoto-rgb in the range 0.0-1.0
 * to gamma corrected form.
 * Transfer curve is gamma 1.8 with a small linear portion.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const b = 1 / 512;
function gam_ProPhoto_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ >= b ? n * Math.pow(_, 1 / 1.8) : 16 * t;
}
/**
 * Convert an array of linear-light a98-rgb in the range 0.0-1.0
 * to gamma corrected form. Negative values are also now accepted
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function gam_a98rgb_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return n * Math.pow(_, 256 / 563);
}
/**
 * Convert an array of rec2020 RGB values in the range 0.0 - 1.0
 * to linear light (un-companded) form.
 * ITU-R BT.2020-2 p.4
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const g = 1.09929682680944, X = .018053968510807;
function lin_2020_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ < 4.5 * X ? t / 4.5 : n * Math.pow((_ + g - 1) / g, 1 / .45);
}
const Y = [
    63426534 / 99577255,
    20160776 / 139408157,
    47086771 / 278816314,
    26158966 / 99577255,
    .677998071518871,
    8267143 / 139408157,
    0,
    19567812 / 697040785,
    1.0609850577107909
];
/**
 * Convert an array of linear-light rec2020 values to CIE XYZ
 * using  D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ /**
 * Convert an array of of sRGB values where in-gamut values are in the range
 * [0 - 1] to linear light (un-companded) form.
 * Extended transfer function:
 *  For negative values, linear portion is extended on reflection of axis,
 *  then reflected power function is used.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://en.wikipedia.org/wiki/SRGB
 */ function lin_sRGB(t) {
    return [
        lin_sRGB_channel(t[0]),
        lin_sRGB_channel(t[1]),
        lin_sRGB_channel(t[2])
    ];
}
function lin_sRGB_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ <= .04045 ? t / 12.92 : n * Math.pow((_ + .055) / 1.055, 2.4);
}
/**
 * Convert an array of display-p3 RGB values in the range 0.0 - 1.0
 * to linear light (un-companded) form.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function lin_P3(t) {
    return lin_sRGB(t);
}
const Z = [
    608311 / 1250200,
    189793 / 714400,
    198249 / 1000160,
    35783 / 156275,
    247089 / 357200,
    198249 / 2500400,
    0,
    32229 / 714400,
    5220557 / 5000800
];
/**
 * Convert an array of linear-light display-p3 values to CIE XYZ
 * using D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ function lin_P3_to_XYZ(t) {
    return multiplyMatrices(Z, t);
}
/**
 * Convert an array of prophoto-rgb values where in-gamut Colors are in the
 * range [0.0 - 1.0] to linear light (un-companded) form. Transfer curve is
 * gamma 1.8 with a small linear portion. Extended transfer function
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const f = 16 / 512;
function lin_ProPhoto_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ <= f ? t / 16 : n * Math.pow(_, 1.8);
}
const L = [
    .7977666449006423,
    .13518129740053308,
    .0313477341283922,
    .2880748288194013,
    .711835234241873,
    8993693872564e-17,
    0,
    0,
    .8251046025104602
];
/**
 * Convert an array of linear-light prophoto-rgb values to CIE D50 XYZ.
 * Matrix cannot be expressed in rational form, but is calculated to 64 bit accuracy.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see see https://github.com/w3c/csswg-drafts/issues/7675
 */ function lin_a98rgb_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return n * Math.pow(_, 563 / 256);
}
const M = [
    573536 / 994567,
    263643 / 1420810,
    187206 / 994567,
    591459 / 1989134,
    6239551 / 9945670,
    374412 / 4972835,
    53769 / 1989134,
    351524 / 4972835,
    4929758 / 4972835
];
/**
 * Convert an array of linear-light a98-rgb values to CIE XYZ
 * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 * has greater numerical precision than section 4.3.5.3 of
 * https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
 * but the values below were calculated from first principles
 * from the chromaticity coordinates of R G B W
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 * @see https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/matrixmaker.html
 */ const d = [
    506752 / 1228815,
    87881 / 245763,
    12673 / 70218,
    87098 / 409605,
    175762 / 245763,
    12673 / 175545,
    7918 / 409605,
    87881 / 737289,
    1001167 / 1053270
];
/**
 * Convert an array of linear-light sRGB values to CIE XYZ
 * using sRGB's own white, D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function lin_sRGB_to_XYZ(t) {
    return multiplyMatrices(d, t);
}
/**
 * Convert an array of gamma-corrected sRGB values in the 0.0 to 1.0 range to HSL.
 *
 * @param {Color} RGB [r, g, b]
 * - Red component 0..1
 * - Green component 0..1
 * - Blue component 0..1
 * @return {number[]} Array of HSL values: Hue as degrees 0..360, Saturation and Lightness as percentages 0..100
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/utilities.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 *
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/better-rgbToHsl.js
 */ function sRGB_to_HSL(t) {
    const n = t[0], _ = t[1], o = t[2], e = Math.max(n, _, o), r = Math.min(n, _, o), a = (r + e) / 2, i = e - r;
    let l = Number.NaN, s = 0;
    if (0 !== Math.round(1e5 * i)) {
        const t = Math.round(1e5 * a);
        switch(s = 0 === t || 1e5 === t ? 0 : (e - a) / Math.min(a, 1 - a), e){
            case n:
                l = (_ - o) / i + (_ < o ? 6 : 0);
                break;
            case _:
                l = (o - n) / i + 2;
                break;
            case o:
                l = (n - _) / i + 4;
        }
        l *= 60;
    }
    return s < 0 && (l += 180, s = Math.abs(s)), l >= 360 && (l -= 360), [
        l,
        100 * s,
        100 * a
    ];
}
function sRGB_to_Hue(t) {
    const n = t[0], _ = t[1], o = t[2], e = Math.max(n, _, o), r = Math.min(n, _, o);
    let a = Number.NaN;
    const i = e - r;
    if (0 !== i) {
        switch(e){
            case n:
                a = (_ - o) / i + (_ < o ? 6 : 0);
                break;
            case _:
                a = (o - n) / i + 2;
                break;
            case o:
                a = (n - _) / i + 4;
        }
        a *= 60;
    }
    return a >= 360 && (a -= 360), a;
}
function inGamut(t) {
    return t[0] >= -1e-4 && t[0] <= 1.0001 && t[1] >= -1e-4 && t[1] <= 1.0001 && t[2] >= -1e-4 && t[2] <= 1.0001;
}
function clip(t) {
    return [
        t[0] < 0 ? 0 : t[0] > 1 ? 1 : t[0],
        t[1] < 0 ? 0 : t[1] > 1 ? 1 : t[1],
        t[2] < 0 ? 0 : t[2] > 1 ? 1 : t[2]
    ];
}
/**
 * @description Calculate deltaE OK which is the simple root sum of squares
 * @param {number[]} reference - Array of OKLab values: L as 0..1, a and b as -1..1
 * @param {number[]} sample - Array of OKLab values: L as 0..1, a and b as -1..1
 * @return {number} How different a color sample is from reference
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js
 */ function deltaEOK(t, n) {
    const [_, o, e] = t, [r, a, i] = n, l = _ - r, s = o - a, c = e - i;
    return Math.sqrt(l ** 2 + s ** 2 + c ** 2);
}
const B = .02, G = 1e-4;
function rayTraceBox(t, n) {
    let _ = 1 / 0, o = -1 / 0;
    const e = [
        0,
        0,
        0
    ];
    for(let r = 0; r < 3; r++){
        const a = t[r], i = n[r] - a;
        e[r] = i;
        const l = 0, s = 1;
        if (i) {
            const t = 1 / i, n = (l - a) * t, e = (s - a) * t;
            o = Math.max(Math.min(n, e), o), _ = Math.min(Math.max(n, e), _);
        } else if (a < l || a > s) return !1;
    }
    return !(o > _ || _ < 0) && (o < 0 && (o = _), !!isFinite(o) && [
        t[0] + e[0] * o,
        t[1] + e[1] * o,
        t[2] + e[2] * o
    ]);
}
function luminance(t) {
    const [n, _, o] = t.map((t)=>t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4));
    return .2126 * n + .7152 * _ + .0722 * o;
}
exports.HSL_to_XYZ_D50 = function HSL_to_XYZ_D50(t) {
    let n = t;
    return n = HSL_to_sRGB(n), n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.HWB_to_XYZ_D50 = function HWB_to_XYZ_D50(t) {
    let n = t;
    return n = HWB_to_sRGB(n), n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.LCH_to_XYZ_D50 = function LCH_to_XYZ_D50(t) {
    let n = t;
    return n = LCH_to_Lab(n), n = Lab_to_XYZ(n), n;
}, exports.Lab_to_XYZ_D50 = function Lab_to_XYZ_D50(t) {
    let n = t;
    return n = Lab_to_XYZ(n), n;
}, exports.OKLCH_to_OKLab = OKLCH_to_OKLab, exports.OKLCH_to_XYZ_D50 = function OKLCH_to_XYZ_D50(t) {
    let n = t;
    return n = OKLCH_to_OKLab(n), n = OKLab_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.OKLab_to_OKLCH = OKLab_to_OKLCH, exports.OKLab_to_XYZ = OKLab_to_XYZ, exports.OKLab_to_XYZ_D50 = function OKLab_to_XYZ_D50(t) {
    let n = t;
    return n = OKLab_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.P3_to_XYZ_D50 = function P3_to_XYZ_D50(t) {
    let n = t;
    return n = lin_P3(n), n = lin_P3_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.ProPhoto_RGB_to_XYZ_D50 = function ProPhoto_RGB_to_XYZ_D50(t) {
    let n = t;
    var _;
    return n = [
        lin_ProPhoto_channel((_ = n)[0]),
        lin_ProPhoto_channel(_[1]),
        lin_ProPhoto_channel(_[2])
    ], n = multiplyMatrices(L, n), n;
}, exports.XYZ_D50_to_HSL = function XYZ_D50_to_HSL(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n = gam_sRGB(n), n = sRGB_to_HSL(n), n;
}, exports.XYZ_D50_to_HWB = function XYZ_D50_to_HWB(t) {
    let n = t;
    n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n);
    const _ = gam_sRGB(n), o = Math.min(_[0], _[1], _[2]), e = 1 - Math.max(_[0], _[1], _[2]);
    return [
        sRGB_to_Hue(_),
        100 * o,
        100 * e
    ];
}, exports.XYZ_D50_to_LCH = function XYZ_D50_to_LCH(t) {
    let n = t;
    return n = XYZ_to_Lab(n), n = Lab_to_LCH(n), n;
}, exports.XYZ_D50_to_Lab = function XYZ_D50_to_Lab(t) {
    let n = t;
    return n = XYZ_to_Lab(n), n;
}, exports.XYZ_D50_to_OKLCH = function XYZ_D50_to_OKLCH(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_OKLab(n), n = OKLab_to_OKLCH(n), n;
}, exports.XYZ_D50_to_OKLab = function XYZ_D50_to_OKLab(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_OKLab(n), n;
}, exports.XYZ_D50_to_P3 = function XYZ_D50_to_P3(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_P3(n), n = gam_P3(n), n;
}, exports.XYZ_D50_to_ProPhoto = function XYZ_D50_to_ProPhoto(t) {
    let n = t;
    var _;
    return n = multiplyMatrices(u, n), n = [
        gam_ProPhoto_channel((_ = n)[0]),
        gam_ProPhoto_channel(_[1]),
        gam_ProPhoto_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_XYZ_D50 = function XYZ_D50_to_XYZ_D50(t) {
    return t;
}, exports.XYZ_D50_to_XYZ_D65 = function XYZ_D50_to_XYZ_D65(t) {
    let n = t;
    return n = D50_to_D65(n), n;
}, exports.XYZ_D50_to_a98_RGB = function XYZ_D50_to_a98_RGB(t) {
    let n = t;
    var _;
    return n = D50_to_D65(n), n = multiplyMatrices(h, n), n = [
        gam_a98rgb_channel((_ = n)[0]),
        gam_a98rgb_channel(_[1]),
        gam_a98rgb_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_lin_sRGB = function XYZ_D50_to_lin_sRGB(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n;
}, exports.XYZ_D50_to_rec_2020 = function XYZ_D50_to_rec_2020(t) {
    let n = t;
    var _;
    return n = D50_to_D65(n), n = multiplyMatrices(s, n), n = [
        gam_2020_channel((_ = n)[0]),
        gam_2020_channel(_[1]),
        gam_2020_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_sRGB = function XYZ_D50_to_sRGB(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n = gam_sRGB(n), n;
}, exports.XYZ_D65_to_XYZ_D50 = function XYZ_D65_to_XYZ_D50(t) {
    let n = t;
    return n = D65_to_D50(n), n;
}, exports.XYZ_to_OKLab = XYZ_to_OKLab, exports.XYZ_to_lin_P3 = XYZ_to_lin_P3, exports.XYZ_to_lin_sRGB = XYZ_to_lin_sRGB, exports.a98_RGB_to_XYZ_D50 = function a98_RGB_to_XYZ_D50(t) {
    let n = t;
    /**
 * Convert an array of a98-rgb values in the range 0.0 - 1.0
 * to linear light (un-companded) form. Negative values are also now accepted
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ var _;
    return n = [
        lin_a98rgb_channel((_ = n)[0]),
        lin_a98rgb_channel(_[1]),
        lin_a98rgb_channel(_[2])
    ], n = multiplyMatrices(M, n), n = D65_to_D50(n), n;
}, exports.clip = clip, exports.contrast_ratio_wcag_2_1 = function contrast_ratio_wcag_2_1(t, n) {
    const _ = luminance(t), o = luminance(n);
    return (Math.max(_, o) + .05) / (Math.min(_, o) + .05);
}, exports.gam_P3 = gam_P3, exports.gam_sRGB = gam_sRGB, exports.inGamut = inGamut, exports.lin_P3 = lin_P3, exports.lin_P3_to_XYZ = lin_P3_to_XYZ, exports.lin_sRGB = lin_sRGB, exports.lin_sRGB_to_XYZ = lin_sRGB_to_XYZ, exports.lin_sRGB_to_XYZ_D50 = function lin_sRGB_to_XYZ_D50(t) {
    let n = t;
    return n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.mapGamut = function mapGamut(t, n, _) {
    const o = t;
    let e = clip(n(o)), r = deltaEOK(OKLCH_to_OKLab(_(e)), OKLCH_to_OKLab(o));
    if (r < B) return e;
    let a = 0, i = o[1], l = !0;
    for(; i - a > G;){
        const t = (a + i) / 2;
        if (o[1] = t, l && inGamut(n(o))) a = t;
        else if (e = clip(n(o)), r = deltaEOK(OKLCH_to_OKLab(_(e)), OKLCH_to_OKLab(o)), r < B) {
            if (B - r < G) return e;
            l = !1, a = t;
        } else i = t;
    }
    return clip(n([
        ...o
    ]));
}, exports.mapGamutRayTrace = function mapGamutRayTrace(t, n, _) {
    const o = t[0], e = t[2];
    let r = n(t);
    const a = n([
        o,
        0,
        e
    ]);
    for(let t = 0; t < 4; t++){
        if (t > 0) {
            const t = _(r);
            t[0] = o, t[2] = e, r = n(t);
        }
        const i = rayTraceBox(a, r);
        if (!i) break;
        r = i;
    }
    return clip(r);
}, exports.namedColors = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, exports.rec_2020_to_XYZ_D50 = function rec_2020_to_XYZ_D50(t) {
    let n = t;
    var _;
    return n = [
        lin_2020_channel((_ = n)[0]),
        lin_2020_channel(_[1]),
        lin_2020_channel(_[2])
    ], n = multiplyMatrices(Y, n), n = D65_to_D50(n), n;
}, exports.sRGB_to_XYZ_D50 = function sRGB_to_XYZ_D50(t) {
    let n = t;
    return n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
};
}}),
"[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function walkerIndexGenerator(e) {
    let n = e.slice();
    return (e, o, t)=>{
        let s = -1;
        for(let i = n.indexOf(o); i < n.length && (s = e.indexOf(n[i]), -1 === s || s < t); i++);
        return -1 === s || s === t && o === e[t] && (s++, s >= e.length) ? -1 : (n = e.slice(), s);
    };
}
function consumeComponentValue(e, o) {
    const t = o[0];
    if (n.isTokenOpenParen(t) || n.isTokenOpenCurly(t) || n.isTokenOpenSquare(t)) {
        const n = consumeSimpleBlock(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenFunction(t)) {
        const n = consumeFunction(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenWhitespace(t)) {
        const n = consumeWhitespace(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenComment(t)) {
        const n = consumeComment(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    return {
        advance: 1,
        node: new TokenNode(t)
    };
}
exports.ComponentValueType = void 0, (e = exports.ComponentValueType || (exports.ComponentValueType = {})).Function = "function", e.SimpleBlock = "simple-block", e.Whitespace = "whitespace", e.Comment = "comment", e.Token = "token";
class ContainerNodeBaseClass {
    value = [];
    indexOf(e) {
        return this.value.indexOf(e);
    }
    at(e) {
        if ("number" == typeof e) return e < 0 && (e = this.value.length + e), this.value[e];
    }
    forEach(e, n) {
        if (0 === this.value.length) return;
        const o = walkerIndexGenerator(this.value);
        let t = 0;
        for(; t < this.value.length;){
            const s = this.value[t];
            let i;
            if (n && (i = {
                ...n
            }), !1 === e({
                node: s,
                parent: this,
                state: i
            }, t)) return !1;
            if (t = o(this.value, s, t), -1 === t) break;
        }
    }
    walk(e, n) {
        0 !== this.value.length && this.forEach((n, o)=>!1 !== e(n, o) && (!("walk" in n.node) || !this.value.includes(n.node) || !1 !== n.node.walk(e, n.state)) && void 0, n);
    }
}
class FunctionNode extends ContainerNodeBaseClass {
    type = exports.ComponentValueType.Function;
    name;
    endToken;
    constructor(e, n, o){
        super(), this.name = e, this.endToken = n, this.value = o;
    }
    getName() {
        return this.name[4].value;
    }
    normalize() {
        n.isTokenEOF(this.endToken) && (this.endToken = [
            n.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]);
    }
    tokens() {
        return n.isTokenEOF(this.endToken) ? [
            this.name,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.name,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>n.isToken(e) ? n.stringify(e) : e.toString()).join("");
        return n.stringify(this.name) + e + n.stringify(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.getName(),
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isFunctionNode() {
        return FunctionNode.isFunctionNode(this);
    }
    static isFunctionNode(e) {
        return !!e && e instanceof FunctionNode && e.type === exports.ComponentValueType.Function;
    }
}
function consumeFunction(e, o) {
    const t = [];
    let s = 1;
    for(;;){
        const i = o[s];
        if (!i || n.isTokenEOF(i)) return e.onParseError(new n.ParseError("Unexpected EOF while consuming a function.", o[0][2], o[o.length - 1][3], [
            "5.4.9. Consume a function",
            "Unexpected EOF"
        ])), {
            advance: o.length,
            node: new FunctionNode(o[0], i, t)
        };
        if (n.isTokenCloseParen(i)) return {
            advance: s + 1,
            node: new FunctionNode(o[0], i, t)
        };
        if (n.isTokenWhiteSpaceOrComment(i)) {
            const n = consumeAllCommentsAndWhitespace(e, o.slice(s));
            s += n.advance, t.push(...n.nodes);
            continue;
        }
        const r = consumeComponentValue(e, o.slice(s));
        s += r.advance, t.push(r.node);
    }
}
class SimpleBlockNode extends ContainerNodeBaseClass {
    type = exports.ComponentValueType.SimpleBlock;
    startToken;
    endToken;
    constructor(e, n, o){
        super(), this.startToken = e, this.endToken = n, this.value = o;
    }
    normalize() {
        if (n.isTokenEOF(this.endToken)) {
            const e = n.mirrorVariant(this.startToken);
            e && (this.endToken = e);
        }
    }
    tokens() {
        return n.isTokenEOF(this.endToken) ? [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>n.isToken(e) ? n.stringify(e) : e.toString()).join("");
        return n.stringify(this.startToken) + e + n.stringify(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            startToken: this.startToken,
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isSimpleBlockNode() {
        return SimpleBlockNode.isSimpleBlockNode(this);
    }
    static isSimpleBlockNode(e) {
        return !!e && e instanceof SimpleBlockNode && e.type === exports.ComponentValueType.SimpleBlock;
    }
}
function consumeSimpleBlock(e, o) {
    const t = n.mirrorVariantType(o[0][0]);
    if (!t) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
    const s = [];
    let i = 1;
    for(;;){
        const r = o[i];
        if (!r || n.isTokenEOF(r)) return e.onParseError(new n.ParseError("Unexpected EOF while consuming a simple block.", o[0][2], o[o.length - 1][3], [
            "5.4.8. Consume a simple block",
            "Unexpected EOF"
        ])), {
            advance: o.length,
            node: new SimpleBlockNode(o[0], r, s)
        };
        if (r[0] === t) return {
            advance: i + 1,
            node: new SimpleBlockNode(o[0], r, s)
        };
        if (n.isTokenWhiteSpaceOrComment(r)) {
            const n = consumeAllCommentsAndWhitespace(e, o.slice(i));
            i += n.advance, s.push(...n.nodes);
            continue;
        }
        const a = consumeComponentValue(e, o.slice(i));
        i += a.advance, s.push(a.node);
    }
}
class WhitespaceNode {
    type = exports.ComponentValueType.Whitespace;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return this.value;
    }
    toString() {
        return n.stringify(...this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isWhitespaceNode() {
        return WhitespaceNode.isWhitespaceNode(this);
    }
    static isWhitespaceNode(e) {
        return !!e && e instanceof WhitespaceNode && e.type === exports.ComponentValueType.Whitespace;
    }
}
function consumeWhitespace(e, o) {
    let t = 0;
    for(;;){
        const e = o[t];
        if (!n.isTokenWhitespace(e)) return {
            advance: t,
            node: new WhitespaceNode(o.slice(0, t))
        };
        t++;
    }
}
class CommentNode {
    type = exports.ComponentValueType.Comment;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return n.stringify(this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isCommentNode() {
        return CommentNode.isCommentNode(this);
    }
    static isCommentNode(e) {
        return !!e && e instanceof CommentNode && e.type === exports.ComponentValueType.Comment;
    }
}
function consumeComment(e, n) {
    return {
        advance: 1,
        node: new CommentNode(n[0])
    };
}
function consumeAllCommentsAndWhitespace(e, o) {
    const t = [];
    let s = 0;
    for(;;)if (n.isTokenWhitespace(o[s])) {
        const e = consumeWhitespace(0, o.slice(s));
        s += e.advance, t.push(e.node);
    } else {
        if (!n.isTokenComment(o[s])) return {
            advance: s,
            nodes: t
        };
        t.push(new CommentNode(o[s])), s++;
    }
}
class TokenNode {
    type = exports.ComponentValueType.Token;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return this.value[1];
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isTokenNode() {
        return TokenNode.isTokenNode(this);
    }
    static isTokenNode(e) {
        return !!e && e instanceof TokenNode && e.type === exports.ComponentValueType.Token;
    }
}
function forEach(e, n, o) {
    if (0 === e.length) return;
    const t = walkerIndexGenerator(e);
    let s = 0;
    for(; s < e.length;){
        const i = e[s];
        let r;
        if (o && (r = {
            ...o
        }), !1 === n({
            node: i,
            parent: {
                value: e
            },
            state: r
        }, s)) return !1;
        if (s = t(e, i, s), -1 === s) break;
    }
}
function walk(e, n, o) {
    0 !== e.length && forEach(e, (o, t)=>!1 !== n(o, t) && (!("walk" in o.node) || !e.includes(o.node) || !1 !== o.node.walk(n, o.state)) && void 0, o);
}
function isWhitespaceNode(e) {
    return WhitespaceNode.isWhitespaceNode(e);
}
function isCommentNode(e) {
    return CommentNode.isCommentNode(e);
}
exports.CommentNode = CommentNode, exports.ContainerNodeBaseClass = ContainerNodeBaseClass, exports.FunctionNode = FunctionNode, exports.SimpleBlockNode = SimpleBlockNode, exports.TokenNode = TokenNode, exports.WhitespaceNode = WhitespaceNode, exports.forEach = forEach, exports.gatherNodeAncestry = function gatherNodeAncestry(e) {
    const n = new Map;
    return e.walk((e)=>{
        Array.isArray(e.node) ? e.node.forEach((o)=>{
            n.set(o, e.parent);
        }) : n.set(e.node, e.parent);
    }), n;
}, exports.isCommentNode = isCommentNode, exports.isFunctionNode = function isFunctionNode(e) {
    return FunctionNode.isFunctionNode(e);
}, exports.isSimpleBlockNode = function isSimpleBlockNode(e) {
    return SimpleBlockNode.isSimpleBlockNode(e);
}, exports.isTokenNode = function isTokenNode(e) {
    return TokenNode.isTokenNode(e);
}, exports.isWhiteSpaceOrCommentNode = function isWhiteSpaceOrCommentNode(e) {
    return isWhitespaceNode(e) || isCommentNode(e);
}, exports.isWhitespaceNode = isWhitespaceNode, exports.parseCommaSeparatedListOfComponentValues = function parseCommaSeparatedListOfComponentValues(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    if (0 === e.length) return [];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = [];
    let r = [], a = 0;
    for(;;){
        if (!s[a] || n.isTokenEOF(s[a])) return r.length && i.push(r), i;
        if (n.isTokenComma(s[a])) {
            i.push(r), r = [], a++;
            continue;
        }
        const o = consumeComponentValue(t, e.slice(a));
        r.push(o.node), a += o.advance;
    }
}, exports.parseComponentValue = function parseComponentValue(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = consumeComponentValue(t, s);
    if (n.isTokenEOF(s[Math.min(i.advance, s.length - 1)])) return i.node;
    t.onParseError(new n.ParseError("Expected EOF after parsing a component value.", e[0][2], e[e.length - 1][3], [
        "5.3.9. Parse a component value",
        "Expected EOF"
    ]));
}, exports.parseListOfComponentValues = function parseListOfComponentValues(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = [];
    let r = 0;
    for(;;){
        if (!s[r] || n.isTokenEOF(s[r])) return i;
        const e = consumeComponentValue(t, s.slice(r));
        i.push(e.node), r += e.advance;
    }
}, exports.replaceComponentValues = function replaceComponentValues(e, n) {
    for(let o = 0; o < e.length; o++){
        walk(e[o], (e, o)=>{
            if ("number" != typeof o) return;
            const t = n(e.node);
            t && (Array.isArray(t) ? e.parent.value.splice(o, 1, ...t) : e.parent.value.splice(o, 1, t));
        });
    }
    return e;
}, exports.sourceIndices = function sourceIndices(e) {
    if (Array.isArray(e)) {
        const n = e[0];
        if (!n) return [
            0,
            0
        ];
        const o = e[e.length - 1] || n;
        return [
            sourceIndices(n)[0],
            sourceIndices(o)[1]
        ];
    }
    const n = e.tokens(), o = n[0], t = n[n.length - 1];
    return o && t ? [
        o[2],
        t[3]
    ] : [
        0,
        0
    ];
}, exports.stringify = function stringify(e) {
    return e.map((e)=>e.map((e)=>n.stringify(...e.tokens())).join("")).join(",");
}, exports.walk = walk, exports.walkerIndexGenerator = walkerIndexGenerator;
}}),
"[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const t = /[A-Z]/g;
function toLowerCaseAZ(e) {
    return e.replace(t, (e)=>String.fromCharCode(e.charCodeAt(0) + 32));
}
const o = {
    cm: "px",
    in: "px",
    mm: "px",
    pc: "px",
    pt: "px",
    px: "px",
    q: "px",
    deg: "deg",
    grad: "deg",
    rad: "deg",
    turn: "deg",
    ms: "s",
    s: "s",
    hz: "hz",
    khz: "hz"
}, r = new Map([
    [
        "cm",
        (e)=>e
    ],
    [
        "mm",
        (e)=>10 * e
    ],
    [
        "q",
        (e)=>40 * e
    ],
    [
        "in",
        (e)=>e / 2.54
    ],
    [
        "pc",
        (e)=>e / 2.54 * 6
    ],
    [
        "pt",
        (e)=>e / 2.54 * 72
    ],
    [
        "px",
        (e)=>e / 2.54 * 96
    ]
]), i = new Map([
    [
        "deg",
        (e)=>e
    ],
    [
        "grad",
        (e)=>e / .9
    ],
    [
        "rad",
        (e)=>e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>e / 360
    ]
]), u = new Map([
    [
        "deg",
        (e)=>.9 * e
    ],
    [
        "grad",
        (e)=>e
    ],
    [
        "rad",
        (e)=>.9 * e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>.9 * e / 360
    ]
]), a = new Map([
    [
        "hz",
        (e)=>e
    ],
    [
        "khz",
        (e)=>e / 1e3
    ]
]), s = new Map([
    [
        "cm",
        (e)=>2.54 * e
    ],
    [
        "mm",
        (e)=>25.4 * e
    ],
    [
        "q",
        (e)=>25.4 * e * 4
    ],
    [
        "in",
        (e)=>e
    ],
    [
        "pc",
        (e)=>6 * e
    ],
    [
        "pt",
        (e)=>72 * e
    ],
    [
        "px",
        (e)=>96 * e
    ]
]), l = new Map([
    [
        "hz",
        (e)=>1e3 * e
    ],
    [
        "khz",
        (e)=>e
    ]
]), c = new Map([
    [
        "cm",
        (e)=>e / 10
    ],
    [
        "mm",
        (e)=>e
    ],
    [
        "q",
        (e)=>4 * e
    ],
    [
        "in",
        (e)=>e / 25.4
    ],
    [
        "pc",
        (e)=>e / 25.4 * 6
    ],
    [
        "pt",
        (e)=>e / 25.4 * 72
    ],
    [
        "px",
        (e)=>e / 25.4 * 96
    ]
]), m = new Map([
    [
        "ms",
        (e)=>e
    ],
    [
        "s",
        (e)=>e / 1e3
    ]
]), v = new Map([
    [
        "cm",
        (e)=>e / 6 * 2.54
    ],
    [
        "mm",
        (e)=>e / 6 * 25.4
    ],
    [
        "q",
        (e)=>e / 6 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 6
    ],
    [
        "pc",
        (e)=>e
    ],
    [
        "pt",
        (e)=>e / 6 * 72
    ],
    [
        "px",
        (e)=>e / 6 * 96
    ]
]), T = new Map([
    [
        "cm",
        (e)=>e / 72 * 2.54
    ],
    [
        "mm",
        (e)=>e / 72 * 25.4
    ],
    [
        "q",
        (e)=>e / 72 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 72
    ],
    [
        "pc",
        (e)=>e / 72 * 6
    ],
    [
        "pt",
        (e)=>e
    ],
    [
        "px",
        (e)=>e / 72 * 96
    ]
]), p = new Map([
    [
        "cm",
        (e)=>e / 96 * 2.54
    ],
    [
        "mm",
        (e)=>e / 96 * 25.4
    ],
    [
        "q",
        (e)=>e / 96 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 96
    ],
    [
        "pc",
        (e)=>e / 96 * 6
    ],
    [
        "pt",
        (e)=>e / 96 * 72
    ],
    [
        "px",
        (e)=>e
    ]
]), N = new Map([
    [
        "cm",
        (e)=>e / 4 / 10
    ],
    [
        "mm",
        (e)=>e / 4
    ],
    [
        "q",
        (e)=>e
    ],
    [
        "in",
        (e)=>e / 4 / 25.4
    ],
    [
        "pc",
        (e)=>e / 4 / 25.4 * 6
    ],
    [
        "pt",
        (e)=>e / 4 / 25.4 * 72
    ],
    [
        "px",
        (e)=>e / 4 / 25.4 * 96
    ]
]), f = new Map([
    [
        "deg",
        (e)=>180 * e / Math.PI
    ],
    [
        "grad",
        (e)=>180 * e / Math.PI / .9
    ],
    [
        "rad",
        (e)=>e
    ],
    [
        "turn",
        (e)=>180 * e / Math.PI / 360
    ]
]), d = new Map([
    [
        "ms",
        (e)=>1e3 * e
    ],
    [
        "s",
        (e)=>e
    ]
]), k = new Map([
    [
        "deg",
        (e)=>360 * e
    ],
    [
        "grad",
        (e)=>360 * e / .9
    ],
    [
        "rad",
        (e)=>360 * e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>e
    ]
]), C = new Map([
    [
        "cm",
        r
    ],
    [
        "mm",
        c
    ],
    [
        "q",
        N
    ],
    [
        "in",
        s
    ],
    [
        "pc",
        v
    ],
    [
        "pt",
        T
    ],
    [
        "px",
        p
    ],
    [
        "ms",
        m
    ],
    [
        "s",
        d
    ],
    [
        "deg",
        i
    ],
    [
        "grad",
        u
    ],
    [
        "rad",
        f
    ],
    [
        "turn",
        k
    ],
    [
        "hz",
        a
    ],
    [
        "khz",
        l
    ]
]);
function convertUnit(e, t) {
    if (!n.isTokenDimension(e)) return t;
    if (!n.isTokenDimension(t)) return t;
    const o = toLowerCaseAZ(e[4].unit), r = toLowerCaseAZ(t[4].unit);
    if (o === r) return t;
    const i = C.get(r);
    if (!i) return t;
    const u = i.get(o);
    if (!u) return t;
    const a = u(t[4].value), s = [
        n.TokenType.Dimension,
        "",
        t[2],
        t[3],
        {
            ...t[4],
            signCharacter: a < 0 ? "-" : void 0,
            type: Number.isInteger(a) ? n.NumberType.Integer : n.NumberType.Number,
            value: a
        }
    ];
    return n.mutateUnit(s, e[4].unit), s;
}
function toCanonicalUnit(e) {
    if (!n.isTokenDimension(e)) return e;
    const t = toLowerCaseAZ(e[4].unit), r = o[t];
    if (t === r) return e;
    const i = C.get(t);
    if (!i) return e;
    const u = i.get(r);
    if (!u) return e;
    const a = u(e[4].value), s = [
        n.TokenType.Dimension,
        "",
        e[2],
        e[3],
        {
            ...e[4],
            signCharacter: a < 0 ? "-" : void 0,
            type: Number.isInteger(a) ? n.NumberType.Integer : n.NumberType.Number,
            value: a
        }
    ];
    return n.mutateUnit(s, r), s;
}
function addition(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value;
    let r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenPercentage(r)) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenDimension(r) && (r = convertUnit(o, r), toLowerCaseAZ(o[4].unit) === toLowerCaseAZ(r[4].unit))) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function division(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value, r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: Number.isInteger(t) ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: Number.isInteger(t) ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function isCalculation(e) {
    return !!e && "object" == typeof e && "inputs" in e && Array.isArray(e.inputs) && "operation" in e;
}
function solve(n) {
    if (-1 === n) return -1;
    const t = [];
    for(let o = 0; o < n.inputs.length; o++){
        const r = n.inputs[o];
        if (e.isTokenNode(r)) {
            t.push(r);
            continue;
        }
        const i = solve(r);
        if (-1 === i) return -1;
        t.push(i);
    }
    return n.operation(t);
}
function multiplication(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value, r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenNumber(o) && n.isTokenPercentage(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    if (n.isTokenNumber(o) && n.isTokenDimension(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + r[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: r[4].unit
            }
        ]);
    }
    return -1;
}
function resolveGlobalsAndConstants(t, o) {
    for(let r = 0; r < t.length; r++){
        const i = t[r];
        if (!e.isTokenNode(i)) continue;
        const u = i.value;
        if (!n.isTokenIdent(u)) continue;
        const a = toLowerCaseAZ(u[4].value);
        switch(a){
            case "e":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    Math.E.toString(),
                    u[2],
                    u[3],
                    {
                        value: Math.E,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "pi":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    Math.PI.toString(),
                    u[2],
                    u[3],
                    {
                        value: Math.PI,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "infinity":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "infinity",
                    u[2],
                    u[3],
                    {
                        value: 1 / 0,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "-infinity":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "-infinity",
                    u[2],
                    u[3],
                    {
                        value: -1 / 0,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "nan":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "NaN",
                    u[2],
                    u[3],
                    {
                        value: Number.NaN,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            default:
                if (o.has(a)) {
                    const n = o.get(a);
                    t.splice(r, 1, new e.TokenNode(n));
                }
        }
    }
    return t;
}
function unary(e) {
    if (1 !== e.length) return -1;
    const t = e[0].value;
    return n.isTokenNumeric(t) ? e[0] : -1;
}
function resultToCalculation(e, t, o) {
    return n.isTokenDimension(t) ? dimensionToCalculation(e, t[4].unit, o) : n.isTokenPercentage(t) ? percentageToCalculation(e, o) : n.isTokenNumber(t) ? numberToCalculation(e, o) : -1;
}
function dimensionToCalculation(t, o, r) {
    const i = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Dimension,
                r.toString() + o,
                i[0][2],
                i[i.length - 1][3],
                {
                    value: r,
                    type: Number.isInteger(r) ? n.NumberType.Integer : n.NumberType.Number,
                    unit: o
                }
            ])
        ],
        operation: unary
    };
}
function percentageToCalculation(t, o) {
    const r = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Percentage,
                o.toString() + "%",
                r[0][2],
                r[r.length - 1][3],
                {
                    value: o
                }
            ])
        ],
        operation: unary
    };
}
function numberToCalculation(t, o) {
    const r = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Number,
                o.toString(),
                r[0][2],
                r[r.length - 1][3],
                {
                    value: o,
                    type: Number.isInteger(o) ? n.NumberType.Integer : n.NumberType.Number
                }
            ])
        ],
        operation: unary
    };
}
function solveACos(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.acos(o[4].value));
}
function solveASin(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.asin(o[4].value));
}
function solveATan(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.atan(o[4].value));
}
function isDimensionOrNumber(e) {
    return n.isTokenDimension(e) || n.isTokenNumber(e);
}
function arrayOfSameNumeric(e) {
    if (0 === e.length) return !0;
    const t = e[0];
    if (!n.isTokenNumeric(t)) return !1;
    if (1 === e.length) return !0;
    if (n.isTokenDimension(t)) {
        const n = toLowerCaseAZ(t[4].unit);
        for(let o = 1; o < e.length; o++){
            const r = e[o];
            if (t[0] !== r[0]) return !1;
            if (n !== toLowerCaseAZ(r[4].unit)) return !1;
        }
        return !0;
    }
    for(let n = 1; n < e.length; n++){
        const o = e[n];
        if (t[0] !== o[0]) return !1;
    }
    return !0;
}
function twoOfSameNumeric(e, t) {
    return !!n.isTokenNumeric(e) && (n.isTokenDimension(e) ? e[0] === t[0] && toLowerCaseAZ(e[4].unit) === toLowerCaseAZ(t[4].unit) : e[0] === t[0]);
}
function solveATan2(e, n, t) {
    const o = n.value;
    if (!isDimensionOrNumber(o)) return -1;
    const r = convertUnit(o, t.value);
    if (!twoOfSameNumeric(o, r)) return -1;
    return dimensionToCalculation(e, "rad", Math.atan2(o[4].value, r[4].value));
}
function solveAbs(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    if (!o.rawPercentages && n.isTokenPercentage(r)) return -1;
    return resultToCalculation(e, r, Math.abs(r[4].value));
}
function solveClamp(t, o, r, i, u) {
    if (!e.isTokenNode(o) || !e.isTokenNode(r) || !e.isTokenNode(i)) return -1;
    const a = o.value;
    if (!n.isTokenNumeric(a)) return -1;
    if (!u.rawPercentages && n.isTokenPercentage(a)) return -1;
    const s = convertUnit(a, r.value);
    if (!twoOfSameNumeric(a, s)) return -1;
    const l = convertUnit(a, i.value);
    if (!twoOfSameNumeric(a, l)) return -1;
    return resultToCalculation(t, a, Math.max(a[4].value, Math.min(s[4].value, l[4].value)));
}
function solveCos(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    let r = o[4].value;
    if (n.isTokenDimension(o)) switch(o[4].unit.toLowerCase()){
        case "rad":
            break;
        case "deg":
            r = i.get("rad")(o[4].value);
            break;
        case "grad":
            r = u.get("rad")(o[4].value);
            break;
        case "turn":
            r = k.get("rad")(o[4].value);
            break;
        default:
            return -1;
    }
    return r = Math.cos(r), numberToCalculation(e, r);
}
function solveExp(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return numberToCalculation(e, Math.exp(o[4].value));
}
function solveHypot(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.hypot(...a);
    return resultToCalculation(t, i, s);
}
function solveMax(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.max(...a);
    return resultToCalculation(t, i, s);
}
function solveMin(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.min(...a);
    return resultToCalculation(t, i, s);
}
function solveMod(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    const i = convertUnit(r, o.value);
    if (!twoOfSameNumeric(r, i)) return -1;
    let u;
    return u = 0 === i[4].value ? Number.NaN : Number.isFinite(r[4].value) && (Number.isFinite(i[4].value) || (i[4].value !== Number.POSITIVE_INFINITY || r[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r[4].value, -0)) && (i[4].value !== Number.NEGATIVE_INFINITY || r[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r[4].value, 0))) ? Number.isFinite(i[4].value) ? (r[4].value % i[4].value + i[4].value) % i[4].value : r[4].value : Number.NaN, resultToCalculation(e, r, u);
}
function solvePow(e, t, o) {
    const r = t.value, i = o.value;
    if (!n.isTokenNumber(r)) return -1;
    if (!twoOfSameNumeric(r, i)) return -1;
    return numberToCalculation(e, Math.pow(r[4].value, i[4].value));
}
function solveRem(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    const i = convertUnit(r, o.value);
    if (!twoOfSameNumeric(r, i)) return -1;
    let u;
    return u = 0 === i[4].value ? Number.NaN : Number.isFinite(r[4].value) ? Number.isFinite(i[4].value) ? r[4].value % i[4].value : r[4].value : Number.NaN, resultToCalculation(e, r, u);
}
function solveRound(e, t, o, r, i) {
    const u = o.value;
    if (!n.isTokenNumeric(u)) return -1;
    if (!i.rawPercentages && n.isTokenPercentage(u)) return -1;
    const a = convertUnit(u, r.value);
    if (!twoOfSameNumeric(u, a)) return -1;
    let s;
    if (0 === a[4].value) s = Number.NaN;
    else if (Number.isFinite(u[4].value) || Number.isFinite(a[4].value)) if (!Number.isFinite(u[4].value) && Number.isFinite(a[4].value)) s = u[4].value;
    else if (Number.isFinite(u[4].value) && !Number.isFinite(a[4].value)) switch(t){
        case "down":
            s = u[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * u[4].value) ? -0 : 0;
            break;
        case "up":
            s = u[4].value > 0 ? 1 / 0 : Object.is(0, 0 * u[4].value) ? 0 : -0;
            break;
        default:
            s = Object.is(0, 0 * u[4].value) ? 0 : -0;
    }
    else if (Number.isFinite(a[4].value)) switch(t){
        case "down":
            s = Math.floor(u[4].value / a[4].value) * a[4].value;
            break;
        case "up":
            s = Math.ceil(u[4].value / a[4].value) * a[4].value;
            break;
        case "to-zero":
            s = Math.trunc(u[4].value / a[4].value) * a[4].value;
            break;
        default:
            {
                let e = Math.floor(u[4].value / a[4].value) * a[4].value, n = Math.ceil(u[4].value / a[4].value) * a[4].value;
                if (e > n) {
                    const t = e;
                    e = n, n = t;
                }
                const t = Math.abs(u[4].value - e), o = Math.abs(u[4].value - n);
                s = t === o ? n : t < o ? e : n;
                break;
            }
    }
    else s = u[4].value;
    else s = Number.NaN;
    return resultToCalculation(e, u, s);
}
function solveSign(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    if (!o.rawPercentages && n.isTokenPercentage(r)) return -1;
    return numberToCalculation(e, Math.sign(r[4].value));
}
function solveSin(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    let r = o[4].value;
    if (n.isTokenDimension(o)) switch(toLowerCaseAZ(o[4].unit)){
        case "rad":
            break;
        case "deg":
            r = i.get("rad")(o[4].value);
            break;
        case "grad":
            r = u.get("rad")(o[4].value);
            break;
        case "turn":
            r = k.get("rad")(o[4].value);
            break;
        default:
            return -1;
    }
    return r = Math.sin(r), numberToCalculation(e, r);
}
function solveSqrt(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return numberToCalculation(e, Math.sqrt(o[4].value));
}
function solveTan(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    const r = o[4].value;
    let a = 0, s = o[4].value;
    if (n.isTokenDimension(o)) switch(toLowerCaseAZ(o[4].unit)){
        case "rad":
            a = f.get("deg")(r);
            break;
        case "deg":
            a = r, s = i.get("rad")(r);
            break;
        case "grad":
            a = u.get("deg")(r), s = u.get("rad")(r);
            break;
        case "turn":
            a = k.get("deg")(r), s = k.get("rad")(r);
            break;
        default:
            return -1;
    }
    const l = a / 90;
    return s = a % 90 == 0 && l % 2 != 0 ? l > 0 ? 1 / 0 : -1 / 0 : Math.tan(s), numberToCalculation(e, s);
}
function subtraction(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value;
    let r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenPercentage(r)) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenDimension(r) && (r = convertUnit(o, r), toLowerCaseAZ(o[4].unit) === toLowerCaseAZ(r[4].unit))) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function solveLog(t, o) {
    if (1 === o.length) {
        const r = o[0];
        if (!r || !e.isTokenNode(r)) return -1;
        const i = r.value;
        if (!n.isTokenNumber(i)) return -1;
        return numberToCalculation(t, Math.log(i[4].value));
    }
    if (2 === o.length) {
        const r = o[0];
        if (!r || !e.isTokenNode(r)) return -1;
        const i = r.value;
        if (!n.isTokenNumber(i)) return -1;
        const u = o[1];
        if (!u || !e.isTokenNode(u)) return -1;
        const a = u.value;
        if (!n.isTokenNumber(a)) return -1;
        return numberToCalculation(t, Math.log(i[4].value) / Math.log(a[4].value));
    }
    return -1;
}
const g = /^none$/i;
function isNone(t) {
    if (Array.isArray(t)) {
        const n = t.filter((n)=>!(e.isWhitespaceNode(n) && e.isCommentNode(n)));
        return 1 === n.length && isNone(n[0]);
    }
    if (!e.isTokenNode(t)) return !1;
    const o = t.value;
    return !!n.isTokenIdent(o) && g.test(o[4].value);
}
const D = String.fromCodePoint(0);
function solveRandom(e, t, o, r, i, u) {
    if (-1 === t.fixed && !u.randomCaching) return -1;
    u.randomCaching || (u.randomCaching = {
        propertyName: "",
        propertyN: 0,
        elementID: "",
        documentID: ""
    }), u.randomCaching && !u.randomCaching.propertyN && (u.randomCaching.propertyN = 0);
    const a = o.value;
    if (!n.isTokenNumeric(a)) return -1;
    const s = convertUnit(a, r.value);
    if (!twoOfSameNumeric(a, s)) return -1;
    let l = null;
    if (i && (l = convertUnit(a, i.value), !twoOfSameNumeric(a, l))) return -1;
    if (!Number.isFinite(a[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (!Number.isFinite(s[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (!Number.isFinite(s[4].value - a[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (l && !Number.isFinite(l[4].value)) return resultToCalculation(e, a, a[4].value);
    const c = -1 === t.fixed ? sfc32(crc32([
        t.dashedIdent ? t.dashedIdent : `${u.randomCaching?.propertyName} ${u.randomCaching.propertyN++}`,
        t.elementShared ? "" : u.randomCaching.elementID,
        u.randomCaching.documentID
    ].join(D))) : ()=>t.fixed;
    let m = a[4].value, v = s[4].value;
    if (m > v && ([m, v] = [
        v,
        m
    ]), l && (l[4].value <= 0 || Math.abs(m - v) / l[4].value > 1e10) && (l = null), l) {
        const n = Math.max(l[4].value / 1e3, 1e-9), t = [
            m
        ];
        let o = 0;
        for(;;){
            o += l[4].value;
            const e = m + o;
            if (!(e + n < v)) {
                t.push(v);
                break;
            }
            if (t.push(e), e + l[4].value - n > v) break;
        }
        const r = c();
        return resultToCalculation(e, a, Number(t[Math.floor(t.length * r)].toFixed(5)));
    }
    const T = c();
    return resultToCalculation(e, a, Number((T * (v - m) + m).toFixed(5)));
}
function sfc32(e = .34944106645296036, n = .19228640875738723, t = .8784393832007205, o = .04850964319275053) {
    return ()=>{
        const r = ((e |= 0) + (n |= 0) | 0) + (o |= 0) | 0;
        return o = o + 1 | 0, e = n ^ n >>> 9, n = (t |= 0) + (t << 3) | 0, t = (t = t << 21 | t >>> 11) + r | 0, (r >>> 0) / 4294967296;
    };
}
function crc32(e) {
    let n = 0, t = 0, o = 0;
    n ^= -1;
    for(let r = 0, i = e.length; r < i; r++)o = 255 & (n ^ e.charCodeAt(r)), t = Number("0x" + "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".substring(9 * o, 9 * o + 8)), n = n >>> 8 ^ t;
    return (-1 ^ n) >>> 0;
}
const b = new Map([
    [
        "abs",
        function abs(e, n, t) {
            return singleNodeSolver(e, n, t, solveAbs);
        }
    ],
    [
        "acos",
        function acos(e, n, t) {
            return singleNodeSolver(e, n, t, solveACos);
        }
    ],
    [
        "asin",
        function asin(e, n, t) {
            return singleNodeSolver(e, n, t, solveASin);
        }
    ],
    [
        "atan",
        function atan(e, n, t) {
            return singleNodeSolver(e, n, t, solveATan);
        }
    ],
    [
        "atan2",
        function atan2(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveATan2);
        }
    ],
    [
        "calc",
        calc$1
    ],
    [
        "clamp",
        function clamp(t, o, r) {
            const i = resolveGlobalsAndConstants([
                ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
            ], o), u = [], a = [], s = [];
            {
                let t = u;
                for(let o = 0; o < i.length; o++){
                    const r = i[o];
                    if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                        if (t === s) return -1;
                        if (t === a) {
                            t = s;
                            continue;
                        }
                        if (t === u) {
                            t = a;
                            continue;
                        }
                        return -1;
                    }
                    t.push(r);
                }
            }
            const l = isNone(u), c = isNone(s);
            if (l && c) return calc$1(calcWrapper(a), o, r);
            const m = solve(calc$1(calcWrapper(a), o, r));
            if (-1 === m) return -1;
            if (l) {
                const t = solve(calc$1(calcWrapper(s), o, r));
                return -1 === t ? -1 : solveMin((v = m, T = t, new e.FunctionNode([
                    n.TokenType.Function,
                    "min(",
                    -1,
                    -1,
                    {
                        value: "min"
                    }
                ], [
                    n.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ], [
                    v,
                    new e.TokenNode([
                        n.TokenType.Comma,
                        ",",
                        -1,
                        -1,
                        void 0
                    ]),
                    T
                ])), [
                    m,
                    t
                ], r);
            }
            if (c) {
                const e = solve(calc$1(calcWrapper(u), o, r));
                return -1 === e ? -1 : solveMax(maxWrapper(e, m), [
                    e,
                    m
                ], r);
            }
            var v, T;
            const p = solve(calc$1(calcWrapper(u), o, r));
            if (-1 === p) return -1;
            const N = solve(calc$1(calcWrapper(s), o, r));
            if (-1 === N) return -1;
            return solveClamp(t, p, m, N, r);
        }
    ],
    [
        "cos",
        function cos(e, n, t) {
            return singleNodeSolver(e, n, t, solveCos);
        }
    ],
    [
        "exp",
        function exp(e, n, t) {
            return singleNodeSolver(e, n, t, solveExp);
        }
    ],
    [
        "hypot",
        function hypot(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveHypot);
        }
    ],
    [
        "log",
        function log(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveLog);
        }
    ],
    [
        "max",
        function max(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveMax);
        }
    ],
    [
        "min",
        function min(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveMin);
        }
    ],
    [
        "mod",
        function mod(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveMod);
        }
    ],
    [
        "pow",
        function pow(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solvePow);
        }
    ],
    [
        "random",
        function random(n, t, o) {
            const r = parseRandomValueSharing(n.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n)), t, o);
            if (-1 === r) return -1;
            const [i, u] = r, a = variadicArguments(u, t, o);
            if (-1 === a) return -1;
            const [s, l, c] = a;
            if (!s || !l) return -1;
            return solveRandom(n, i, s, l, c, o);
        }
    ],
    [
        "rem",
        function rem(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveRem);
        }
    ],
    [
        "round",
        function round(t, o, r) {
            const i = resolveGlobalsAndConstants([
                ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
            ], o);
            let u = "", a = !1;
            const s = [], l = [];
            {
                let t = s;
                for(let o = 0; o < i.length; o++){
                    const r = i[o];
                    if (!u && 0 === s.length && 0 === l.length && e.isTokenNode(r) && n.isTokenIdent(r.value)) {
                        const e = r.value[4].value.toLowerCase();
                        if (y.has(e)) {
                            u = e;
                            continue;
                        }
                    }
                    if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                        if (t === l) return -1;
                        if (t === s && u && 0 === s.length) continue;
                        if (t === s) {
                            a = !0, t = l;
                            continue;
                        }
                        return -1;
                    }
                    t.push(r);
                }
            }
            const c = solve(calc$1(calcWrapper(s), o, r));
            if (-1 === c) return -1;
            a || 0 !== l.length || l.push(new e.TokenNode([
                n.TokenType.Number,
                "1",
                -1,
                -1,
                {
                    value: 1,
                    type: n.NumberType.Integer
                }
            ]));
            const m = solve(calc$1(calcWrapper(l), o, r));
            if (-1 === m) return -1;
            u || (u = "nearest");
            return solveRound(t, u, c, m, r);
        }
    ],
    [
        "sign",
        function sign(e, n, t) {
            return singleNodeSolver(e, n, t, solveSign);
        }
    ],
    [
        "sin",
        function sin(e, n, t) {
            return singleNodeSolver(e, n, t, solveSin);
        }
    ],
    [
        "sqrt",
        function sqrt(e, n, t) {
            return singleNodeSolver(e, n, t, solveSqrt);
        }
    ],
    [
        "tan",
        function tan(e, n, t) {
            return singleNodeSolver(e, n, t, solveTan);
        }
    ]
]);
function calc$1(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o);
    if (1 === i.length && e.isTokenNode(i[0])) return {
        inputs: [
            i[0]
        ],
        operation: unary
    };
    let u = 0;
    for(; u < i.length;){
        const t = i[u];
        if (e.isSimpleBlockNode(t) && n.isTokenOpenParen(t.startToken)) {
            const e = calc$1(t, o, r);
            if (-1 === e) return -1;
            i.splice(u, 1, e);
        } else if (e.isFunctionNode(t)) {
            const e = b.get(t.getName().toLowerCase());
            if (!e) return -1;
            const n = e(t, o, r);
            if (-1 === n) return -1;
            i.splice(u, 1, n);
        } else u++;
    }
    if (u = 0, 1 === i.length && isCalculation(i[0])) return i[0];
    for(; u < i.length;){
        const t = i[u];
        if (!t || !e.isTokenNode(t) && !isCalculation(t)) {
            u++;
            continue;
        }
        const o = i[u + 1];
        if (!o || !e.isTokenNode(o)) {
            u++;
            continue;
        }
        const r = o.value;
        if (!n.isTokenDelim(r) || "*" !== r[4].value && "/" !== r[4].value) {
            u++;
            continue;
        }
        const a = i[u + 2];
        if (!a || !e.isTokenNode(a) && !isCalculation(a)) return -1;
        "*" !== r[4].value ? "/" !== r[4].value ? u++ : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: division
        }) : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: multiplication
        });
    }
    if (u = 0, 1 === i.length && isCalculation(i[0])) return i[0];
    for(; u < i.length;){
        const t = i[u];
        if (!t || !e.isTokenNode(t) && !isCalculation(t)) {
            u++;
            continue;
        }
        const o = i[u + 1];
        if (!o || !e.isTokenNode(o)) {
            u++;
            continue;
        }
        const r = o.value;
        if (!n.isTokenDelim(r) || "+" !== r[4].value && "-" !== r[4].value) {
            u++;
            continue;
        }
        const a = i[u + 2];
        if (!a || !e.isTokenNode(a) && !isCalculation(a)) return -1;
        "+" !== r[4].value ? "-" !== r[4].value ? u++ : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: subtraction
        }) : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: addition
        });
    }
    return 1 === i.length && isCalculation(i[0]) ? i[0] : -1;
}
function singleNodeSolver(e, n, t, o) {
    const r = singleArgument(e.value, n, t);
    return -1 === r ? -1 : o(e, r, t);
}
function singleArgument(n, t, o) {
    const r = solve(calc$1(calcWrapper(resolveGlobalsAndConstants([
        ...n.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], t)), t, o));
    return -1 === r ? -1 : r;
}
function twoCommaSeparatedNodesSolver(e, n, t, o) {
    const r = twoCommaSeparatedArguments(e.value, n, t);
    if (-1 === r) return -1;
    const [i, u] = r;
    return o(e, i, u, t);
}
function twoCommaSeparatedArguments(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o), u = [], a = [];
    {
        let t = u;
        for(let o = 0; o < i.length; o++){
            const r = i[o];
            if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                if (t === a) return -1;
                if (t === u) {
                    t = a;
                    continue;
                }
                return -1;
            }
            t.push(r);
        }
    }
    const s = solve(calc$1(calcWrapper(u), o, r));
    if (-1 === s) return -1;
    const l = solve(calc$1(calcWrapper(a), o, r));
    return -1 === l ? -1 : [
        s,
        l
    ];
}
function variadicNodesSolver(e, n, t, o, r) {
    const i = variadicArguments(e.value, t, o);
    return -1 === i ? -1 : r(e, i, o);
}
function variadicArguments(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o), u = [];
    {
        const t = [];
        let a = [];
        for(let o = 0; o < i.length; o++){
            const r = i[o];
            e.isTokenNode(r) && n.isTokenComma(r.value) ? (t.push(a), a = []) : a.push(r);
        }
        t.push(a);
        for(let e = 0; e < t.length; e++){
            if (0 === t[e].length) return -1;
            const n = solve(calc$1(calcWrapper(t[e]), o, r));
            if (-1 === n) return -1;
            u.push(n);
        }
    }
    return u;
}
const y = new Set([
    "nearest",
    "up",
    "down",
    "to-zero"
]);
function parseRandomValueSharing(t, o, r) {
    const i = {
        isAuto: !1,
        dashedIdent: "",
        fixed: -1,
        elementShared: !1
    }, u = t[0];
    if (!e.isTokenNode(u) || !n.isTokenIdent(u.value)) return [
        i,
        t
    ];
    for(let u = 0; u < t.length; u++){
        const a = t[u];
        if (!e.isTokenNode(a)) return -1;
        if (n.isTokenComma(a.value)) return [
            i,
            t.slice(u + 1)
        ];
        if (!n.isTokenIdent(a.value)) return -1;
        const s = a.value[4].value.toLowerCase();
        if ("element-shared" !== s) if ("fixed" !== s) if ("auto" !== s) if (s.startsWith("--")) {
            if (-1 !== i.fixed || i.isAuto) return -1;
            i.dashedIdent = s;
        } else ;
        else {
            if (-1 !== i.fixed || i.dashedIdent) return -1;
            i.isAuto = !0;
        }
        else {
            if (i.elementShared || i.dashedIdent || i.isAuto) return -1;
            u++;
            const e = t[u];
            if (!e) return -1;
            const a = solve(calc$1(calcWrapper([
                e
            ]), o, r));
            if (-1 === a) return -1;
            if (!n.isTokenNumber(a.value)) return -1;
            if (a.value[4].value < 0 || a.value[4].value > 1) return -1;
            i.fixed = Math.max(0, Math.min(a.value[4].value, 1 - 1e-9));
        }
        else {
            if (-1 !== i.fixed) return -1;
            i.elementShared = !0;
        }
    }
    return -1;
}
function calcWrapper(t) {
    return new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        -1,
        -1,
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], t);
}
function maxWrapper(t, o) {
    return new e.FunctionNode([
        n.TokenType.Function,
        "max(",
        -1,
        -1,
        {
            value: "max"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], [
        t,
        new e.TokenNode([
            n.TokenType.Comma,
            ",",
            -1,
            -1,
            void 0
        ]),
        o
    ]);
}
function patchNaN(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    return n.isTokenNumeric(o) && Number.isNaN(o[4].value) ? n.isTokenNumber(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ])
    ]) : n.isTokenDimension(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Dimension,
            "1" + o[4].unit,
            o[2],
            o[3],
            {
                value: 1,
                type: n.NumberType.Integer,
                unit: o[4].unit
            }
        ])
    ]) : n.isTokenPercentage(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Percentage,
            "1%",
            o[2],
            o[3],
            {
                value: 1
            }
        ])
    ]) : -1 : t;
}
function patchInfinity(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    if (!n.isTokenNumeric(o)) return t;
    if (Number.isFinite(o[4].value) || Number.isNaN(o[4].value)) return t;
    let r = "";
    return Number.NEGATIVE_INFINITY === o[4].value && (r = "-"), n.isTokenNumber(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ])
    ]) : n.isTokenDimension(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Dimension,
            "1" + o[4].unit,
            o[2],
            o[3],
            {
                value: 1,
                type: n.NumberType.Integer,
                unit: o[4].unit
            }
        ])
    ]) : new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Percentage,
            "1%",
            o[2],
            o[3],
            {
                value: 1
            }
        ])
    ]);
}
function patchMinusZero(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    return n.isTokenNumeric(o) && Object.is(-0, o[4].value) ? ("-0" === o[1] || (n.isTokenPercentage(o) ? o[1] = "-0%" : n.isTokenDimension(o) ? o[1] = "-0" + o[4].unit : o[1] = "-0"), t) : t;
}
function patchPrecision(t, o = 13) {
    if (-1 === t) return -1;
    if (o <= 0) return t;
    if (e.isFunctionNode(t)) return t;
    const r = t.value;
    if (!n.isTokenNumeric(r)) return t;
    if (Number.isInteger(r[4].value)) return t;
    const i = Number(r[4].value.toFixed(o)).toString();
    return n.isTokenNumber(r) ? r[1] = i : n.isTokenPercentage(r) ? r[1] = i + "%" : n.isTokenDimension(r) && (r[1] = i + r[4].unit), t;
}
function patchCanonicalUnit(t) {
    return -1 === t ? -1 : e.isFunctionNode(t) ? t : n.isTokenDimension(t.value) ? (t.value = toCanonicalUnit(t.value), t) : t;
}
function patchCalcResult(e, n) {
    let t = e;
    return n?.toCanonicalUnits && (t = patchCanonicalUnit(t)), t = patchPrecision(t, n?.precision), t = patchMinusZero(t), n?.censorIntoStandardRepresentableValues || (t = patchNaN(t), t = patchInfinity(t)), t;
}
function tokenizeGlobals(e) {
    const t = new Map;
    if (!e) return t;
    for (const [o, r] of e)if (n.isToken(r)) t.set(o, r);
    else if ("string" != typeof r) ;
    else {
        const e = n.tokenizer({
            css: r
        }), i = e.nextToken();
        if (e.nextToken(), !e.endOfFile()) continue;
        if (!n.isTokenNumeric(i)) continue;
        t.set(o, i);
    }
    return t;
}
function calcFromComponentValues(n, t) {
    const o = tokenizeGlobals(t?.globals);
    return e.replaceComponentValues(n, (n)=>{
        if (!e.isFunctionNode(n)) return;
        const r = b.get(n.getName().toLowerCase());
        if (!r) return;
        const i = patchCalcResult(solve(r(n, o, t ?? {})), t);
        return -1 !== i ? i : void 0;
    });
}
const h = new Set(b.keys());
exports.calc = function calc(t, o) {
    return calcFromComponentValues(e.parseCommaSeparatedListOfComponentValues(n.tokenize({
        css: t
    }), {}), o).map((e)=>e.map((e)=>n.stringify(...e.tokens())).join("")).join(",");
}, exports.calcFromComponentValues = calcFromComponentValues, exports.mathFunctionNames = h;
}}),
"[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, o, a = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
function convertNaNToZero(e) {
    return [
        Number.isNaN(e[0]) ? 0 : e[0],
        Number.isNaN(e[1]) ? 0 : e[1],
        Number.isNaN(e[2]) ? 0 : e[2]
    ];
}
function colorData_to_XYZ_D50(e) {
    switch(e.colorNotation){
        case exports.ColorNotation.HEX:
        case exports.ColorNotation.RGB:
        case exports.ColorNotation.sRGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.sRGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Linear_sRGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.lin_sRGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Display_P3:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.P3_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Rec2020:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.rec_2020_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.A98_RGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.a98_RGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.ProPhoto_RGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.ProPhoto_RGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.HSL:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.HSL_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.HWB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.HWB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Lab:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.Lab_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.OKLab:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.OKLab_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.LCH:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.LCH_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.OKLCH:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.OKLCH_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.XYZ_D50:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.XYZ_D50_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.XYZ_D65:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.XYZ_D65_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        default:
            throw new Error("Unsupported color notation");
    }
}
exports.ColorNotation = void 0, (e = exports.ColorNotation || (exports.ColorNotation = {})).A98_RGB = "a98-rgb", e.Display_P3 = "display-p3", e.HEX = "hex", e.HSL = "hsl", e.HWB = "hwb", e.LCH = "lch", e.Lab = "lab", e.Linear_sRGB = "srgb-linear", e.OKLCH = "oklch", e.OKLab = "oklab", e.ProPhoto_RGB = "prophoto-rgb", e.RGB = "rgb", e.sRGB = "srgb", e.Rec2020 = "rec2020", e.XYZ_D50 = "xyz-d50", e.XYZ_D65 = "xyz-d65", exports.SyntaxFlag = void 0, (o = exports.SyntaxFlag || (exports.SyntaxFlag = {})).ColorKeyword = "color-keyword", o.HasAlpha = "has-alpha", o.HasDimensionValues = "has-dimension-values", o.HasNoneKeywords = "has-none-keywords", o.HasNumberValues = "has-number-values", o.HasPercentageAlpha = "has-percentage-alpha", o.HasPercentageValues = "has-percentage-values", o.HasVariableAlpha = "has-variable-alpha", o.Hex = "hex", o.LegacyHSL = "legacy-hsl", o.LegacyRGB = "legacy-rgb", o.NamedColor = "named-color", o.RelativeColorSyntax = "relative-color-syntax", o.ColorMix = "color-mix", o.ColorMixVariadic = "color-mix-variadic", o.ContrastColor = "contrast-color", o.Experimental = "experimental";
const s = new Set([
    exports.ColorNotation.A98_RGB,
    exports.ColorNotation.Display_P3,
    exports.ColorNotation.HEX,
    exports.ColorNotation.Linear_sRGB,
    exports.ColorNotation.ProPhoto_RGB,
    exports.ColorNotation.RGB,
    exports.ColorNotation.sRGB,
    exports.ColorNotation.Rec2020,
    exports.ColorNotation.XYZ_D50,
    exports.ColorNotation.XYZ_D65
]);
function colorDataTo(e, o) {
    const a = {
        ...e
    };
    if (e.colorNotation !== o) {
        const e = colorData_to_XYZ_D50(a);
        switch(o){
            case exports.ColorNotation.HEX:
            case exports.ColorNotation.RGB:
                a.colorNotation = exports.ColorNotation.RGB, a.channels = n.XYZ_D50_to_sRGB(e.channels);
                break;
            case exports.ColorNotation.sRGB:
                a.colorNotation = exports.ColorNotation.sRGB, a.channels = n.XYZ_D50_to_sRGB(e.channels);
                break;
            case exports.ColorNotation.Linear_sRGB:
                a.colorNotation = exports.ColorNotation.Linear_sRGB, a.channels = n.XYZ_D50_to_lin_sRGB(e.channels);
                break;
            case exports.ColorNotation.Display_P3:
                a.colorNotation = exports.ColorNotation.Display_P3, a.channels = n.XYZ_D50_to_P3(e.channels);
                break;
            case exports.ColorNotation.Rec2020:
                a.colorNotation = exports.ColorNotation.Rec2020, a.channels = n.XYZ_D50_to_rec_2020(e.channels);
                break;
            case exports.ColorNotation.ProPhoto_RGB:
                a.colorNotation = exports.ColorNotation.ProPhoto_RGB, a.channels = n.XYZ_D50_to_ProPhoto(e.channels);
                break;
            case exports.ColorNotation.A98_RGB:
                a.colorNotation = exports.ColorNotation.A98_RGB, a.channels = n.XYZ_D50_to_a98_RGB(e.channels);
                break;
            case exports.ColorNotation.HSL:
                a.colorNotation = exports.ColorNotation.HSL, a.channels = n.XYZ_D50_to_HSL(e.channels);
                break;
            case exports.ColorNotation.HWB:
                a.colorNotation = exports.ColorNotation.HWB, a.channels = n.XYZ_D50_to_HWB(e.channels);
                break;
            case exports.ColorNotation.Lab:
                a.colorNotation = exports.ColorNotation.Lab, a.channels = n.XYZ_D50_to_Lab(e.channels);
                break;
            case exports.ColorNotation.LCH:
                a.colorNotation = exports.ColorNotation.LCH, a.channels = n.XYZ_D50_to_LCH(e.channels);
                break;
            case exports.ColorNotation.OKLCH:
                a.colorNotation = exports.ColorNotation.OKLCH, a.channels = n.XYZ_D50_to_OKLCH(e.channels);
                break;
            case exports.ColorNotation.OKLab:
                a.colorNotation = exports.ColorNotation.OKLab, a.channels = n.XYZ_D50_to_OKLab(e.channels);
                break;
            case exports.ColorNotation.XYZ_D50:
                a.colorNotation = exports.ColorNotation.XYZ_D50, a.channels = n.XYZ_D50_to_XYZ_D50(e.channels);
                break;
            case exports.ColorNotation.XYZ_D65:
                a.colorNotation = exports.ColorNotation.XYZ_D65, a.channels = n.XYZ_D50_to_XYZ_D65(e.channels);
                break;
            default:
                throw new Error("Unsupported color notation");
        }
    } else a.channels = convertNaNToZero(e.channels);
    if (o === e.colorNotation) a.channels = carryForwardMissingComponents(e.channels, [
        0,
        1,
        2
    ], a.channels, [
        0,
        1,
        2
    ]);
    else if (s.has(o) && s.has(e.colorNotation)) a.channels = carryForwardMissingComponents(e.channels, [
        0,
        1,
        2
    ], a.channels, [
        0,
        1,
        2
    ]);
    else switch(o){
        case exports.ColorNotation.HSL:
            switch(e.colorNotation){
                case exports.ColorNotation.HWB:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        2
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        2,
                        1,
                        0
                    ]);
            }
            break;
        case exports.ColorNotation.HWB:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
            }
            break;
        case exports.ColorNotation.Lab:
        case exports.ColorNotation.OKLab:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        0,
                        1,
                        2
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
            }
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        2,
                        1,
                        0
                    ]);
                    break;
                case exports.ColorNotation.HWB:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        0,
                        1,
                        2
                    ]);
            }
    }
    return a.channels = convertPowerlessComponentsToMissingComponents(a.channels, o), a;
}
function convertPowerlessComponentsToMissingComponents(e, o) {
    const a = [
        ...e
    ];
    switch(o){
        case exports.ColorNotation.HSL:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 4) <= 0 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.HWB:
            Math.max(0, reducePrecision(a[1], 4)) + Math.max(0, reducePrecision(a[2], 4)) >= 100 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.LCH:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 4) <= 0 && (a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLCH:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 6) <= 0 && (a[2] = Number.NaN);
    }
    return a;
}
function convertPowerlessComponentsToZeroValuesForDisplay(e, o) {
    const a = [
        ...e
    ];
    switch(o){
        case exports.ColorNotation.HSL:
            (reducePrecision(a[2]) <= 0 || reducePrecision(a[2]) >= 100) && (a[0] = Number.NaN, a[1] = Number.NaN), reducePrecision(a[1]) <= 0 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.HWB:
            Math.max(0, reducePrecision(a[1])) + Math.max(0, reducePrecision(a[2])) >= 100 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.Lab:
            (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 100) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.LCH:
            reducePrecision(a[1]) <= 0 && (a[2] = Number.NaN), (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 100) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLab:
            (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 1) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLCH:
            reducePrecision(a[1]) <= 0 && (a[2] = Number.NaN), (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 1) && (a[1] = Number.NaN, a[2] = Number.NaN);
    }
    return a;
}
function carryForwardMissingComponents(e, o, a, n) {
    const t = [
        ...a
    ];
    for (const a of o)Number.isNaN(e[o[a]]) && (t[n[a]] = Number.NaN);
    return t;
}
function normalizeRelativeColorDataChannels(e) {
    const o = new Map;
    switch(e.colorNotation){
        case exports.ColorNotation.RGB:
        case exports.ColorNotation.HEX:
            o.set("r", dummyNumberToken(255 * e.channels[0])), o.set("g", dummyNumberToken(255 * e.channels[1])), o.set("b", dummyNumberToken(255 * e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.HSL:
            o.set("h", dummyNumberToken(e.channels[0])), o.set("s", dummyNumberToken(e.channels[1])), o.set("l", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.HWB:
            o.set("h", dummyNumberToken(e.channels[0])), o.set("w", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.Lab:
        case exports.ColorNotation.OKLab:
            o.set("l", dummyNumberToken(e.channels[0])), o.set("a", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            o.set("l", dummyNumberToken(e.channels[0])), o.set("c", dummyNumberToken(e.channels[1])), o.set("h", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.sRGB:
        case exports.ColorNotation.A98_RGB:
        case exports.ColorNotation.Display_P3:
        case exports.ColorNotation.Rec2020:
        case exports.ColorNotation.Linear_sRGB:
        case exports.ColorNotation.ProPhoto_RGB:
            o.set("r", dummyNumberToken(e.channels[0])), o.set("g", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.XYZ_D50:
        case exports.ColorNotation.XYZ_D65:
            o.set("x", dummyNumberToken(e.channels[0])), o.set("y", dummyNumberToken(e.channels[1])), o.set("z", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
    }
    return o;
}
function noneToZeroInRelativeColorDataChannels(e) {
    const o = new Map(e);
    for (const [a, n] of e)Number.isNaN(n[4].value) && o.set(a, dummyNumberToken(0));
    return o;
}
function dummyNumberToken(e) {
    return Number.isNaN(e) ? [
        a.TokenType.Number,
        "none",
        -1,
        -1,
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ] : [
        a.TokenType.Number,
        e.toString(),
        -1,
        -1,
        {
            value: e,
            type: a.NumberType.Number
        }
    ];
}
function reducePrecision(e, o = 7) {
    if (Number.isNaN(e)) return 0;
    const a = Math.pow(10, o);
    return Math.round(e * a) / a;
}
function normalize(e, o, a, n) {
    return Math.min(Math.max(e / o, a), n);
}
const l = /[A-Z]/g;
function toLowerCaseAZ(e) {
    return e.replace(l, (e)=>String.fromCharCode(e.charCodeAt(0) + 32));
}
function normalize_Color_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
const i = new Set([
    "srgb",
    "srgb-linear",
    "display-p3",
    "a98-rgb",
    "prophoto-rgb",
    "rec2020",
    "xyz",
    "xyz-d50",
    "xyz-d65"
]);
function color$1(e, o) {
    const n = [], s = [], l = [], u = [];
    let c, p, N = !1, m = !1;
    const h = {
        colorNotation: exports.ColorNotation.sRGB,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([])
    };
    let x = n;
    for(let y = 0; y < e.value.length; y++){
        let b = e.value[y];
        if (t.isWhitespaceNode(b) || t.isCommentNode(b)) for(; t.isWhitespaceNode(e.value[y + 1]) || t.isCommentNode(e.value[y + 1]);)y++;
        else if (x === n && n.length && (x = s), x === s && s.length && (x = l), t.isTokenNode(b) && a.isTokenDelim(b.value) && "/" === b.value[4].value) {
            if (x === u) return !1;
            x = u;
        } else {
            if (t.isFunctionNode(b)) {
                if (x === u && "var" === toLowerCaseAZ(b.getName())) {
                    h.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), x.push(b);
                    continue;
                }
                if (!r.mathFunctionNames.has(toLowerCaseAZ(b.getName()))) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        b
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    globals: p,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), b = e;
            }
            if (x === n && 0 === n.length && t.isTokenNode(b) && a.isTokenIdent(b.value) && i.has(toLowerCaseAZ(b.value[4].value))) {
                if (N) return !1;
                N = toLowerCaseAZ(b.value[4].value), h.colorNotation = colorSpaceNameToColorNotation(N), m && (m.colorNotation !== h.colorNotation && (m = colorDataTo(m, h.colorNotation)), c = normalizeRelativeColorDataChannels(m), p = noneToZeroInRelativeColorDataChannels(c));
            } else if (x === n && 0 === n.length && t.isTokenNode(b) && a.isTokenIdent(b.value) && "from" === toLowerCaseAZ(b.value[4].value)) {
                if (m) return !1;
                if (N) return !1;
                for(; t.isWhitespaceNode(e.value[y + 1]) || t.isCommentNode(e.value[y + 1]);)y++;
                if (y++, b = e.value[y], m = o(b), !1 === m) return !1;
                m.syntaxFlags.has(exports.SyntaxFlag.Experimental) && h.syntaxFlags.add(exports.SyntaxFlag.Experimental), h.syntaxFlags.add(exports.SyntaxFlag.RelativeColorSyntax);
            } else {
                if (!t.isTokenNode(b)) return !1;
                if (a.isTokenIdent(b.value) && c && c.has(toLowerCaseAZ(b.value[4].value))) {
                    x.push(new t.TokenNode(c.get(toLowerCaseAZ(b.value[4].value))));
                    continue;
                }
                x.push(b);
            }
        }
    }
    if (!N) return !1;
    if (1 !== x.length) return !1;
    if (1 !== n.length || 1 !== s.length || 1 !== l.length) return !1;
    if (!t.isTokenNode(n[0]) || !t.isTokenNode(s[0]) || !t.isTokenNode(l[0])) return !1;
    if (c && !c.has("alpha")) return !1;
    const y = normalize_Color_ChannelValues(n[0].value, 0, h);
    if (!y || !a.isTokenNumber(y)) return !1;
    const b = normalize_Color_ChannelValues(s[0].value, 1, h);
    if (!b || !a.isTokenNumber(b)) return !1;
    const C = normalize_Color_ChannelValues(l[0].value, 2, h);
    if (!C || !a.isTokenNumber(C)) return !1;
    const d = [
        y,
        b,
        C
    ];
    if (1 === u.length) if (h.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(u[0])) {
        const e = normalize_Color_ChannelValues(u[0].value, 3, h);
        if (!e || !a.isTokenNumber(e)) return !1;
        d.push(e);
    } else h.alpha = u[0];
    else if (c && c.has("alpha")) {
        const e = normalize_Color_ChannelValues(c.get("alpha"), 3, h);
        if (!e || !a.isTokenNumber(e)) return !1;
        d.push(e);
    }
    return h.channels = [
        d[0][4].value,
        d[1][4].value,
        d[2][4].value
    ], 4 === d.length && (h.alpha = d[3][4].value), h;
}
function colorSpaceNameToColorNotation(e) {
    switch(e){
        case "srgb":
            return exports.ColorNotation.sRGB;
        case "srgb-linear":
            return exports.ColorNotation.Linear_sRGB;
        case "display-p3":
            return exports.ColorNotation.Display_P3;
        case "a98-rgb":
            return exports.ColorNotation.A98_RGB;
        case "prophoto-rgb":
            return exports.ColorNotation.ProPhoto_RGB;
        case "rec2020":
            return exports.ColorNotation.Rec2020;
        case "xyz":
        case "xyz-d65":
            return exports.ColorNotation.XYZ_D65;
        case "xyz-d50":
            return exports.ColorNotation.XYZ_D50;
        default:
            throw new Error("Unknown color space name: " + e);
    }
}
const u = new Set([
    "srgb",
    "srgb-linear",
    "display-p3",
    "a98-rgb",
    "prophoto-rgb",
    "rec2020",
    "lab",
    "oklab",
    "xyz",
    "xyz-d50",
    "xyz-d65"
]), c = new Set([
    "hsl",
    "hwb",
    "lch",
    "oklch"
]), p = new Set([
    "shorter",
    "longer",
    "increasing",
    "decreasing"
]);
function colorMix(e, o) {
    let n = null, r = null, s = null, l = !1;
    for(let i = 0; i < e.value.length; i++){
        const N = e.value[i];
        if (!t.isWhiteSpaceOrCommentNode(N)) {
            if (t.isTokenNode(N) && a.isTokenIdent(N.value)) {
                if (!n && "in" === toLowerCaseAZ(N.value[4].value)) {
                    n = N;
                    continue;
                }
                if (n && !r) {
                    r = toLowerCaseAZ(N.value[4].value);
                    continue;
                }
                if (n && r && !s && c.has(r)) {
                    s = toLowerCaseAZ(N.value[4].value);
                    continue;
                }
                if (n && r && s && !l && "hue" === toLowerCaseAZ(N.value[4].value)) {
                    l = !0;
                    continue;
                }
                return !1;
            }
            return !(!t.isTokenNode(N) || !a.isTokenComma(N.value)) && !!r && (s || l ? !!(r && s && l && c.has(r) && p.has(s)) && colorMixPolar(r, s, colorMixComponents(e.value.slice(i + 1), o)) : u.has(r) ? colorMixRectangular(r, colorMixComponents(e.value.slice(i + 1), o)) : !!c.has(r) && colorMixPolar(r, "shorter", colorMixComponents(e.value.slice(i + 1), o)));
        }
    }
    return !1;
}
function colorMixComponents(e, o) {
    const n = [];
    let s = 1, l = !1, i = !1;
    for(let s = 0; s < e.length; s++){
        let u = e[s];
        if (!t.isWhiteSpaceOrCommentNode(u)) {
            if (!t.isTokenNode(u) || !a.isTokenComma(u.value)) {
                if (!l) {
                    const e = o(u);
                    if (e) {
                        l = e;
                        continue;
                    }
                }
                if (!i) {
                    if (t.isFunctionNode(u) && r.mathFunctionNames.has(toLowerCaseAZ(u.getName()))) {
                        if ([[u]] = r.calcFromComponentValues([
                            [
                                u
                            ]
                        ], {
                            censorIntoStandardRepresentableValues: !0,
                            precision: -1,
                            toCanonicalUnits: !0,
                            rawPercentages: !0
                        }), !u || !t.isTokenNode(u) || !a.isTokenNumeric(u.value)) return !1;
                        Number.isNaN(u.value[4].value) && (u.value[4].value = 0);
                    }
                    if (t.isTokenNode(u) && a.isTokenPercentage(u.value) && u.value[4].value >= 0) {
                        i = u.value[4].value;
                        continue;
                    }
                }
                return !1;
            }
            if (!l) return !1;
            n.push({
                color: l,
                percentage: i
            }), l = !1, i = !1;
        }
    }
    l && n.push({
        color: l,
        percentage: i
    });
    let u = 0, c = 0;
    for(let e = 0; e < n.length; e++){
        const o = n[e].percentage;
        if (!1 !== o) {
            if (o < 0 || o > 100) return !1;
            u += o;
        } else c++;
    }
    const p = Math.max(0, 100 - u);
    u = 0;
    for(let e = 0; e < n.length; e++)!1 === n[e].percentage && (n[e].percentage = p / c), u += n[e].percentage;
    if (0 === u) return {
        colors: [
            {
                color: {
                    channels: [
                        0,
                        0,
                        0
                    ],
                    colorNotation: exports.ColorNotation.sRGB,
                    alpha: 0,
                    syntaxFlags: new Set
                },
                percentage: 0
            }
        ],
        alphaMultiplier: 0
    };
    if (u > 100) for(let e = 0; e < n.length; e++){
        let o = n[e].percentage;
        o = o / u * 100, n[e].percentage = o;
    }
    if (u < 100) {
        s = u / 100;
        for(let e = 0; e < n.length; e++){
            let o = n[e].percentage;
            o = o / u * 100, n[e].percentage = o;
        }
    }
    return {
        colors: n,
        alphaMultiplier: s
    };
}
function colorMixRectangular(e, o) {
    if (!o || !o.colors.length) return !1;
    const a = o.colors.slice();
    a.reverse();
    let n = exports.ColorNotation.RGB;
    switch(e){
        case "srgb":
            n = exports.ColorNotation.RGB;
            break;
        case "srgb-linear":
            n = exports.ColorNotation.Linear_sRGB;
            break;
        case "display-p3":
            n = exports.ColorNotation.Display_P3;
            break;
        case "a98-rgb":
            n = exports.ColorNotation.A98_RGB;
            break;
        case "prophoto-rgb":
            n = exports.ColorNotation.ProPhoto_RGB;
            break;
        case "rec2020":
            n = exports.ColorNotation.Rec2020;
            break;
        case "lab":
            n = exports.ColorNotation.Lab;
            break;
        case "oklab":
            n = exports.ColorNotation.OKLab;
            break;
        case "xyz-d50":
            n = exports.ColorNotation.XYZ_D50;
            break;
        case "xyz":
        case "xyz-d65":
            n = exports.ColorNotation.XYZ_D65;
            break;
        default:
            return !1;
    }
    if (1 === a.length) {
        const e = colorDataTo(a[0].color, n);
        return e.colorNotation = n, e.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), "number" != typeof e.alpha ? !1 : (e.alpha = e.alpha * o.alphaMultiplier, e);
    }
    for(; a.length >= 2;){
        const e = a.pop(), o = a.pop();
        if (!e || !o) return !1;
        const t = colorMixRectangularPair(n, e.color, e.percentage, o.color, o.percentage);
        if (!t) return !1;
        a.push({
            color: t,
            percentage: e.percentage + o.percentage
        });
    }
    const t = a[0]?.color;
    return !!t && (o.colors.some((e)=>e.color.syntaxFlags.has(exports.SyntaxFlag.Experimental)) && t.syntaxFlags.add(exports.SyntaxFlag.Experimental), "number" == typeof t.alpha && (t.alpha = t.alpha * o.alphaMultiplier, 2 !== o.colors.length && t.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), t));
}
function colorMixRectangularPair(e, o, a, n, t) {
    const r = a / (a + t);
    let s = o.alpha;
    if ("number" != typeof s) return !1;
    let l = n.alpha;
    if ("number" != typeof l) return !1;
    s = Number.isNaN(s) ? l : s, l = Number.isNaN(l) ? s : l;
    const i = colorDataTo(o, e).channels, u = colorDataTo(n, e).channels;
    i[0] = fillInMissingComponent(i[0], u[0]), u[0] = fillInMissingComponent(u[0], i[0]), i[1] = fillInMissingComponent(i[1], u[1]), u[1] = fillInMissingComponent(u[1], i[1]), i[2] = fillInMissingComponent(i[2], u[2]), u[2] = fillInMissingComponent(u[2], i[2]), i[0] = premultiply(i[0], s), i[1] = premultiply(i[1], s), i[2] = premultiply(i[2], s), u[0] = premultiply(u[0], l), u[1] = premultiply(u[1], l), u[2] = premultiply(u[2], l);
    const c = interpolate(s, l, r);
    return {
        colorNotation: e,
        channels: [
            un_premultiply(interpolate(i[0], u[0], r), c),
            un_premultiply(interpolate(i[1], u[1], r), c),
            un_premultiply(interpolate(i[2], u[2], r), c)
        ],
        alpha: c,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorMix
        ])
    };
}
function colorMixPolar(e, o, a) {
    if (!a || !a.colors.length) return !1;
    const n = a.colors.slice();
    n.reverse();
    let t = exports.ColorNotation.HSL;
    switch(e){
        case "hsl":
            t = exports.ColorNotation.HSL;
            break;
        case "hwb":
            t = exports.ColorNotation.HWB;
            break;
        case "lch":
            t = exports.ColorNotation.LCH;
            break;
        case "oklch":
            t = exports.ColorNotation.OKLCH;
            break;
        default:
            return !1;
    }
    if (1 === n.length) {
        const e = colorDataTo(n[0].color, t);
        return e.colorNotation = t, e.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), "number" != typeof e.alpha ? !1 : (e.alpha = e.alpha * a.alphaMultiplier, e);
    }
    for(; n.length >= 2;){
        const e = n.pop(), a = n.pop();
        if (!e || !a) return !1;
        const r = colorMixPolarPair(t, o, e.color, e.percentage, a.color, a.percentage);
        if (!r) return !1;
        n.push({
            color: r,
            percentage: e.percentage + a.percentage
        });
    }
    const r = n[0]?.color;
    return !!r && (a.colors.some((e)=>e.color.syntaxFlags.has(exports.SyntaxFlag.Experimental)) && r.syntaxFlags.add(exports.SyntaxFlag.Experimental), "number" == typeof r.alpha && (r.alpha = r.alpha * a.alphaMultiplier, 2 !== a.colors.length && r.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), r));
}
function colorMixPolarPair(e, o, a, n, t, r) {
    const s = n / (n + r);
    let l = 0, i = 0, u = 0, c = 0, p = 0, N = 0, m = a.alpha;
    if ("number" != typeof m) return !1;
    let h = t.alpha;
    if ("number" != typeof h) return !1;
    m = Number.isNaN(m) ? h : m, h = Number.isNaN(h) ? m : h;
    const x = colorDataTo(a, e).channels, y = colorDataTo(t, e).channels;
    switch(e){
        case exports.ColorNotation.HSL:
        case exports.ColorNotation.HWB:
            l = x[0], i = y[0], u = x[1], c = y[1], p = x[2], N = y[2];
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            u = x[0], c = y[0], p = x[1], N = y[1], l = x[2], i = y[2];
    }
    l = fillInMissingComponent(l, i), Number.isNaN(l) && (l = 0), i = fillInMissingComponent(i, l), Number.isNaN(i) && (i = 0), u = fillInMissingComponent(u, c), c = fillInMissingComponent(c, u), p = fillInMissingComponent(p, N), N = fillInMissingComponent(N, p);
    const b = i - l;
    switch(o){
        case "shorter":
            b > 180 ? l += 360 : b < -180 && (i += 360);
            break;
        case "longer":
            -180 < b && b < 180 && (b > 0 ? l += 360 : i += 360);
            break;
        case "increasing":
            b < 0 && (i += 360);
            break;
        case "decreasing":
            b > 0 && (l += 360);
            break;
        default:
            throw new Error("Unknown hue interpolation method");
    }
    u = premultiply(u, m), p = premultiply(p, m), c = premultiply(c, h), N = premultiply(N, h);
    let C = [
        0,
        0,
        0
    ];
    const d = interpolate(m, h, s);
    switch(e){
        case exports.ColorNotation.HSL:
        case exports.ColorNotation.HWB:
            C = [
                interpolate(l, i, s),
                un_premultiply(interpolate(u, c, s), d),
                un_premultiply(interpolate(p, N, s), d)
            ];
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            C = [
                un_premultiply(interpolate(u, c, s), d),
                un_premultiply(interpolate(p, N, s), d),
                interpolate(l, i, s)
            ];
    }
    return {
        colorNotation: e,
        channels: C,
        alpha: d,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorMix
        ])
    };
}
function fillInMissingComponent(e, o) {
    return Number.isNaN(e) ? o : e;
}
function interpolate(e, o, a) {
    return e * a + o * (1 - a);
}
function premultiply(e, o) {
    return Number.isNaN(o) ? e : Number.isNaN(e) ? Number.NaN : e * o;
}
function un_premultiply(e, o) {
    return 0 === o || Number.isNaN(o) ? e : Number.isNaN(e) ? Number.NaN : e / o;
}
function hex(e) {
    const o = toLowerCaseAZ(e[4].value);
    if (o.match(/[^a-f0-9]/)) return !1;
    const a = {
        colorNotation: exports.ColorNotation.HEX,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.Hex
        ])
    }, n = o.length;
    if (3 === n) {
        const e = o[0], n = o[1], t = o[2];
        return a.channels = [
            parseInt(e + e, 16) / 255,
            parseInt(n + n, 16) / 255,
            parseInt(t + t, 16) / 255
        ], a;
    }
    if (6 === n) {
        const e = o[0] + o[1], n = o[2] + o[3], t = o[4] + o[5];
        return a.channels = [
            parseInt(e, 16) / 255,
            parseInt(n, 16) / 255,
            parseInt(t, 16) / 255
        ], a;
    }
    if (4 === n) {
        const e = o[0], n = o[1], t = o[2], r = o[3];
        return a.channels = [
            parseInt(e + e, 16) / 255,
            parseInt(n + n, 16) / 255,
            parseInt(t + t, 16) / 255
        ], a.alpha = parseInt(r + r, 16) / 255, a.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), a;
    }
    if (8 === n) {
        const e = o[0] + o[1], n = o[2] + o[3], t = o[4] + o[5], r = o[6] + o[7];
        return a.channels = [
            parseInt(e, 16) / 255,
            parseInt(n, 16) / 255,
            parseInt(t, 16) / 255
        ], a.alpha = parseInt(r, 16) / 255, a.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), a;
    }
    return !1;
}
function normalizeHue(e) {
    if (a.isTokenNumber(e)) return e[4].value = e[4].value % 360, e[1] = e[4].value.toString(), e;
    if (a.isTokenDimension(e)) {
        let o = e[4].value;
        switch(toLowerCaseAZ(e[4].unit)){
            case "deg":
                break;
            case "rad":
                o = 180 * e[4].value / Math.PI;
                break;
            case "grad":
                o = .9 * e[4].value;
                break;
            case "turn":
                o = 360 * e[4].value;
                break;
            default:
                return !1;
        }
        return o %= 360, [
            a.TokenType.Number,
            o.toString(),
            e[2],
            e[3],
            {
                value: o,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_legacy_HSL_ChannelValues(e, o, n) {
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        if (3 !== o) return !1;
        let n = normalize(e[4].value, 1, 0, 100);
        return 3 === o && (n = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            n.toString(),
            e[2],
            e[3],
            {
                value: n,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_modern_HSL_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = e[4].value;
        return 3 === o ? t = normalize(e[4].value, 100, 0, 1) : 1 === o && (t = normalize(e[4].value, 1, 0, 2147483647)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = e[4].value;
        return 3 === o ? t = normalize(e[4].value, 1, 0, 1) : 1 === o && (t = normalize(e[4].value, 1, 0, 2147483647)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function threeChannelLegacySyntax(e, o, n, s) {
    const l = [], i = [], u = [], c = [], p = {
        colorNotation: n,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set(s)
    };
    let N = l;
    for(let o = 0; o < e.value.length; o++){
        let n = e.value[o];
        if (!t.isWhitespaceNode(n) && !t.isCommentNode(n)) {
            if (t.isTokenNode(n) && a.isTokenComma(n.value)) {
                if (N === l) {
                    N = i;
                    continue;
                }
                if (N === i) {
                    N = u;
                    continue;
                }
                if (N === u) {
                    N = c;
                    continue;
                }
                if (N === c) return !1;
            }
            if (t.isFunctionNode(n)) {
                if (N === c && "var" === n.getName().toLowerCase()) {
                    p.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), N.push(n);
                    continue;
                }
                if (!r.mathFunctionNames.has(n.getName().toLowerCase())) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        n
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), n = e;
            }
            if (!t.isTokenNode(n)) return !1;
            N.push(n);
        }
    }
    if (1 !== N.length) return !1;
    if (1 !== l.length || 1 !== i.length || 1 !== u.length) return !1;
    if (!t.isTokenNode(l[0]) || !t.isTokenNode(i[0]) || !t.isTokenNode(u[0])) return !1;
    const m = o(l[0].value, 0, p);
    if (!m || !a.isTokenNumber(m)) return !1;
    const h = o(i[0].value, 1, p);
    if (!h || !a.isTokenNumber(h)) return !1;
    const x = o(u[0].value, 2, p);
    if (!x || !a.isTokenNumber(x)) return !1;
    const y = [
        m,
        h,
        x
    ];
    if (1 === c.length) if (p.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(c[0])) {
        const e = o(c[0].value, 3, p);
        if (!e || !a.isTokenNumber(e)) return !1;
        y.push(e);
    } else p.alpha = c[0];
    return p.channels = [
        y[0][4].value,
        y[1][4].value,
        y[2][4].value
    ], 4 === y.length && (p.alpha = y[3][4].value), p;
}
function threeChannelSpaceSeparated(e, o, n, s, l) {
    const i = [], u = [], c = [], p = [];
    let N, m, h = !1;
    const x = {
        colorNotation: n,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set(s)
    };
    let y = i;
    for(let o = 0; o < e.value.length; o++){
        let s = e.value[o];
        if (t.isWhitespaceNode(s) || t.isCommentNode(s)) for(; t.isWhitespaceNode(e.value[o + 1]) || t.isCommentNode(e.value[o + 1]);)o++;
        else if (y === i && i.length && (y = u), y === u && u.length && (y = c), t.isTokenNode(s) && a.isTokenDelim(s.value) && "/" === s.value[4].value) {
            if (y === p) return !1;
            y = p;
        } else {
            if (t.isFunctionNode(s)) {
                if (y === p && "var" === s.getName().toLowerCase()) {
                    x.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), y.push(s);
                    continue;
                }
                if (!r.mathFunctionNames.has(s.getName().toLowerCase())) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        s
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    globals: m,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), s = e;
            }
            if (y === i && 0 === i.length && t.isTokenNode(s) && a.isTokenIdent(s.value) && "from" === s.value[4].value.toLowerCase()) {
                if (h) return !1;
                for(; t.isWhitespaceNode(e.value[o + 1]) || t.isCommentNode(e.value[o + 1]);)o++;
                if (o++, s = e.value[o], h = l(s), !1 === h) return !1;
                h.syntaxFlags.has(exports.SyntaxFlag.Experimental) && x.syntaxFlags.add(exports.SyntaxFlag.Experimental), x.syntaxFlags.add(exports.SyntaxFlag.RelativeColorSyntax), h.colorNotation !== n && (h = colorDataTo(h, n)), N = normalizeRelativeColorDataChannels(h), m = noneToZeroInRelativeColorDataChannels(N);
            } else {
                if (!t.isTokenNode(s)) return !1;
                if (a.isTokenIdent(s.value) && N) {
                    const e = s.value[4].value.toLowerCase();
                    if (N.has(e)) {
                        y.push(new t.TokenNode(N.get(e)));
                        continue;
                    }
                }
                y.push(s);
            }
        }
    }
    if (1 !== y.length) return !1;
    if (1 !== i.length || 1 !== u.length || 1 !== c.length) return !1;
    if (!t.isTokenNode(i[0]) || !t.isTokenNode(u[0]) || !t.isTokenNode(c[0])) return !1;
    if (N && !N.has("alpha")) return !1;
    const b = o(i[0].value, 0, x);
    if (!b || !a.isTokenNumber(b)) return !1;
    const C = o(u[0].value, 1, x);
    if (!C || !a.isTokenNumber(C)) return !1;
    const d = o(c[0].value, 2, x);
    if (!d || !a.isTokenNumber(d)) return !1;
    const g = [
        b,
        C,
        d
    ];
    if (1 === p.length) if (x.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(p[0])) {
        const e = o(p[0].value, 3, x);
        if (!e || !a.isTokenNumber(e)) return !1;
        g.push(e);
    } else x.alpha = p[0];
    else if (N && N.has("alpha")) {
        const e = o(N.get("alpha"), 3, x);
        if (!e || !a.isTokenNumber(e)) return !1;
        g.push(e);
    }
    return x.channels = [
        g[0][4].value,
        g[1][4].value,
        g[2][4].value
    ], 4 === g.length && (x.alpha = g[3][4].value), x;
}
function hsl(e, o) {
    if (e.value.some((e)=>t.isTokenNode(e) && a.isTokenComma(e.value))) {
        const o = hslCommaSeparated(e);
        if (!1 !== o) return o;
    }
    {
        const a = hslSpaceSeparated(e, o);
        if (!1 !== a) return a;
    }
    return !1;
}
function hslCommaSeparated(e) {
    return threeChannelLegacySyntax(e, normalize_legacy_HSL_ChannelValues, exports.ColorNotation.HSL, [
        exports.SyntaxFlag.LegacyHSL
    ]);
}
function hslSpaceSeparated(e, o) {
    return threeChannelSpaceSeparated(e, normalize_modern_HSL_ChannelValues, exports.ColorNotation.HSL, [], o);
}
function normalize_HWB_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = e[4].value;
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = e[4].value;
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_Lab_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o || 2 === o ? t = normalize(e[4].value, .8, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 1, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function lab(e, o) {
    return threeChannelSpaceSeparated(e, normalize_Lab_ChannelValues, exports.ColorNotation.Lab, [], o);
}
function normalize_LCH_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (2 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o ? t = normalize(e[4].value, 100 / 150, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o ? t = normalize(e[4].value, 1, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function lch(e, o) {
    return threeChannelSpaceSeparated(e, normalize_LCH_ChannelValues, exports.ColorNotation.LCH, [], o);
}
const N = new Map;
for (const [e, o] of Object.entries(n.namedColors))N.set(e, o);
function namedColor(e) {
    const o = N.get(toLowerCaseAZ(e));
    return !!o && {
        colorNotation: exports.ColorNotation.RGB,
        channels: [
            o[0] / 255,
            o[1] / 255,
            o[2] / 255
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorKeyword,
            exports.SyntaxFlag.NamedColor
        ])
    };
}
function normalize_OKLab_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, 0, 1);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 250, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 1);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 1, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function oklab(e, o) {
    return threeChannelSpaceSeparated(e, normalize_OKLab_ChannelValues, exports.ColorNotation.OKLab, [], o);
}
function normalize_OKLCH_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (2 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, 0, 1);
        return 1 === o ? t = normalize(e[4].value, 250, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 1);
        return 1 === o ? t = normalize(e[4].value, 1, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function oklch(e, o) {
    return threeChannelSpaceSeparated(e, normalize_OKLCH_ChannelValues, exports.ColorNotation.OKLCH, [], o);
}
function normalize_legacy_sRGB_ChannelValues(e, o, n) {
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        const t = normalize(e[4].value, 100, 0, 1);
        return [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 255, 0, 1);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_modern_sRGB_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === e[4].value.toLowerCase()) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 255, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function rgb(e, o) {
    if (e.value.some((e)=>t.isTokenNode(e) && a.isTokenComma(e.value))) {
        const o = rgbCommaSeparated(e);
        if (!1 !== o) return (!o.syntaxFlags.has(exports.SyntaxFlag.HasNumberValues) || !o.syntaxFlags.has(exports.SyntaxFlag.HasPercentageValues)) && o;
    } else {
        const a = rgbSpaceSeparated(e, o);
        if (!1 !== a) return a;
    }
    return !1;
}
function rgbCommaSeparated(e) {
    return threeChannelLegacySyntax(e, normalize_legacy_sRGB_ChannelValues, exports.ColorNotation.RGB, [
        exports.SyntaxFlag.LegacyRGB
    ]);
}
function rgbSpaceSeparated(e, o) {
    return threeChannelSpaceSeparated(e, normalize_modern_sRGB_ChannelValues, exports.ColorNotation.RGB, [], o);
}
function XYZ_D50_to_sRGB_Gamut(e) {
    const o = n.XYZ_D50_to_sRGB(e);
    if (n.inGamut(o)) return n.clip(o);
    let a = e;
    return a = n.XYZ_D50_to_OKLCH(a), a[0] < 1e-6 && (a = [
        0,
        0,
        0
    ]), a[0] > .999999 && (a = [
        1,
        0,
        0
    ]), n.gam_sRGB(n.mapGamutRayTrace(a, oklch_to_lin_srgb, lin_srgb_to_oklch));
}
function oklch_to_lin_srgb(e) {
    return e = n.OKLCH_to_OKLab(e), e = n.OKLab_to_XYZ(e), n.XYZ_to_lin_sRGB(e);
}
function lin_srgb_to_oklch(e) {
    return e = n.lin_sRGB_to_XYZ(e), e = n.XYZ_to_OKLab(e), n.OKLab_to_OKLCH(e);
}
function contrastColor(e, o) {
    let a = !1;
    for(let n = 0; n < e.value.length; n++){
        const r = e.value[n];
        if (!t.isWhitespaceNode(r) && !t.isCommentNode(r) && (a || (a = o(r), !a))) return !1;
    }
    if (!a) return !1;
    a.channels = convertNaNToZero(a.channels), a.channels = XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(a).channels), a.colorNotation = exports.ColorNotation.sRGB;
    const r = {
        colorNotation: exports.ColorNotation.sRGB,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ContrastColor,
            exports.SyntaxFlag.Experimental
        ])
    }, s = n.contrast_ratio_wcag_2_1(a.channels, [
        1,
        1,
        1
    ]), l = n.contrast_ratio_wcag_2_1(a.channels, [
        0,
        0,
        0
    ]);
    return r.channels = s > l ? [
        1,
        1,
        1
    ] : [
        0,
        0,
        0
    ], r;
}
function XYZ_D50_to_P3_Gamut(e) {
    const o = n.XYZ_D50_to_P3(e);
    if (n.inGamut(o)) return n.clip(o);
    let a = e;
    return a = n.XYZ_D50_to_OKLCH(a), a[0] < 1e-6 && (a = [
        0,
        0,
        0
    ]), a[0] > .999999 && (a = [
        1,
        0,
        0
    ]), n.gam_P3(n.mapGamutRayTrace(a, oklch_to_lin_p3, lin_p3_to_oklch));
}
function oklch_to_lin_p3(e) {
    return e = n.OKLCH_to_OKLab(e), e = n.OKLab_to_XYZ(e), n.XYZ_to_lin_P3(e);
}
function lin_p3_to_oklch(e) {
    return e = n.lin_P3_to_XYZ(e), e = n.XYZ_to_OKLab(e), n.OKLab_to_OKLCH(e);
}
function toPrecision(e, o = 7) {
    e = +e, o = +o;
    const a = (Math.floor(Math.abs(e)) + "").length;
    if (o > a) return +e.toFixed(o - a);
    {
        const n = 10 ** (a - o);
        return Math.round(e / n) * n;
    }
}
function serializeWithAlpha(e, o, n, r) {
    const s = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ];
    if ("number" == typeof e.alpha) {
        const l = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(l, 4) ? new t.FunctionNode(o, s, r) : new t.FunctionNode(o, s, [
            ...r,
            new t.WhitespaceNode([
                n
            ]),
            new t.TokenNode([
                a.TokenType.Delim,
                "/",
                -1,
                -1,
                {
                    value: "/"
                }
            ]),
            new t.WhitespaceNode([
                n
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(l, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Integer
                }
            ])
        ]);
    }
    return new t.FunctionNode(o, s, [
        ...r,
        new t.WhitespaceNode([
            n
        ]),
        new t.TokenNode([
            a.TokenType.Delim,
            "/",
            -1,
            -1,
            {
                value: "/"
            }
        ]),
        new t.WhitespaceNode([
            n
        ]),
        e.alpha
    ]);
}
exports.color = function color(e) {
    if (t.isFunctionNode(e)) {
        switch(toLowerCaseAZ(e.getName())){
            case "rgb":
            case "rgba":
                return rgb(e, color);
            case "hsl":
            case "hsla":
                return hsl(e, color);
            case "hwb":
                return o = color, threeChannelSpaceSeparated(e, normalize_HWB_ChannelValues, exports.ColorNotation.HWB, [], o);
            case "lab":
                return lab(e, color);
            case "lch":
                return lch(e, color);
            case "oklab":
                return oklab(e, color);
            case "oklch":
                return oklch(e, color);
            case "color":
                return color$1(e, color);
            case "color-mix":
                return colorMix(e, color);
            case "contrast-color":
                return contrastColor(e, color);
        }
    }
    var o;
    if (t.isTokenNode(e)) {
        if (a.isTokenHash(e.value)) return hex(e.value);
        if (a.isTokenIdent(e.value)) {
            const o = namedColor(e.value[4].value);
            return !1 !== o ? o : "transparent" === toLowerCaseAZ(e.value[4].value) && {
                colorNotation: exports.ColorNotation.RGB,
                channels: [
                    0,
                    0,
                    0
                ],
                alpha: 0,
                syntaxFlags: new Set([
                    exports.SyntaxFlag.ColorKeyword
                ])
            };
        }
    }
    return !1;
}, exports.colorDataFitsDisplayP3_Gamut = function colorDataFitsDisplayP3_Gamut(e) {
    const o = {
        ...e,
        channels: [
            ...e.channels
        ]
    };
    return o.channels = convertPowerlessComponentsToZeroValuesForDisplay(o.channels, o.colorNotation), !colorDataTo(o, exports.ColorNotation.Display_P3).channels.find((e)=>e < -1e-5 || e > 1.00001);
}, exports.colorDataFitsRGB_Gamut = function colorDataFitsRGB_Gamut(e) {
    const o = {
        ...e,
        channels: [
            ...e.channels
        ]
    };
    return o.channels = convertPowerlessComponentsToZeroValuesForDisplay(o.channels, o.colorNotation), !colorDataTo(o, exports.ColorNotation.RGB).channels.find((e)=>e < -1e-5 || e > 1.00001);
}, exports.serializeHSL = function serializeHSL(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    r = o ? n.XYZ_D50_to_HSL(n.sRGB_to_XYZ_D50(XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(e).channels))) : n.XYZ_D50_to_HSL(colorData_to_XYZ_D50(e).channels), r = r.map((e)=>Number.isNaN(e) ? 0 : e);
    const s = Math.min(360, Math.max(0, Math.round(toPrecision(r[0])))), l = Math.min(100, Math.max(0, Math.round(toPrecision(r[1])))), i = Math.min(100, Math.max(0, Math.round(toPrecision(r[2])))), u = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ], p = [
        a.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ], N = [
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: r[0],
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Percentage,
            l.toString() + "%",
            -1,
            -1,
            {
                value: r[1]
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Percentage,
            i.toString() + "%",
            -1,
            -1,
            {
                value: r[2]
            }
        ])
    ];
    if ("number" == typeof e.alpha) {
        const o = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(o, 4) ? new t.FunctionNode([
            a.TokenType.Function,
            "hsl(",
            -1,
            -1,
            {
                value: "hsl"
            }
        ], u, N) : new t.FunctionNode([
            a.TokenType.Function,
            "hsla(",
            -1,
            -1,
            {
                value: "hsla"
            }
        ], u, [
            ...N,
            new t.TokenNode(p),
            new t.WhitespaceNode([
                c
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(o, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Number
                }
            ])
        ]);
    }
    return new t.FunctionNode([
        a.TokenType.Function,
        "hsla(",
        -1,
        -1,
        {
            value: "hsla"
        }
    ], u, [
        ...N,
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        e.alpha
    ]);
}, exports.serializeOKLCH = function serializeOKLCH(e) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let o = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    e.colorNotation !== exports.ColorNotation.OKLCH && (o = n.XYZ_D50_to_OKLCH(colorData_to_XYZ_D50(e).channels));
    const r = toPrecision(o[0], 6), s = toPrecision(o[1], 6), l = toPrecision(o[2], 6), i = [
        a.TokenType.Function,
        "oklch(",
        -1,
        -1,
        {
            value: "oklch"
        }
    ], u = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ];
    return serializeWithAlpha(e, i, u, [
        new t.TokenNode([
            a.TokenType.Number,
            r.toString(),
            -1,
            -1,
            {
                value: o[0],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            u
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: o[1],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            u
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: o[2],
                type: a.NumberType.Number
            }
        ])
    ]);
}, exports.serializeP3 = function serializeP3(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    o ? r = XYZ_D50_to_P3_Gamut(colorData_to_XYZ_D50(e).channels) : e.colorNotation !== exports.ColorNotation.Display_P3 && (r = n.XYZ_D50_to_P3(colorData_to_XYZ_D50(e).channels));
    const s = o ? Math.min(1, Math.max(0, toPrecision(r[0], 6))) : toPrecision(r[0], 6), l = o ? Math.min(1, Math.max(0, toPrecision(r[1], 6))) : toPrecision(r[1], 6), i = o ? Math.min(1, Math.max(0, toPrecision(r[2], 6))) : toPrecision(r[2], 6), u = [
        a.TokenType.Function,
        "color(",
        -1,
        -1,
        {
            value: "color"
        }
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ];
    return serializeWithAlpha(e, u, c, [
        new t.TokenNode([
            a.TokenType.Ident,
            "display-p3",
            -1,
            -1,
            {
                value: "display-p3"
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: r[0],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: r[1],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            i.toString(),
            -1,
            -1,
            {
                value: r[2],
                type: a.NumberType.Number
            }
        ])
    ]);
}, exports.serializeRGB = function serializeRGB(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    r = o ? XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(e).channels) : n.XYZ_D50_to_sRGB(colorData_to_XYZ_D50(e).channels);
    const s = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[0])))), l = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[1])))), i = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[2])))), u = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ], p = [
        a.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ], N = [
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[0])),
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[1])),
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            i.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[2])),
                type: a.NumberType.Integer
            }
        ])
    ];
    if ("number" == typeof e.alpha) {
        const o = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(o, 4) ? new t.FunctionNode([
            a.TokenType.Function,
            "rgb(",
            -1,
            -1,
            {
                value: "rgb"
            }
        ], u, N) : new t.FunctionNode([
            a.TokenType.Function,
            "rgba(",
            -1,
            -1,
            {
                value: "rgba"
            }
        ], u, [
            ...N,
            new t.TokenNode(p),
            new t.WhitespaceNode([
                c
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(o, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Number
                }
            ])
        ]);
    }
    return new t.FunctionNode([
        a.TokenType.Function,
        "rgba(",
        -1,
        -1,
        {
            value: "rgba"
        }
    ], u, [
        ...N,
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        e.alpha
    ]);
};
}}),
"[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports.hasFallback = function hasFallback(t) {
    const e = t.parent;
    if (!e) return !1;
    const r = t.prop.toLowerCase(), s = e.index(t);
    for(let t = 0; t < s; t++){
        const s = e.nodes[t];
        if ("decl" === s.type && s.prop.toLowerCase() === r) return !0;
    }
    return !1;
}, exports.hasSupportsAtRuleAncestor = function hasSupportsAtRuleAncestor(t, e) {
    let r = t.parent;
    for(; r;)if ("atrule" === r.type && "supports" === r.name.toLowerCase()) {
        if (e.test(r.params)) return !0;
        r = r.parent;
    } else r = r.parent;
    return !1;
};
}}),
"[project]/node_modules/@csstools/postcss-color-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor\(/i, n = /^color$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-function",
        Declaration (i) {
            const c = i.value;
            if (!a.test(c)) return;
            if (r.hasFallback(i)) return;
            if (r.hasSupportsAtRuleAncestor(i, a)) return;
            const l = e.tokenize({
                css: c
            }), u = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(l), (s)=>{
                if (!t.isFunctionNode(s) || !n.test(s.getName())) return;
                const e = o.color(s);
                return e && !(e.syntaxFlags.has(o.SyntaxFlag.Experimental) || e.syntaxFlags.has(o.SyntaxFlag.HasNoneKeywords) || e.syntaxFlags.has(o.SyntaxFlag.RelativeColorSyntax)) ? o.serializeRGB(e) : void 0;
            }), p = t.stringify(u);
            p !== c && (i.cloneBefore({
                value: p
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const o = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return o.enableProgressiveCustomProperties && o.preserve ? {
        postcssPlugin: "postcss-color-function",
        plugins: [
            s(),
            basePlugin(o)
        ]
    } : basePlugin(o);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-color-mix-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor-mix\(/i, i = /^color-mix$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-mix-function",
        Declaration (n) {
            const l = n.value;
            if (!a.test(l)) return;
            if (r.hasFallback(n)) return;
            if (r.hasSupportsAtRuleAncestor(n, a)) return;
            const u = o.tokenize({
                css: l
            }), c = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return !r || r.syntaxFlags.has(e.SyntaxFlag.Experimental) || r.syntaxFlags.has(e.SyntaxFlag.ColorMixVariadic) ? void 0 : e.serializeRGB(r);
            }), p = t.stringify(c);
            if (p === l) return;
            let m = p;
            s?.subFeatures.displayP3 && (m = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) ? e.colorDataFitsRGB_Gamut(r) ? e.serializeRGB(r) : e.serializeP3(r) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && m !== p && n.cloneBefore({
                value: m
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return r.subFeatures = Object.assign({
        displayP3: !0
    }, r.subFeatures), r.enableProgressiveCustomProperties && (r.preserve || r.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-color-mix-function",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-color-mix-variadic-function-arguments/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor-mix\(/i, i = /^color-mix$/i, basePlugin = (s)=>({
        postcssPlugin: "color-mix-variadic-function-arguments",
        Declaration (n) {
            const l = n.value;
            if (!a.test(l)) return;
            if (r.hasFallback(n)) return;
            if (r.hasSupportsAtRuleAncestor(n, a)) return;
            const u = o.tokenize({
                css: l
            }), c = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) && r.syntaxFlags.has(e.SyntaxFlag.ColorMixVariadic) ? e.serializeRGB(r) : void 0;
            }), p = t.stringify(c);
            if (p === l) return;
            let m = p;
            s?.subFeatures.displayP3 && (m = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) ? e.colorDataFitsRGB_Gamut(r) ? e.serializeRGB(r) : e.serializeP3(r) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && m !== p && n.cloneBefore({
                value: m
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return r.subFeatures = Object.assign({
        displayP3: !0
    }, r.subFeatures), r.enableProgressiveCustomProperties && (r.preserve || r.subFeatures.displayP3) ? {
        postcssPlugin: "color-mix-variadic-function-arguments",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-content-alt-text/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function transform(e, s) {
    const o = e[0];
    if (!o.length) return "";
    if (s) return t.stringify([
        o
    ]);
    const n = e[1].filter((e)=>!t.isWhiteSpaceOrCommentNode(e));
    return 1 === n.length && t.isTokenNode(n[0]) && r.isTokenString(n[0].value) && "" === n[0].value[4].value ? t.stringify([
        o
    ]) : t.stringify([
        [
            ...o,
            ...e[1]
        ]
    ]);
}
function parse(e) {
    const s = t.parseListOfComponentValues(r.tokenize({
        css: e
    })), o = [];
    let n = 0;
    for(let e = s.length - 1; e >= 0; e--){
        const i = s[e];
        if (!t.isTokenNode(i)) continue;
        const l = i.value;
        r.isTokenDelim(l) && "/" === l[4].value && (o.push(s.slice(n, e)), n = e + 1);
    }
    return 0 !== n && o.push(s.slice(n, s.length)), o;
}
const o = {
    test: (e)=>e.includes("content:") && e.includes("/")
}, basePlugin = (e)=>({
        postcssPlugin: "postcss-content-alt-text",
        Declaration (t) {
            if ("content" !== t.prop || !t.value.includes("/")) return;
            if (s.hasFallback(t)) return;
            if (s.hasSupportsAtRuleAncestor(t, o)) return;
            const r = parse(t.value);
            if (2 !== r.length) return;
            const n = transform(r, e?.stripAltText);
            n !== t.value && (t.cloneBefore({
                value: n
            }), !1 === e?.preserve && t.remove());
        }
    });
basePlugin.postcss = !0;
const creator = (s)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0,
        stripAltText: !1
    }, s);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-content-alt-text",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
class LayerName {
    parts;
    constructor(e){
        this.parts = e;
    }
    tokens() {
        return [
            ...this.parts
        ];
    }
    slice(r, n) {
        const t = [];
        for(let r = 0; r < this.parts.length; r++)e.isTokenIdent(this.parts[r]) && t.push(r);
        const s = t.slice(r, n);
        return new LayerName(this.parts.slice(s[0], s[s.length - 1] + 1));
    }
    concat(r) {
        const n = [
            e.TokenType.Delim,
            ".",
            -1,
            -1,
            {
                value: "."
            }
        ];
        return new LayerName([
            ...this.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r)),
            n,
            ...r.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r))
        ]);
    }
    segments() {
        return this.parts.filter((r)=>e.isTokenIdent(r)).map((e)=>e[4].value);
    }
    name() {
        return this.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r)).map((e)=>e[1]).join("");
    }
    equal(e) {
        const r = this.segments(), n = e.segments();
        if (r.length !== n.length) return !1;
        for(let e = 0; e < r.length; e++){
            if (r[e] !== n[e]) return !1;
        }
        return !0;
    }
    toString() {
        return e.stringify(...this.parts);
    }
    toJSON() {
        return {
            parts: this.parts,
            segments: this.segments(),
            name: this.name()
        };
    }
}
function parseFromTokens(n, t) {
    const s = r.parseCommaSeparatedListOfComponentValues(n, {
        onParseError: t?.onParseError
    }), a = t?.onParseError ?? (()=>{}), o = [
        "6.4.2. Layer Naming and Nesting",
        "Layer name syntax",
        "<layer-name> = <ident> [ '.' <ident> ]*"
    ], i = n[0][2], l = n[n.length - 1][3], m = [];
    for(let n = 0; n < s.length; n++){
        const t = s[n];
        for(let n = 0; n < t.length; n++){
            const s = t[n];
            if (!r.isTokenNode(s) && !r.isCommentNode(s) && !r.isWhitespaceNode(s)) return a(new e.ParseError(`Invalid cascade layer name. Invalid layer name part "${s.toString()}"`, i, l, o)), [];
        }
        const c = t.flatMap((e)=>e.tokens());
        let d = !1, p = !1, u = null;
        for(let r = 0; r < c.length; r++){
            const n = c[r];
            if (!(e.isTokenWhiteSpaceOrComment(n) || e.isTokenIdent(n) || e.isTokenDelim(n) && "." === n[4].value)) return a(new e.ParseError(`Invalid cascade layer name. Invalid character "${n[1]}"`, i, l, o)), [];
            if (!d && e.isTokenDelim(n)) return a(new e.ParseError("Invalid cascade layer name. Layer names can not start with a dot.", i, l, o)), [];
            if (d) {
                if (e.isTokenWhitespace(n)) {
                    p = !0;
                    continue;
                }
                if (p && e.isTokenComment(n)) continue;
                if (p) return a(new e.ParseError("Invalid cascade layer name. Encountered unexpected whitespace between layer name parts.", i, l, o)), [];
                if (e.isTokenIdent(u) && e.isTokenIdent(n)) return a(new e.ParseError("Invalid cascade layer name. Layer name parts must be separated by dots.", i, l, o)), [];
                if (e.isTokenDelim(u) && e.isTokenDelim(n)) return a(new e.ParseError("Invalid cascade layer name. Layer name parts must not be empty.", i, l, o)), [];
            }
            e.isTokenIdent(n) && (d = !0), (e.isTokenIdent(n) || e.isTokenDelim(n)) && (u = n);
        }
        if (!u) return a(new e.ParseError("Invalid cascade layer name. Empty layer name.", i, l, o)), [];
        if (e.isTokenDelim(u)) return a(new e.ParseError("Invalid cascade layer name. Layer name must not end with a dot.", i, l, o)), [];
        m.push(new LayerName(c));
    }
    return m;
}
exports.LayerName = LayerName, exports.addLayerToModel = function addLayerToModel(e, r) {
    r.forEach((r)=>{
        const n = r.segments();
        e: for(let t = 0; t < n.length; t++){
            const n = r.slice(0, t + 1), s = n.segments();
            let a = -1, o = 0;
            for(let r = 0; r < e.length; r++){
                const n = e[r].segments();
                let t = 0;
                r: for(let e = 0; e < n.length; e++){
                    const r = n[e], a = s[e];
                    if (a === r && e + 1 === s.length) continue e;
                    if (a !== r) {
                        if (a !== r) break r;
                    } else t++;
                }
                t >= o && (a = r, o = t);
            }
            -1 === a ? e.push(n) : e.splice(a + 1, 0, n);
        }
    });
}, exports.parse = function parse(r, n) {
    return parseFromTokens(e.tokenize({
        css: r
    }, {
        onParseError: n?.onParseError
    }), n);
}, exports.parseFromTokens = parseFromTokens;
}}),
"[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
exports.NodeType = void 0, (e = exports.NodeType || (exports.NodeType = {})).CustomMedia = "custom-media", e.GeneralEnclosed = "general-enclosed", e.MediaAnd = "media-and", e.MediaCondition = "media-condition", e.MediaConditionListWithAnd = "media-condition-list-and", e.MediaConditionListWithOr = "media-condition-list-or", e.MediaFeature = "media-feature", e.MediaFeatureBoolean = "mf-boolean", e.MediaFeatureName = "mf-name", e.MediaFeaturePlain = "mf-plain", e.MediaFeatureRangeNameValue = "mf-range-name-value", e.MediaFeatureRangeValueName = "mf-range-value-name", e.MediaFeatureRangeValueNameValue = "mf-range-value-name-value", e.MediaFeatureValue = "mf-value", e.MediaInParens = "media-in-parens", e.MediaNot = "media-not", e.MediaOr = "media-or", e.MediaQueryWithType = "media-query-with-type", e.MediaQueryWithoutType = "media-query-without-type", e.MediaQueryInvalid = "media-query-invalid";
class MediaCondition {
    type = exports.NodeType.MediaCondition;
    media;
    constructor(e){
        this.media = e;
    }
    tokens() {
        return this.media.tokens();
    }
    toString() {
        return this.media.toString();
    }
    hasLeadingSpace() {
        return this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            media: this.media.toJSON()
        };
    }
    isMediaCondition() {
        return MediaCondition.isMediaCondition(this);
    }
    static isMediaCondition(e) {
        return !!e && e instanceof MediaCondition && e.type === exports.NodeType.MediaCondition;
    }
}
class MediaInParens {
    type = exports.NodeType.MediaInParens;
    media;
    before;
    after;
    constructor(e, t = [], i = []){
        this.media = e, this.before = t, this.after = i;
    }
    tokens() {
        return [
            ...this.before,
            ...this.media.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.media.toString() + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && ("walk" in this.media ? this.media.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            media: this.media.toJSON(),
            before: this.before,
            after: this.after
        };
    }
    isMediaInParens() {
        return MediaInParens.isMediaInParens(this);
    }
    static isMediaInParens(e) {
        return !!e && e instanceof MediaInParens && e.type === exports.NodeType.MediaInParens;
    }
}
class MediaQueryWithType {
    type = exports.NodeType.MediaQueryWithType;
    modifier;
    mediaType;
    and = void 0;
    media = void 0;
    constructor(e, t, i, a){
        this.modifier = e, this.mediaType = t, i && a && (this.and = i, this.media = a);
    }
    getModifier() {
        if (!this.modifier.length) return "";
        for(let e = 0; e < this.modifier.length; e++){
            const t = this.modifier[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    negateQuery() {
        const e = "not" === this.getModifier().toLowerCase(), t = this.getMediaType();
        return this.and && this.media ? e ? [
            new MediaQueryWithType([], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ]),
            new MediaQueryWithoutType(this.media)
        ] : [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ]),
            ...new MediaQueryWithoutType(this.media).negateQuery()
        ] : e ? [
            new MediaQueryWithType([], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ])
        ] : [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ])
        ];
    }
    getMediaType() {
        if (!this.mediaType.length) return "";
        for(let e = 0; e < this.mediaType.length; e++){
            const t = this.mediaType[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    tokens() {
        return this.and && this.media ? [
            ...this.modifier,
            ...this.mediaType,
            ...this.and,
            ...this.media.tokens()
        ] : [
            ...this.modifier,
            ...this.mediaType
        ];
    }
    toString() {
        return this.and && this.media ? i.stringify(...this.modifier) + i.stringify(...this.mediaType) + i.stringify(...this.and) + this.media.toString() : i.stringify(...this.modifier) + i.stringify(...this.mediaType);
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        if (t && (i = {
            ...t
        }), this.media) return !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            modifier: this.modifier,
            mediaType: this.mediaType,
            and: this.and,
            media: this.media
        };
    }
    isMediaQueryWithType() {
        return MediaQueryWithType.isMediaQueryWithType(this);
    }
    static isMediaQueryWithType(e) {
        return !!e && e instanceof MediaQueryWithType && e.type === exports.NodeType.MediaQueryWithType;
    }
}
class MediaQueryWithoutType {
    type = exports.NodeType.MediaQueryWithoutType;
    media;
    constructor(e){
        this.media = e;
    }
    negateQuery() {
        let e = this.media;
        if (e.media.type === exports.NodeType.MediaNot) return [
            new MediaQueryWithoutType(new MediaCondition(e.media.media))
        ];
        e.media.type !== exports.NodeType.MediaConditionListWithOr && e.media.type !== exports.NodeType.MediaConditionListWithAnd || (e = new MediaCondition(new MediaInParens(e, [
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ],
            [
                i.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ]
        ], [
            [
                i.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ]
        ]))), "before" in e.media && (e.media.hasLeadingSpace() || e.media.before.splice(0, 0, [
            i.TokenType.Whitespace,
            " ",
            -1,
            -1,
            void 0
        ]));
        return [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    "all",
                    -1,
                    -1,
                    {
                        value: "all"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ]
            ], e)
        ];
    }
    tokens() {
        return this.media.tokens();
    }
    toString() {
        return this.media.toString();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            media: this.media
        };
    }
    isMediaQueryWithoutType() {
        return MediaQueryWithoutType.isMediaQueryWithoutType(this);
    }
    static isMediaQueryWithoutType(e) {
        return !!e && e instanceof MediaQueryWithoutType && e.type === exports.NodeType.MediaQueryWithoutType;
    }
}
class MediaQueryInvalid {
    type = exports.NodeType.MediaQueryInvalid;
    media;
    constructor(e){
        this.media = e;
    }
    negateQuery() {
        return [
            new MediaQueryInvalid(this.media)
        ];
    }
    tokens() {
        return this.media.flatMap((e)=>e.tokens());
    }
    toString() {
        return this.media.map((e)=>e.toString()).join("");
    }
    walk(e, i) {
        if (0 === this.media.length) return;
        const a = t.walkerIndexGenerator(this.media);
        let r = 0;
        for(; r < this.media.length;){
            const t = this.media[r];
            let n;
            if (i && (n = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: n
            }, r)) return !1;
            if ("walk" in t && this.media.includes(t) && !1 === t.walk(e, n)) return !1;
            if (r = a(this.media, t, r), -1 === r) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            media: this.media
        };
    }
    isMediaQueryInvalid() {
        return MediaQueryInvalid.isMediaQueryInvalid(this);
    }
    static isMediaQueryInvalid(e) {
        return !!e && e instanceof MediaQueryInvalid && e.type === exports.NodeType.MediaQueryInvalid;
    }
}
class GeneralEnclosed {
    type = exports.NodeType.GeneralEnclosed;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return this.value.tokens();
    }
    toString() {
        return this.value.toString();
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.value.tokens()[0]);
    }
    indexOf(e) {
        return e === this.value ? "value" : -1;
    }
    at(e) {
        if ("value" === e) return this.value;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isGeneralEnclosed() {
        return GeneralEnclosed.isGeneralEnclosed(this);
    }
    static isGeneralEnclosed(e) {
        return !!e && e instanceof GeneralEnclosed && e.type === exports.NodeType.GeneralEnclosed;
    }
}
class MediaAnd {
    type = exports.NodeType.MediaAnd;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.modifier[0]);
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        return "media" === e ? this.media : null;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaAnd() {
        return MediaAnd.isMediaAnd(this);
    }
    static isMediaAnd(e) {
        return !!e && e instanceof MediaAnd && e.type === exports.NodeType.MediaAnd;
    }
}
class MediaConditionListWithAnd {
    type = exports.NodeType.MediaConditionListWithAnd;
    leading;
    list;
    before;
    after;
    constructor(e, t, i = [], a = []){
        this.leading = e, this.list = t, this.before = i, this.after = a;
    }
    tokens() {
        return [
            ...this.before,
            ...this.leading.tokens(),
            ...this.list.flatMap((e)=>e.tokens()),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.leading.toString() + this.list.map((e)=>e.toString()).join("") + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.leading.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.leading ? "leading" : e.type === exports.NodeType.MediaAnd ? this.list.indexOf(e) : -1;
    }
    at(e) {
        return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }
    walk(e, i) {
        let a;
        if (i && (a = {
            ...i
        }), !1 === e({
            node: this.leading,
            parent: this,
            state: a
        }, "leading")) return !1;
        if ("walk" in this.leading && !1 === this.leading.walk(e, a)) return !1;
        if (0 === this.list.length) return;
        const r = t.walkerIndexGenerator(this.list);
        let n = 0;
        for(; n < this.list.length;){
            const t = this.list[n];
            if (i && (a = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: a
            }, n)) return !1;
            if ("walk" in t && this.list.includes(t) && !1 === t.walk(e, a)) return !1;
            if (n = r(this.list, t, n), -1 === n) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            leading: this.leading.toJSON(),
            list: this.list.map((e)=>e.toJSON()),
            before: this.before,
            after: this.after
        };
    }
    isMediaConditionListWithAnd() {
        return MediaConditionListWithAnd.isMediaConditionListWithAnd(this);
    }
    static isMediaConditionListWithAnd(e) {
        return !!e && e instanceof MediaConditionListWithAnd && e.type === exports.NodeType.MediaConditionListWithAnd;
    }
}
class MediaConditionListWithOr {
    type = exports.NodeType.MediaConditionListWithOr;
    leading;
    list;
    before;
    after;
    constructor(e, t, i = [], a = []){
        this.leading = e, this.list = t, this.before = i, this.after = a;
    }
    tokens() {
        return [
            ...this.before,
            ...this.leading.tokens(),
            ...this.list.flatMap((e)=>e.tokens()),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.leading.toString() + this.list.map((e)=>e.toString()).join("") + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.leading.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.leading ? "leading" : e.type === exports.NodeType.MediaOr ? this.list.indexOf(e) : -1;
    }
    at(e) {
        return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }
    walk(e, i) {
        let a;
        if (i && (a = {
            ...i
        }), !1 === e({
            node: this.leading,
            parent: this,
            state: a
        }, "leading")) return !1;
        if ("walk" in this.leading && !1 === this.leading.walk(e, a)) return !1;
        if (0 === this.list.length) return;
        const r = t.walkerIndexGenerator(this.list);
        let n = 0;
        for(; n < this.list.length;){
            const t = this.list[n];
            if (i && (a = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: a
            }, n)) return !1;
            if ("walk" in t && this.list.includes(t) && !1 === t.walk(e, a)) return !1;
            if (n = r(this.list, t, n), -1 === n) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            leading: this.leading.toJSON(),
            list: this.list.map((e)=>e.toJSON()),
            before: this.before,
            after: this.after
        };
    }
    isMediaConditionListWithOr() {
        return MediaConditionListWithOr.isMediaConditionListWithOr(this);
    }
    static isMediaConditionListWithOr(e) {
        return !!e && e instanceof MediaConditionListWithOr && e.type === exports.NodeType.MediaConditionListWithOr;
    }
}
function isNumber(e) {
    return !!(t.isTokenNode(e) && i.isTokenNumber(e.value) || t.isFunctionNode(e) && a.has(e.getName().toLowerCase()));
}
const a = new Set([
    "abs",
    "acos",
    "asin",
    "atan",
    "atan2",
    "calc",
    "clamp",
    "cos",
    "exp",
    "hypot",
    "log",
    "max",
    "min",
    "mod",
    "pow",
    "rem",
    "round",
    "sign",
    "sin",
    "sqrt",
    "tan"
]);
function isDimension(e) {
    return t.isTokenNode(e) && i.isTokenDimension(e.value);
}
function isIdent(e) {
    return t.isTokenNode(e) && i.isTokenIdent(e.value);
}
function isEnvironmentVariable(e) {
    return t.isFunctionNode(e) && "env" === e.getName().toLowerCase();
}
class MediaFeatureName {
    type = exports.NodeType.MediaFeatureName;
    name;
    before;
    after;
    constructor(e, t = [], i = []){
        this.name = e, this.before = t, this.after = i;
    }
    getName() {
        return this.name.value[4].value;
    }
    getNameToken() {
        return this.name.value;
    }
    tokens() {
        return [
            ...this.before,
            ...this.name.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.name.toString() + i.stringify(...this.after);
    }
    indexOf(e) {
        return e === this.name ? "name" : -1;
    }
    at(e) {
        if ("name" === e) return this.name;
    }
    toJSON() {
        return {
            type: this.type,
            name: this.getName(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureName() {
        return MediaFeatureName.isMediaFeatureName(this);
    }
    static isMediaFeatureName(e) {
        return !!e && e instanceof MediaFeatureName && e.type === exports.NodeType.MediaFeatureName;
    }
}
function parseMediaFeatureName(e) {
    let i = -1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (!isIdent(r)) return !1;
            if (-1 !== i) return !1;
            i = a;
        }
    }
    return -1 !== i && new MediaFeatureName(e[i], e.slice(0, i).flatMap((e)=>e.tokens()), e.slice(i + 1).flatMap((e)=>e.tokens()));
}
class MediaFeatureBoolean {
    type = exports.NodeType.MediaFeatureBoolean;
    name;
    constructor(e){
        this.name = e;
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return this.name.tokens();
    }
    toString() {
        return this.name.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : -1;
    }
    at(e) {
        if ("name" === e) return this.name;
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureBoolean() {
        return MediaFeatureBoolean.isMediaFeatureBoolean(this);
    }
    static isMediaFeatureBoolean(e) {
        return !!e && e instanceof MediaFeatureBoolean && e.type === exports.NodeType.MediaFeatureBoolean;
    }
}
function parseMediaFeatureBoolean(e) {
    const t = parseMediaFeatureName(e);
    return !1 === t ? t : new MediaFeatureBoolean(t);
}
class MediaFeatureValue {
    type = exports.NodeType.MediaFeatureValue;
    value;
    before;
    after;
    constructor(e, t = [], i = []){
        Array.isArray(e) && 1 === e.length ? this.value = e[0] : this.value = e, this.before = t, this.after = i;
    }
    tokens() {
        return Array.isArray(this.value) ? [
            ...this.before,
            ...this.value.flatMap((e)=>e.tokens()),
            ...this.after
        ] : [
            ...this.before,
            ...this.value.tokens(),
            ...this.after
        ];
    }
    toString() {
        return Array.isArray(this.value) ? i.stringify(...this.before) + this.value.map((e)=>e.toString()).join("") + i.stringify(...this.after) : i.stringify(...this.before) + this.value.toString() + i.stringify(...this.after);
    }
    indexOf(e) {
        return e === this.value ? "value" : -1;
    }
    at(e) {
        return "value" === e ? this.value : Array.isArray(this.value) && "number" == typeof e ? (e < 0 && (e = this.value.length + e), this.value[e]) : void 0;
    }
    walk(e, i) {
        if (Array.isArray(this.value)) {
            if (0 === this.value.length) return;
            const a = t.walkerIndexGenerator(this.value);
            let r = 0;
            for(; r < this.value.length;){
                const t = this.value[r];
                let n;
                if (i && (n = {
                    ...i
                }), !1 === e({
                    node: t,
                    parent: this,
                    state: n
                }, r)) return !1;
                if ("walk" in t && this.value.includes(t) && !1 === t.walk(e, n)) return !1;
                if (r = a(this.value, t, r), -1 === r) break;
            }
        } else {
            let t;
            if (i && (t = {
                ...i
            }), !1 === e({
                node: this.value,
                parent: this,
                state: t
            }, "value")) return !1;
            if ("walk" in this.value) return this.value.walk(e, t);
        }
    }
    toJSON() {
        return Array.isArray(this.value) ? {
            type: this.type,
            value: this.value.map((e)=>e.toJSON()),
            tokens: this.tokens()
        } : {
            type: this.type,
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureValue() {
        return MediaFeatureValue.isMediaFeatureValue(this);
    }
    static isMediaFeatureValue(e) {
        return !!e && e instanceof MediaFeatureValue && e.type === exports.NodeType.MediaFeatureValue;
    }
}
function parseMediaFeatureValue(e, i = !1) {
    let a = -1, r = -1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (s.type !== t.ComponentValueType.Whitespace && s.type !== t.ComponentValueType.Comment) {
            if (-1 !== a) return !1;
            if (isNumber(s)) {
                const t = matchesRatioExactly(e.slice(n));
                if (-1 !== t) {
                    a = t[0] + n, r = t[1] + n, n += t[1] - t[0];
                    continue;
                }
                a = n, r = n;
            } else if (isEnvironmentVariable(s)) a = n, r = n;
            else if (isDimension(s)) a = n, r = n;
            else {
                if (i || !isIdent(s)) return !1;
                a = n, r = n;
            }
        }
    }
    return -1 !== a && new MediaFeatureValue(e.slice(a, r + 1), e.slice(0, a).flatMap((e)=>e.tokens()), e.slice(r + 1).flatMap((e)=>e.tokens()));
}
function matchesRatioExactly(e) {
    let i = -1, a = -1;
    const r = matchesRatio(e);
    if (-1 === r) return -1;
    i = r[0], a = r[1];
    for(let i = a + 1; i < e.length; i++){
        const a = e[i];
        if (!t.isWhiteSpaceOrCommentNode(a)) return -1;
    }
    return [
        i,
        a
    ];
}
function matchesRatio(e) {
    let a = -1, r = -1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (!t.isWhiteSpaceOrCommentNode(s)) {
            if (t.isTokenNode(s)) {
                const e = s.value;
                if (i.isTokenDelim(e) && "/" === e[4].value) {
                    if (-1 === a) return -1;
                    if (-1 !== r) return -1;
                    r = n;
                    continue;
                }
            }
            if (!isNumber(s)) return -1;
            if (-1 !== r) return [
                a,
                n
            ];
            if (-1 !== a) return -1;
            a = n;
        }
    }
    return -1;
}
class MediaFeaturePlain {
    type = exports.NodeType.MediaFeaturePlain;
    name;
    colon;
    value;
    constructor(e, t, i){
        this.name = e, this.colon = t, this.value = i;
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.name.tokens(),
            this.colon,
            ...this.value.tokens()
        ];
    }
    toString() {
        return this.name.toString() + i.stringify(this.colon) + this.value.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && this.value.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeaturePlain() {
        return MediaFeaturePlain.isMediaFeaturePlain(this);
    }
    static isMediaFeaturePlain(e) {
        return !!e && e instanceof MediaFeaturePlain && e.type === exports.NodeType.MediaFeaturePlain;
    }
}
function parseMediaFeaturePlain(e) {
    let a = [], r = [], n = null;
    for(let s = 0; s < e.length; s++){
        const o = e[s];
        if (o.type === t.ComponentValueType.Token) {
            const t = o.value;
            if (i.isTokenColon(t)) {
                a = e.slice(0, s), r = e.slice(s + 1), n = t;
                break;
            }
        }
    }
    if (!a.length || !r.length || !n) return !1;
    const s = parseMediaFeatureName(a);
    if (!1 === s) return !1;
    const o = parseMediaFeatureValue(r);
    return !1 !== o && new MediaFeaturePlain(s, n, o);
}
var r, n, s;
function matchesComparison(e) {
    let a = -1;
    for(let r = 0; r < e.length; r++){
        const n = e[r];
        if (n.type === t.ComponentValueType.Token) {
            const e = n.value;
            if (i.isTokenDelim(e)) {
                if (e[4].value === exports.MediaFeatureEQ.EQ) return -1 !== a ? [
                    a,
                    r
                ] : [
                    r,
                    r
                ];
                if (e[4].value === exports.MediaFeatureLT.LT) {
                    a = r;
                    continue;
                }
                if (e[4].value === exports.MediaFeatureGT.GT) {
                    a = r;
                    continue;
                }
            }
        }
        break;
    }
    return -1 !== a && [
        a,
        a
    ];
}
function comparisonFromTokens(e) {
    if (1 !== e.length && 2 !== e.length) return !1;
    if (!i.isTokenDelim(e[0])) return !1;
    if (1 === e.length) switch(e[0][4].value){
        case exports.MediaFeatureEQ.EQ:
            return exports.MediaFeatureEQ.EQ;
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureLT.LT;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureGT.GT;
        default:
            return !1;
    }
    if (!i.isTokenDelim(e[1])) return !1;
    if (e[1][4].value !== exports.MediaFeatureEQ.EQ) return !1;
    switch(e[0][4].value){
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureLT.LT_OR_EQ;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureGT.GT_OR_EQ;
        default:
            return !1;
    }
}
exports.MediaFeatureLT = void 0, (r = exports.MediaFeatureLT || (exports.MediaFeatureLT = {})).LT = "<", r.LT_OR_EQ = "<=", exports.MediaFeatureGT = void 0, (n = exports.MediaFeatureGT || (exports.MediaFeatureGT = {})).GT = ">", n.GT_OR_EQ = ">=", exports.MediaFeatureEQ = void 0, (exports.MediaFeatureEQ || (exports.MediaFeatureEQ = {})).EQ = "=";
class MediaFeatureRangeNameValue {
    type = exports.NodeType.MediaFeatureRangeNameValue;
    name;
    operator;
    value;
    constructor(e, t, i){
        this.name = e, this.operator = t, this.value = i;
    }
    operatorKind() {
        return comparisonFromTokens(this.operator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.name.tokens(),
            ...this.operator,
            ...this.value.tokens()
        ];
    }
    toString() {
        return this.name.toString() + i.stringify(...this.operator) + this.value.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeNameValue() {
        return MediaFeatureRangeNameValue.isMediaFeatureRangeNameValue(this);
    }
    static isMediaFeatureRangeNameValue(e) {
        return !!e && e instanceof MediaFeatureRangeNameValue && e.type === exports.NodeType.MediaFeatureRangeNameValue;
    }
}
class MediaFeatureRangeValueName {
    type = exports.NodeType.MediaFeatureRangeValueName;
    name;
    operator;
    value;
    constructor(e, t, i){
        this.name = e, this.operator = t, this.value = i;
    }
    operatorKind() {
        return comparisonFromTokens(this.operator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.value.tokens(),
            ...this.operator,
            ...this.name.tokens()
        ];
    }
    toString() {
        return this.value.toString() + i.stringify(...this.operator) + this.name.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeValueName() {
        return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(this);
    }
    static isMediaFeatureRangeValueName(e) {
        return !!e && e instanceof MediaFeatureRangeValueName && e.type === exports.NodeType.MediaFeatureRangeValueName;
    }
}
class MediaFeatureRangeValueNameValue {
    type = exports.NodeType.MediaFeatureRangeValueNameValue;
    name;
    valueOne;
    valueOneOperator;
    valueTwo;
    valueTwoOperator;
    constructor(e, t, i, a, r){
        this.name = e, this.valueOne = t, this.valueOneOperator = i, this.valueTwo = a, this.valueTwoOperator = r;
    }
    valueOneOperatorKind() {
        return comparisonFromTokens(this.valueOneOperator);
    }
    valueTwoOperatorKind() {
        return comparisonFromTokens(this.valueTwoOperator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.valueOne.tokens(),
            ...this.valueOneOperator,
            ...this.name.tokens(),
            ...this.valueTwoOperator,
            ...this.valueTwo.tokens()
        ];
    }
    toString() {
        return this.valueOne.toString() + i.stringify(...this.valueOneOperator) + this.name.toString() + i.stringify(...this.valueTwoOperator) + this.valueTwo.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.valueOne ? "valueOne" : e === this.valueTwo ? "valueTwo" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "valueOne" === e ? this.valueOne : "valueTwo" === e ? this.valueTwo : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.valueOne,
            parent: this,
            state: i
        }, "valueOne") && (!("walk" in this.valueOne) || !1 !== this.valueOne.walk(e, i)) && (t && (i = {
            ...t
        }), !1 !== e({
            node: this.valueTwo,
            parent: this,
            state: i
        }, "valueTwo") && (!("walk" in this.valueTwo) || !1 !== this.valueTwo.walk(e, i)) && void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            valueOne: this.valueOne.toJSON(),
            valueTwo: this.valueTwo.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeValueNameValue() {
        return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(this);
    }
    static isMediaFeatureRangeValueNameValue(e) {
        return !!e && e instanceof MediaFeatureRangeValueNameValue && e.type === exports.NodeType.MediaFeatureRangeValueNameValue;
    }
}
function parseMediaFeatureRange(e) {
    let a = !1, r = !1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (s.type === t.ComponentValueType.Token) {
            const t = s.value;
            if (i.isTokenDelim(t)) {
                const t = matchesComparison(e.slice(n));
                if (!1 !== t) {
                    if (!1 !== a) {
                        r = [
                            t[0] + n,
                            t[1] + n
                        ];
                        break;
                    }
                    a = [
                        t[0] + n,
                        t[1] + n
                    ], n += t[1];
                }
            }
        }
    }
    if (!1 === a) return !1;
    const n = [
        e[a[0]].value
    ];
    if (a[0] !== a[1] && n.push(e[a[1]].value), !1 === r) {
        const t = e.slice(0, a[0]), i = e.slice(a[1] + 1), r = parseMediaFeatureName(t);
        if (r) {
            const e = parseMediaFeatureValue(i, !0);
            return !!e && new MediaFeatureRangeNameValue(r, n, e);
        }
        const s = parseMediaFeatureName(i);
        if (s) {
            const e = parseMediaFeatureValue(t, !0);
            return !!e && new MediaFeatureRangeValueName(s, n, e);
        }
        return !1;
    }
    const s = [
        e[r[0]].value
    ];
    r[0] !== r[1] && s.push(e[r[1]].value);
    const o = e.slice(0, a[0]), u = e.slice(a[1] + 1, r[0]), d = e.slice(r[1] + 1), l = parseMediaFeatureValue(o, !0), p = parseMediaFeatureName(u), h = parseMediaFeatureValue(d, !0);
    if (!l || !p || !h) return !1;
    {
        const e = comparisonFromTokens(n);
        if (!1 === e || e === exports.MediaFeatureEQ.EQ) return !1;
        const t = comparisonFromTokens(s);
        if (!1 === t || t === exports.MediaFeatureEQ.EQ) return !1;
        if (!(e !== exports.MediaFeatureLT.LT && e !== exports.MediaFeatureLT.LT_OR_EQ || t !== exports.MediaFeatureGT.GT && t !== exports.MediaFeatureGT.GT_OR_EQ)) return !1;
        if (!(e !== exports.MediaFeatureGT.GT && e !== exports.MediaFeatureGT.GT_OR_EQ || t !== exports.MediaFeatureLT.LT && t !== exports.MediaFeatureLT.LT_OR_EQ)) return !1;
    }
    return new MediaFeatureRangeValueNameValue(p, l, n, h, s);
}
class MediaFeature {
    type = exports.NodeType.MediaFeature;
    feature;
    before;
    after;
    constructor(e, t = [], i = []){
        this.feature = e, this.before = t, this.after = i;
    }
    getName() {
        return this.feature.getName();
    }
    getNameToken() {
        return this.feature.getNameToken();
    }
    tokens() {
        return [
            ...this.before,
            ...this.feature.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.feature.toString() + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.before[0]);
    }
    indexOf(e) {
        return e === this.feature ? "feature" : -1;
    }
    at(e) {
        if ("feature" === e) return this.feature;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.feature,
            parent: this,
            state: i
        }, "feature") && ("walk" in this.feature ? this.feature.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            feature: this.feature.toJSON(),
            before: this.before,
            after: this.after
        };
    }
    isMediaFeature() {
        return MediaFeature.isMediaFeature(this);
    }
    static isMediaFeature(e) {
        return !!e && e instanceof MediaFeature && e.type === exports.NodeType.MediaFeature;
    }
}
function parseMediaFeature(e, t = [], a = []) {
    if (!i.isTokenOpenParen(e.startToken)) return !1;
    const r = parseMediaFeatureBoolean(e.value);
    if (!1 !== r) return new MediaFeature(r, t, a);
    const n = parseMediaFeaturePlain(e.value);
    if (!1 !== n) return new MediaFeature(n, t, a);
    const s = parseMediaFeatureRange(e.value);
    return !1 !== s && new MediaFeature(s, t, a);
}
class MediaNot {
    type = exports.NodeType.MediaNot;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    hasLeadingSpace() {
        return this.modifier.length ? i.isTokenWhiteSpaceOrComment(this.modifier[0]) : this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaNot() {
        return MediaNot.isMediaNot(this);
    }
    static isMediaNot(e) {
        return !!e && e instanceof MediaNot && e.type === exports.NodeType.MediaNot;
    }
}
class MediaOr {
    type = exports.NodeType.MediaOr;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaOr() {
        return MediaOr.isMediaOr(this);
    }
    static isMediaOr(e) {
        return !!e && e instanceof MediaOr && e.type === exports.NodeType.MediaOr;
    }
}
function modifierFromToken(e) {
    if (!i.isTokenIdent(e)) return !1;
    switch(e[4].value.toLowerCase()){
        case exports.MediaQueryModifier.Not:
            return exports.MediaQueryModifier.Not;
        case exports.MediaQueryModifier.Only:
            return exports.MediaQueryModifier.Only;
        default:
            return !1;
    }
}
function parseMediaQuery(e) {
    {
        const t = parseMediaCondition(e);
        if (!1 !== t) return new MediaQueryWithoutType(t);
    }
    {
        let a = -1, r = -1, n = -1;
        for(let s = 0; s < e.length; s++){
            const o = e[s];
            if (!t.isWhitespaceNode(o) && !t.isCommentNode(o)) {
                if (t.isTokenNode(o)) {
                    const t = o.value;
                    if (-1 === a && i.isTokenIdent(t) && modifierFromToken(t)) {
                        a = s;
                        continue;
                    }
                    if (-1 === r && i.isTokenIdent(t) && !modifierFromToken(t)) {
                        r = s;
                        continue;
                    }
                    if (-1 === n && i.isTokenIdent(t) && d.test(t[4].value)) {
                        n = s;
                        if (!1 === parseMediaConditionWithoutOr(e.slice(s + 1))) return !1;
                        break;
                    }
                    return !1;
                }
                return !1;
            }
        }
        let s = [], o = [];
        -1 !== a ? (s = e.slice(0, a + 1).flatMap((e)=>e.tokens()), -1 !== r && (o = e.slice(a + 1, r + 1).flatMap((e)=>e.tokens()))) : -1 !== r && (o = e.slice(0, r + 1).flatMap((e)=>e.tokens()));
        const u = parseMediaConditionWithoutOr(e.slice(Math.max(a, r, n) + 1));
        return !1 === u ? new MediaQueryWithType(s, [
            ...o,
            ...e.slice(r + 1).flatMap((e)=>e.tokens())
        ]) : new MediaQueryWithType(s, o, e.slice(r + 1, n + 1).flatMap((e)=>e.tokens()), u);
    }
}
function parseMediaConditionListWithOr(e) {
    let i = !1;
    const a = [];
    let r = -1, n = -1;
    for(let s = 0; s < e.length; s++){
        if (i) {
            const t = parseMediaOr(e.slice(s));
            if (!1 !== t) {
                s += t.advance, a.push(t.node), n = s;
                continue;
            }
        }
        const o = e[s];
        if (o.type !== t.ComponentValueType.Whitespace && o.type !== t.ComponentValueType.Comment) {
            if (i) return !1;
            if (!1 !== i || !t.isSimpleBlockNode(o)) return !1;
            if (o.normalize(), i = parseMediaInParensFromSimpleBlock(o), !1 === i) return !1;
            r = s;
        }
    }
    return !(!i || !a.length) && new MediaConditionListWithOr(i, a, e.slice(0, r).flatMap((e)=>e.tokens()), e.slice(n + 1).flatMap((e)=>e.tokens()));
}
function parseMediaConditionListWithAnd(e) {
    let i = !1;
    const a = [];
    let r = -1, n = -1;
    for(let s = 0; s < e.length; s++){
        if (i) {
            const t = parseMediaAnd(e.slice(s));
            if (!1 !== t) {
                s += t.advance, a.push(t.node), n = s;
                continue;
            }
        }
        const o = e[s];
        if (o.type !== t.ComponentValueType.Whitespace && o.type !== t.ComponentValueType.Comment) {
            if (i) return !1;
            if (!1 !== i || !t.isSimpleBlockNode(o)) return !1;
            if (o.normalize(), i = parseMediaInParensFromSimpleBlock(o), !1 === i) return !1;
            r = s;
        }
    }
    return !(!i || !a.length) && new MediaConditionListWithAnd(i, a, e.slice(0, r).flatMap((e)=>e.tokens()), e.slice(n + 1).flatMap((e)=>e.tokens()));
}
function parseMediaCondition(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaConditionListWithOr(e);
    if (!1 !== a) return new MediaCondition(a);
    const r = parseMediaInParens(e);
    return !1 !== r && new MediaCondition(r);
}
function parseMediaConditionWithoutOr(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaInParens(e);
    return !1 !== a && new MediaCondition(a);
}
function parseMediaInParens(e) {
    let a = -1;
    for(let i = 0; i < e.length; i++){
        const r = e[i];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (!t.isSimpleBlockNode(r)) return !1;
            if (-1 !== a) return !1;
            a = i;
        }
    }
    if (-1 === a) return !1;
    const r = e[a];
    if (!i.isTokenOpenParen(r.startToken)) return !1;
    r.normalize();
    const n = [
        ...e.slice(0, a).flatMap((e)=>e.tokens()),
        r.startToken
    ], s = [
        r.endToken,
        ...e.slice(a + 1).flatMap((e)=>e.tokens())
    ], o = parseMediaFeature(r, n, s);
    if (!1 !== o) return new MediaInParens(o);
    const u = parseMediaCondition(r.value);
    return !1 !== u ? new MediaInParens(u, n, s) : new MediaInParens(new GeneralEnclosed(r), e.slice(0, a).flatMap((e)=>e.tokens()), e.slice(a + 1).flatMap((e)=>e.tokens()));
}
function parseMediaInParensFromSimpleBlock(e) {
    if (!i.isTokenOpenParen(e.startToken)) return !1;
    const t = parseMediaFeature(e, [
        e.startToken
    ], [
        e.endToken
    ]);
    if (!1 !== t) return new MediaInParens(t);
    const a = parseMediaCondition(e.value);
    return !1 !== a ? new MediaInParens(a, [
        e.startToken
    ], [
        e.endToken
    ]) : new MediaInParens(new GeneralEnclosed(e));
}
exports.MediaQueryModifier = void 0, (s = exports.MediaQueryModifier || (exports.MediaQueryModifier = {})).Not = "not", s.Only = "only";
const o = /^not$/i;
function parseMediaNot(e) {
    let i = !1, a = null;
    for(let r = 0; r < e.length; r++){
        const n = e[r];
        if (n.type !== t.ComponentValueType.Whitespace && n.type !== t.ComponentValueType.Comment) {
            if (isIdent(n)) {
                const e = n.value;
                if (o.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (!i || !t.isSimpleBlockNode(n)) return !1;
            {
                n.normalize();
                const t = parseMediaInParensFromSimpleBlock(n);
                if (!1 === t) return !1;
                a = new MediaNot(e.slice(0, r).flatMap((e)=>e.tokens()), t);
            }
        }
    }
    return a || !1;
}
const u = /^or$/i;
function parseMediaOr(e) {
    let i = !1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (isIdent(r)) {
                const e = r.value;
                if (u.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (i && t.isSimpleBlockNode(r)) {
                r.normalize();
                const t = parseMediaInParensFromSimpleBlock(r);
                return !1 !== t && {
                    advance: a,
                    node: new MediaOr(e.slice(0, a).flatMap((e)=>e.tokens()), t)
                };
            }
            return !1;
        }
    }
    return !1;
}
const d = /^and$/i;
function parseMediaAnd(e) {
    let i = !1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (isIdent(r)) {
                const e = r.value;
                if (d.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (i && t.isSimpleBlockNode(r)) {
                r.normalize();
                const t = parseMediaInParensFromSimpleBlock(r);
                return !1 !== t && {
                    advance: a,
                    node: new MediaAnd(e.slice(0, a).flatMap((e)=>e.tokens()), t)
                };
            }
            return !1;
        }
    }
    return !1;
}
function parseFromTokens(e, i) {
    const a = t.parseCommaSeparatedListOfComponentValues(e, {
        onParseError: i?.onParseError
    });
    return a.map((e, t)=>{
        const r = parseMediaQuery(e);
        return !1 === r && !0 === i?.preserveInvalidMediaQueries ? new MediaQueryInvalid(a[t]) : r;
    }).filter((e)=>!!e);
}
class CustomMedia {
    type = exports.NodeType.CustomMedia;
    name;
    mediaQueryList = null;
    trueOrFalseKeyword = null;
    constructor(e, t, i){
        this.name = e, this.mediaQueryList = t, this.trueOrFalseKeyword = i ?? null;
    }
    getName() {
        for(let e = 0; e < this.name.length; e++){
            const t = this.name[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    getNameToken() {
        for(let e = 0; e < this.name.length; e++){
            const t = this.name[e];
            if (i.isTokenIdent(t)) return t;
        }
        return null;
    }
    hasMediaQueryList() {
        return !!this.mediaQueryList;
    }
    hasTrueKeyword() {
        if (!this.trueOrFalseKeyword) return !1;
        for(let e = 0; e < this.trueOrFalseKeyword.length; e++){
            const t = this.trueOrFalseKeyword[e];
            if (!i.isTokenWhiteSpaceOrComment(t)) return !!i.isTokenIdent(t) && "true" === t[4].value.toLowerCase();
        }
        return !1;
    }
    hasFalseKeyword() {
        if (!this.trueOrFalseKeyword) return !1;
        for(let e = 0; e < this.trueOrFalseKeyword.length; e++){
            const t = this.trueOrFalseKeyword[e];
            if (!i.isTokenWhiteSpaceOrComment(t)) return !!i.isTokenIdent(t) && "false" === t[4].value.toLowerCase();
        }
        return !1;
    }
    tokens() {
        if (this.trueOrFalseKeyword) return [
            ...this.name,
            ...this.trueOrFalseKeyword
        ];
        if (!this.mediaQueryList) return [
            ...this.name
        ];
        const e = [];
        for(let t = 0; t < this.mediaQueryList.length; t++){
            const a = this.mediaQueryList[t];
            0 !== t && e.push([
                i.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]), e.push(...a.tokens());
        }
        return [
            ...this.name,
            ...e
        ];
    }
    toString() {
        return i.stringify(...this.tokens());
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            nameValue: this.getName(),
            name: this.name,
            hasFalseKeyword: this.hasFalseKeyword(),
            hasTrueKeyword: this.hasTrueKeyword(),
            trueOrFalseKeyword: this.trueOrFalseKeyword,
            mediaQueryList: this.mediaQueryList?.map((e)=>e.toJSON())
        };
    }
    isCustomMedia() {
        return CustomMedia.isCustomMedia(this);
    }
    static isCustomMedia(e) {
        return !!e && e instanceof CustomMedia && e.type === exports.NodeType.CustomMedia;
    }
}
function parseCustomMediaFromTokens(e, t) {
    let a = [], r = e;
    for(let t = 0; t < e.length; t++)if (!i.isTokenWhiteSpaceOrComment(e[t])) {
        if (i.isTokenIdent(e[t])) {
            if (e[t][4].value.startsWith("--")) {
                a = e.slice(0, t + 1), r = e.slice(t + 1);
                break;
            }
        }
        return !1;
    }
    let n = !0;
    for(let e = 0; e < r.length; e++)if (!i.isTokenWhiteSpaceOrComment(r[e])) {
        if (i.isTokenIdent(r[e])) {
            const t = r[e][4].value.toLowerCase();
            if ("false" === t) continue;
            if ("true" === t) continue;
        }
        if (i.isTokenEOF(r[e])) break;
        n = !1;
    }
    return n ? new CustomMedia(a, null, r) : new CustomMedia(a, parseFromTokens(i.cloneTokens(r), t));
}
function isMediaConditionListWithAnd(e) {
    return MediaConditionListWithAnd.isMediaConditionListWithAnd(e);
}
function isMediaConditionListWithOr(e) {
    return MediaConditionListWithOr.isMediaConditionListWithOr(e);
}
function isMediaFeatureRangeNameValue(e) {
    return MediaFeatureRangeNameValue.isMediaFeatureRangeNameValue(e);
}
function isMediaFeatureRangeValueName(e) {
    return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(e);
}
function isMediaFeatureRangeValueNameValue(e) {
    return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(e);
}
function isMediaQueryWithType(e) {
    return MediaQueryWithType.isMediaQueryWithType(e);
}
function isMediaQueryWithoutType(e) {
    return MediaQueryWithoutType.isMediaQueryWithoutType(e);
}
function isMediaQueryInvalid(e) {
    return MediaQueryInvalid.isMediaQueryInvalid(e);
}
var l;
exports.MediaType = void 0, (l = exports.MediaType || (exports.MediaType = {})).All = "all", l.Print = "print", l.Screen = "screen", l.Tty = "tty", l.Tv = "tv", l.Projection = "projection", l.Handheld = "handheld", l.Braille = "braille", l.Embossed = "embossed", l.Aural = "aural", l.Speech = "speech", exports.CustomMedia = CustomMedia, exports.GeneralEnclosed = GeneralEnclosed, exports.MediaAnd = MediaAnd, exports.MediaCondition = MediaCondition, exports.MediaConditionListWithAnd = MediaConditionListWithAnd, exports.MediaConditionListWithOr = MediaConditionListWithOr, exports.MediaFeature = MediaFeature, exports.MediaFeatureBoolean = MediaFeatureBoolean, exports.MediaFeatureName = MediaFeatureName, exports.MediaFeaturePlain = MediaFeaturePlain, exports.MediaFeatureRangeNameValue = MediaFeatureRangeNameValue, exports.MediaFeatureRangeValueName = MediaFeatureRangeValueName, exports.MediaFeatureRangeValueNameValue = MediaFeatureRangeValueNameValue, exports.MediaFeatureValue = MediaFeatureValue, exports.MediaInParens = MediaInParens, exports.MediaNot = MediaNot, exports.MediaOr = MediaOr, exports.MediaQueryInvalid = MediaQueryInvalid, exports.MediaQueryWithType = MediaQueryWithType, exports.MediaQueryWithoutType = MediaQueryWithoutType, exports.cloneMediaQuery = function cloneMediaQuery(e) {
    const t = i.cloneTokens(e.tokens()), a = parseFromTokens(t, {
        preserveInvalidMediaQueries: !0
    })[0];
    if (!a) throw new Error(`Failed to clone media query for : "${i.stringify(...t)}"`);
    if (isMediaQueryInvalid(e) && isMediaQueryInvalid(a)) return a;
    if (isMediaQueryWithType(e) && isMediaQueryWithType(a)) return a;
    if (isMediaQueryWithoutType(e) && isMediaQueryWithoutType(a)) return a;
    throw new Error(`Failed to clone media query for : "${i.stringify(...t)}"`);
}, exports.comparisonFromTokens = comparisonFromTokens, exports.invertComparison = function invertComparison(e) {
    switch(e){
        case exports.MediaFeatureEQ.EQ:
            return exports.MediaFeatureEQ.EQ;
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureGT.GT;
        case exports.MediaFeatureLT.LT_OR_EQ:
            return exports.MediaFeatureGT.GT_OR_EQ;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureLT.LT;
        case exports.MediaFeatureGT.GT_OR_EQ:
            return exports.MediaFeatureLT.LT_OR_EQ;
        default:
            return !1;
    }
}, exports.isCustomMedia = function isCustomMedia(e) {
    return CustomMedia.isCustomMedia(e);
}, exports.isGeneralEnclosed = function isGeneralEnclosed(e) {
    return GeneralEnclosed.isGeneralEnclosed(e);
}, exports.isMediaAnd = function isMediaAnd(e) {
    return MediaAnd.isMediaAnd(e);
}, exports.isMediaCondition = function isMediaCondition(e) {
    return MediaCondition.isMediaCondition(e);
}, exports.isMediaConditionList = function isMediaConditionList(e) {
    return isMediaConditionListWithAnd(e) || isMediaConditionListWithOr(e);
}, exports.isMediaConditionListWithAnd = isMediaConditionListWithAnd, exports.isMediaConditionListWithOr = isMediaConditionListWithOr, exports.isMediaFeature = function isMediaFeature(e) {
    return MediaFeature.isMediaFeature(e);
}, exports.isMediaFeatureBoolean = function isMediaFeatureBoolean(e) {
    return MediaFeatureBoolean.isMediaFeatureBoolean(e);
}, exports.isMediaFeatureName = function isMediaFeatureName(e) {
    return MediaFeatureName.isMediaFeatureName(e);
}, exports.isMediaFeaturePlain = function isMediaFeaturePlain(e) {
    return MediaFeaturePlain.isMediaFeaturePlain(e);
}, exports.isMediaFeatureRange = function isMediaFeatureRange(e) {
    return isMediaFeatureRangeNameValue(e) || isMediaFeatureRangeValueName(e) || isMediaFeatureRangeValueNameValue(e);
}, exports.isMediaFeatureRangeNameValue = isMediaFeatureRangeNameValue, exports.isMediaFeatureRangeValueName = isMediaFeatureRangeValueName, exports.isMediaFeatureRangeValueNameValue = isMediaFeatureRangeValueNameValue, exports.isMediaFeatureValue = function isMediaFeatureValue(e) {
    return MediaFeatureValue.isMediaFeatureValue(e);
}, exports.isMediaInParens = function isMediaInParens(e) {
    return MediaInParens.isMediaInParens(e);
}, exports.isMediaNot = function isMediaNot(e) {
    return MediaNot.isMediaNot(e);
}, exports.isMediaOr = function isMediaOr(e) {
    return MediaOr.isMediaOr(e);
}, exports.isMediaQuery = function isMediaQuery(e) {
    return isMediaQueryWithType(e) || isMediaQueryWithoutType(e) || isMediaQueryInvalid(e);
}, exports.isMediaQueryInvalid = isMediaQueryInvalid, exports.isMediaQueryWithType = isMediaQueryWithType, exports.isMediaQueryWithoutType = isMediaQueryWithoutType, exports.matchesComparison = matchesComparison, exports.matchesRatio = matchesRatio, exports.matchesRatioExactly = matchesRatioExactly, exports.modifierFromToken = modifierFromToken, exports.newMediaFeatureBoolean = function newMediaFeatureBoolean(e) {
    const a = [
        i.TokenType.Ident,
        "",
        -1,
        -1,
        {
            value: ""
        }
    ];
    return i.mutateIdent(a, e), new MediaFeature(new MediaFeatureBoolean(new MediaFeatureName(new t.TokenNode(a))), [
        [
            i.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ]
    ], [
        [
            i.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]
    ]);
}, exports.newMediaFeaturePlain = function newMediaFeaturePlain(e, ...a) {
    const r = [
        i.TokenType.Ident,
        "",
        -1,
        -1,
        {
            value: ""
        }
    ];
    i.mutateIdent(r, e);
    const n = t.parseListOfComponentValues(a);
    return new MediaFeature(new MediaFeaturePlain(new MediaFeatureName(new t.TokenNode(r)), [
        i.TokenType.Colon,
        ":",
        -1,
        -1,
        void 0
    ], new MediaFeatureValue(1 === n.length ? n[0] : n)), [
        [
            i.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ]
    ], [
        [
            i.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]
    ]);
}, exports.parse = function parse(e, t) {
    return parseFromTokens(i.tokenize({
        css: e
    }, {
        onParseError: t?.onParseError
    }), t);
}, exports.parseCustomMedia = function parseCustomMedia(e, t) {
    return parseCustomMediaFromTokens(i.tokenize({
        css: e
    }, {
        onParseError: t?.onParseError
    }), t);
}, exports.parseCustomMediaFromTokens = parseCustomMediaFromTokens, exports.parseFromTokens = parseFromTokens, exports.typeFromToken = function typeFromToken(e) {
    if (!i.isTokenIdent(e)) return !1;
    switch(e[4].value.toLowerCase()){
        case exports.MediaType.All:
            return exports.MediaType.All;
        case exports.MediaType.Print:
            return exports.MediaType.Print;
        case exports.MediaType.Screen:
            return exports.MediaType.Screen;
        case exports.MediaType.Tty:
            return exports.MediaType.Tty;
        case exports.MediaType.Tv:
            return exports.MediaType.Tv;
        case exports.MediaType.Projection:
            return exports.MediaType.Projection;
        case exports.MediaType.Handheld:
            return exports.MediaType.Handheld;
        case exports.MediaType.Braille:
            return exports.MediaType.Braille;
        case exports.MediaType.Embossed:
            return exports.MediaType.Embossed;
        case exports.MediaType.Aural:
            return exports.MediaType.Aural;
        case exports.MediaType.Speech:
            return exports.MediaType.Speech;
        default:
            return !1;
    }
};
}}),
"[project]/node_modules/@csstools/postcss-normalize-display-values/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), l = new Map([
    [
        "block,flex",
        "flex"
    ],
    [
        "block,flow",
        "block"
    ],
    [
        "block,flow-root",
        "flow-root"
    ],
    [
        "block,grid",
        "grid"
    ],
    [
        "block,table",
        "table"
    ],
    [
        "inline,flex",
        "inline-flex"
    ],
    [
        "inline,flow",
        "inline"
    ],
    [
        "inline,flow,list-item",
        "inline list-item"
    ],
    [
        "inline,flow-root",
        "inline-block"
    ],
    [
        "inline,grid",
        "inline-grid"
    ],
    [
        "inline,ruby",
        "ruby"
    ],
    [
        "inline,table",
        "inline-table"
    ],
    [
        "list-item,block,flow",
        "list-item"
    ],
    [
        "ruby-base,flow",
        "ruby-base"
    ],
    [
        "ruby-text,flow",
        "ruby-text"
    ],
    [
        "run-in,flow",
        "run-in"
    ],
    [
        "table-caption,flow",
        "table-caption"
    ],
    [
        "table-cell,flow",
        "table-cell"
    ]
]);
function transform(n) {
    if (!n.trim()) return n;
    const { nodes: i } = e(n);
    if (i.length <= 1) return n;
    const t = i.filter((e)=>"word" === e.type).map((e)=>e.value.toLowerCase());
    if (t.length <= 1) return n;
    const o = l.get(t.join(","));
    return o || n;
}
const n = /^display$/i, creator = (e)=>{
    const l = !("preserve" in Object(e)) || Boolean(e?.preserve);
    return {
        postcssPlugin: "postcss-normalize-display-values",
        Declaration (e) {
            if (!n.test(e.prop)) return;
            const i = e.value;
            if (!i) return;
            const t = transform(i);
            e.value !== t && (e.cloneBefore({
                value: t
            }), l || e.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-exponential-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:exp|hypot|log|pow|sqrt)\(/i, creator = (t)=>{
    const o = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-exponential-functions",
        Declaration (t) {
            if (!s.test(t.value)) return;
            const c = e.calc(t.value);
            c !== t.value && (t.cloneBefore({
                value: c
            }), o.preserve || t.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-float-and-clear/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const t = "inline-start", o = "inline-end";
var e, i;
function directionFlowToAxes(t) {
    switch(t){
        case e.TopToBottom:
            return [
                i.Top,
                i.Bottom
            ];
        case e.BottomToTop:
            return [
                i.Bottom,
                i.Top
            ];
        case e.RightToLeft:
            return [
                i.Right,
                i.Left
            ];
        case e.LeftToRight:
            return [
                i.Left,
                i.Right
            ];
    }
}
function cloneDeclaration(t, o, e) {
    t.parent && t.parent.some((t)=>"decl" == t.type && t.prop === e && t.value === o) || t.cloneBefore({
        value: o,
        prop: e
    });
}
!function(t) {
    t.TopToBottom = "top-to-bottom", t.BottomToTop = "bottom-to-top", t.RightToLeft = "right-to-left", t.LeftToRight = "left-to-right";
}(e || (e = {})), function(t) {
    t.Top = "top", t.Right = "right", t.Bottom = "bottom", t.Left = "left";
}(i || (i = {}));
const creator = (i)=>{
    const n = Object.assign({
        inlineDirection: e.LeftToRight
    }, i), c = Object.values(e);
    if (!c.includes(n.inlineDirection)) throw new Error(`[postcss-logical-float-and-clear] "inlineDirection" must be one of ${c.join(", ")}`);
    if (![
        e.LeftToRight,
        e.RightToLeft
    ].includes(n.inlineDirection)) return {
        postcssPlugin: "postcss-logical-float-and-clear",
        Once () {}
    };
    const [r, l] = directionFlowToAxes(n.inlineDirection), makeTransform = (e)=>{
        const i = e.value.toLowerCase();
        if (![
            t,
            o
        ].includes(i)) return;
        cloneDeclaration(e, i === t ? r : l, e.prop), e.remove();
    };
    return {
        postcssPlugin: "postcss-logical-float-and-clear",
        Declaration: {
            float: makeTransform,
            clear: makeTransform
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-font-format-keywords/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const o = [
    "woff",
    "truetype",
    "opentype",
    "woff2",
    "embedded-opentype",
    "collection",
    "svg"
], creator = (r)=>{
    const s = "preserve" in Object(r) && Boolean(r?.preserve);
    return {
        postcssPlugin: "postcss-font-format-keywords",
        Declaration (r) {
            if ("src" !== r.prop.toLowerCase()) return;
            if (!r.value.toLowerCase().includes("format(")) return;
            if (t.hasFallback(r)) return;
            const a = r.parent;
            if (!a || "atrule" !== a.type) return;
            if ("font-face" !== a.name.toLowerCase()) return;
            const n = e(r.value);
            n.walk((t)=>{
                "function" === t.type && "format" === t.value.toLowerCase() && t.nodes.forEach((t)=>{
                    "word" === t.type && o.includes(t.value.toLowerCase()) && (t.value = e.stringify({
                        type: "string",
                        value: t.value,
                        quote: '"'
                    }));
                });
            }), n.toString() !== r.value && (r.cloneBefore({
                value: n.toString()
            }), s || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-gamut-mapping/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)");
const t = /\bcolor-gamut\b/i;
function hasConditionalAncestor(e) {
    let o = e.parent;
    for(; o;)if ("atrule" === o.type) {
        if ("media" === o.name.toLowerCase() && t.test(o.params)) return !0;
        o = o.parent;
    } else o = o.parent;
    return !1;
}
function sameProperty(e) {
    const o = e.prop.toLowerCase(), a = [], t = e.parent?.nodes ?? [];
    for(let e = 0; e < t.length; e++){
        const s = t[e];
        "decl" === s.type && s.prop.toLowerCase() === o && a.push(s);
    }
    return a;
}
const s = /\b(?:color|lab|lch|oklab|oklch)\(/i, n = /^(?:color|lab|lch|oklab|oklch)$/i, creator = ()=>({
        postcssPlugin: "postcss-gamut-mapping",
        prepare () {
            const t = new WeakMap, r = new WeakSet;
            return {
                postcssPlugin: "postcss-gamut-mapping",
                OnceExit (i, { postcss: l }) {
                    i.walkDecls((i)=>{
                        if (r.has(i)) return;
                        if (!s.test(i.value)) return;
                        if (!i.parent || hasConditionalAncestor(i)) return;
                        const c = sameProperty(i).map((t, s)=>{
                            r.add(t);
                            let i = !1;
                            const l = t.value, c = o.replaceComponentValues(o.parseCommaSeparatedListOfComponentValues(e.tokenize({
                                css: l
                            })), (e)=>{
                                if (!o.isFunctionNode(e) || !n.test(e.getName())) return;
                                const t = a.color(e);
                                return !t || t.syntaxFlags.has(a.SyntaxFlag.HasNoneKeywords) || a.colorDataFitsRGB_Gamut(t) ? void 0 : (i || a.colorDataFitsDisplayP3_Gamut(t) || (i = !0), a.serializeRGB(t, !0));
                            }), p = o.stringify(c);
                            return {
                                isRec2020: i,
                                matchesOriginal: p === l,
                                modifiedValue: p,
                                hasFallback: s > 0,
                                item: t
                            };
                        }), p = [];
                        c.reverse();
                        for (const e of c){
                            if (e.matchesOriginal) break;
                            p.push(e);
                        }
                        p.reverse(), p.forEach(({ isRec2020: e, modifiedValue: o, hasFallback: a, item: s })=>{
                            const n = s.parent;
                            if (!n) return;
                            const i = t.get(n) || {
                                conditionalRules: [],
                                propNames: new Set,
                                lastConditionParams: {
                                    media: void 0
                                },
                                lastConditionalRule: void 0
                            };
                            t.set(n, i);
                            const c = `(color-gamut: ${e ? "rec2020" : "p3"})`;
                            if (i.lastConditionParams.media !== c && (i.lastConditionalRule = void 0), !a) {
                                const e = s.cloneBefore({
                                    value: o
                                });
                                r.add(e);
                            }
                            if (i.lastConditionalRule) {
                                const e = s.clone();
                                return i.lastConditionalRule.append(e), r.add(e), void s.remove();
                            }
                            const p = l.atRule({
                                name: "media",
                                params: c,
                                source: n.source,
                                raws: {
                                    before: "\n\n",
                                    after: "\n"
                                }
                            }), u = n.clone();
                            u.removeAll(), u.raws.before = "\n";
                            const d = s.clone();
                            u.append(d), s.remove(), r.add(d), i.lastConditionParams.media = p.params, i.lastConditionalRule = u, p.append(u), i.conditionalRules.push(p);
                        });
                    }), i.walk((e)=>{
                        const o = t.get(e);
                        o && 0 !== o.conditionalRules.length && o.conditionalRules.reverse().forEach((o)=>{
                            e.after(o);
                        });
                    });
                }
            };
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-gradients-interpolation-method/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)");
const s = /(?:repeating-)?(?:linear|radial|conic)-gradient\(/i, r = /\bin\b/i, a = {
    test: (e)=>s.test(e) && r.test(e)
}, l = /^(repeating-)?(linear|radial|conic)-gradient$/i;
function interpolateColorsInColorStopsList(e, o, s, r = !1) {
    const a = [], l = [];
    for(let r = 0; r < e.length - 1; r++){
        const a = e[r], c = e[r + 1];
        if (l.push(a), s || n.serializeP3(a.colorData, !1).toString() !== n.serializeP3(c.colorData, !1).toString() && a.position.toString() !== c.position.toString()) for(let e = 1; e <= 9; e++){
            const r = 10 * e;
            let u = [];
            s && (u = [
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                s,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Ident,
                    "hue",
                    -1,
                    -1,
                    {
                        value: "hue"
                    }
                ])
            ]);
            const p = new t.FunctionNode([
                i.TokenType.Function,
                "color-mix(",
                -1,
                -1,
                {
                    value: "color-mix"
                }
            ], [
                i.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], [
                new t.TokenNode([
                    i.TokenType.Ident,
                    "in",
                    -1,
                    -1,
                    {
                        value: "in"
                    }
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                o,
                ...u,
                new t.TokenNode([
                    i.TokenType.Comma,
                    ",",
                    -1,
                    -1,
                    void 0
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                a.color,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Percentage,
                    100 - r + "%",
                    -1,
                    -1,
                    {
                        value: 100 - r
                    }
                ]),
                new t.TokenNode([
                    i.TokenType.Comma,
                    ",",
                    -1,
                    -1,
                    void 0
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                c.color,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Percentage,
                    `${r}%`,
                    -1,
                    -1,
                    {
                        value: r
                    }
                ])
            ]), d = n.color(p);
            if (!d) return !1;
            l.push({
                colorData: d
            });
        }
        r === e.length - 2 && l.push(c);
    }
    for(let e = 0; e < l.length; e++)r && !n.colorDataFitsRGB_Gamut(l[e].colorData) ? l[e].color = n.serializeP3(l[e].colorData, !1) : l[e].color = n.serializeRGB(l[e].colorData, !1);
    for(let e = 0; e < l.length; e++){
        const o = l[e];
        o.position ? a.push(o.color, new t.WhitespaceNode([
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]), o.position) : a.push(o.color), e !== l.length - 1 && a.push(new t.TokenNode([
            i.TokenType.Comma,
            ",",
            -1,
            -1,
            void 0
        ]), new t.WhitespaceNode([
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]));
    }
    return a;
}
function parseColorStops(e) {
    const o = [];
    let s = {};
    for(let r = 0; r < e.length; r++){
        const a = e[r];
        if (t.isCommentNode(a) || t.isWhitespaceNode(a)) continue;
        if (t.isTokenNode(a) && i.isTokenComma(a.value)) {
            if (s.color && s.colorData && s.positionA) {
                o.push({
                    color: s.color,
                    colorData: s.colorData,
                    position: s.positionA
                }), s.positionB && o.push({
                    color: s.color,
                    colorData: s.colorData,
                    position: s.positionB
                }), s = {};
                continue;
            }
            return !1;
        }
        const l = n.color(a);
        if (l) {
            if (s.color) return !1;
            if (l.syntaxFlags.has(n.SyntaxFlag.Experimental)) return !1;
            s.color = a, s.colorData = l;
        } else {
            if (!s.color) return !1;
            if (s.positionA) {
                if (!s.positionA || s.positionB) return !1;
                s.positionB = a;
            } else s.positionA = a;
        }
    }
    return !(!s.color || !s.positionA) && (s.color && s.colorData && s.positionA && (o.push({
        color: s.color,
        colorData: s.colorData,
        position: s.positionA
    }), s.positionB && o.push({
        color: s.color,
        colorData: s.colorData,
        position: s.positionB
    })), !(o.length < 2) && o);
}
const c = /^(?:srgb|srgb-linear|lab|oklab|xyz|xyz-d50|xyz-d65|hsl|hwb|lch|oklch)$/i, u = /^(?:hsl|hwb|lch|oklch)$/i, p = /^(?:shorter|longer|increasing|decreasing)$/i, d = /^in$/i, v = /^hue$/i;
function modifyGradientFunctionComponentValues(e, o = !1) {
    const n = e.getName();
    if (!l.test(n)) return !1;
    let s = "srgb", r = null, a = null, h = null, T = null, f = null, m = [];
    {
        let o = 0, n = e.value[o];
        for(; n && !(t.isTokenNode(n) && i.isTokenIdent(n.value) && d.test(n.value[4].value));){
            if (t.isTokenNode(n) && i.isTokenComma(n.value)) return !1;
            o++, n = e.value[o];
        }
        for(r = n, o++, n = e.value[o]; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && c.test(n.value[4].value)) {
            if (a) return !1;
            a = n, s = n.value[4].value, o++, n = e.value[o];
        }
        for(; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && p.test(n.value[4].value) && u.test(s)) {
            if (h || !a) return !1;
            h = n, o++, n = e.value[o];
        }
        for(; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && v.test(n.value[4].value)) {
            if (T || !a || !h) return !1;
            T = n, o++, n = e.value[o];
        }
        for(; n && (!t.isTokenNode(n) || !i.isTokenComma(n.value));)o++, n = e.value[o];
        if (f = n, !f) return !1;
        m = e.value.slice(o + 1);
    }
    if (!a) return !1;
    if (h && !T) return !1;
    if (T && !h) return !1;
    const k = parseColorStops(m);
    if (!k) return !1;
    const g = interpolateColorsInColorStopsList(k, a, h, o);
    if (!g) return !1;
    const N = trim([
        ...e.value.slice(0, e.value.indexOf(r)),
        ...e.value.slice(e.value.indexOf(T || a) + 1, e.value.indexOf(f))
    ]);
    return N.length > 0 && N.some((e)=>!t.isCommentNode(e)) && N.push(new t.TokenNode([
        i.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ]), new t.WhitespaceNode([
        [
            i.TokenType.Whitespace,
            " ",
            -1,
            -1,
            void 0
        ]
    ])), trim([
        ...N,
        ...trim(g)
    ]);
}
function trim(e) {
    let o = 0, i = e.length - 1;
    for(let i = 0; i < e.length; i++)if (!t.isWhitespaceNode(e[i])) {
        o = i;
        break;
    }
    for(let o = e.length - 1; o >= 0; o--)if (!t.isWhitespaceNode(e[o])) {
        i = o;
        break;
    }
    return e.slice(o, i + 1);
}
const basePlugin = (e)=>({
        postcssPlugin: "postcss-gradients-interpolation-method",
        Declaration (n) {
            if (!a.test(n.value)) return;
            if (o.hasFallback(n)) return;
            if (o.hasSupportsAtRuleAncestor(n, a)) return;
            const s = i.tokenize({
                css: n.value
            }), r = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(s), (e)=>{
                if (!t.isFunctionNode(e)) return;
                const o = modifyGradientFunctionComponentValues(e);
                o && (e.value = o);
            }));
            if (r === n.value) return;
            const l = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(s), (e)=>{
                if (!t.isFunctionNode(e)) return;
                const o = modifyGradientFunctionComponentValues(e, !0);
                o && (e.value = o);
            }));
            n.cloneBefore({
                value: r
            }), r !== l && n.cloneBefore({
                value: l
            }), e?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (o)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, o);
    return t.enableProgressiveCustomProperties ? {
        postcssPlugin: "postcss-gradients-interpolation-method",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-hwb-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bhwb\(/i, n = /^hwb$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-hwb-function",
        Declaration (i) {
            const c = i.value;
            if (!a.test(c)) return;
            if (t.hasFallback(i)) return;
            if (t.hasSupportsAtRuleAncestor(i, a)) return;
            const l = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: c
            })), (s)=>{
                if (!r.isFunctionNode(s) || !n.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), u = r.stringify(l);
            u !== c && (i.cloneBefore({
                value: u
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-hwb-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-ic-unit/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const t = /ic\b/i, o = /\(font-size: \d+ic\)/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-ic-unit",
        Declaration (i) {
            if (!t.test(i.value)) return;
            if (r.hasFallback(i)) return;
            if (r.hasSupportsAtRuleAncestor(i, o)) return;
            const u = e(i.value);
            u.walk((s)=>{
                if (!s.type || "word" !== s.type) return;
                const r = e.unit(s.value);
                r && "ic" === r.unit.toLowerCase() && (s.value = `${r.number}em`);
            });
            const c = String(u);
            c !== i.value && (i.cloneBefore({
                value: c
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return r.enableProgressiveCustomProperties && r.preserve ? {
        postcssPlugin: "postcss-ic-unit",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-is-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
function alwaysValidSelector(s) {
    const o = e().astSync(s);
    let n = !0;
    return o.walk((e)=>{
        if ("class" !== e.type && "comment" !== e.type && "id" !== e.type && "root" !== e.type && "selector" !== e.type && "string" !== e.type && "tag" !== e.type && "universal" !== e.type && ("attribute" !== e.type || e.insensitive) && ("combinator" !== e.type || "+" !== e.value && ">" !== e.value && "~" !== e.value && " " !== e.value) && ("pseudo" !== e.type || e.nodes?.length || ":hover" !== e.value.toLowerCase() && ":focus" !== e.value.toLowerCase())) {
            if ("pseudo" === e.type && 1 === e.nodes?.length && ":not" === e.value.toLowerCase()) {
                let s = !0;
                if (e.nodes[0].walkCombinators(()=>{
                    s = !1;
                }), s) return;
            }
            return n = !1, !1;
        }
    }), n;
}
function sortCompoundSelectorsInsideComplexSelector(s) {
    if (!s || !s.nodes || 1 === s.nodes.length) return;
    const o = [];
    let n = [];
    for(let t = 0; t < s.nodes.length; t++)"combinator" !== s.nodes[t].type ? e.isPseudoElement(s.nodes[t]) ? (o.push(n), n = [
        s.nodes[t]
    ]) : n.push(s.nodes[t]) : (o.push(n), o.push([
        s.nodes[t]
    ]), n = []);
    o.push(n);
    const t = [];
    for(let e = 0; e < o.length; e++){
        const s = o[e];
        s.sort((e, s)=>"selector" === e.type && "selector" === s.type && e.nodes.length && s.nodes.length ? selectorTypeOrder(e.nodes[0], e.nodes[0].type) - selectorTypeOrder(s.nodes[0], s.nodes[0].type) : "selector" === e.type && e.nodes.length ? selectorTypeOrder(e.nodes[0], e.nodes[0].type) - selectorTypeOrder(s, s.type) : "selector" === s.type && s.nodes.length ? selectorTypeOrder(e, e.type) - selectorTypeOrder(s.nodes[0], s.nodes[0].type) : selectorTypeOrder(e, e.type) - selectorTypeOrder(s, s.type));
        const n = new Set(s.map((e)=>e.type)), r = n.has("universal") && (n.has("tag") || n.has("attribute") || n.has("class") || n.has("id") || n.has("pseudo"));
        for(let e = 0; e < s.length; e++)"universal" === s[e].type && r ? s[e].remove() : t.push(s[e]);
    }
    s.removeAll();
    for(let o = t.length - 1; o >= 0; o--){
        const n = t[o - 1];
        if (t[o].remove(), n && "tag" === n.type && "tag" === t[o].type) {
            const n = e.pseudo({
                value: ":is",
                nodes: [
                    e.selector({
                        value: "",
                        nodes: [
                            t[o]
                        ]
                    })
                ]
            });
            n.parent = s, s.nodes.unshift(n);
        } else t[o].parent = s, s.nodes.unshift(t[o]);
    }
}
function selectorTypeOrder(s, n) {
    return e.isPseudoElement(s) ? o.pseudoElement : o[n];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    id: 3,
    class: 4,
    attribute: 5,
    pseudo: 6,
    selector: 7,
    string: 8,
    root: 9,
    comment: 10
};
function childAdjacentChild(e) {
    return !(!e || !e.nodes) && "selector" === e.type && 3 === e.nodes.length && !(!e.nodes[0] || "pseudo" !== e.nodes[0].type || ":-csstools-matches" !== e.nodes[0].value) && !(!e.nodes[1] || "combinator" !== e.nodes[1].type || "+" !== e.nodes[1].value && "~" !== e.nodes[1].value) && !(!e.nodes[2] || "pseudo" !== e.nodes[2].type || ":-csstools-matches" !== e.nodes[2].value) && !(!e.nodes[0].nodes || 1 !== e.nodes[0].nodes.length) && "selector" === e.nodes[0].nodes[0].type && !(!e.nodes[0].nodes[0].nodes || 3 !== e.nodes[0].nodes[0].nodes.length) && !(!e.nodes[0].nodes[0].nodes || "combinator" !== e.nodes[0].nodes[0].nodes[1].type || ">" !== e.nodes[0].nodes[0].nodes[1].value) && !(!e.nodes[2].nodes || 1 !== e.nodes[2].nodes.length) && "selector" === e.nodes[2].nodes[0].type && !(!e.nodes[2].nodes[0].nodes || 3 !== e.nodes[2].nodes[0].nodes.length) && !(!e.nodes[2].nodes[0].nodes || "combinator" !== e.nodes[2].nodes[0].nodes[1].type || ">" !== e.nodes[2].nodes[0].nodes[1].value) && (e.nodes[0].nodes[0].insertAfter(e.nodes[0].nodes[0].nodes[0], e.nodes[2].nodes[0].nodes[0].clone()), e.nodes[2].nodes[0].nodes[1].remove(), e.nodes[2].nodes[0].nodes[0].remove(), e.nodes[0].replaceWith(e.nodes[0].nodes[0]), e.nodes[2].replaceWith(e.nodes[2].nodes[0]), !0);
}
function isInCompoundWithOneOtherElement(s) {
    if (!s || !s.nodes) return !1;
    if (!e.isSelector(s)) return !1;
    if (2 !== s.nodes.length) return !1;
    let o = -1, n = -1;
    s.nodes[0] && e.isPseudoClass(s.nodes[0]) && ":-csstools-matches" === s.nodes[0].value ? (o = 0, n = 1) : s.nodes[1] && e.isPseudoClass(s.nodes[1]) && ":-csstools-matches" === s.nodes[1].value && (o = 1, n = 0);
    const t = s.nodes[o];
    if (!t || !e.isPseudoClass(t) || 1 !== t.nodes.length) return !1;
    const r = s.nodes[n];
    return !!r && !e.isCombinator(r) && !e.isPseudoElement(r) && (t.nodes[0].append(r.clone()), t.replaceWith(...t.nodes[0].nodes), r.remove(), !0);
}
function isPseudoInFirstCompound(s) {
    if (!s || !s.nodes) return !1;
    if (!e.isSelector(s)) return !1;
    let o = -1;
    for(let n = 0; n < s.nodes.length; n++){
        const t = s.nodes[n];
        if (e.isCombinator(t)) return !1;
        if (e.isPseudoElement(t)) return !1;
        if (e.isPseudoClass(t)) {
            const e = t;
            if (":-csstools-matches" === e.value) {
                if (!e.nodes || 1 !== e.nodes.length) return !1;
                o = n;
                break;
            }
        }
    }
    if (-1 === o) return !1;
    const n = s.nodes[o];
    if (!n || !e.isPseudoClass(n)) return !1;
    const t = s.nodes.slice(0, o), r = s.nodes.slice(o + 1);
    return t.forEach((e)=>{
        n.nodes[0].append(e.clone());
    }), r.forEach((e)=>{
        n.nodes[0].append(e.clone());
    }), n.replaceWith(...n.nodes), t.forEach((e)=>{
        e.remove();
    }), r.forEach((e)=>{
        e.remove();
    }), !0;
}
function samePrecedingElement(s) {
    if (!s || !s.nodes) return !1;
    if ("selector" !== s.type) return !1;
    let o = -1;
    for(let n = 0; n < s.nodes.length; n++){
        const t = s.nodes[n];
        if (e.isCombinator(t)) {
            o = n;
            break;
        }
        if (e.isPseudoElement(t)) return !1;
    }
    if (-1 === o) return !1;
    const n = o + 1;
    if (!s.nodes[o] || "combinator" !== s.nodes[o].type || ">" !== s.nodes[o].value && "+" !== s.nodes[o].value) return !1;
    const t = s.nodes[o].value;
    if (!s.nodes[n] || "pseudo" !== s.nodes[n].type || ":-csstools-matches" !== s.nodes[n].value) return !1;
    if (!s.nodes[n].nodes || 1 !== s.nodes[n].nodes.length) return !1;
    if ("selector" !== s.nodes[n].nodes[0].type) return !1;
    if (!s.nodes[n].nodes[0].nodes || 3 !== s.nodes[n].nodes[0].nodes.length) return !1;
    if (!s.nodes[n].nodes[0].nodes || "combinator" !== s.nodes[n].nodes[0].nodes[1].type || s.nodes[n].nodes[0].nodes[1].value !== t) return !1;
    const r = s.nodes[n];
    if (!r || !e.isPseudoClass(r)) return !1;
    const d = s.nodes.slice(0, o), l = s.nodes.slice(n + 1);
    return s.each((e)=>{
        e.remove();
    }), d.forEach((e)=>{
        s.append(e);
    }), r.nodes[0].nodes.forEach((e)=>{
        s.append(e);
    }), l.forEach((e)=>{
        s.append(e);
    }), !0;
}
function complexSelectors(s, o, n, t) {
    return s.flatMap((s)=>{
        if (-1 === s.indexOf(":-csstools-matches") && -1 === s.toLowerCase().indexOf(":is")) return s;
        const r = e().astSync(s);
        return r.walkPseudos((s)=>{
            if (":is" === s.value.toLowerCase() && s.nodes && s.nodes.length && "selector" === s.nodes[0].type && 0 === s.nodes[0].nodes.length) return s.value = ":not", void s.nodes[0].append(e.universal());
            if (":-csstools-matches" === s.value) if (!s.nodes || s.nodes.length) {
                if (s.walkPseudos((s)=>{
                    if (e.isPseudoElement(s)) {
                        let e = s.value;
                        if (e.startsWith("::-csstools-invalid-")) return;
                        for(; e.startsWith(":");)e = e.slice(1);
                        s.value = `::-csstools-invalid-${e}`, t();
                    }
                }), 1 === s.nodes.length && "selector" === s.nodes[0].type) {
                    if (1 === s.nodes[0].nodes.length) return void s.replaceWith(s.nodes[0].nodes[0]);
                    if (!s.nodes[0].some((e)=>"combinator" === e.type)) return void s.replaceWith(...s.nodes[0].nodes);
                }
                1 !== r.nodes.length || "selector" !== r.nodes[0].type || 1 !== r.nodes[0].nodes.length || r.nodes[0].nodes[0] !== s ? childAdjacentChild(s.parent) || isInCompoundWithOneOtherElement(s.parent) || isPseudoInFirstCompound(s.parent) || samePrecedingElement(s.parent) || ("warning" === o.onComplexSelector && n(), s.value = ":is") : s.replaceWith(...s.nodes[0].nodes);
            } else s.remove();
        }), r.walk((e)=>{
            "selector" === e.type && "nodes" in e && 1 === e.nodes.length && "selector" === e.nodes[0].type && e.replaceWith(e.nodes[0]);
        }), r.walk((e)=>{
            "nodes" in e && sortCompoundSelectorsInsideComplexSelector(e);
        }), r.toString();
    }).filter((e)=>!!e);
}
function splitSelectors(o, n, t = 0) {
    const r = ":not(#" + n.specificityMatchingName + ")", d = ":not(." + n.specificityMatchingName + ")", l = ":not(" + n.specificityMatchingName + ")";
    return o.flatMap((o)=>{
        if (-1 === o.toLowerCase().indexOf(":is")) return o;
        let i = !1;
        const a = [];
        if (e().astSync(o).walkPseudos((e)=>{
            if (":is" !== e.value.toLowerCase() || !e.nodes || !e.nodes.length) return;
            if ("selector" === e.nodes[0].type && 0 === e.nodes[0].nodes.length) return;
            if ("pseudo" === e.parent?.parent?.type && ":not" === e.parent?.parent?.value?.toLowerCase()) return void a.push([
                {
                    start: e.parent.parent.sourceIndex,
                    end: e.parent.parent.sourceIndex + e.parent.parent.toString().length,
                    option: `:not(${e.nodes.toString()})`
                }
            ]);
            if ("pseudo" === e.parent?.parent?.type && ":has" === e.parent?.parent?.value?.toLowerCase()) return void (e.value = ":-csstools-matches");
            let o = e.parent;
            for(; o;){
                if (o.value && ":is" === o.value.toLowerCase() && "pseudo" === o.type) return void (i = !0);
                o = o.parent;
            }
            const n = s.selectorSpecificity(e), t = e.sourceIndex, c = t + e.toString().length, u = [];
            e.nodes.forEach((e)=>{
                const o = {
                    start: t,
                    end: c,
                    option: ""
                }, i = s.selectorSpecificity(e);
                let a = e.toString().trim();
                const p = Math.max(0, n.a - i.a), h = Math.max(0, n.b - i.b), f = Math.max(0, n.c - i.c);
                for(let e = 0; e < p; e++)a += r;
                for(let e = 0; e < h; e++)a += d;
                for(let e = 0; e < f; e++)a += l;
                o.option = a, u.push(o);
            }), a.push(u);
        }), !a.length) return [
            o
        ];
        let c = [];
        return cartesianProduct(...a).forEach((e)=>{
            let s = "";
            for(let n = 0; n < e.length; n++){
                const t = e[n];
                s += o.substring(e[n - 1]?.end || 0, e[n].start), s += ":-csstools-matches(" + t.option + ")", n === e.length - 1 && (s += o.substring(e[n].end));
            }
            c.push(s);
        }), i && t < 10 && (c = splitSelectors(c, n, t + 1)), c;
    }).filter((e)=>!!e);
}
function cartesianProduct(...e) {
    const s = [], o = e.length - 1;
    return function helper(n, t) {
        for(let r = 0, d = e[t].length; r < d; r++){
            const d = n.slice(0);
            d.push(e[t][r]), t === o ? s.push(d) : helper(d, t + 1);
        }
    }([], 0), s;
}
const n = /:is\(/i, creator = (e)=>{
    const s = {
        specificityMatchingName: "does-not-exist",
        ...e || {}
    };
    return {
        postcssPlugin: "postcss-is-pseudo-class",
        prepare () {
            const e = new WeakSet;
            return {
                postcssPlugin: "postcss-is-pseudo-class",
                Rule (o, { result: t }) {
                    if (!o.selector) return;
                    if (!n.test(o.selector)) return;
                    if (e.has(o)) return;
                    let r = !1;
                    const warnOnComplexSelector = ()=>{
                        "warning" === s.onComplexSelector && (r || (r = !0, o.warn(t, `Complex selectors in '${o.selector}' can not be transformed to an equivalent selector without ':is()'.`)));
                    };
                    let d = !1;
                    const warnOnPseudoElements = ()=>{
                        "warning" === s.onPseudoElement && (d || (d = !0, o.warn(t, `Pseudo elements are not allowed in ':is()', unable to transform '${o.selector}'`)));
                    };
                    try {
                        let n = !1;
                        const t = [], r = complexSelectors(splitSelectors(o.selectors, {
                            specificityMatchingName: s.specificityMatchingName
                        }), {
                            onComplexSelector: s.onComplexSelector
                        }, warnOnComplexSelector, warnOnPseudoElements);
                        if (Array.from(new Set(r)).forEach((s)=>{
                            if (o.selectors.indexOf(s) > -1) t.push(s);
                            else {
                                if (alwaysValidSelector(s)) return t.push(s), void (n = !0);
                                e.add(o), o.cloneBefore({
                                    selector: s
                                }), n = !0;
                            }
                        }), t.length && n && (e.add(o), o.cloneBefore({
                            selectors: t
                        })), !s.preserve) {
                            if (!n) return;
                            o.remove();
                        }
                    } catch (e) {
                        if (!(e instanceof Error)) throw e;
                        if (e.message.indexOf("call stack size exceeded") > -1) throw e;
                        o.warn(t, `Failed to parse selector "${o.selector}" with error: ${e.message}`);
                    }
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-light-dark-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const s = "--csstools-color-scheme--light", n = "initial";
function toggleNameGenerator(e) {
    return `--csstools-light-dark-toggle--${e}`;
}
const i = /dark/i, a = /light/i;
function colorSchemes(e) {
    const t = o.tokenize({
        css: e
    });
    let r = !1, s = !1;
    return t.forEach((e)=>{
        o.isTokenIdent(e) && (a.test(e[4].value) ? r = !0 : i.test(e[4].value) && (s = !0));
    }), [
        r,
        s
    ];
}
const c = /^light-dark$/i;
function isComma(e) {
    return r.isTokenNode(e) && o.isTokenComma(e.value);
}
function parseLightDark(e) {
    if (!r.isFunctionNode(e) || !c.test(e.getName())) return !1;
    const o = e.value.filter((e)=>!r.isWhitespaceNode(e) && !r.isCommentNode(e));
    if (3 !== o.length) return !1;
    let t = o[0];
    const s = o[1];
    let n = o[2];
    if (!t || !s || !n) return !1;
    if (!isComma(s)) return !1;
    if (isComma(t) || isComma(n)) return !1;
    if (r.isFunctionNode(t)) {
        const e = [
            t
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, !0);
        }), [t] = e;
    }
    if (r.isFunctionNode(n)) {
        const e = [
            n
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, !1);
        }), [n] = e;
    }
    return [
        t,
        n
    ];
}
function recurseLightDark(e, o, t, s) {
    if ("number" != typeof t) return;
    const n = parseLightDark(e);
    if (!n) return;
    let i = n[s ? 0 : 1];
    if (r.isFunctionNode(i)) {
        const e = [
            i
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, s);
        }), [i] = e;
    }
    o.value[t] = i;
}
function transformLightDark(e, t) {
    const n = new Map, i = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(o.tokenize({
        css: e
    })), (e)=>{
        const i = parseLightDark(e);
        if (!i) return;
        const [a, c] = i, u = t();
        return n.set(u, `var(${s}) ${c.toString()}`), new r.FunctionNode([
            o.TokenType.Function,
            "var(",
            -1,
            -1,
            {
                value: "var"
            }
        ], [
            o.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], [
            new r.TokenNode([
                o.TokenType.Ident,
                u,
                -1,
                -1,
                {
                    value: u
                }
            ]),
            new r.TokenNode([
                o.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]),
            new r.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            a
        ]);
    });
    return {
        value: r.stringify(i),
        toggles: n
    };
}
function newNestedRuleWithSupportsNot(e, o, t, r) {
    const s = o({
        selector: "& *",
        source: e.source
    });
    if (!r) return {
        inner: s,
        outer: s
    };
    const n = t({
        name: "supports",
        params: "not (color: light-dark(tan, tan))",
        source: e.source
    });
    return n.append(s), {
        inner: s,
        outer: n
    };
}
const u = /^color-scheme$/i, l = /\blight-dark\(/i, basePlugin = (e)=>({
        postcssPlugin: "postcss-light-dark-function",
        prepare () {
            let o = 0;
            const currentToggleNameGenerator = ()=>toggleNameGenerator(o++), r = new Map;
            return {
                postcssPlugin: "postcss-light-dark-function",
                Declaration (o, { atRule: i, rule: a }) {
                    const c = o.parent;
                    if (c) {
                        if (u.test(o.prop)) {
                            if (c.some((e)=>"decl" === e.type && e.prop === s)) return;
                            const [e, t] = colorSchemes(o.value);
                            if (e && t) {
                                o.cloneBefore({
                                    prop: s,
                                    value: n
                                });
                                const e = c.clone();
                                e.removeAll(), e.append(o.clone({
                                    prop: s,
                                    value: " "
                                }));
                                const t = i({
                                    name: "media",
                                    params: "(prefers-color-scheme: dark)",
                                    source: c.source
                                });
                                return t.append(e), void c.after(t);
                            }
                            return t ? void o.cloneBefore({
                                prop: s,
                                value: " "
                            }) : e ? void o.cloneBefore({
                                prop: s,
                                value: n
                            }) : void 0;
                        }
                        if (l.test(o.value)) {
                            if (t.hasFallback(o)) return;
                            if (t.hasSupportsAtRuleAncestor(o, l)) return;
                            const s = transformLightDark(o.value, currentToggleNameGenerator);
                            if (s.value === o.value) return;
                            for (const [e, t] of s.toggles)o.cloneBefore({
                                prop: e,
                                value: t
                            });
                            if (o.cloneBefore({
                                value: s.value
                            }), o.variable && o.parent) {
                                const t = r.get(o.parent) ?? newNestedRuleWithSupportsNot(o, a, i, e?.preserve);
                                for (const [e, r] of s.toggles)t.inner.append(o.clone({
                                    prop: e,
                                    value: r
                                }));
                                t.inner.append(o.clone({
                                    value: s.value
                                })), r.has(o.parent) || (o.parent.append(t.outer), r.set(o.parent, t));
                            }
                            e?.preserve || o.remove();
                        }
                    }
                }
            };
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (o)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, o);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-light-dark-function",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-logical-overflow/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o;
function transformAxes(o, t) {
    const e = t ? "-x" : "-y", i = t ? "-y" : "-x", n = o.prop.toLowerCase().replace("-inline", e).replace("-block", i), s = o.value;
    o.parent?.some((o)=>"decl" == o.type && o.prop === n && o.value === s) || (o.cloneBefore({
        prop: n,
        value: s
    }), o.remove());
}
!function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(o || (o = {}));
const creator = (t)=>{
    const e = Object.assign({
        inlineDirection: o.LeftToRight
    }, t);
    switch(e.inlineDirection){
        case o.LeftToRight:
        case o.RightToLeft:
        case o.TopToBottom:
        case o.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(o).join(", ")}`);
    }
    const i = [
        o.LeftToRight,
        o.RightToLeft
    ].includes(e.inlineDirection);
    return {
        postcssPlugin: "postcss-logical-overflow",
        Declaration: {
            "overflow-block": (o)=>transformAxes(o, i),
            "overflow-inline": (o)=>transformAxes(o, i)
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-overscroll-behavior/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o;
function transformAxes(o, t) {
    const e = t ? "-x" : "-y", i = t ? "-y" : "-x", r = o.prop.toLowerCase().replace("-inline", e).replace("-block", i), s = o.value;
    o.parent?.some((o)=>"decl" == o.type && o.prop === r && o.value === s) || (o.cloneBefore({
        prop: r,
        value: s
    }), o.remove());
}
!function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(o || (o = {}));
const creator = (t)=>{
    const e = Object.assign({
        inlineDirection: o.LeftToRight
    }, t);
    switch(e.inlineDirection){
        case o.LeftToRight:
        case o.RightToLeft:
        case o.TopToBottom:
        case o.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(o).join(", ")}`);
    }
    const i = [
        o.LeftToRight,
        o.RightToLeft
    ].includes(e.inlineDirection);
    return {
        postcssPlugin: "postcss-logical-overscroll-behavior",
        Declaration: {
            "overscroll-behavior-block": (o)=>transformAxes(o, i),
            "overscroll-behavior-inline": (o)=>transformAxes(o, i)
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-resize/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o, t, e, i = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function cloneDeclaration(o, t, e) {
    o.parent && o.parent.some((o)=>"decl" == o.type && o.prop === e && o.value === t) || o.cloneBefore({
        value: t,
        prop: e
    });
}
function transformResize(o) {
    return (t)=>{
        const { prop: e, value: n } = t, r = i(n), c = o.inlineIsHorizontal ? "horizontal" : "vertical", s = o.inlineIsHorizontal ? "vertical" : "horizontal";
        r.nodes.forEach((o)=>{
            if ("word" === o.type) {
                const t = o.value.toLowerCase();
                if ("inline" === t) return void (o.value = c);
                "block" === t && (o.value = s);
            }
        });
        const l = r.toString();
        return l !== n && (cloneDeclaration(t, l, e), !0);
    };
}
function directionFlowToAxes(o) {
    switch(o){
        case t.TopToBottom:
            return [
                e.Top,
                e.Bottom
            ];
        case t.BottomToTop:
            return [
                e.Bottom,
                e.Top
            ];
        case t.RightToLeft:
            return [
                e.Right,
                e.Left
            ];
        case t.LeftToRight:
            return [
                e.Left,
                e.Right
            ];
    }
}
!function(o) {
    o.Block = "block", o.Inline = "inline";
}(o || (o = {})), function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(t || (t = {})), function(o) {
    o.Top = "top", o.Right = "right", o.Bottom = "bottom", o.Left = "left";
}(e || (e = {}));
const creator = (o)=>{
    const i = Object.assign({
        blockDirection: t.TopToBottom,
        inlineDirection: t.LeftToRight
    }, o), n = Object.values(t);
    if (!n.includes(i.blockDirection)) throw new Error(`[postcss-logical-resize] "blockDirection" must be one of ${n.join(", ")}`);
    if (!n.includes(i.inlineDirection)) throw new Error(`[postcss-logical-resize] "inlineDirection" must be one of ${n.join(", ")}`);
    const [r, c] = directionFlowToAxes(i.blockDirection), [s, l] = directionFlowToAxes(i.inlineDirection);
    if (!Object.values(e).every((o)=>[
            r,
            c,
            s,
            l
        ].includes(o))) throw new Error('[postcss-logical-resize] "blockDirection" and "inlineDirection" must be on separate axes');
    const a = {
        block: [
            r,
            c
        ],
        inline: [
            s,
            l
        ],
        inlineIsHorizontal: [
            t.LeftToRight,
            t.RightToLeft
        ].includes(i.inlineDirection)
    };
    return {
        postcssPlugin: "postcss-logical-resize",
        Declaration: {
            resize: (u = transformResize(a), (o, { result: t })=>{
                if (!u) return;
                let e = !1;
                try {
                    e = u(o);
                } catch (e) {
                    return void o.warn(t, e instanceof Error ? e.message : String(e));
                }
                e && o.remove();
            })
        }
    };
    "TURBOPACK unreachable";
    var u;
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-viewport-units/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var t, e = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function transform(t, e) {
    const i = o.tokenizer({
        css: t
    }), n = [];
    let s = !1;
    for(;;){
        const t = i.nextToken();
        if (!t) break;
        if (n.push(t), o.isTokenEOF(t)) break;
        if (!o.isTokenDimension(t)) continue;
        const r = t[4].unit.toLowerCase();
        let c;
        "vi" === r ? c = e.vi : "vb" === r && (c = e.vb), c && (t[1] = t[4].value.toString() + c, t[4].unit = c, s = !0);
    }
    return s ? o.stringify(...n) : t;
}
!function(t) {
    t.TopToBottom = "top-to-bottom", t.BottomToTop = "bottom-to-top", t.RightToLeft = "right-to-left", t.LeftToRight = "left-to-right";
}(t || (t = {}));
const i = /vb|vi/i, n = {
    test (t) {
        if (!i.test(t)) return !1;
        const e = o.tokenizer({
            css: t
        });
        for(;;){
            const t = e.nextToken();
            if (o.isTokenEOF(t)) break;
            if (!o.isTokenDimension(t)) continue;
            const i = t[4].unit.toLowerCase();
            if ("vb" === i || "vi" === i) return !0;
        }
        return !1;
    }
}, s = /(?:vi|vb)\b/i, creator = (o)=>{
    const i = Object.assign({
        inlineDirection: t.LeftToRight,
        preserve: !0
    }, o);
    switch(i.inlineDirection){
        case t.LeftToRight:
        case t.RightToLeft:
        case t.TopToBottom:
        case t.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(t).join(", ")}`);
    }
    const r = [
        t.LeftToRight,
        t.RightToLeft
    ].includes(i.inlineDirection), c = {
        vb: "vh",
        vi: "vw"
    };
    return r || (c.vb = "vw", c.vi = "vh"), {
        postcssPlugin: "postcss-logical-viewport-units",
        Declaration (t, { atRule: o }) {
            if (!s.test(t.value)) return;
            if (e.hasFallback(t)) return;
            if (e.hasSupportsAtRuleAncestor(t, n)) return;
            const r = transform(t.value, c);
            if (r === t.value) return;
            if (t.cloneBefore({
                value: r
            }), !i.preserve) return void t.remove();
            if (!t.variable) return;
            const u = o({
                name: "supports",
                params: "(top: 1vi)",
                source: t.source
            }), a = t.parent;
            if (!a) return;
            const f = a.cloneAfter({
                nodes: []
            });
            f.append(t), u.append(f), a.after(u);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-media-queries-aspect-ratio-number-values/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = 1e5, t = 2147483647;
function transformMediaFeatureValue(a) {
    if (Array.isArray(a.value) && e.matchesRatioExactly(a.value)) {
        const e = [];
        for(let o = 0; o < a.value.length; o++){
            const t = a.value[o];
            r.isTokenNode(t) && n.isTokenNumber(t.value) ? e.push(t) : r.isFunctionNode(t) && "calc" === t.getName().toLowerCase() && e.push(t);
        }
        if (2 !== e.length) return;
        const i = e[0], u = a.value.indexOf(i), s = e[1], l = a.value.indexOf(s);
        if (r.isTokenNode(s) && n.isTokenNumber(s.value) && 0 === s.value[4].value) return a.value.splice(u, 1, new r.TokenNode([
            n.TokenType.Number,
            t.toString(),
            -1,
            -1,
            {
                value: t,
                type: n.NumberType.Integer
            }
        ])), void a.value.splice(l, 1, new r.TokenNode([
            n.TokenType.Number,
            "1",
            -1,
            -1,
            {
                value: 1,
                type: n.NumberType.Integer
            }
        ]));
        if (r.isTokenNode(i) && n.isTokenNumber(i.value) && i.value[4].type === n.NumberType.Integer && r.isTokenNode(s) && n.isTokenNumber(s.value) && s.value[4].type === n.NumberType.Integer) return;
        let c = null, d = null;
        if (r.isFunctionNode(i) && "calc" === i.getName().toLowerCase()) {
            if (i.toString().includes(o.toString())) return;
            c = modifyCalc(i);
        }
        if (r.isFunctionNode(s) && "calc" === s.getName().toLowerCase()) {
            if (s.toString().includes(o.toString())) return;
            d = modifyCalc(s);
        }
        if (r.isTokenNode(i) && n.isTokenNumber(i.value) && r.isTokenNode(s) && n.isTokenNumber(s.value)) {
            const e = i.value, t = s.value, a = Math.round(e[4].value * o), u = Math.round(t[4].value * o), l = greatestCommonDivisor(a, u);
            c = new r.TokenNode([
                n.TokenType.Number,
                Math.round(a / l).toString(),
                -1,
                -1,
                {
                    value: Math.round(a / l),
                    type: n.NumberType.Integer
                }
            ]), d = new r.TokenNode([
                n.TokenType.Number,
                Math.round(u / l).toString(),
                -1,
                -1,
                {
                    value: Math.round(u / l),
                    type: n.NumberType.Integer
                }
            ]);
        } else {
            if (r.isTokenNode(i) && n.isTokenNumber(i.value)) {
                const e = i.value;
                c = new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(e[4].value * o).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(e[4].value * o),
                        type: n.NumberType.Integer
                    }
                ]);
            }
            if (r.isTokenNode(s) && n.isTokenNumber(s.value)) {
                const e = s.value;
                d = new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(e[4].value * o).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(e[4].value * o),
                        type: n.NumberType.Integer
                    }
                ]);
            }
        }
        return c && d ? (a.value.splice(u, 1, c), void a.value.splice(l, 1, d)) : void 0;
    }
    const i = Array.isArray(a.value) ? a.value : [
        a.value
    ];
    for(let e = 0; e < i.length; e++){
        const t = i[e];
        if (r.isTokenNode(t)) {
            const u = t.value;
            if (!n.isTokenNumber(u)) return;
            if (u[4].type === n.NumberType.Integer) return i.splice(e + 1, 0, new r.TokenNode([
                n.TokenType.Delim,
                "/",
                -1,
                -1,
                {
                    value: "/"
                }
            ]), new r.TokenNode([
                n.TokenType.Number,
                "1",
                -1,
                -1,
                {
                    value: 1,
                    type: n.NumberType.Integer
                }
            ])), void (a.value = i);
            if (u[4].type === n.NumberType.Number) {
                const t = Math.round(u[4].value * o), s = greatestCommonDivisor(t, o);
                return i.splice(e, 1, new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(t / s).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(t / s),
                        type: n.NumberType.Integer
                    }
                ]), new r.TokenNode([
                    n.TokenType.Delim,
                    "/",
                    -1,
                    -1,
                    {
                        value: "/"
                    }
                ]), new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(o / s).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(o / s),
                        type: n.NumberType.Integer
                    }
                ])), void (a.value = i);
            }
            return;
        }
        if (r.isFunctionNode(t) && "calc" === t.getName().toLowerCase()) return i.splice(e, 1, modifyCalc(t), new r.TokenNode([
            n.TokenType.Delim,
            "/",
            -1,
            -1,
            {
                value: "/"
            }
        ]), new r.TokenNode([
            n.TokenType.Number,
            o.toString(),
            -1,
            -1,
            {
                value: o,
                type: n.NumberType.Integer
            }
        ])), void (a.value = i);
    }
}
function modifyCalc(e) {
    return new r.FunctionNode([
        n.TokenType.Function,
        "calc(",
        -1,
        -1,
        {
            value: "calc("
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], [
        new r.SimpleBlockNode([
            n.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ], [
            n.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], e.value),
        new r.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]),
        new r.TokenNode([
            n.TokenType.Delim,
            "*",
            -1,
            -1,
            {
                value: "*"
            }
        ]),
        new r.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]),
        new r.TokenNode([
            n.TokenType.Number,
            o.toString(),
            -1,
            -1,
            {
                value: o,
                type: n.NumberType.Integer
            }
        ])
    ]);
}
function greatestCommonDivisor(e, r) {
    if (Number.isNaN(e) || Number.isNaN(r)) throw new Error("Unexpected 'NaN' when calculating the greatest common divisor.");
    if (!Number.isFinite(e) || !Number.isFinite(r)) throw new Error("Unexpected 'Infinite' value when calculating the greatest common divisor.");
    for(r > e && ([e, r] = [
        r,
        e
    ]);;){
        if (0 == r) return e;
        if (0 == (e %= r)) return r;
        r %= e;
    }
}
const a = new Set([
    "aspect-ratio",
    "min-aspect-ratio",
    "max-aspect-ratio",
    "device-aspect-ratio",
    "min-device-aspect-ratio",
    "max-device-aspect-ratio"
]);
function transformMediaQueryList(r, n) {
    const o = e.parse(r, {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r}"`);
        }
    }), t = new Set(o.map((e)=>e.toString()));
    return o.flatMap((r)=>{
        if (e.isMediaQueryInvalid(r)) return [
            r.toString()
        ];
        const o = e.cloneMediaQuery(r);
        o.walk((r)=>{
            const n = r.node;
            if (e.isMediaFeaturePlain(n) || e.isMediaFeatureRangeNameValue(n) || e.isMediaFeatureRangeValueName(n)) {
                const e = n.name.getName().toLowerCase();
                if (!a.has(e)) return;
                transformMediaFeatureValue(n.value);
            } else if (e.isMediaFeatureRangeValueNameValue(n)) {
                const e = n.name.getName().toLowerCase();
                if (!a.has(e)) return;
                transformMediaFeatureValue(n.valueOne);
                transformMediaFeatureValue(n.valueTwo);
            } else ;
        });
        const i = r.toString(), u = o.toString();
        return u === i || t.has(u) ? [
            i
        ] : n ? [
            i,
            u
        ] : [
            u
        ];
    }).join(",");
}
const creator = (e)=>{
    const r = Object.assign({
        preserve: !1
    }, e);
    return {
        postcssPlugin: "postcss-media-queries-aspect-ratio-number-values",
        AtRule (e, { result: n }) {
            if ("media" !== e.name.toLowerCase()) return;
            const o = e.params.toLowerCase();
            if (!(o.includes("aspect-ratio") || o.includes("min-aspect-ratio") || o.includes("max-aspect-ratio") || o.includes("device-aspect-ratio") || o.includes("min-device-aspect-ratio") || o.includes("max-device-aspect-ratio"))) return;
            let t;
            try {
                if (t = transformMediaQueryList(e.params, r.preserve), t === e.params) return;
            } catch (r) {
                return void e.warn(n, `Failed to transform @media params for "${e.params}" with message: "${r instanceof Error ? r.message : r}"`);
            }
            e.cloneBefore({
                params: t
            }), e.remove();
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-media-minmax/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const t = {
    width: "px",
    height: "px",
    "device-width": "px",
    "device-height": "px",
    "aspect-ratio": "",
    "device-aspect-ratio": "",
    color: "",
    "color-index": "",
    monochrome: "",
    resolution: "dpi"
}, r = {
    width: !1,
    height: !1,
    "device-width": !1,
    "device-height": !1,
    "aspect-ratio": !1,
    "device-aspect-ratio": !1,
    color: !0,
    "color-index": !0,
    monochrome: !0,
    resolution: "dpi"
};
function featureNamePrefix(e) {
    return e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? "max-" : e === n.MediaFeatureGT.GT || e === n.MediaFeatureGT.GT_OR_EQ ? "min-" : "";
}
const o = {
    ">": 1,
    "<": -1
}, s = .001;
function transformSingleNameValuePair(u, d, l, c) {
    let p = l.before, m = l.after;
    if (c || (p = l.after, m = l.before), !c) {
        const e = n.invertComparison(d);
        if (!1 === e) return;
        d = e;
    }
    if (d === n.MediaFeatureEQ.EQ || d === n.MediaFeatureLT.LT_OR_EQ || d === n.MediaFeatureGT.GT_OR_EQ) return Array.isArray(l.value) ? n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, ...l.value.flatMap((e)=>e.tokens()), ...m) : n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, ...l.value.tokens(), ...m);
    let T, f, v = !1;
    if (Array.isArray(l.value)) {
        if (!n.matchesRatioExactly(l.value)) return;
        if ("aspect-ratio" !== u && "device-aspect-ratio" !== u) return;
        const e = n.matchesRatio(l.value);
        if (-1 === e) return;
        v = !0, T = l.value[e[0]], f = [
            ...l.value.slice(e[0] + 1).flatMap((e)=>e.tokens())
        ];
    } else T = l.value, f = [];
    const y = t[u.toLowerCase()];
    if (e.isFunctionNode(T)) {
        const t = T.getName().toLowerCase();
        if (a.mathFunctionNames.has(t) || "env" === t) {
            const [[t]] = a.calcFromComponentValues([
                [
                    T
                ]
            ], {
                precision: 5,
                toCanonicalUnits: !0
            });
            if (!(t && e.isTokenNode(t) && i.isTokenNumeric(t.value) && Number.isInteger(t.value[4].value))) {
                let e;
                if (void 0 !== y) {
                    const n = o[d] * ("px" === y ? .02 : s);
                    e = [
                        i.TokenType.Dimension,
                        `${n.toString()}${y}`,
                        -1,
                        -1,
                        {
                            value: n,
                            unit: y,
                            type: i.NumberType.Integer
                        }
                    ];
                } else if (!0 === r[u]) {
                    const n = o[d];
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                } else if (v) {
                    const n = o[d] * s;
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                } else {
                    const n = o[d];
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                }
                return n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, [
                    i.TokenType.Function,
                    "calc(",
                    -1,
                    -1,
                    {
                        value: "calc("
                    }
                ], [
                    i.TokenType.OpenParen,
                    "(",
                    -1,
                    -1,
                    void 0
                ], ...T.tokens().slice(1), [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ], [
                    i.TokenType.Delim,
                    "+",
                    -1,
                    -1,
                    {
                        value: "+"
                    }
                ], [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ], e, [
                    i.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ], ...f, ...m);
            }
            T = t;
        }
    }
    if (!e.isTokenNode(T)) return;
    let h, M = T.value, g = "";
    if (void 0 !== y && i.isTokenNumber(M) && 0 === M[4].value) h = o[d], g = y;
    else if (i.isTokenNumber(M) && 0 === M[4].value) h = o[d], g = "";
    else if (i.isTokenDimension(M) && 0 === M[4].value) h = o[d], g = M[4].unit;
    else if (i.isTokenNumber(M) && !0 === r[u]) h = M[4].value + o[d];
    else if (i.isTokenDimension(M) && "px" === M[4].unit && M[4].type === i.NumberType.Integer) h = Number(Math.round(Number(M[4].value + .02 * o[d] + "e6")) + "e-6");
    else {
        if (!i.isTokenDimension(M) && !i.isTokenNumber(M)) return;
        h = Number(Math.round(Number(M[4].value + s * o[d] + "e6")) + "e-6");
    }
    return g && (M = [
        i.TokenType.Dimension,
        M[1],
        M[2],
        M[3],
        {
            value: M[4].value,
            unit: g,
            type: M[4].type
        }
    ]), M[4].value = h, i.isTokenDimension(M) ? M[1] = M[4].value.toString() + M[4].unit : M[1] = M[4].value.toString(), n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, M, ...f, ...m);
}
const u = new Set([
    "aspect-ratio",
    "color",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "height",
    "horizontal-viewport-segments",
    "monochrome",
    "resolution",
    "vertical-viewport-segments",
    "width"
]);
function transform(a) {
    return a.map((a, t)=>{
        const r = e.gatherNodeAncestry(a);
        a.walk((e)=>{
            const t = e.node;
            if (!n.isMediaFeatureRange(t)) return;
            const o = e.parent;
            if (!n.isMediaFeature(o)) return;
            const s = t.name.getName().toLowerCase();
            if (!u.has(s)) return;
            if (n.isMediaFeatureRangeNameValue(t) || n.isMediaFeatureRangeValueName(t)) {
                const e = t.operatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.value, n.isMediaFeatureRangeNameValue(t));
                return void (i && (o.feature = i.feature));
            }
            const d = r.get(o);
            if (!n.isMediaInParens(d)) return;
            let l = null, c = null;
            {
                const e = t.valueOneOperatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.valueOne, !1);
                if (!i) return;
                e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? (l = i, l.before = o.before) : (c = i, c.after = o.after);
            }
            {
                const e = t.valueTwoOperatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.valueTwo, !0);
                if (!i) return;
                e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? (c = i, c.before = o.before) : (l = i, l.after = o.after);
            }
            if (!l || !c) return;
            const p = new n.MediaInParens(l), m = new n.MediaInParens(c), T = getMediaConditionListWithAndFromAncestry(d, r);
            if (T) return T.leading === d ? (T.leading = p, void (T.list = [
                new n.MediaAnd([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ],
                    [
                        i.TokenType.Ident,
                        "and",
                        -1,
                        -1,
                        {
                            value: "and"
                        }
                    ],
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ], m),
                ...T.list
            ])) : void T.list.splice(T.indexOf(r.get(d)), 1, new n.MediaAnd([
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], p), new n.MediaAnd([
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], m));
            const f = new n.MediaConditionListWithAnd(p, [
                new n.MediaAnd([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ],
                    [
                        i.TokenType.Ident,
                        "and",
                        -1,
                        -1,
                        {
                            value: "and"
                        }
                    ],
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ], m)
            ], [
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]), v = getMediaConditionInShallowMediaQueryFromAncestry(d, a, r);
            v ? v.media = f : d.media = new n.MediaCondition(new n.MediaInParens(new n.MediaCondition(f), [
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.OpenParen,
                    "(",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ]
            ]));
        });
        const o = a.tokens();
        return i.stringify(...o.filter((e, n)=>(0 !== n || 0 !== t || !i.isTokenWhitespace(e)) && !(i.isTokenWhitespace(e) && o[n + 1] && i.isTokenWhitespace(o[n + 1]))));
    }).join(",");
}
function getMediaConditionListWithAndFromAncestry(e, i) {
    let a = e;
    if (a) {
        if (a = i.get(a), n.isMediaConditionListWithAnd(a)) return a;
        if (n.isMediaAnd(a)) return a = i.get(a), n.isMediaConditionListWithAnd(a) ? a : void 0;
    }
}
function getMediaConditionInShallowMediaQueryFromAncestry(e, i, a) {
    let t = e;
    if (!t) return;
    if (t = a.get(t), !n.isMediaCondition(t)) return;
    const r = t;
    return t = a.get(t), n.isMediaQuery(t) && t === i ? r : void 0;
}
const creator = ()=>({
        postcssPlugin: "postcss-media-minmax",
        AtRule: {
            media (e) {
                if (!(e.params.includes("<") || e.params.includes(">") || e.params.includes("="))) return;
                const i = transform(n.parse(e.params, {
                    preserveInvalidMediaQueries: !0,
                    onParseError: ()=>{
                        throw e.error(`Unable to parse media query "${e.params}"`);
                    }
                }));
                e.params !== i && (e.params = i);
            },
            "custom-media" (e) {
                if (!(e.params.includes("<") || e.params.includes(">") || e.params.includes("="))) return;
                const a = n.parseCustomMedia(e.params, {
                    preserveInvalidMediaQueries: !0,
                    onParseError: ()=>{
                        throw e.error(`Unable to parse media query "${e.params}"`);
                    }
                });
                if (!a || !a.mediaQueryList) return;
                const t = a.mediaQueryList.map((e)=>e.toString()).join(","), r = transform(a.mediaQueryList);
                t !== r && (e.params = `${i.stringify(...a.name)} ${r}`);
            }
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-nested-calc/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const r = /calc\(/gi;
const creator = (s)=>{
    const a = Object.assign({
        preserve: !0
    }, s);
    return {
        postcssPlugin: "postcss-nested-calc",
        Declaration (s, { result: o }) {
            if ((s.value.match(r) || []).length < 2) return;
            if (s.variable) return;
            if (t.hasFallback(s)) return;
            const c = s.value;
            let l;
            try {
                l = e(c);
            } catch  {
                return void s.warn(o, `Failed to parse value '${c}'. Leaving the original value intact.`);
            }
            if (void 0 === l) return;
            e.walk(l.nodes, (t)=>{
                t.type && "function" === t.type && "calc" === t.value.toLowerCase() && e.walk(t.nodes, (e)=>{
                    if (e.type && "function" === e.type) return "calc" === e.value.toLowerCase() && void (e.value = "");
                });
            }, !0);
            const n = String(l);
            n !== c && (s.cloneBefore({
                value: n
            }), a.preserve || s.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-oklab-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:oklab|oklch)\(/i, l = /^(?:oklab|oklch)$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-oklab-function",
        Declaration (n) {
            const i = n.value;
            if (!o.test(i)) return;
            if (t.hasFallback(n)) return;
            if (t.hasSupportsAtRuleAncestor(n, o)) return;
            const u = r.tokenize({
                css: i
            }), c = a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), p = a.stringify(c);
            if (p === i) return;
            let g = p;
            s?.subFeatures.displayP3 && (g = a.stringify(a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.colorDataFitsRGB_Gamut(t) ? e.serializeRGB(t) : e.serializeP3(t) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && g !== p && n.cloneBefore({
                value: g
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return t.subFeatures = Object.assign({
        displayP3: !0
    }, t.subFeatures), t.enableProgressiveCustomProperties && (t.preserve || t.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-oklab-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-random-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const r = String.fromCodePoint(0);
function randomCacheKeyFromPostcssDeclaration(e) {
    let o = "", s = e.parent;
    for(; s;){
        switch(s.type){
            case "rule":
                o += r + "selector" + r + s.selector + r;
                break;
            case "atrule":
                "scope" === s.name && (o += r + "prelude" + r + s.params + r);
        }
        s = s.parent;
    }
    return {
        propertyName: e.prop,
        propertyN: 0,
        elementID: o,
        documentID: e.source?.input.css ?? e.root().toString()
    };
}
const o = /(?<![-\w])(?:random)\(/i, creator = (r)=>{
    const s = Object.assign({
        preserve: !1
    }, r);
    return {
        postcssPlugin: "postcss-random-function",
        Declaration (r) {
            if (!o.test(r.value)) return;
            const t = e.calc(r.value, {
                precision: 5,
                toCanonicalUnits: !0,
                randomCaching: randomCacheKeyFromPostcssDeclaration(r)
            });
            t !== r.value && (r.cloneBefore({
                value: t
            }), s.preserve || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-relative-color-syntax/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)\(/i, l = /\b(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)\(\s*from/i, i = /^(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)$/i, n = /from/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-relative-color-syntax",
        Declaration (c) {
            const u = c.value;
            if (!o.test(u) || !n.test(u)) return;
            if (a.hasFallback(c)) return;
            if (a.hasSupportsAtRuleAncestor(c, l)) return;
            const p = t.tokenize({
                css: u
            }), g = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(p), (s)=>{
                if (!r.isFunctionNode(s) || !i.test(s.getName())) return;
                const a = e.color(s);
                return a && !a.syntaxFlags.has(e.SyntaxFlag.Experimental) && !a.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) && a.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) ? e.serializeRGB(a) : void 0;
            }), b = r.stringify(g);
            if (b === u) return;
            let y = b;
            s?.subFeatures.displayP3 && (y = r.stringify(r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(p), (s)=>{
                if (!r.isFunctionNode(s) || !i.test(s.getName())) return;
                const a = e.color(s);
                return a && !a.syntaxFlags.has(e.SyntaxFlag.Experimental) && !a.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) && a.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) ? e.colorDataFitsRGB_Gamut(a) ? e.serializeRGB(a) : e.serializeP3(a) : void 0;
            }))), c.cloneBefore({
                value: b
            }), s?.subFeatures.displayP3 && y !== b && c.cloneBefore({
                value: y
            }), s?.preserve || c.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const a = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return a.subFeatures = Object.assign({
        displayP3: !0
    }, a.subFeatures), a.enableProgressiveCustomProperties && (a.preserve || a.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-relative-color-syntax",
        plugins: [
            s(),
            basePlugin(a)
        ]
    } : basePlugin(a);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-scope-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-scope-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const creator = (s)=>{
    const r = Object.assign({
        preserve: !1
    }, s);
    return {
        postcssPlugin: "postcss-scope-pseudo-class",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "postcss-scope-pseudo-class",
                Rule (t, { result: o }) {
                    if (!t.selector.toLowerCase().includes(":scope")) return;
                    if (s.has(t)) return;
                    {
                        let e = t.parent;
                        for(; e;){
                            if ("atrule" === e.type && "scope" === e.name.toLowerCase()) return;
                            e = e.parent;
                        }
                    }
                    let c = t.selector;
                    try {
                        const s = e().astSync(c);
                        if (!s) return;
                        s.walkPseudos((e)=>{
                            if (":has" === e.value.toLowerCase()) return !1;
                            ":scope" === e.value.toLowerCase() && (e.value = ":root");
                        }), c = s.toString();
                    } catch (e) {
                        t.warn(o, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                    c !== t.selector && (s.add(t), t.cloneBefore({
                        selector: c
                    }), r.preserve || t.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-sign-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:sign|abs)\(/i, a = /(?<![-\w])(?:sign|abs)\(/i, creator = (t)=>{
    const r = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-sign-functions",
        Declaration (t) {
            if (!s.test(t.value)) return;
            let i;
            i = a.test(t.value) ? n.replaceComponentValues(n.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: t.value
            })), replacer) : n.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: t.value
            }));
            const p = n.stringify(e.calcFromComponentValues(i, {
                precision: 5,
                toCanonicalUnits: !0
            }));
            p !== t.value && (t.cloneBefore({
                value: p
            }), r.preserve || t.remove());
        }
    };
};
function replacer(e) {
    if (!n.isFunctionNode(e)) return;
    if ("abs" !== e.getName().toLowerCase()) return;
    const [s] = n.replaceComponentValues([
        e.value
    ], replacer);
    return [
        new n.FunctionNode([
            o.TokenType.Function,
            "max(",
            -1,
            -1,
            {
                value: "max"
            }
        ], [
            o.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], [
            new n.SimpleBlockNode([
                o.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ], [
                o.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], n.parseListOfComponentValues(s.flatMap((e)=>e.tokens()))),
            new n.TokenNode([
                o.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.TokenNode([
                o.TokenType.Number,
                "-1",
                -1,
                -1,
                {
                    value: -1,
                    type: o.NumberType.Integer,
                    signCharacter: "-"
                }
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.TokenNode([
                o.TokenType.Delim,
                "*",
                -1,
                -1,
                {
                    value: "*"
                }
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.SimpleBlockNode([
                o.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ], [
                o.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], n.parseListOfComponentValues(s.flatMap((e)=>e.tokens())))
        ])
    ];
}
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-stepped-value-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:mod|rem|round)\(/i, creator = (o)=>{
    const t = Object.assign({
        preserve: !1
    }, o);
    return {
        postcssPlugin: "postcss-stepped-value-functions",
        Declaration (o) {
            if (!s.test(o.value)) return;
            const c = e.calc(o.value, {
                precision: 5,
                toCanonicalUnits: !0
            });
            c !== o.value && (o.cloneBefore({
                value: c
            }), t.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-text-decoration-shorthand/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)");
const r = /^text-decoration$/i, creator = (o)=>{
    const c = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-text-decoration-shorthand",
        prepare () {
            const o = new Map;
            return {
                postcssPlugin: "postcss-text-decoration-shorthand",
                OnceExit () {
                    o.clear();
                },
                Declaration (u) {
                    if (!r.test(u.prop)) return;
                    const a = u.parent;
                    if (!a) return;
                    const i = a.index(u);
                    if (a.nodes.some((e)=>"decl" === e.type && r.test(e.prop) && o.get(u.value) === e.value && a.index(e) !== i)) return;
                    const d = e(u.value), p = d.nodes.filter((e)=>"space" !== e.type && "comment" !== e.type);
                    if (p.find((e)=>"var" === e.value.toLowerCase() && "function" === e.type)) return;
                    if (p.find((e)=>"word" === e.type && t.includes(e.value))) return;
                    const f = {
                        line: [],
                        style: null,
                        color: null,
                        thickness: null
                    };
                    for(let o = 0; o < p.length; o++){
                        const r = p[o];
                        if (f.line.length || "word" !== r.type || !n.includes(r.value.toLowerCase())) if (f.line.length || "word" !== r.type || "none" !== r.value.toLowerCase()) if (f.style || "word" !== r.type || !s.includes(r.value.toLowerCase())) if (f.thickness || "word" !== r.type || !l.includes(r.value.toLowerCase())) if (f.thickness || "function" !== r.type || "calc" !== r.value.toLowerCase()) if (f.color || !nodeIsAColor(r)) {
                            if ("word" !== r.type) return;
                            {
                                let o;
                                try {
                                    o = e.unit(r.value);
                                } catch  {
                                    return;
                                }
                                if (!o || !o.unit) return;
                                f.thickness = r, "%" === o.unit && (f.thickness = {
                                    before: "",
                                    after: "",
                                    sourceIndex: 0,
                                    sourceEndIndex: 0,
                                    type: "function",
                                    value: "calc",
                                    nodes: [
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: "0.01em"
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "space",
                                            value: " "
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: "*"
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "space",
                                            value: " "
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: o.number
                                        }
                                    ]
                                });
                            }
                        } else f.color = r;
                        else f.thickness = r;
                        else f.thickness = r;
                        else f.style = r;
                        else f.line.push(r);
                        else {
                            const e = r;
                            let t = r;
                            for(;;){
                                const e = p[o + 1];
                                if (!e || "word" !== e.type || !n.includes(e.value.toLowerCase())) break;
                                t = e, o++;
                            }
                            f.line = d.nodes.slice(d.nodes.indexOf(e), d.nodes.indexOf(t) + 1);
                        }
                    }
                    f.line.length || f.line.push({
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "none"
                    }), f.style || (f.style = {
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "solid"
                    }), f.color || (f.color = {
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "currentColor"
                    });
                    const v = e.stringify(f.line);
                    if (u.value.toLowerCase() === v.toLowerCase()) {
                        const e = u.next();
                        return void (e && "decl" === e.type && "text-decoration" === e.prop.toLowerCase() || u.cloneBefore({
                            prop: "-webkit-text-decoration",
                            value: v
                        }));
                    }
                    u.cloneBefore({
                        prop: "text-decoration",
                        value: v
                    });
                    const y = e.stringify([
                        ...f.line,
                        {
                            before: "",
                            after: "",
                            sourceIndex: 0,
                            sourceEndIndex: 0,
                            type: "space",
                            value: " "
                        },
                        f.style,
                        {
                            before: "",
                            after: "",
                            sourceIndex: 0,
                            sourceEndIndex: 0,
                            type: "space",
                            value: " "
                        },
                        f.color
                    ]);
                    f.thickness && u.cloneBefore({
                        prop: "text-decoration",
                        value: y
                    }), f.thickness && u.cloneBefore({
                        prop: "text-decoration-thickness",
                        value: e.stringify([
                            f.thickness
                        ])
                    }), o.set(u.value, v), o.set(y, v), c.preserve || u.remove();
                }
            };
        }
    };
};
function nodeIsAColor(e) {
    return !("word" !== e.type || !e.value.startsWith("#")) || !("word" !== e.type || !u.includes(e.value.toLowerCase())) || !("function" !== e.type || !c.includes(e.value.toLowerCase()));
}
creator.postcss = !0;
const t = [
    "unset",
    "inherit",
    "initial",
    "revert",
    "revert-layer"
], n = [
    "underline",
    "overline",
    "line-through",
    "blink",
    "spelling-error",
    "grammar-error"
], s = [
    "solid",
    "double",
    "dotted",
    "dashed",
    "wavy"
], l = [
    "auto",
    "from-font"
], c = [
    "color",
    "color-mix",
    "hsl",
    "hsla",
    "hwb",
    "lab",
    "lch",
    "oklab",
    "oklch",
    "rgb",
    "rgba"
], u = [
    "currentcolor",
    "transparent",
    ...Object.keys(o.namedColors)
];
module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-trigonometric-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const e = /(?<![-\w])(?:asin|acos|atan|atan2|sin|cos|tan)\(/i, creator = (t)=>{
    const c = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-trigonometric-functions",
        Declaration (t) {
            if (!e.test(t.value)) return;
            const o = s.calc(t.value, {
                precision: 5,
                toCanonicalUnits: !0
            });
            o !== t.value && (t.cloneBefore({
                value: o
            }), c.preserve || t.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-unset-value/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = new Set([
    "block-ellipsis",
    "border-boundary",
    "border-collapse",
    "border-spacing",
    "box-snap",
    "caption-side",
    "caret",
    "caret-shape",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "cursor",
    "direction",
    "dominant-baseline",
    "empty-cells",
    "fill",
    "fill-color",
    "fill-image",
    "fill-opacity",
    "fill-position",
    "fill-repeat",
    "fill-rule",
    "fill-size",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-variant",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-weight",
    "forced-color-adjust",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphenate-limit-last",
    "hyphenate-limit-lines",
    "hyphenate-limit-zone",
    "hyphens",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "initial-letter-wrap",
    "letter-spacing",
    "line-break",
    "line-height",
    "line-padding",
    "line-snap",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-side",
    "marker-start",
    "orphans",
    "overflow-wrap",
    "paint-order",
    "pointer-events",
    "print-color-adjust",
    "quotes",
    "ruby-merge",
    "ruby-overhang",
    "ruby-position",
    "shape-rendering",
    "speak",
    "speak-as",
    "stroke",
    "stroke-align",
    "stroke-alignment",
    "stroke-color",
    "stroke-dash-corner",
    "stroke-dash-justify",
    "stroke-dashadjust",
    "stroke-dasharray",
    "stroke-dashcorner",
    "stroke-dashoffset",
    "stroke-image",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-position",
    "stroke-repeat",
    "stroke-size",
    "stroke-width",
    "tab-size",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration-skip",
    "text-decoration-skip-box",
    "text-decoration-skip-inset",
    "text-decoration-skip-self",
    "text-decoration-skip-spaces",
    "text-edge",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-skip",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-space-collapse",
    "text-spacing",
    "text-transform",
    "text-underline-position",
    "text-wrap",
    "visibility",
    "voice-balance",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "widows",
    "word-boundary-detection",
    "word-boundary-expansion",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode"
]), t = new Set([
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-block",
    "background-position-inline",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "baseline-source",
    "block-step",
    "block-step-align",
    "block-step-insert",
    "block-step-round",
    "block-step-size",
    "bookmark-label",
    "bookmark-level",
    "bookmark-state",
    "border",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-clip",
    "border-clip-bottom",
    "border-clip-left",
    "border-clip-right",
    "border-clip-top",
    "border-color",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-limit",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "clear",
    "clip",
    "clip-path",
    "color-adjust",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "continue",
    "copy-into",
    "corner-shape",
    "corners",
    "counter-increment",
    "counter-reset",
    "cue",
    "cue-after",
    "cue-before",
    "cx",
    "cy",
    "d",
    "display",
    "fill-break",
    "fill-origin",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "float-defer",
    "float-offset",
    "float-reference",
    "flood-color",
    "flood-opacity",
    "flow-from",
    "flow-into",
    "footnote-display",
    "footnote-policy",
    "gap",
    "glyph-orientation-vertical",
    "grid-auto-columns",
    "grid-auto-rows",
    "grid-column-gap",
    "grid-gap",
    "grid-row-gap",
    "grid-template-columns",
    "grid-template-rows",
    "height",
    "initial-letter",
    "inline-sizing",
    "input-security",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "leading-trim",
    "left",
    "lighting-color",
    "line-clamp",
    "line-grid",
    "margin",
    "margin-bottom",
    "margin-break",
    "margin-left",
    "margin-right",
    "margin-top",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-image",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "max-height",
    "max-lines",
    "max-width",
    "min-height",
    "min-intrinsic-sizing",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-left",
    "nav-right",
    "nav-up",
    "object-fit",
    "object-position",
    "opacity",
    "order",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-x",
    "overflow-y",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "position",
    "r",
    "region-fragment",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "row-gap",
    "rx",
    "ry",
    "scroll-snap-type",
    "shape-image-threshold",
    "shape-inside",
    "shape-margin",
    "shape-outside",
    "shape-padding",
    "shape-subtract",
    "spatial-navigation-action",
    "spatial-navigation-contain",
    "spatial-navigation-function",
    "stop-color",
    "stop-opacity",
    "string-set",
    "stroke-break",
    "stroke-origin",
    "table-layout",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-style",
    "text-emphasis",
    "text-group-align",
    "text-overflow",
    "text-space-trim",
    "top",
    "touch-action",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "unicode-bidi",
    "user-select",
    "vector-effect",
    "vertical-align",
    "voice-duration",
    "width",
    "will-change",
    "wrap-after",
    "wrap-before",
    "wrap-flow",
    "wrap-inside",
    "wrap-through",
    "x",
    "y",
    "z-index"
]), creator = (o)=>{
    const i = Object.assign({
        preserve: !1
    }, o);
    return {
        postcssPlugin: "postcss-unset-value",
        Declaration (o) {
            if ("unset" !== o.value.toLowerCase()) return;
            let r = !1;
            e.has(o.prop.toLowerCase()) ? r = "inherit" : t.has(o.prop.toLowerCase()) && (r = "initial"), r && (o.cloneBefore({
                prop: o.prop,
                value: r
            }), i.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),

};

//# sourceMappingURL=node_modules_%40csstools_3990f874._.js.map