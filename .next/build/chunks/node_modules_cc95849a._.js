module.exports = {

"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let result = "", cursor = 0;
    do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }while (~index)
    return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported)=>{
    let f = enabled ? formatter : ()=>String;
    return {
        isColorSupported: enabled,
        reset: f("\x1b[0m", "\x1b[0m"),
        bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
        dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
        italic: f("\x1b[3m", "\x1b[23m"),
        underline: f("\x1b[4m", "\x1b[24m"),
        inverse: f("\x1b[7m", "\x1b[27m"),
        hidden: f("\x1b[8m", "\x1b[28m"),
        strikethrough: f("\x1b[9m", "\x1b[29m"),
        black: f("\x1b[30m", "\x1b[39m"),
        red: f("\x1b[31m", "\x1b[39m"),
        green: f("\x1b[32m", "\x1b[39m"),
        yellow: f("\x1b[33m", "\x1b[39m"),
        blue: f("\x1b[34m", "\x1b[39m"),
        magenta: f("\x1b[35m", "\x1b[39m"),
        cyan: f("\x1b[36m", "\x1b[39m"),
        white: f("\x1b[37m", "\x1b[39m"),
        gray: f("\x1b[90m", "\x1b[39m"),
        bgBlack: f("\x1b[40m", "\x1b[49m"),
        bgRed: f("\x1b[41m", "\x1b[49m"),
        bgGreen: f("\x1b[42m", "\x1b[49m"),
        bgYellow: f("\x1b[43m", "\x1b[49m"),
        bgBlue: f("\x1b[44m", "\x1b[49m"),
        bgMagenta: f("\x1b[45m", "\x1b[49m"),
        bgCyan: f("\x1b[46m", "\x1b[49m"),
        bgWhite: f("\x1b[47m", "\x1b[49m"),
        blackBright: f("\x1b[90m", "\x1b[39m"),
        redBright: f("\x1b[91m", "\x1b[39m"),
        greenBright: f("\x1b[92m", "\x1b[39m"),
        yellowBright: f("\x1b[93m", "\x1b[39m"),
        blueBright: f("\x1b[94m", "\x1b[39m"),
        magentaBright: f("\x1b[95m", "\x1b[39m"),
        cyanBright: f("\x1b[96m", "\x1b[39m"),
        whiteBright: f("\x1b[97m", "\x1b[39m"),
        bgBlackBright: f("\x1b[100m", "\x1b[49m"),
        bgRedBright: f("\x1b[101m", "\x1b[49m"),
        bgGreenBright: f("\x1b[102m", "\x1b[49m"),
        bgYellowBright: f("\x1b[103m", "\x1b[49m"),
        bgBlueBright: f("\x1b[104m", "\x1b[49m"),
        bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
        bgCyanBright: f("\x1b[106m", "\x1b[49m"),
        bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
};
module.exports = createColors();
module.exports.createColors = createColors;
}}),
"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = '';
        // A compact alternative for `for (var i = 0; i < step; i++)`.
        let i = size | 0;
        while(i--){
            // `| 0` is more compact and faster than `Math.floor()`.
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
let nanoid = (size = 21)=>{
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while(i--){
        // `| 0` is more compact and faster than `Math.floor()`.
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
module.exports = {
    nanoid,
    customAlphabet
};
}}),
"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */ exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */ exports.decode = function(charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
}}),
"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var base64 = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)");
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */ function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */ function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */ exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }while (vlq > 0)
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    }while (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}}),
"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */ function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
        return aArgs[aName];
    } else if (arguments.length === 3) {
        return aDefaultValue;
    } else {
        throw new Error('"' + aName + '" is a required argument.');
    }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
        return null;
    }
    return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
    };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;
/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */ function lruMemoize(f) {
    var cache = [];
    return function(input) {
        for(var i = 0; i < cache.length; i++){
            if (cache[i].input === input) {
                var temp = cache[0];
                cache[0] = cache[i];
                cache[i] = temp;
                return cache[0].result;
            }
        }
        var result = f(input);
        cache.unshift({
            input,
            result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
        }
        return result;
    };
}
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */ var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
        if (!url.path) {
            return aPath;
        }
        path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while(true){
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
            parts.push(path.slice(start));
            break;
        } else {
            parts.push(path.slice(start, i));
            while(i < path.length && path[i] === "/"){
                i++;
            }
        }
    }
    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
        part = parts[i];
        if (part === '.') {
            parts.splice(i, 1);
        } else if (part === '..') {
            up++;
        } else if (up > 0) {
            if (part === '') {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
            } else {
                parts.splice(i, 2);
                up--;
            }
        }
    }
    path = parts.join('/');
    if (path === '') {
        path = isAbsolute ? '/' : '.';
    }
    if (url) {
        url.path = path;
        return urlGenerate(url);
    }
    return path;
});
exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */ function join(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    if (aPath === "") {
        aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
    }
    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
    }
    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
    }
    return joined;
}
exports.join = join;
exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */ function relative(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, '');
    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while(aPath.indexOf(aRoot + '/') !== 0){
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
            return aPath;
        }
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
        }
        ++level;
    }
    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function() {
    var obj = Object.create(null);
    return !('__proto__' in obj);
}();
function identity(s) {
    return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */ function toSetString(aStr) {
    if (isProtoString(aStr)) {
        return '$' + aStr;
    }
    return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
    if (isProtoString(aStr)) {
        return aStr.slice(1);
    }
    return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
    if (!s) {
        return false;
    }
    var length = s.length;
    if (length < 9 /* "__proto__".length */ ) {
        return false;
    }
    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {
        return false;
    }
    for(var i = length - 10; i >= 0; i--){
        if (s.charCodeAt(i) !== 36 /* '$' */ ) {
            return false;
        }
    }
    return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
        return 0;
    }
    if (aStr1 === null) {
        return 1; // aStr2 !== null
    }
    if (aStr2 === null) {
        return -1; // aStr1 !== null
    }
    if (aStr1 > aStr2) {
        return 1;
    }
    return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */ function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';
    if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
    }
    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}}),
"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */ function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for(var i = 0, len = aArray.length; i < len; i++){
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
exports.ArraySet = ArraySet;
}}),
"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */ function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */ function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
        generatedLine: -1,
        generatedColumn: 0
    };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */ MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    } else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */ MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
exports.MappingList = MappingList;
}}),
"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var MappingList = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */ function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
            generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
            }
        };
        if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
            };
            if (mapping.name != null) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
            return;
        }
    }
    if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
            this._sources.add(source);
        }
    }
    if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
            this._names.add(name);
        }
    }
    this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    });
};
/**
 * Set the source content for a source file.
 */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
        }
    }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
            });
            if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                    mapping.name = original.name;
                }
            }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
            newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
            newNames.add(name);
        }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
        }
    }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        // Cases 2 and 3.
        return;
    } else {
        var message = 'Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
        });
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for(var i = 0, len = mappings.length; i < len; i++){
        mapping = mappings[i];
        next = '';
        if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while(mapping.generatedLine !== previousGeneratedLine){
                next += ';';
                previousGeneratedLine++;
            }
        } else {
            if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                    continue;
                }
                next += ',';
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
        if (!this._sourcesContents) {
            return null;
        }
        if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
};
/**
 * Externalize the source map.
 */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
    };
    if (this._file != null) {
        map.file = this._file;
    }
    if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
};
/**
 * Render the source map being generated to a string.
 */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}}),
"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
    } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
        } else {
            return mid;
        }
    } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
        } else {
            return aLow < 0 ? -1 : aLow;
        }
    }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
        return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
        return -1;
    }
    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while(index - 1 >= 0){
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
        }
        --index;
    }
    return index;
};
}}),
"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
function SortTemplate(comparator) {
    /**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */ function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
    }
    /**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */ function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
    }
    /**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */ function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
        if (p < r) {
            // (1) Partitioning.
            //
            // The partitioning chooses a pivot between `p` and `r` and moves all
            // elements that are less than or equal to the pivot to the before it, and
            // all the elements that are greater than it after it. The effect is that
            // once partition is done, the pivot is in the exact place it will be when
            // the array is put in sorted order, and it will not need to be moved
            // again. This runs in O(n) time.
            // Always choose a random pivot so that an input array which is reverse
            // sorted does not cause O(n^2) running time.
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            // Immediately after `j` is incremented in this loop, the following hold
            // true:
            //
            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
            //
            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
            for(var j = p; j < r; j++){
                if (comparator(ary[j], pivot, false) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            // (2) Recurse on each half.
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
        }
    }
    return doQuickSort;
}
function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */ let sortCache = new WeakMap();
exports.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
};
}}),
"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var binarySearch = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var quickSort = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)").quickSort;
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */ SourceMapConsumer.prototype._version = 3;
// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch(order){
        case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
        case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
        default:
            throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;
    for(var i = 0, n = mappings.length; i < n; i++){
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        if (source !== null) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
        });
    }
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
        return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while(mapping && mapping.originalLine === originalLine){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        } else {
            var originalColumn = mapping.originalColumn;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        }
    }
    return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);
    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
    }
    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for(i = 0; i < this._absoluteSources.length; ++i){
        if (this._absoluteSources[i] == aSource) {
            return i;
        }
    }
    return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for(var i = 0, length = generatedMappings.length; i < length; i++){
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */ BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function() {
        return this._absoluteSources.slice();
    }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */ function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;
    if (n <= 1) {
        return;
    } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
            array[start] = b;
            array[start + 1] = a;
        }
    } else if (n < 20) {
        for(let i = start; i < l; i++){
            for(let j = i; j > start; j--){
                let a = array[j - 1];
                let b = array[j];
                if (compareGenerated(a, b) <= 0) {
                    break;
                }
                array[j - 1] = b;
                array[j] = a;
            }
        }
    } else {
        quickSort(array, compareGenerated, start);
    }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while(index < length){
        if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ',') {
            index++;
        } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for(end = index; end < length; end++){
                if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                }
            }
            str = aStr.slice(index, end);
            segment = [];
            while(index < end){
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
            }
            if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
            }
            if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
            }
            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
                let currentSource = mapping.source;
                while(originalMappings.length <= currentSource){
                    originalMappings.push(null);
                }
                if (originalMappings[currentSource] === null) {
                    originalMappings[currentSource] = [];
                }
                originalMappings[currentSource].push(mapping);
            }
        }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for(var i = 0; i < originalMappings.length; i++){
        if (originalMappings[i] != null) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
    }
    this.__originalMappings = [].concat(...originalMappings);
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for(var index = 0; index < this._generatedMappings.length; ++index){
        var mapping = this._generatedMappings[index];
        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
            }
        }
        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
    }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
                name = this._names.at(name);
            }
            return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
            };
        }
    }
    return {
        source: null,
        line: null,
        column: null,
        name: null
    };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
        return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
        return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
        return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
    }
    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
        return {
            line: null,
            column: null,
            lastColumn: null
        };
    }
    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
            return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
        }
    }
    return {
        line: null,
        column: null,
        lastColumn: null
    };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
        line: -1,
        column: 0
    };
    this._sections = sections.map(function(s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        };
    });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */ IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function() {
        var sources = [];
        for(var i = 0; i < this._sections.length; i++){
            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
            return cmp;
        }
        return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
        return {
            source: null,
            line: null,
            column: null,
            name: null
        };
    }
    return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
    });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === '') {
            return content;
        }
    }
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
            var ret = {
                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
        }
    }
    return {
        line: null,
        column: null
    };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for(var j = 0; j < sectionMappings.length; j++){
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            if (source !== null) {
                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            }
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
            }
            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
            }
        }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}}),
"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;
// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;
// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();
    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        "TURBOPACK unreachable";
        function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
    };
    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
            // The remaining code is added without mapping
            } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[remainingLinesIndex] || '';
                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
            }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while(lastGeneratedLine < mapping.generatedLine){
            node.add(shiftNextLine());
            lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
        }
    });
    return node;
    "TURBOPACK unreachable";
    function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
            node.add(code);
        } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
    }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
            this.add(chunk);
        }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
            this.children.push(aChunk);
        }
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
        for(var i = aChunk.length - 1; i >= 0; i--){
            this.prepend(aChunk[i]);
        }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for(var i = 0, len = this.children.length; i < len; i++){
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
            chunk.walk(aFn);
        } else {
            if (chunk !== '') {
                aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }
        }
    }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */ SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
        newChildren = [];
        for(i = 0; i < len - 1; i++){
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
    }
    return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
        this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for(var i = 0, len = this.children.length; i < len; i++){
        if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
        }
    }
    var sources = Object.keys(this.sourceContents);
    for(var i = 0, len = sources.length; i < len; i++){
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */ SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
        str += chunk;
    });
    return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({
                    source: original.source,
                    original: {
                        line: original.line,
                        column: original.column
                    },
                    generated: {
                        line: generated.line,
                        column: generated.column
                    },
                    name: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
        } else if (sourceMappingActive) {
            map.addMapping({
                generated: {
                    line: generated.line,
                    column: generated.column
                }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
        }
        for(var idx = 0, length = chunk.length; idx < length; idx++){
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                // Mappings end at eol
                if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                } else if (sourceMappingActive) {
                    map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                }
            } else {
                generated.column++;
            }
        }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
    });
    return {
        code: generated.code,
        map: map
    };
};
exports.SourceNode = SourceNode;
}}),
"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
exports.SourceMapConsumer = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)").SourceMapConsumer;
exports.SourceNode = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)").SourceNode;
}}),
"[project]/node_modules/cssesc/cssesc.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! https://mths.be/cssesc v3.0.0 by @mathias */ 'use strict';
var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
    if (!options) {
        return defaults;
    }
    var result = {};
    for(var key in defaults){
        // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
        // only recognized option names are used.
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
    }
    return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
    options = merge(options, cssesc.options);
    if (options.quotes != 'single' && options.quotes != 'double') {
        options.quotes = 'single';
    }
    var quote = options.quotes == 'double' ? '"' : '\'';
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = '';
    var counter = 0;
    var length = string.length;
    while(counter < length){
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        // If it’s not a printable ASCII character…
        if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
                // It’s a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                    // next character is low surrogate
                    codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
                } else {
                    // It’s an unmatched surrogate; only append this code unit, in case
                    // the next code unit is the high surrogate of a surrogate pair.
                    counter--;
                }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        } else {
            if (options.escapeEverything) {
                if (regexAnySingleEscape.test(character)) {
                    value = '\\' + character;
                } else {
                    value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
                }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
                value = '\\' + character;
            } else {
                value = character;
            }
        }
        output += value;
    }
    if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
        } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
        }
    }
    // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
    // since they’re redundant. Note that this is only possible if the escape
    // sequence isn’t preceded by an odd number of backslashes.
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
            // It’s not safe to remove the space, so don’t.
            return $0;
        }
        // Strip the space.
        return ($1 || '') + $2;
    });
    if (!isIdentifier && options.wrap) {
        return quote + output + quote;
    }
    return output;
};
// Expose default options (so they can be overridden globally).
cssesc.options = {
    'escapeEverything': false,
    'isIdentifier': false,
    'quotes': 'single',
    'wrap': false
};
cssesc.version = '3.0.0';
module.exports = cssesc;
}}),
"[project]/node_modules/util-deprecate/node.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").deprecate;
}}),
"[project]/node_modules/postcss-nested/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let parser = __turbopack_context__.r("[project]/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function parse(str, rule) {
    let nodes;
    let saver = parser((parsed)=>{
        nodes = parsed;
    });
    try {
        saver.processSync(str);
    } catch (e) {
        if (str.includes(':')) {
            throw rule ? rule.error('Missed semicolon') : e;
        } else {
            throw rule ? rule.error(e.message) : e;
        }
    }
    return nodes.at(0);
}
function replace(nodes, parent) {
    let replaced = false;
    nodes.each((i)=>{
        if (i.type === 'nesting') {
            let clonedParent = parent.clone();
            if (i.value !== '&') {
                i.replaceWith(parse(i.value.replace('&', clonedParent.toString())));
            } else {
                i.replaceWith(clonedParent);
            }
            replaced = true;
        } else if (i.nodes) {
            if (replace(i, parent)) {
                replaced = true;
            }
        }
    });
    return replaced;
}
function selectors(parent, child) {
    let result = [];
    parent.selectors.forEach((i)=>{
        let parentNode = parse(i, parent);
        child.selectors.forEach((j)=>{
            if (j.length) {
                let node = parse(j, child);
                let replaced = replace(node, parentNode);
                if (!replaced) {
                    node.prepend(parser.combinator({
                        value: ' '
                    }));
                    node.prepend(parentNode.clone());
                }
                result.push(node.toString());
            }
        });
    });
    return result;
}
function pickComment(comment, after) {
    if (comment && comment.type === 'comment') {
        after.after(comment);
        return comment;
    } else {
        return after;
    }
}
function createFnAtruleChilds(bubble) {
    return function atruleChilds(rule, atrule, bubbling) {
        let children = [];
        atrule.each((child)=>{
            if (child.type === 'comment') {
                children.push(child);
            } else if (child.type === 'decl') {
                children.push(child);
            } else if (child.type === 'rule' && bubbling) {
                child.selectors = selectors(rule, child);
            } else if (child.type === 'atrule') {
                if (child.nodes && bubble[child.name]) {
                    atruleChilds(rule, child, true);
                } else {
                    children.push(child);
                }
            }
        });
        if (bubbling) {
            if (children.length) {
                let clone = rule.clone({
                    nodes: []
                });
                for (let child of children){
                    clone.append(child);
                }
                atrule.prepend(clone);
            }
        }
    };
}
function pickDeclarations(selector, declarations, after, Rule) {
    let parent = new Rule({
        selector,
        nodes: []
    });
    for (let declaration of declarations){
        parent.append(declaration);
    }
    after.after(parent);
    return parent;
}
function atruleNames(defaults, custom) {
    let list = {};
    for (let i of defaults){
        list[i] = true;
    }
    if (custom) {
        for (let i of custom){
            let name = i.replace(/^@/, '');
            list[name] = true;
        }
    }
    return list;
}
module.exports = (opts = {})=>{
    let bubble = atruleNames([
        'media',
        'supports'
    ], opts.bubble);
    let atruleChilds = createFnAtruleChilds(bubble);
    let unwrap = atruleNames([
        'document',
        'font-face',
        'keyframes',
        '-webkit-keyframes',
        '-moz-keyframes'
    ], opts.unwrap);
    let preserveEmpty = opts.preserveEmpty;
    return {
        postcssPlugin: 'postcss-nested',
        Rule (rule, { Rule }) {
            let unwrapped = false;
            let after = rule;
            let copyDeclarations = false;
            let declarations = [];
            rule.each((child)=>{
                if (child.type === 'rule') {
                    if (declarations.length) {
                        after = pickDeclarations(rule.selector, declarations, after, Rule);
                        declarations = [];
                    }
                    copyDeclarations = true;
                    unwrapped = true;
                    child.selectors = selectors(rule, child);
                    after = pickComment(child.prev(), after);
                    after.after(child);
                    after = child;
                } else if (child.type === 'atrule') {
                    if (declarations.length) {
                        after = pickDeclarations(rule.selector, declarations, after, Rule);
                        declarations = [];
                    }
                    if (child.name === 'at-root') {
                        unwrapped = true;
                        atruleChilds(rule, child, false);
                        let nodes = child.nodes;
                        if (child.params) {
                            nodes = new Rule({
                                selector: child.params,
                                nodes
                            });
                        }
                        after.after(nodes);
                        after = nodes;
                        child.remove();
                    } else if (bubble[child.name]) {
                        copyDeclarations = true;
                        unwrapped = true;
                        atruleChilds(rule, child, true);
                        after = pickComment(child.prev(), after);
                        after.after(child);
                        after = child;
                    } else if (unwrap[child.name]) {
                        copyDeclarations = true;
                        unwrapped = true;
                        atruleChilds(rule, child, false);
                        after = pickComment(child.prev(), after);
                        after.after(child);
                        after = child;
                    } else if (copyDeclarations) {
                        declarations.push(child);
                    }
                } else if (child.type === 'decl' && copyDeclarations) {
                    declarations.push(child);
                }
            });
            if (declarations.length) {
                after = pickDeclarations(rule.selector, declarations, after, Rule);
            }
            if (unwrapped && preserveEmpty !== true) {
                rule.raws.semicolon = true;
                if (rule.nodes.length === 0) rule.remove();
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/@tailwindcss/nesting/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let postcss = __turbopack_context__.r("[project]/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)");
let postcssNested = __turbopack_context__.r("[project]/node_modules/postcss-nested/index.js [postcss] (ecmascript)");
module.exports = (opts = postcssNested)=>{
    return {
        postcssPlugin: '@tailwindcss/nesting',
        Once (root, { result }) {
            root.walkAtRules('screen', (rule)=>{
                rule.name = 'media';
                rule.params = `screen(${rule.params})`;
            });
            root.walkAtRules('apply', (rule)=>{
                rule.before(postcss.decl({
                    prop: '__apply',
                    value: rule.params
                }));
                rule.remove();
            });
            let plugin = (()=>{
                if (typeof opts === 'function') {
                    return opts;
                }
                if (typeof opts === 'string') {
                    return (()=>{
                        const e = new Error("Cannot find module as expression is too dynamic");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                }
                if (Object.keys(opts).length <= 0) {
                    return postcssNested;
                }
                throw new Error('@tailwindcss/nesting should be loaded with a nesting plugin.');
            })();
            postcss([
                plugin
            ]).process(root, result.opts).sync();
            root.walkDecls('__apply', (decl)=>{
                decl.before(postcss.atRule({
                    name: 'apply',
                    params: decl.value
                }));
                decl.remove();
            });
            return root;
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/node-releases/data/processed/envs.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("[{\"name\":\"nodejs\",\"version\":\"0.2.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.3.8.0\"},{\"name\":\"nodejs\",\"version\":\"0.3.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.5.1.0\"},{\"name\":\"nodejs\",\"version\":\"0.4.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.2.0\"},{\"name\":\"nodejs\",\"version\":\"0.5.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.8.25\"},{\"name\":\"nodejs\",\"version\":\"0.6.0\",\"date\":\"2011-11-04\",\"lts\":false,\"security\":false,\"v8\":\"3.6.6.6\"},{\"name\":\"nodejs\",\"version\":\"0.7.0\",\"date\":\"2012-01-17\",\"lts\":false,\"security\":false,\"v8\":\"3.8.6.0\"},{\"name\":\"nodejs\",\"version\":\"0.8.0\",\"date\":\"2012-06-22\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.10\"},{\"name\":\"nodejs\",\"version\":\"0.9.0\",\"date\":\"2012-07-20\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.15\"},{\"name\":\"nodejs\",\"version\":\"0.10.0\",\"date\":\"2013-03-11\",\"lts\":false,\"security\":false,\"v8\":\"3.14.5.8\"},{\"name\":\"nodejs\",\"version\":\"0.11.0\",\"date\":\"2013-03-28\",\"lts\":false,\"security\":false,\"v8\":\"3.17.13.0\"},{\"name\":\"nodejs\",\"version\":\"0.12.0\",\"date\":\"2015-02-06\",\"lts\":false,\"security\":false,\"v8\":\"3.28.73.0\"},{\"name\":\"nodejs\",\"version\":\"4.0.0\",\"date\":\"2015-09-08\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.30\"},{\"name\":\"nodejs\",\"version\":\"4.1.0\",\"date\":\"2015-09-17\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.33\"},{\"name\":\"nodejs\",\"version\":\"4.2.0\",\"date\":\"2015-10-12\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.3.0\",\"date\":\"2016-02-09\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.4.0\",\"date\":\"2016-03-08\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.5.0\",\"date\":\"2016-08-16\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.6.0\",\"date\":\"2016-09-27\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.7.0\",\"date\":\"2016-12-06\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.43\"},{\"name\":\"nodejs\",\"version\":\"4.8.0\",\"date\":\"2017-02-21\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.45\"},{\"name\":\"nodejs\",\"version\":\"4.9.0\",\"date\":\"2018-03-28\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.53\"},{\"name\":\"nodejs\",\"version\":\"5.0.0\",\"date\":\"2015-10-29\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.28\"},{\"name\":\"nodejs\",\"version\":\"5.1.0\",\"date\":\"2015-11-17\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.2.0\",\"date\":\"2015-12-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.3.0\",\"date\":\"2015-12-15\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.4.0\",\"date\":\"2016-01-06\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.5.0\",\"date\":\"2016-01-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.6.0\",\"date\":\"2016-02-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.7.0\",\"date\":\"2016-02-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.8.0\",\"date\":\"2016-03-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.9.0\",\"date\":\"2016-03-16\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.10.0\",\"date\":\"2016-04-01\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.11.0\",\"date\":\"2016-04-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.12.0\",\"date\":\"2016-06-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.32\"},{\"name\":\"nodejs\",\"version\":\"6.0.0\",\"date\":\"2016-04-26\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.1.0\",\"date\":\"2016-05-05\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.2.0\",\"date\":\"2016-05-17\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.47\"},{\"name\":\"nodejs\",\"version\":\"6.3.0\",\"date\":\"2016-07-06\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.52\"},{\"name\":\"nodejs\",\"version\":\"6.4.0\",\"date\":\"2016-08-12\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.60\"},{\"name\":\"nodejs\",\"version\":\"6.5.0\",\"date\":\"2016-08-26\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.81\"},{\"name\":\"nodejs\",\"version\":\"6.6.0\",\"date\":\"2016-09-14\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.7.0\",\"date\":\"2016-09-27\",\"lts\":false,\"security\":true,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.8.0\",\"date\":\"2016-10-12\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.9.0\",\"date\":\"2016-10-18\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.10.0\",\"date\":\"2017-02-21\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.93\"},{\"name\":\"nodejs\",\"version\":\"6.11.0\",\"date\":\"2017-06-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.102\"},{\"name\":\"nodejs\",\"version\":\"6.12.0\",\"date\":\"2017-11-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.108\"},{\"name\":\"nodejs\",\"version\":\"6.13.0\",\"date\":\"2018-02-10\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.14.0\",\"date\":\"2018-03-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.15.0\",\"date\":\"2018-11-27\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.16.0\",\"date\":\"2018-12-26\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.17.0\",\"date\":\"2019-02-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"7.0.0\",\"date\":\"2016-10-25\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.1.0\",\"date\":\"2016-11-08\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.2.0\",\"date\":\"2016-11-22\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.43\"},{\"name\":\"nodejs\",\"version\":\"7.3.0\",\"date\":\"2016-12-20\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.4.0\",\"date\":\"2017-01-04\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.5.0\",\"date\":\"2017-01-31\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.48\"},{\"name\":\"nodejs\",\"version\":\"7.6.0\",\"date\":\"2017-02-21\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.40\"},{\"name\":\"nodejs\",\"version\":\"7.7.0\",\"date\":\"2017-02-28\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.41\"},{\"name\":\"nodejs\",\"version\":\"7.8.0\",\"date\":\"2017-03-29\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.9.0\",\"date\":\"2017-04-11\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.10.0\",\"date\":\"2017-05-02\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"8.0.0\",\"date\":\"2017-05-30\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.1.0\",\"date\":\"2017-06-08\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.2.0\",\"date\":\"2017-07-19\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.3.0\",\"date\":\"2017-08-08\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.4.0\",\"date\":\"2017-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.5.0\",\"date\":\"2017-09-12\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.6.0\",\"date\":\"2017-09-26\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.7.0\",\"date\":\"2017-10-11\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.8.0\",\"date\":\"2017-10-24\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.9.0\",\"date\":\"2017-10-31\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.1.534.46\"},{\"name\":\"nodejs\",\"version\":\"8.10.0\",\"date\":\"2018-03-06\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.11.0\",\"date\":\"2018-03-28\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.12.0\",\"date\":\"2018-09-10\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.66\"},{\"name\":\"nodejs\",\"version\":\"8.13.0\",\"date\":\"2018-11-20\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.75\"},{\"name\":\"nodejs\",\"version\":\"8.16.0\",\"date\":\"2019-04-16\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.77\"},{\"name\":\"nodejs\",\"version\":\"8.17.0\",\"date\":\"2019-12-17\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.78\"},{\"name\":\"nodejs\",\"version\":\"9.0.0\",\"date\":\"2017-10-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.1.0\",\"date\":\"2017-11-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.2.0\",\"date\":\"2017-11-14\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.44\"},{\"name\":\"nodejs\",\"version\":\"9.3.0\",\"date\":\"2017-12-12\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.4.0\",\"date\":\"2018-01-10\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.5.0\",\"date\":\"2018-01-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.6.0\",\"date\":\"2018-02-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.7.0\",\"date\":\"2018-03-01\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.8.0\",\"date\":\"2018-03-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.9.0\",\"date\":\"2018-03-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.10.0\",\"date\":\"2018-03-28\",\"lts\":false,\"security\":true,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.11.0\",\"date\":\"2018-04-04\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"10.0.0\",\"date\":\"2018-04-24\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.24\"},{\"name\":\"nodejs\",\"version\":\"10.1.0\",\"date\":\"2018-05-08\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.27\"},{\"name\":\"nodejs\",\"version\":\"10.2.0\",\"date\":\"2018-05-23\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.3.0\",\"date\":\"2018-05-29\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.4.0\",\"date\":\"2018-06-06\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.43\"},{\"name\":\"nodejs\",\"version\":\"10.5.0\",\"date\":\"2018-06-20\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.6.0\",\"date\":\"2018-07-04\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.7.0\",\"date\":\"2018-07-18\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.8.0\",\"date\":\"2018-08-01\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.9.0\",\"date\":\"2018-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.24\"},{\"name\":\"nodejs\",\"version\":\"10.10.0\",\"date\":\"2018-09-06\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.30\"},{\"name\":\"nodejs\",\"version\":\"10.11.0\",\"date\":\"2018-09-19\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.12.0\",\"date\":\"2018-10-10\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.13.0\",\"date\":\"2018-10-30\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.16.0\",\"date\":\"2019-05-28\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.17.0\",\"date\":\"2019-10-22\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.18.0\",\"date\":\"2019-12-17\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.19.0\",\"date\":\"2020-02-05\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.20.0\",\"date\":\"2020-03-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.21.0\",\"date\":\"2020-06-02\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.22.0\",\"date\":\"2020-07-21\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.23.0\",\"date\":\"2020-10-27\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.24.0\",\"date\":\"2021-02-23\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"11.0.0\",\"date\":\"2018-10-23\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.28\"},{\"name\":\"nodejs\",\"version\":\"11.1.0\",\"date\":\"2018-10-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.32\"},{\"name\":\"nodejs\",\"version\":\"11.2.0\",\"date\":\"2018-11-15\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.3.0\",\"date\":\"2018-11-27\",\"lts\":false,\"security\":true,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.4.0\",\"date\":\"2018-12-07\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.5.0\",\"date\":\"2018-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.6.0\",\"date\":\"2018-12-26\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.7.0\",\"date\":\"2019-01-17\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.8.0\",\"date\":\"2019-01-24\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.9.0\",\"date\":\"2019-01-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.10.0\",\"date\":\"2019-02-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.11.0\",\"date\":\"2019-03-05\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.12.0\",\"date\":\"2019-03-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.13.0\",\"date\":\"2019-03-28\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.14.0\",\"date\":\"2019-04-10\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.15.0\",\"date\":\"2019-04-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"12.0.0\",\"date\":\"2019-04-23\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.1.0\",\"date\":\"2019-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.2.0\",\"date\":\"2019-05-07\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.3.0\",\"date\":\"2019-05-21\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.4.0\",\"date\":\"2019-06-04\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.5.0\",\"date\":\"2019-06-26\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.6.0\",\"date\":\"2019-07-03\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.7.0\",\"date\":\"2019-07-23\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.8.0\",\"date\":\"2019-08-06\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.9.0\",\"date\":\"2019-08-20\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.10.0\",\"date\":\"2019-09-04\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.11.0\",\"date\":\"2019-09-25\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.11\"},{\"name\":\"nodejs\",\"version\":\"12.12.0\",\"date\":\"2019-10-11\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.13.0\",\"date\":\"2019-10-21\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.14.0\",\"date\":\"2019-12-17\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.15.0\",\"date\":\"2020-02-05\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.16.0\",\"date\":\"2020-02-11\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.17.0\",\"date\":\"2020-05-26\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.18.0\",\"date\":\"2020-06-02\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.19.0\",\"date\":\"2020-10-06\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.20.0\",\"date\":\"2020-11-24\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.21.0\",\"date\":\"2021-02-23\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.22.0\",\"date\":\"2021-03-30\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"13.0.0\",\"date\":\"2019-10-22\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.1.0\",\"date\":\"2019-11-05\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.2.0\",\"date\":\"2019-11-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.23\"},{\"name\":\"nodejs\",\"version\":\"13.3.0\",\"date\":\"2019-12-03\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.4.0\",\"date\":\"2019-12-17\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.5.0\",\"date\":\"2019-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.6.0\",\"date\":\"2020-01-07\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.7.0\",\"date\":\"2020-01-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.8.0\",\"date\":\"2020-02-05\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.9.0\",\"date\":\"2020-02-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.10.0\",\"date\":\"2020-03-04\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.11.0\",\"date\":\"2020-03-12\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.12.0\",\"date\":\"2020-03-26\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.13.0\",\"date\":\"2020-04-14\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.14.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"14.0.0\",\"date\":\"2020-04-21\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.30\"},{\"name\":\"nodejs\",\"version\":\"14.1.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.2.0\",\"date\":\"2020-05-05\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.3.0\",\"date\":\"2020-05-19\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.4.0\",\"date\":\"2020-06-02\",\"lts\":false,\"security\":true,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.5.0\",\"date\":\"2020-06-30\",\"lts\":false,\"security\":false,\"v8\":\"8.3.110.9\"},{\"name\":\"nodejs\",\"version\":\"14.6.0\",\"date\":\"2020-07-20\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.7.0\",\"date\":\"2020-07-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.8.0\",\"date\":\"2020-08-11\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.9.0\",\"date\":\"2020-08-27\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.10.0\",\"date\":\"2020-09-08\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.11.0\",\"date\":\"2020-09-15\",\"lts\":false,\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.12.0\",\"date\":\"2020-09-22\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.13.0\",\"date\":\"2020-09-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.14.0\",\"date\":\"2020-10-15\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.15.0\",\"date\":\"2020-10-27\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.16.0\",\"date\":\"2021-02-23\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.17.0\",\"date\":\"2021-05-11\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.18.0\",\"date\":\"2021-09-28\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.19.0\",\"date\":\"2022-02-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.20.0\",\"date\":\"2022-07-07\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.21.0\",\"date\":\"2022-11-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"15.0.0\",\"date\":\"2020-10-20\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.16\"},{\"name\":\"nodejs\",\"version\":\"15.1.0\",\"date\":\"2020-11-04\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.2.0\",\"date\":\"2020-11-10\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.3.0\",\"date\":\"2020-11-24\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.4.0\",\"date\":\"2020-12-09\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.5.0\",\"date\":\"2020-12-22\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.6.0\",\"date\":\"2021-01-14\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.7.0\",\"date\":\"2021-01-25\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.8.0\",\"date\":\"2021-02-02\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.9.0\",\"date\":\"2021-02-18\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.10.0\",\"date\":\"2021-02-23\",\"lts\":false,\"security\":true,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.11.0\",\"date\":\"2021-03-03\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.12.0\",\"date\":\"2021-03-17\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.13.0\",\"date\":\"2021-03-31\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.14.0\",\"date\":\"2021-04-06\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"16.0.0\",\"date\":\"2021-04-20\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.17\"},{\"name\":\"nodejs\",\"version\":\"16.1.0\",\"date\":\"2021-05-04\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.24\"},{\"name\":\"nodejs\",\"version\":\"16.2.0\",\"date\":\"2021-05-19\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.3.0\",\"date\":\"2021-06-03\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.4.0\",\"date\":\"2021-06-23\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.36\"},{\"name\":\"nodejs\",\"version\":\"16.5.0\",\"date\":\"2021-07-14\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.38\"},{\"name\":\"nodejs\",\"version\":\"16.6.0\",\"date\":\"2021-07-29\",\"lts\":false,\"security\":true,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.7.0\",\"date\":\"2021-08-18\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.8.0\",\"date\":\"2021-08-25\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.9.0\",\"date\":\"2021-09-07\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.16\"},{\"name\":\"nodejs\",\"version\":\"16.10.0\",\"date\":\"2021-09-22\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.19\"},{\"name\":\"nodejs\",\"version\":\"16.11.0\",\"date\":\"2021-10-08\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.12.0\",\"date\":\"2021-10-20\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.13.0\",\"date\":\"2021-10-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.14.0\",\"date\":\"2022-02-08\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.15.0\",\"date\":\"2022-04-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.16.0\",\"date\":\"2022-07-07\",\"lts\":\"Gallium\",\"security\":true,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.17.0\",\"date\":\"2022-08-16\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.18.0\",\"date\":\"2022-10-12\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.19.0\",\"date\":\"2022-12-13\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.20.0\",\"date\":\"2023-03-28\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"17.0.0\",\"date\":\"2021-10-19\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.21\"},{\"name\":\"nodejs\",\"version\":\"17.1.0\",\"date\":\"2021-11-09\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.25\"},{\"name\":\"nodejs\",\"version\":\"17.2.0\",\"date\":\"2021-11-30\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.14\"},{\"name\":\"nodejs\",\"version\":\"17.3.0\",\"date\":\"2021-12-17\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.4.0\",\"date\":\"2022-01-18\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.5.0\",\"date\":\"2022-02-10\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.6.0\",\"date\":\"2022-02-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.7.0\",\"date\":\"2022-03-09\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.8.0\",\"date\":\"2022-03-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.9.0\",\"date\":\"2022-04-07\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"18.0.0\",\"date\":\"2022-04-18\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.1.0\",\"date\":\"2022-05-03\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.2.0\",\"date\":\"2022-05-17\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.3.0\",\"date\":\"2022-06-02\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.4.0\",\"date\":\"2022-06-16\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.5.0\",\"date\":\"2022-07-06\",\"lts\":false,\"security\":true,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.6.0\",\"date\":\"2022-07-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.7.0\",\"date\":\"2022-07-26\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.8.0\",\"date\":\"2022-08-24\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.9.0\",\"date\":\"2022-09-07\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.10.0\",\"date\":\"2022-09-28\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.11.0\",\"date\":\"2022-10-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.12.0\",\"date\":\"2022-10-25\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.13.0\",\"date\":\"2023-01-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.14.0\",\"date\":\"2023-02-01\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.15.0\",\"date\":\"2023-03-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.16.0\",\"date\":\"2023-04-12\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.17.0\",\"date\":\"2023-07-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.18.0\",\"date\":\"2023-09-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.19.0\",\"date\":\"2023-11-29\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.20.0\",\"date\":\"2024-03-26\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"19.0.0\",\"date\":\"2022-10-17\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.13\"},{\"name\":\"nodejs\",\"version\":\"19.1.0\",\"date\":\"2022-11-14\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.20\"},{\"name\":\"nodejs\",\"version\":\"19.2.0\",\"date\":\"2022-11-29\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.20\"},{\"name\":\"nodejs\",\"version\":\"19.3.0\",\"date\":\"2022-12-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.21\"},{\"name\":\"nodejs\",\"version\":\"19.4.0\",\"date\":\"2023-01-05\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.5.0\",\"date\":\"2023-01-24\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.6.0\",\"date\":\"2023-02-01\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.7.0\",\"date\":\"2023-02-21\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.8.0\",\"date\":\"2023-03-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.9.0\",\"date\":\"2023-04-10\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"20.0.0\",\"date\":\"2023-04-17\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.4\"},{\"name\":\"nodejs\",\"version\":\"20.1.0\",\"date\":\"2023-05-03\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.2.0\",\"date\":\"2023-05-16\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.3.0\",\"date\":\"2023-06-08\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.4.0\",\"date\":\"2023-07-04\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.5.0\",\"date\":\"2023-07-19\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.6.0\",\"date\":\"2023-08-23\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.7.0\",\"date\":\"2023-09-18\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.8.0\",\"date\":\"2023-09-28\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.9.0\",\"date\":\"2023-10-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.10.0\",\"date\":\"2023-11-22\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.11.0\",\"date\":\"2024-01-09\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.12.0\",\"date\":\"2024-03-26\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.13.0\",\"date\":\"2024-05-07\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.14.0\",\"date\":\"2024-05-28\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.15.0\",\"date\":\"2024-06-20\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.16.0\",\"date\":\"2024-07-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.17.0\",\"date\":\"2024-08-21\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.18.0\",\"date\":\"2024-10-03\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"21.0.0\",\"date\":\"2023-10-17\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.13\"},{\"name\":\"nodejs\",\"version\":\"21.1.0\",\"date\":\"2023-10-24\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.15\"},{\"name\":\"nodejs\",\"version\":\"21.2.0\",\"date\":\"2023-11-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.3.0\",\"date\":\"2023-11-30\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.4.0\",\"date\":\"2023-12-05\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.5.0\",\"date\":\"2023-12-19\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.6.0\",\"date\":\"2024-01-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.7.0\",\"date\":\"2024-03-06\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"22.0.0\",\"date\":\"2024-04-24\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.1.0\",\"date\":\"2024-05-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.2.0\",\"date\":\"2024-05-15\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.3.0\",\"date\":\"2024-06-11\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.20\"},{\"name\":\"nodejs\",\"version\":\"22.4.0\",\"date\":\"2024-07-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.5.0\",\"date\":\"2024-07-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.6.0\",\"date\":\"2024-08-06\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.7.0\",\"date\":\"2024-08-21\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.8.0\",\"date\":\"2024-09-03\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.9.0\",\"date\":\"2024-09-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.10.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.11.0\",\"date\":\"2024-10-29\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.12.0\",\"date\":\"2024-12-02\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"23.0.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.26\"},{\"name\":\"nodejs\",\"version\":\"23.1.0\",\"date\":\"2024-10-24\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.2.0\",\"date\":\"2024-11-11\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.3.0\",\"date\":\"2024-11-20\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"}]"));}}),
"[project]/node_modules/node-releases/data/release-schedule/release-schedule.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"v0.8\":{\"start\":\"2012-06-25\",\"end\":\"2014-07-31\"},\"v0.10\":{\"start\":\"2013-03-11\",\"end\":\"2016-10-31\"},\"v0.12\":{\"start\":\"2015-02-06\",\"end\":\"2016-12-31\"},\"v4\":{\"start\":\"2015-09-08\",\"lts\":\"2015-10-12\",\"maintenance\":\"2017-04-01\",\"end\":\"2018-04-30\",\"codename\":\"Argon\"},\"v5\":{\"start\":\"2015-10-29\",\"maintenance\":\"2016-04-30\",\"end\":\"2016-06-30\"},\"v6\":{\"start\":\"2016-04-26\",\"lts\":\"2016-10-18\",\"maintenance\":\"2018-04-30\",\"end\":\"2019-04-30\",\"codename\":\"Boron\"},\"v7\":{\"start\":\"2016-10-25\",\"maintenance\":\"2017-04-30\",\"end\":\"2017-06-30\"},\"v8\":{\"start\":\"2017-05-30\",\"lts\":\"2017-10-31\",\"maintenance\":\"2019-01-01\",\"end\":\"2019-12-31\",\"codename\":\"Carbon\"},\"v9\":{\"start\":\"2017-10-01\",\"maintenance\":\"2018-04-01\",\"end\":\"2018-06-30\"},\"v10\":{\"start\":\"2018-04-24\",\"lts\":\"2018-10-30\",\"maintenance\":\"2020-05-19\",\"end\":\"2021-04-30\",\"codename\":\"Dubnium\"},\"v11\":{\"start\":\"2018-10-23\",\"maintenance\":\"2019-04-22\",\"end\":\"2019-06-01\"},\"v12\":{\"start\":\"2019-04-23\",\"lts\":\"2019-10-21\",\"maintenance\":\"2020-11-30\",\"end\":\"2022-04-30\",\"codename\":\"Erbium\"},\"v13\":{\"start\":\"2019-10-22\",\"maintenance\":\"2020-04-01\",\"end\":\"2020-06-01\"},\"v14\":{\"start\":\"2020-04-21\",\"lts\":\"2020-10-27\",\"maintenance\":\"2021-10-19\",\"end\":\"2023-04-30\",\"codename\":\"Fermium\"},\"v15\":{\"start\":\"2020-10-20\",\"maintenance\":\"2021-04-01\",\"end\":\"2021-06-01\"},\"v16\":{\"start\":\"2021-04-20\",\"lts\":\"2021-10-26\",\"maintenance\":\"2022-10-18\",\"end\":\"2023-09-11\",\"codename\":\"Gallium\"},\"v17\":{\"start\":\"2021-10-19\",\"maintenance\":\"2022-04-01\",\"end\":\"2022-06-01\"},\"v18\":{\"start\":\"2022-04-19\",\"lts\":\"2022-10-25\",\"maintenance\":\"2023-10-18\",\"end\":\"2025-04-30\",\"codename\":\"Hydrogen\"},\"v19\":{\"start\":\"2022-10-18\",\"maintenance\":\"2023-04-01\",\"end\":\"2023-06-01\"},\"v20\":{\"start\":\"2023-04-18\",\"lts\":\"2023-10-24\",\"maintenance\":\"2024-10-22\",\"end\":\"2026-04-30\",\"codename\":\"Iron\"},\"v21\":{\"start\":\"2023-10-17\",\"maintenance\":\"2024-04-01\",\"end\":\"2024-06-01\"},\"v22\":{\"start\":\"2024-04-24\",\"lts\":\"2024-10-29\",\"maintenance\":\"2025-10-21\",\"end\":\"2027-04-30\",\"codename\":\"Jod\"},\"v23\":{\"start\":\"2024-10-16\",\"maintenance\":\"2025-04-01\",\"end\":\"2025-06-01\"},\"v24\":{\"start\":\"2025-04-22\",\"lts\":\"2025-10-28\",\"maintenance\":\"2026-10-20\",\"end\":\"2028-04-30\",\"codename\":\"\"}}"));}}),
"[project]/node_modules/electron-to-chromium/versions.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "32.3": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "33.4": "130",
    "34.0": "132",
    "34.1": "132",
    "34.2": "132",
    "34.3": "132",
    "34.4": "132",
    "34.5": "132",
    "35.0": "134",
    "35.1": "134",
    "35.2": "134",
    "35.3": "134",
    "35.4": "134",
    "35.5": "134",
    "36.0": "136",
    "36.1": "136",
    "36.2": "136",
    "36.3": "136",
    "36.4": "136",
    "36.5": "136",
    "37.0": "138"
};
}}),
"[project]/node_modules/normalize-range/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = {
    wrap: wrapRange,
    limit: limitRange,
    validate: validateRange,
    test: testRange,
    curry: curry,
    name: name
};
function wrapRange(min, max, value) {
    var maxLessMin = max - min;
    return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
}
function limitRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
}
function validateRange(min, max, value, minExclusive, maxExclusive) {
    if (!testRange(min, max, value, minExclusive, maxExclusive)) {
        throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
    }
    return value;
}
function testRange(min, max, value, minExclusive, maxExclusive) {
    return !(value < min || value > max || maxExclusive && value === max || minExclusive && value === min);
}
function name(min, max, minExcl, maxExcl) {
    return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
}
function curry(min, max, minExclusive, maxExclusive) {
    var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
    return {
        wrap: wrapRange.bind(null, min, max),
        limit: limitRange.bind(null, min, max),
        validate: function(value) {
            return validateRange(min, max, value, minExclusive, maxExclusive);
        },
        test: function(value) {
            return testRange(min, max, value, minExclusive, maxExclusive);
        },
        toString: boundNameFn,
        name: boundNameFn
    };
}
}}),
"[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code >= 48 && code <= 57) {
        return true;
    }
    return false;
}
// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
        return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
        pos++;
    }
    while(pos < length){
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
            break;
        }
        pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
    };
};
}}),
"[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;
module.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [
        {
            nodes: tokens
        }
    ];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while(pos < max){
        // Whitespaces
        if (code <= 32) {
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
                after = token;
            } else if (prev && prev.type === "div") {
                prev.after = token;
                prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                before = token;
            } else {
                tokens.push({
                    type: "space",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        // Quotes
        } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
                type: "string",
                sourceIndex: pos,
                quote: quote
            };
            do {
                escape = false;
                next = value.indexOf(quote, next + 1);
                if (~next) {
                    escapePos = next;
                    while(value.charCodeAt(escapePos - 1) === backslash){
                        escapePos -= 1;
                        escape = !escape;
                    }
                } else {
                    value += quote;
                    next = value.length - 1;
                    token.unclosed = true;
                }
            }while (escape)
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);
        // Comments
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
                type: "comment",
                sourceIndex: pos,
                sourceEndIndex: next + 2
            };
            if (next === -1) {
                token.unclosed = true;
                next = value.length;
                token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value.charCodeAt(pos);
        // Operation within calc
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
                type: "word",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token
            });
            pos += 1;
            code = value.charCodeAt(pos);
        // Dividers
        } else if (code === slash || code === comma || code === colon) {
            token = value[pos];
            tokens.push({
                type: "div",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token,
                before: before,
                after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
        // Open parentheses
        } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            parenthesesOpenPos = pos;
            token = {
                type: "function",
                sourceIndex: pos - name.length,
                value: name,
                before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                next -= 1;
                do {
                    escape = false;
                    next = value.indexOf(")", next + 1);
                    if (~next) {
                        escapePos = next;
                        while(value.charCodeAt(escapePos - 1) === backslash){
                            escapePos -= 1;
                            escape = !escape;
                        }
                    } else {
                        value += ")";
                        next = value.length - 1;
                        token.unclosed = true;
                    }
                }while (escape)
                // Whitespaces before closed
                whitespacePos = next;
                do {
                    whitespacePos -= 1;
                    code = value.charCodeAt(whitespacePos);
                }while (code <= 32)
                if (parenthesesOpenPos < whitespacePos) {
                    if (pos !== whitespacePos + 1) {
                        token.nodes = [
                            {
                                type: "word",
                                sourceIndex: pos,
                                sourceEndIndex: whitespacePos + 1,
                                value: value.slice(pos, whitespacePos + 1)
                            }
                        ];
                    } else {
                        token.nodes = [];
                    }
                    if (token.unclosed && whitespacePos + 1 !== next) {
                        token.after = "";
                        token.nodes.push({
                            type: "space",
                            sourceIndex: whitespacePos + 1,
                            sourceEndIndex: next,
                            value: value.slice(whitespacePos + 1, next)
                        });
                    } else {
                        token.after = value.slice(whitespacePos + 1, next);
                        token.sourceEndIndex = next;
                    }
                } else {
                    token.after = "";
                    token.nodes = [];
                }
                pos = next + 1;
                token.sourceEndIndex = token.unclosed ? next : pos;
                code = value.charCodeAt(pos);
                tokens.push(token);
            } else {
                balanced += 1;
                token.after = "";
                token.sourceEndIndex = pos + 1;
                tokens.push(token);
                stack.push(token);
                tokens = token.nodes = [];
                parent = token;
            }
            name = "";
        // Close parentheses
        } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
        // Words
        } else {
            next = pos;
            do {
                if (code === backslash) {
                    next += 1;
                }
                next += 1;
                code = value.charCodeAt(next);
            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced))
            token = value.slice(pos, next);
            if (openParentheses === code) {
                name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                tokens.push({
                    type: "unicode-range",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            } else {
                tokens.push({
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        }
    }
    for(pos = stack.length - 1; pos; pos -= 1){
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
};
}}),
"[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for(i = 0, max = nodes.length; i < max; i += 1){
        node = nodes[i];
        if (!bubble) {
            result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
        }
        if (bubble) {
            cb(node, i, nodes);
        }
    }
};
}}),
"[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
        return customResult;
    } else if (type === "word" || type === "space") {
        return value;
    } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
            return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
}
function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
        result = "";
        for(i = nodes.length - 1; ~i; i -= 1){
            result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
    }
    return stringifyNode(nodes, custom);
}
module.exports = stringify;
}}),
"[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var parse = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)");
var walk = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)");
var stringify = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)");
function ValueParser(value) {
    if (this instanceof ValueParser) {
        this.nodes = parse(value);
        return this;
    }
    return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
};
ValueParser.unit = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)");
ValueParser.walk = walk;
ValueParser.stringify = stringify;
module.exports = ValueParser;
}}),
"[project]/node_modules/fraction.js/fraction.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ /**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <numerator>, 1 => <denominator> ]
 * [ n => <numerator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */ (function(root) {
    "use strict";
    // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
    var MAX_CYCLE_LEN = 2000;
    // Parsed data to avoid calling "new" all the time
    var P = {
        "s": 1,
        "n": 0,
        "d": 1
    };
    function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
            throw InvalidParameter();
        }
        return n * s;
    }
    // Creates a new Fraction internally without the need of the bulky constructor
    function newFraction(n, d) {
        if (d === 0) {
            throw DivisionByZero();
        }
        var f = Object.create(Fraction.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
    }
    function factorize(num) {
        var factors = {};
        var n = num;
        var i = 2;
        var s = 4;
        while(s <= n){
            while(n % i === 0){
                n /= i;
                factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
        }
        if (n !== num) {
            if (n > 1) factors[n] = (factors[n] || 0) + 1;
        } else {
            factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
    }
    var parse = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 10000000;
        var M;
        if (p1 === undefined || p1 === null) {
        /* void */ } else if (p2 !== undefined) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
                throw NonIntegerParameter();
            }
        } else switch(typeof p1){
            case "object":
                {
                    if ("d" in p1 && "n" in p1) {
                        n = p1["n"];
                        d = p1["d"];
                        if ("s" in p1) n *= p1["s"];
                    } else if (0 in p1) {
                        n = p1[0];
                        if (1 in p1) d = p1[1];
                    } else {
                        throw InvalidParameter();
                    }
                    s = n * d;
                    break;
                }
            case "number":
                {
                    if (p1 < 0) {
                        s = p1;
                        p1 = -p1;
                    }
                    if (p1 % 1 === 0) {
                        n = p1;
                    } else if (p1 > 0) {
                        if (p1 >= 1) {
                            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                            p1 /= z;
                        }
                        // Using Farey Sequences
                        // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/
                        while(B <= N && D <= N){
                            M = (A + C) / (B + D);
                            if (p1 === M) {
                                if (B + D <= N) {
                                    n = A + C;
                                    d = B + D;
                                } else if (D > B) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                                break;
                            } else {
                                if (p1 > M) {
                                    A += C;
                                    B += D;
                                } else {
                                    C += A;
                                    D += B;
                                }
                                if (B > N) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                            }
                        }
                        n *= z;
                    } else if (isNaN(p1) || isNaN(p2)) {
                        d = n = NaN;
                    }
                    break;
                }
            case "string":
                {
                    B = p1.match(/\d+|./g);
                    if (B === null) throw InvalidParameter();
                    if (B[A] === '-') {
                        s = -1;
                        A++;
                    } else if (B[A] === '+') {
                        A++;
                    }
                    if (B.length === A + 1) {
                        w = assign(B[A++], s);
                    } else if (B[A + 1] === '.' || B[A] === '.') {
                        if (B[A] !== '.') {
                            v = assign(B[A++], s);
                        }
                        A++;
                        // Check for decimal places
                        if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                            w = assign(B[A], s);
                            y = Math.pow(10, B[A].length);
                            A++;
                        }
                        // Check for repeating places
                        if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                            x = assign(B[A + 1], s);
                            z = Math.pow(10, B[A + 1].length) - 1;
                            A += 3;
                        }
                    } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                        w = assign(B[A], s);
                        y = assign(B[A + 2], 1);
                        A += 3;
                    } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                        v = assign(B[A], s);
                        w = assign(B[A + 2], s);
                        y = assign(B[A + 4], 1);
                        A += 5;
                    }
                    if (B.length <= A) {
                        d = y * z;
                        s = /* void */ n = x + d * v + z * w;
                        break;
                    }
                /* Fall through on error */ }
            default:
                throw InvalidParameter();
        }
        if (d === 0) {
            throw DivisionByZero();
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
    };
    function modpow(b, e, m) {
        var r = 1;
        for(; e > 0; b = b * b % m, e >>= 1){
            if (e & 1) {
                r = r * b % m;
            }
        }
        return r;
    }
    function cycleLen(n, d) {
        for(; d % 2 === 0; d /= 2){}
        for(; d % 5 === 0; d /= 5){}
        if (d === 1) return 0;
        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.
        var rem = 10 % d;
        var t = 1;
        for(; rem !== 1; t++){
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }
        return t;
    }
    function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for(var t = 0; t < 300; t++){
            // Solve 10^s == 10^(s+t) (mod d)
            if (rem1 === rem2) return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
        }
        return 0;
    }
    function gcd(a, b) {
        if (!a) return b;
        if (!b) return a;
        while(1){
            a %= b;
            if (!a) return b;
            b %= a;
            if (!b) return a;
        }
    }
    ;
    /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */ function Fraction(a, b) {
        parse(a, b);
        if (this instanceof Fraction) {
            a = gcd(P["d"], P["n"]); // Abuse variable a
            this["s"] = P["s"];
            this["n"] = P["n"] / a;
            this["d"] = P["d"] / a;
        } else {
            return newFraction(P['s'] * P['n'], P['d']);
        }
    }
    var DivisionByZero = function() {
        return new Error("Division by Zero");
    };
    var InvalidParameter = function() {
        return new Error("Invalid argument");
    };
    var NonIntegerParameter = function() {
        return new Error("Parameters must be integer");
    };
    Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/ "abs": function() {
            return newFraction(this["n"], this["d"]);
        },
        /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/ "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/ "add": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/ "sub": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/ "mul": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/ "div": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
        },
        /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/ "clone": function() {
            return newFraction(this['s'] * this['n'], this['d']);
        },
        /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/ "mod": function(a, b) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return new Fraction(NaN);
            }
            if (a === undefined) {
                return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P["n"] && 0 === this["d"]) {
                throw DivisionByZero();
            }
            /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/ /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */ return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */ "gcd": function(a, b) {
            parse(a, b);
            // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)
            return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */ "lcm": function(a, b) {
            parse(a, b);
            // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)
            if (P["n"] === 0 && this["n"] === 0) {
                return newFraction(0, 1);
            }
            return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },
        /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/ "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/ "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/ "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational number to a multiple of another rational number
     *
     * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
     **/ "roundTo": function(a, b) {
            /*
      k * x/y ≤ a/b < (k+1) * x/y
      ⇔ k ≤ a/b / (x/y) < (k+1)
      ⇔ k = floor(a/b * y/x)
      */ parse(a, b);
            return newFraction(this['s'] * Math.round(this['n'] * P['d'] / (this['d'] * P['n'])) * P['n'], P['d']);
        },
        /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/ "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */ "pow": function(a, b) {
            parse(a, b);
            // Trivial case when exp is an integer
            if (P['d'] === 1) {
                if (P['s'] < 0) {
                    return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
                } else {
                    return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
                }
            }
            // Negative roots become complex
            //     (-a/b)^(c/d) = x
            // <=> (-1)^(c/d) * (a/b)^(c/d) = x
            // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
            // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
            // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
            if (this['s'] < 0) return null;
            // Now prime factor n and d
            var N = factorize(this['n']);
            var D = factorize(this['d']);
            // Exponentiate and take root for n and d individually
            var n = 1;
            var d = 1;
            for(var k in N){
                if (k === '1') continue;
                if (k === '0') {
                    n = 0;
                    break;
                }
                N[k] *= P['n'];
                if (N[k] % P['d'] === 0) {
                    N[k] /= P['d'];
                } else return null;
                n *= Math.pow(k, N[k]);
            }
            for(var k in D){
                if (k === '1') continue;
                D[k] *= P['n'];
                if (D[k] % P['d'] === 0) {
                    D[k] /= P['d'];
                } else return null;
                d *= Math.pow(k, D[k]);
            }
            if (P['s'] < 0) {
                return newFraction(d, n);
            }
            return newFraction(n, d);
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
            return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return this;
            }
            eps = eps || 0.001;
            var thisABS = this['abs']();
            var cont = thisABS['toContinued']();
            for(var i = 1; i < cont.length; i++){
                var s = newFraction(cont[i - 1], 1);
                for(var k = i - 2; k >= 0; k--){
                    s = s['inverse']()['add'](cont[k]);
                }
                if (Math.abs(s['sub'](thisABS).valueOf()) < eps) {
                    return s['mul'](this['s']);
                }
            }
            return this;
        },
        /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */ "divisible": function(a, b) {
            parse(a, b);
            return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/ 'valueOf': function() {
            return this["s"] * this["n"] / this["d"];
        },
        /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/ 'toFraction': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    str += " ";
                    n %= d;
                }
                str += n;
                str += '/';
                str += d;
            }
            return str;
        },
        /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/ 'toLatex': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    n %= d;
                }
                str += "\\frac{";
                str += n;
                str += '}{';
                str += d;
                str += '}';
            }
            return str;
        },
        /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */ 'toContinued': function() {
            var t;
            var a = this['n'];
            var b = this['d'];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
                return res;
            }
            do {
                res.push(Math.floor(a / b));
                t = a % b;
                a = b;
                b = t;
            }while (a !== 1)
            return res;
        },
        /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/ 'toString': function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
                return "NaN";
            }
            dec = dec || 15; // 15 = decimal places when no repetation
            var cycLen = cycleLen(N, D); // Cycle length
            var cycOff = cycleStart(N, D, cycLen); // Cycle start
            var str = this['s'] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N) str += ".";
            if (cycLen) {
                for(var i = cycOff; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += "(";
                for(var i = cycLen; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += ")";
            } else {
                for(var i = dec; N && i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
            }
            return str;
        }
    };
    if ("TURBOPACK compile-time truthy", 1) {
        Object.defineProperty(exports, "__esModule", {
            'value': true
        });
        exports['default'] = Fraction;
        module['exports'] = Fraction;
    } else {
        "TURBOPACK unreachable";
    }
})(this);
}}),
"[project]/node_modules/cssdb/cssdb.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("[{\"id\":\"all-property\",\"title\":\"`all` Property\",\"description\":\"A property for defining the reset of all properties of an element\",\"specification\":\"https://www.w3.org/TR/css-cascade-3/#all-shorthand\",\"stage\":4,\"browser_support\":{\"and_chr\":\"37\",\"and_ff\":\"27\",\"android\":\"37\",\"chrome\":\"37\",\"edge\":\"79\",\"firefox\":\"27\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"24\",\"opera\":\"24\",\"safari\":\"9.1\",\"samsung\":\"3.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/all\"},\"example\":\"a {\\n  all: initial;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/maximkoretskiy/postcss-initial\"}],\"vendors_implementations\":3},{\"id\":\"any-link-pseudo-class\",\"title\":\"`:any-link` Hyperlink Pseudo-Class\",\"description\":\"A pseudo-class for matching anchor elements independent of whether they have been visited\",\"specification\":\"https://www.w3.org/TR/selectors-4/#any-link-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"4\",\"android\":\"4.4\",\"chrome\":\"1\",\"edge\":\"79\",\"firefox\":\"1\",\"ios_saf\":\"1\",\"oculus\":\"5.0\",\"op_mob\":\"14\",\"opera\":\"15\",\"safari\":\"3\",\"samsung\":\"1.0\",\"webview_ios\":\"1\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link\"},\"example\":\"nav :any-link > span {\\n  background-color: yellow;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-pseudo-class-any-link\"}],\"vendors_implementations\":3},{\"id\":\"blank-pseudo-class\",\"title\":\"`:blank` Empty-Value Pseudo-Class\",\"description\":\"A pseudo-class for matching form elements when they are empty\",\"specification\":\"https://www.w3.org/TR/selectors-4/#blank\",\"stage\":2,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:blank\"},\"example\":\"input:blank {\\n  background-color: yellow;\\n}\",\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-blank-pseudo\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-blank-pseudo\"}],\"vendors_implementations\":0},{\"id\":\"break-properties\",\"title\":\"Break Properties\",\"description\":\"Properties for defining the break behavior between and within boxes\",\"specification\":\"https://www.w3.org/TR/css-break-3/#breaking-controls\",\"stage\":3,\"browser_support\":{\"and_chr\":\"51\",\"and_ff\":\"92\",\"android\":\"51\",\"chrome\":\"51\",\"edge\":\"12\",\"firefox\":\"92\",\"oculus\":\"5.0\",\"op_mob\":\"37\",\"opera\":\"11.1\",\"samsung\":\"5.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/break-after\"},\"example\":\"a {\\n  break-inside: avoid;\\n  break-before: avoid-column;\\n  break-after: always;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/shrpne/postcss-page-break\"}],\"vendors_implementations\":2},{\"id\":\"calc-constants\",\"title\":\"`e`, `pi`, `infinity`, `-infinity` and `NaN` constants for calculation\",\"description\":\"Constants for calculation simplification\",\"specification\":\"https://drafts.csswg.org/css-values-4/#calc-keywords\",\"stage\":2,\"browser_support\":{\"and_chr\":\"110\",\"and_ff\":\"114\",\"android\":\"110\",\"chrome\":\"110\",\"edge\":\"110\",\"firefox\":\"114\",\"ios_saf\":\"16\",\"op_mob\":\"74\",\"opera\":\"96\",\"safari\":\"16\",\"samsung\":\"21.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/calc-keyword\"},\"example\":\"p {\\n  font-size: calc(pow(e, pi) * 1rem);\\n}\",\"interoperable_at\":1686009600,\"vendors_implementations\":3},{\"id\":\"cascade-layers\",\"title\":\"CSS Cascade Layers\",\"description\":\"The `@layer` at-rule allows authors to explicitly layer their styles in the cascade, before specificity and order of appearance are considered.\",\"specification\":\"https://www.w3.org/TR/css-cascade-5/#layering\",\"stage\":2,\"browser_support\":{\"and_chr\":\"99\",\"and_ff\":\"97\",\"android\":\"99\",\"chrome\":\"99\",\"edge\":\"99\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"oculus\":\"21.0\",\"op_mob\":\"68\",\"opera\":\"85\",\"safari\":\"15.4\",\"samsung\":\"18.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@layer\"},\"example\":\"/* Un-layered styles have the highest priority */\\na {\\n  color: mediumvioletred;\\n}\\n\\n@layer defaults {\\n  a { color: maroon; }\\n}\",\"interoperable_at\":1647216000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-cascade-layers\"}],\"vendors_implementations\":3,\"web-feature\":\"cascade-layers\"},{\"id\":\"case-insensitive-attributes\",\"title\":\"Case-Insensitive Attributes\",\"description\":\"An attribute selector matching attribute values case-insensitively\",\"specification\":\"https://www.w3.org/TR/selectors-4/#attribute-case\",\"stage\":2,\"browser_support\":{\"and_chr\":\"49\",\"and_ff\":\"47\",\"android\":\"49\",\"chrome\":\"49\",\"edge\":\"79\",\"firefox\":\"47\",\"ios_saf\":\"9\",\"oculus\":\"5.0\",\"op_mob\":\"36\",\"opera\":\"36\",\"safari\":\"9\",\"samsung\":\"5.0\",\"webview_ios\":\"9\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\"},\"example\":\"[frame=hsides i] {\\n  border-style: solid none;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-attribute-case-insensitive\"}],\"vendors_implementations\":3},{\"id\":\"clamp\",\"title\":\"`clamp` Function\",\"description\":\"The clamp() CSS function clamps a value between an upper and lower bound. It enables selecting a middle value within a range of values between a defined minimum and maximum.\",\"specification\":\"https://www.w3.org/TR/css-values-4/#funcdef-clamp\",\"stage\":2,\"browser_support\":{\"and_chr\":\"79\",\"and_ff\":\"79\",\"android\":\"79\",\"chrome\":\"79\",\"edge\":\"79\",\"firefox\":\"75\",\"ios_saf\":\"13.4\",\"oculus\":\"8.0\",\"op_mob\":\"57\",\"opera\":\"66\",\"safari\":\"13.1\",\"samsung\":\"12.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/clamp\"},\"example\":\"button {\\n  font-size: clamp(1rem, 2.5vw, 2rem);\\n}\",\"interoperable_at\":1595894400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/polemius/postcss-clamp\"}],\"vendors_implementations\":3},{\"id\":\"color-adjust\",\"title\":\"`color-adjust` Property\",\"description\":\"The color-adjust property is a non-standard CSS extension that can be used to force printing of background colors and images\",\"specification\":\"https://www.w3.org/TR/css-color-4/#color-adjust\",\"stage\":2,\"browser_support\":{\"and_chr\":\"136\",\"and_ff\":\"97\",\"chrome\":\"136\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"safari\":\"15.4\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/print-color-adjust\"},\"example\":\".background {\\n  background-color:#ccc;\\n}\\n.background.color-adjust {\\n  color-adjust: economy;\\n}\\n.background.color-adjust-exact {\\n  color-adjust: exact;\\n}\",\"vendors_implementations\":2},{\"id\":\"color-function\",\"title\":\"`color()` Function\",\"description\":\"A function that allows a color to be specified in a particular, specified color space rather than the implicit sRGB color space that most of the other color functions operate in.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-color\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"113\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"113\",\"ios_saf\":\"15\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"15\",\"samsung\":\"22.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color\"},\"example\":\"p {\\n  color: color(display-p3 1 0.5 0);\\n  color: color(display-p3 1 0.5 0 / .5);\\n}\",\"interoperable_at\":1683590400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-function\"}],\"vendors_implementations\":3,\"web-feature\":\"color-function\"},{\"id\":\"color-functional-notation\",\"title\":\"Color Functional Notation\",\"description\":\"A space and slash separated notation for specifying colors\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-rgb\",\"stage\":2,\"browser_support\":{\"and_chr\":\"65\",\"and_ff\":\"52\",\"android\":\"65\",\"chrome\":\"65\",\"edge\":\"79\",\"firefox\":\"52\",\"ios_saf\":\"12.2\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"52\",\"safari\":\"12.1\",\"samsung\":\"9.0\",\"webview_ios\":\"12.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb#syntax\"},\"example\":\"em {\\n  background-color: hsl(120deg 100% 25%);\\n  color: rgb(0 255 0);\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-functional-notation\"}],\"vendors_implementations\":3},{\"id\":\"color-mix\",\"title\":\"`color-mix()` Function\",\"description\":\"A function for mixing colors\",\"specification\":\"https://www.w3.org/TR/css-color-5/#color-mix\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"113\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"16.2\",\"samsung\":\"22.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix\"},\"example\":\"p {\\n  color: color-mix(in lch, purple 50%, plum 50%);\\n}\",\"interoperable_at\":1683590400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-mix-function\"}],\"vendors_implementations\":3,\"web-feature\":\"color-mix\"},{\"id\":\"color-mix-variadic-function-arguments\",\"title\":\"`color-mix()` Function with 1+ arguments\",\"description\":\"Mix any number of colors\",\"specification\":\"https://www.w3.org/TR/css-color-5/#color-mix\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"p {\\n  color: color-mix(in lch, red, lime, blue);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-mix-variadic-function-arguments\"}],\"vendors_implementations\":0},{\"id\":\"container-queries\",\"title\":\"Container Queries\",\"description\":\"New container property and container at rule to make changes depending on the container's size\",\"specification\":\"https://www.w3.org/TR/css-contain-3/#container-queries\",\"stage\":2,\"browser_support\":{\"and_chr\":\"105\",\"and_ff\":\"110\",\"android\":\"105\",\"chrome\":\"105\",\"edge\":\"105\",\"firefox\":\"110\",\"ios_saf\":\"16\",\"op_mob\":\"72\",\"opera\":\"91\",\"safari\":\"16\",\"samsung\":\"20.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries\"},\"example\":\".container {\\n  contain: layout inline-size;\\n}\\n\\n@container (min-width: 700px) {\\n  .container {\\n    /* styles applied when a container is at least 700px */\\n  }\\n}\",\"interoperable_at\":1676332800,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://www.npmjs.com/package/container-query-polyfill\"}],\"vendors_implementations\":3,\"web-feature\":\"container-queries\"},{\"id\":\"content-alt-text\",\"title\":\"Alt text for `content`\",\"description\":\"Syntax that allows setting alternative text\",\"specification\":\"https://drafts.csswg.org/css-content/#content-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"77\",\"and_ff\":\"128\",\"android\":\"77\",\"chrome\":\"77\",\"edge\":\"79\",\"firefox\":\"128\",\"ios_saf\":\"17.4\",\"oculus\":\"7.0\",\"op_mob\":\"55\",\"opera\":\"64\",\"safari\":\"17.4\",\"samsung\":\"12.0\",\"webview_ios\":\"17.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/content#adding_an_image_with_alternative_text\"},\"example\":\".element {\\n  content: url(tree.jpg) / \\\"image with a tree\\\";\\n}\",\"interoperable_at\":1720483200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-content-alt-text\"}],\"vendors_implementations\":3},{\"id\":\"contrast-color-function\",\"title\":\"`contrast-color()` Function\",\"description\":\"Dynamically specifying a text color with adequate contrast.\",\"specification\":\"https://drafts.csswg.org/css-color-5/#contrast-color\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"p {\\n  color: contrast-color( purple max );\\n}\",\"polyfills\":[],\"vendors_implementations\":0},{\"id\":\"custom-media-queries\",\"title\":\"Custom Media Queries\",\"description\":\"An at-rule for defining aliases that represent media queries\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#at-ruledef-custom-media\",\"stage\":2,\"browser_support\":{},\"example\":\"@custom-media --narrow-window (max-width: 30em);\\n\\n@media (--narrow-window) {}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-media\"}],\"vendors_implementations\":0},{\"id\":\"custom-properties\",\"title\":\"Custom Properties\",\"description\":\"A syntax for defining custom values accepted by all CSS properties\",\"specification\":\"https://www.w3.org/TR/css-variables-1/\",\"stage\":3,\"browser_support\":{\"and_chr\":\"49\",\"and_ff\":\"31\",\"android\":\"50\",\"chrome\":\"49\",\"edge\":\"15\",\"firefox\":\"31\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"36\",\"opera\":\"36\",\"safari\":\"9.1\",\"samsung\":\"5.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/var\"},\"example\":\":root {\\n  --some-length: 32px;\\n\\n  height: var(--some-length);\\n  width: var(--some-length);\\n}\",\"interoperable_at\":1491350400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-properties\"}],\"vendors_implementations\":3,\"web-feature\":\"custom-properties\"},{\"id\":\"custom-selectors\",\"title\":\"Custom Selectors\",\"description\":\"An at-rule for defining aliases that represent selectors\",\"specification\":\"https://drafts.csswg.org/css-extensions/#custom-selectors\",\"stage\":1,\"browser_support\":{},\"example\":\"@custom-selector :--heading h1, h2, h3, h4, h5, h6;\\n\\narticle :--heading + p {}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-selectors\"}],\"vendors_implementations\":0},{\"id\":\"dir-pseudo-class\",\"title\":\"`:dir` Directionality Pseudo-Class\",\"description\":\"A pseudo-class for matching elements based on their directionality\",\"specification\":\"https://www.w3.org/TR/selectors-4/#dir-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"49\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"49\",\"ios_saf\":\"16.4\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"16.4\",\"samsung\":\"25.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:dir\"},\"example\":\"blockquote:dir(rtl) {\\n  margin-right: 10px;\\n}\\n\\nblockquote:dir(ltr) {\\n  margin-left: 10px;\\n}\",\"interoperable_at\":1701907200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-dir-pseudo-class\"}],\"vendors_implementations\":3},{\"id\":\"display-two-values\",\"title\":\"Two values syntax for `display`\",\"description\":\"Syntax that allows definition of outer and inner displays types for an element\",\"specification\":\"https://www.w3.org/TR/css-display-3/#the-display-properties\",\"stage\":2,\"browser_support\":{\"and_chr\":\"115\",\"and_ff\":\"79\",\"android\":\"115\",\"chrome\":\"115\",\"edge\":\"115\",\"firefox\":\"70\",\"ios_saf\":\"15\",\"op_mob\":\"77\",\"opera\":\"101\",\"safari\":\"15\",\"samsung\":\"23.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/multi-keyword_syntax_of_display\"},\"example\":\".element {\\n  display: inline flow-root;\\n  display: inline flex;\\n  display: block grid;\\n}\",\"interoperable_at\":1689897600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-normalize-display-values\"}],\"vendors_implementations\":3},{\"id\":\"double-position-gradients\",\"title\":\"Double Position Gradients\",\"description\":\"A syntax for using two positions in a gradient.\",\"specification\":\"https://www.w3.org/TR/css-images-4/#color-stop-syntax\",\"stage\":2,\"browser_support\":{\"and_chr\":\"72\",\"and_ff\":\"83\",\"android\":\"72\",\"chrome\":\"72\",\"edge\":\"79\",\"firefox\":\"83\",\"ios_saf\":\"12.2\",\"oculus\":\"6.0\",\"op_mob\":\"51\",\"opera\":\"60\",\"safari\":\"12.1\",\"samsung\":\"11.0\",\"webview_ios\":\"12.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient\"},\"example\":\".pie_chart {\\n  background-image: conic-gradient(yellowgreen 40%, gold 0deg 75%, #f06 0deg);\\n}\",\"interoperable_at\":1605571200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-double-position-gradients\"}],\"vendors_implementations\":3},{\"id\":\"environment-variables\",\"title\":\"Custom Environment Variables\",\"description\":\"A syntax for using custom values accepted by CSS globally\",\"specification\":\"https://drafts.csswg.org/css-env-1/\",\"stage\":0,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/env\"},\"example\":\"@media (max-width: env(--brand-small)) {\\n  body {\\n    padding: env(--brand-spacing);\\n  }\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-env-function\"}],\"vendors_implementations\":0},{\"id\":\"exponential-functions\",\"title\":\"`pow()`, `sqrt()`, `hypot()`, `log()`, `exp()` exponential functions\",\"description\":\"Compute various exponential functions with their arguments\",\"specification\":\"https://www.w3.org/TR/css-values-4/#exponent-funcs\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"118\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"15.4\",\"samsung\":\"25.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/exp\"},\"example\":\"p {\\n  font-size: calc(pow(10, 12) * 1rem);\\n  font-size: calc(sqrt(100) * 1rem);\\n  font-size: calc(hypot(3, 4) * 1rem);\\n  font-size: calc(log(10) * 1rem);\\n  font-size: calc(exp(10) * 1rem);\\n}\",\"interoperable_at\":1701907200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-exponential-functions\"}],\"vendors_implementations\":3},{\"id\":\"fangsong-font-family\",\"title\":\"`fangsong` Font Family\",\"description\":\"A generic font used for Fang Song (仿宋) typefaces in Chinese\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#fangsong-def\",\"stage\":2,\"browser_support\":{},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Syntax\"},\"example\":\"body {\\n  font-family: fangsong;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/JLHwung/postcss-font-family-fangsong\"}],\"vendors_implementations\":0},{\"id\":\"float-clear-logical-values\",\"title\":\"Logical Values in float and clear\",\"description\":\"Flow-relative (inline-start and inline-end) values for float and clear\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"118\",\"and_ff\":\"55\",\"android\":\"118\",\"chrome\":\"118\",\"edge\":\"118\",\"firefox\":\"55\",\"ios_saf\":\"15\",\"op_mob\":\"79\",\"opera\":\"104\",\"safari\":\"15\",\"samsung\":\"25.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/float\"},\"example\":\"span:first-child {\\n  float: inline-start;\\n}\",\"interoperable_at\":1697155200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-float-and-clear\"}],\"vendors_implementations\":3},{\"id\":\"focus-visible-pseudo-class\",\"title\":\"`:focus-visible` Focus-Indicated Pseudo-Class\",\"description\":\"A pseudo-class for matching focused elements that indicate that focus to a user\",\"specification\":\"https://www.w3.org/TR/selectors-4/#focus-visible-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"86\",\"and_ff\":\"85\",\"android\":\"86\",\"chrome\":\"86\",\"edge\":\"86\",\"firefox\":\"85\",\"ios_saf\":\"15.4\",\"oculus\":\"12.0\",\"op_mob\":\"61\",\"opera\":\"72\",\"safari\":\"15.4\",\"samsung\":\"14.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible\"},\"example\":\":focus:not(:focus-visible) {\\n  outline: 0;\\n}\",\"interoperable_at\":1647216000,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/WICG/focus-visible\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-focus-visible\"}],\"vendors_implementations\":3,\"web-feature\":\"focus-visible\"},{\"id\":\"focus-within-pseudo-class\",\"title\":\"`:focus-within` Focus Container Pseudo-Class\",\"description\":\"A pseudo-class for matching elements that are either focused or that have focused descendants\",\"specification\":\"https://www.w3.org/TR/selectors-4/#focus-within-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"60\",\"and_ff\":\"52\",\"android\":\"60\",\"chrome\":\"60\",\"edge\":\"79\",\"firefox\":\"52\",\"ios_saf\":\"10.3\",\"oculus\":\"5.0\",\"op_mob\":\"44\",\"opera\":\"47\",\"safari\":\"10.1\",\"samsung\":\"8.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-within\"},\"example\":\"form:focus-within {\\n  background: rgb(0 128 0);\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/jsxtools/focus-within\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-focus-within\"}],\"vendors_implementations\":3},{\"id\":\"font-format-keywords\",\"title\":\"Font `format()` Keywords\",\"description\":\"A syntax for specifying font format as a keyword in `@font-face` rule’s `format()` function\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#font-format-values\",\"stage\":2,\"browser_support\":{\"and_chr\":\"108\",\"android\":\"108\",\"chrome\":\"108\",\"edge\":\"108\",\"ios_saf\":\"5\",\"op_mob\":\"73\",\"opera\":\"94\",\"safari\":\"4\",\"samsung\":\"21.0\",\"webview_ios\":\"5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face\"},\"example\":\"@font-face {\\n  src: url(file.woff2) format(woff2);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/valtlai/postcss-font-format-keywords\"}],\"vendors_implementations\":2},{\"id\":\"font-variant-property\",\"title\":\"`font-variant` Property\",\"description\":\"A property for defining the usage of alternate glyphs in a font\",\"specification\":\"https://www.w3.org/TR/css-fonts-3/#propdef-font-variant\",\"stage\":4,\"browser_support\":{\"and_ff\":\"34\",\"firefox\":\"34\",\"ios_saf\":\"9.3\",\"safari\":\"9.1\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant\"},\"example\":\"h2 {\\n  font-variant: small-caps;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/postcss/postcss-font-variant\"}],\"vendors_implementations\":2},{\"id\":\"gamut-mapping\",\"title\":\"Gamut mapping for CSS color functions\",\"description\":\"Gamut map css colors to fit display specific gamuts.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#gamut-mapping\",\"stage\":2,\"browser_support\":{},\"example\":\"@media (color-gamut: rec2020) {\\n\\tp {\\n\\t\\tcolor: oklch(40% 0.234 0.39 / 0.5);\\n\\t}\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gamut-mapping\"}],\"vendors_implementations\":0},{\"id\":\"gap-properties\",\"title\":\"Gap Properties\",\"description\":\"Properties for defining gutters within a layout\",\"specification\":\"https://www.w3.org/TR/css-grid-1/#gutters\",\"stage\":3,\"browser_support\":{\"and_chr\":\"66\",\"and_ff\":\"61\",\"android\":\"66\",\"chrome\":\"66\",\"edge\":\"16\",\"firefox\":\"61\",\"ios_saf\":\"12\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"53\",\"safari\":\"12\",\"samsung\":\"9.0\",\"webview_ios\":\"12\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gap\"},\"example\":\".grid-1 {\\n  gap: 20px;\\n}\\n\\n.grid-2 {\\n  column-gap: 40px;\\n  row-gap: 20px;\\n}\",\"interoperable_at\":1537142400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gap-properties\"}],\"vendors_implementations\":3},{\"id\":\"gradients-interpolation-method\",\"title\":\"Gradients Interpolation Method\",\"description\":\"Define the interpolation method for gradients\",\"specification\":\"https://www.w3.org/TR/css-images-4/#color-interpolation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"127\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"127\",\"ios_saf\":\"16.2\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"16.2\",\"samsung\":\"22.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#syntax\"},\"example\":\".pie_chart {\\n  background-image: conic-gradient(in oklch, yellowgreen 40%, gold 0deg 75%, #f06 0deg);\\n}\",\"interoperable_at\":1718064000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-gradients-interpolation-method\"}],\"vendors_implementations\":3},{\"id\":\"grid-layout\",\"title\":\"Grid Layout\",\"description\":\"A syntax for using a grid concept to lay out content\",\"specification\":\"https://www.w3.org/TR/css-grid-1/\",\"stage\":3,\"browser_support\":{\"and_chr\":\"57\",\"and_ff\":\"52\",\"android\":\"57\",\"chrome\":\"57\",\"edge\":\"16\",\"firefox\":\"52\",\"ios_saf\":\"10.3\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"44\",\"safari\":\"10.1\",\"samsung\":\"6.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/grid\"},\"example\":\"section {\\n  display: grid;\\n  grid-template-columns: 100px 100px 100px;\\n  grid-gap: 10px;\\n}\",\"interoperable_at\":1508198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/postcss/autoprefixer\"}],\"vendors_implementations\":3},{\"id\":\"has-pseudo-class\",\"title\":\"`:has()` Relational Pseudo-Class\",\"description\":\"A pseudo-class for matching ancestor and sibling elements\",\"specification\":\"https://www.w3.org/TR/selectors-4/#has-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"105\",\"and_ff\":\"121\",\"android\":\"105\",\"chrome\":\"105\",\"edge\":\"105\",\"firefox\":\"121\",\"ios_saf\":\"15.4\",\"op_mob\":\"72\",\"opera\":\"91\",\"safari\":\"15.4\",\"samsung\":\"20.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:has\"},\"example\":\"a:has(> img) {\\n  display: block;\\n}\",\"interoperable_at\":1702944000,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-has-pseudo\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-has-pseudo\"}],\"vendors_implementations\":3,\"web-feature\":\"has\"},{\"id\":\"hexadecimal-alpha-notation\",\"title\":\"Hexadecimal Alpha Notation\",\"description\":\"A 4 & 8 character hex color notation for specifying the opacity level\",\"specification\":\"https://www.w3.org/TR/css-color-4/#hex-notation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"62\",\"and_ff\":\"49\",\"android\":\"62\",\"chrome\":\"62\",\"edge\":\"79\",\"firefox\":\"49\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"47\",\"opera\":\"49\",\"safari\":\"10\",\"samsung\":\"8.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Syntax_2\"},\"example\":\"section {\\n  background-color: #f3f3f3f3;\\n  color: #0003;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-hex-alpha\"}],\"vendors_implementations\":3},{\"id\":\"hwb-function\",\"title\":\"`hwb()` Function\",\"description\":\"A function for specifying colors by hue and then a degree of whiteness and blackness to mix into it\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-hwb\",\"stage\":2,\"browser_support\":{\"and_chr\":\"101\",\"and_ff\":\"96\",\"android\":\"101\",\"chrome\":\"101\",\"edge\":\"101\",\"firefox\":\"96\",\"ios_saf\":\"15\",\"oculus\":\"22.0\",\"op_mob\":\"70\",\"opera\":\"87\",\"safari\":\"15\",\"samsung\":\"19.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb\"},\"example\":\"p {\\n  color: hwb(120 44% 50%);\\n}\",\"interoperable_at\":1651104000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-hwb-function\"}],\"vendors_implementations\":3},{\"id\":\"ic-unit\",\"title\":\"`ic` length unit\",\"description\":\"Equal to the used advance measure of the \\\"水\\\" (CJK water ideograph, U+6C34) glyph found in the font used to render it\",\"specification\":\"https://www.w3.org/TR/css-values-4/#ic\",\"stage\":2,\"browser_support\":{\"and_chr\":\"106\",\"and_ff\":\"97\",\"android\":\"106\",\"chrome\":\"106\",\"edge\":\"106\",\"firefox\":\"97\",\"ios_saf\":\"15.4\",\"op_mob\":\"72\",\"opera\":\"92\",\"safari\":\"15.4\",\"samsung\":\"20.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Values_and_Units#dimensions\"},\"example\":\"p {\\n  text-indent: 2ic;\\n}\",\"interoperable_at\":1664755200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-ic-unit\"}],\"vendors_implementations\":3,\"web-feature\":\"ic\"},{\"id\":\"image-set-function\",\"title\":\"`image-set()` Function\",\"description\":\"A function for specifying image sources based on the user’s resolution\",\"specification\":\"https://www.w3.org/TR/css-images-4/#image-set-notation\",\"stage\":2,\"browser_support\":{\"and_chr\":\"25\",\"and_ff\":\"89\",\"android\":\"4.4\",\"chrome\":\"21\",\"edge\":\"79\",\"firefox\":\"89\",\"ios_saf\":\"14\",\"oculus\":\"5.0\",\"op_mob\":\"14\",\"opera\":\"15\",\"safari\":\"14\",\"samsung\":\"1.5\",\"webview_ios\":\"17\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set\"},\"example\":\"p {\\n  background-image: image-set(\\n    \\\"foo.png\\\" 1x,\\n    \\\"foo-2x.png\\\" 2x,\\n    \\\"foo-print.png\\\" 600dpi\\n  );\\n}\",\"interoperable_at\":1622505600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-image-set-function\"}],\"vendors_implementations\":3},{\"id\":\"in-out-of-range-pseudo-class\",\"title\":\"`:in-range` and `:out-of-range` Pseudo-Classes\",\"description\":\"A pseudo-class for matching elements that have range limitations\",\"specification\":\"https://www.w3.org/TR/selectors-4/#range-pseudos\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"16\",\"android\":\"2.2\",\"chrome\":\"10\",\"edge\":\"13\",\"firefox\":\"29\",\"ios_saf\":\"5\",\"oculus\":\"5.0\",\"op_mob\":\"11\",\"opera\":\"11\",\"safari\":\"5.1\",\"samsung\":\"1.0\",\"webview_ios\":\"5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range\"},\"example\":\"input:in-range {\\n  background-color: rgb(0 255 0 / 0.25);\\n}\\ninput:out-of-range {\\n  background-color: rgb(255 0 0 / 0.25);\\n  border: 2px solid red;\\n}\",\"interoperable_at\":1447286400,\"vendors_implementations\":3},{\"id\":\"is-pseudo-class\",\"title\":\"`:is()` Matches-Any Pseudo-Class\",\"description\":\"A pseudo-class for matching elements in a selector list\",\"specification\":\"https://www.w3.org/TR/selectors-4/#matches-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"82\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"82\",\"ios_saf\":\"14\",\"oculus\":\"14.0\",\"op_mob\":\"63\",\"opera\":\"74\",\"safari\":\"14\",\"samsung\":\"15.0\",\"webview_ios\":\"14\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:is\"},\"example\":\"p:is(:first-child, .special) {\\n  margin-top: 1em;\\n}\",\"interoperable_at\":1611187200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-is-pseudo-class\"}],\"vendors_implementations\":3,\"web-feature\":\"is\"},{\"id\":\"lab-function\",\"title\":\"`lab()` Function\",\"description\":\"A function for specifying colors expressed in the CIE Lab color space\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-lab\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab\"},\"example\":\"body {\\n  color: lab(80% 50 20);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-lab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"lab\"},{\"id\":\"lch-function\",\"title\":\"`lch()` Function\",\"description\":\"A function for specifying colors expressed in the CIE Lab color space with chroma and hue\",\"specification\":\"https://www.w3.org/TR/css-color-4/#funcdef-lch\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch\"},\"example\":\"body {\\n  color: lch(53% 105 40);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-lab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"lab\"},{\"id\":\"light-dark-function\",\"title\":\"`light-dark()` Function\",\"description\":\"React to the current used `color-scheme` value\",\"specification\":\"https://drafts.csswg.org/css-color-5/#light-dark\",\"stage\":2,\"browser_support\":{\"and_chr\":\"123\",\"and_ff\":\"120\",\"android\":\"123\",\"chrome\":\"123\",\"edge\":\"123\",\"firefox\":\"120\",\"ios_saf\":\"17.5\",\"op_mob\":\"82\",\"opera\":\"109\",\"safari\":\"17.5\",\"samsung\":\"27.0\",\"webview_ios\":\"17.5\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark\"},\"example\":\"body {\\n  color: light-dark(cyan, magenta);\\n}\",\"interoperable_at\":1715558400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-light-dark-function\"}],\"vendors_implementations\":3},{\"id\":\"logical-overflow\",\"title\":\"Logical Overflow\",\"description\":\"Flow-relative `overflow` properties\",\"specification\":\"https://www.w3.org/TR/css-overflow-3/#overflow-control\",\"stage\":2,\"browser_support\":{\"and_chr\":\"135\",\"and_ff\":\"79\",\"android\":\"135\",\"chrome\":\"135\",\"edge\":\"135\",\"firefox\":\"69\",\"op_mob\":\"89\",\"opera\":\"120\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-block\"},\"example\":\"div {\\n  overflow-block: scroll;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-overflow\"}],\"vendors_implementations\":2},{\"id\":\"logical-overscroll-behavior\",\"title\":\"Logical Overscroll Behavior\",\"description\":\"Flow-relative `overscroll-behavior` properties\",\"specification\":\"https://www.w3.org/TR/css-overscroll-1/#overscroll-behavior-longhands-logical\",\"stage\":2,\"browser_support\":{\"and_chr\":\"77\",\"and_ff\":\"79\",\"android\":\"77\",\"chrome\":\"77\",\"edge\":\"79\",\"firefox\":\"73\",\"ios_saf\":\"16\",\"oculus\":\"7.0\",\"op_mob\":\"55\",\"opera\":\"64\",\"safari\":\"16\",\"samsung\":\"12.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior-block\"},\"example\":\"div {\\n  overscroll-behavior-block: scroll;\\n}\",\"interoperable_at\":1662940800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-overscroll-behavior\"}],\"vendors_implementations\":3},{\"id\":\"logical-properties-and-values\",\"title\":\"Logical Properties and Values\",\"description\":\"Flow-relative (left-to-right or right-to-left) properties and values\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"89\",\"and_ff\":\"66\",\"android\":\"89\",\"chrome\":\"89\",\"edge\":\"89\",\"firefox\":\"66\",\"ios_saf\":\"15\",\"oculus\":\"15.0\",\"op_mob\":\"63\",\"opera\":\"75\",\"safari\":\"15\",\"samsung\":\"15.0\",\"webview_ios\":\"15\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values\"},\"example\":\"span:first-child {\\n  margin-inline-start: 10px;\\n}\",\"interoperable_at\":1632096000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical\"}],\"vendors_implementations\":3},{\"id\":\"logical-resize\",\"title\":\"Logical values in the `resize` property\",\"description\":\"Flow-relative (block or inline) values in resize\",\"specification\":\"https://www.w3.org/TR/css-logical-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"118\",\"and_ff\":\"63\",\"android\":\"118\",\"chrome\":\"118\",\"edge\":\"118\",\"firefox\":\"63\",\"op_mob\":\"79\",\"opera\":\"104\",\"safari\":\"16\",\"samsung\":\"25.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/resize\"},\"example\":\"area {\\n  resize: inline;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-resize\"}],\"vendors_implementations\":2},{\"id\":\"logical-viewport-units\",\"title\":\"Logical Viewport Units\",\"description\":\"Flow-relative (horizontal or vertical) Viewport Units\",\"specification\":\"https://www.w3.org/TR/css-values-4/#viewport-relative-units\",\"stage\":2,\"browser_support\":{\"and_chr\":\"108\",\"and_ff\":\"101\",\"android\":\"108\",\"chrome\":\"108\",\"edge\":\"108\",\"firefox\":\"101\",\"ios_saf\":\"15.4\",\"op_mob\":\"73\",\"opera\":\"94\",\"safari\":\"15.4\",\"samsung\":\"21.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/length#vb\"},\"example\":\"span:first-child {\\n  width: 5vi; height: 10vb; \\n}\",\"interoperable_at\":1670198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-logical-viewport-units\"}],\"vendors_implementations\":3,\"web-feature\":\"viewport-unit-variants\"},{\"id\":\"media-queries-aspect-ratio-number-values\",\"title\":\"Aspect-Ratio number values\",\"description\":\"Support `<ratio>` values with `<number>` components in `@media`\",\"specification\":\"https://www.w3.org/TR/css-values-4/#ratio-value\",\"stage\":2,\"browser_support\":{\"and_chr\":\"110\",\"and_ff\":\"79\",\"android\":\"110\",\"chrome\":\"110\",\"edge\":\"110\",\"firefox\":\"78\",\"ios_saf\":\"16.4\",\"op_mob\":\"74\",\"opera\":\"96\",\"safari\":\"16.4\",\"samsung\":\"21.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/ratio\"},\"example\":\"@media (aspect-ratio: 1.77) {\\n  html {\\n    background-color: cyan;\\n  }\\n}\",\"interoperable_at\":1679875200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-media-queries-aspect-ratio-number-values\"}],\"vendors_implementations\":3},{\"id\":\"media-query-ranges\",\"title\":\"Media Query Ranges\",\"description\":\"A syntax for defining media query ranges using ordinary comparison operators\",\"specification\":\"https://www.w3.org/TR/mediaqueries-4/#range-context\",\"stage\":3,\"browser_support\":{\"and_chr\":\"104\",\"and_ff\":\"102\",\"android\":\"104\",\"chrome\":\"104\",\"edge\":\"104\",\"firefox\":\"102\",\"ios_saf\":\"16.4\",\"oculus\":\"23.0\",\"op_mob\":\"71\",\"opera\":\"90\",\"safari\":\"16.4\",\"samsung\":\"20.0\",\"webview_ios\":\"16.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries#Syntax_improvements_in_Level_4\"},\"example\":\"@media (width < 480px) {}\\n\\n@media (480px <= width < 768px) {}\\n\\n@media (width >= 768px) {}\",\"interoperable_at\":1679875200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-media-minmax\"}],\"vendors_implementations\":3,\"web-feature\":\"media-query-range-syntax\"},{\"id\":\"nested-calc\",\"title\":\"Nested `calc()`\",\"description\":\"Nest calc functions with the calc function name\",\"specification\":\"https://www.w3.org/TR/css-values-4/#calc-func\",\"stage\":2,\"browser_support\":{\"and_chr\":\"51\",\"and_ff\":\"48\",\"android\":\"51\",\"chrome\":\"51\",\"edge\":\"16\",\"firefox\":\"48\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"41\",\"opera\":\"38\",\"safari\":\"11\",\"samsung\":\"5.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/calc\"},\"example\":\"p {\\n  padding: calc(1px + calc(4 / 3));\\n}\",\"interoperable_at\":1508198400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nested-calc\"}],\"vendors_implementations\":3},{\"id\":\"nesting-rules\",\"title\":\"Nesting Rules\",\"description\":\"A syntax for nesting relative rules within rules\",\"specification\":\"https://www.w3.org/TR/css-nesting-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"120\",\"and_ff\":\"117\",\"android\":\"120\",\"chrome\":\"120\",\"edge\":\"120\",\"firefox\":\"117\",\"ios_saf\":\"17.2\",\"op_mob\":\"80\",\"opera\":\"106\",\"safari\":\"17.2\",\"samsung\":\"25.0\",\"webview_ios\":\"17.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/Nesting_selector\"},\"example\":\"article {\\n  & p {\\n    color: #333;\\n  }\\n}\",\"interoperable_at\":1702252800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting\"}],\"vendors_implementations\":3,\"web-feature\":\"nesting\"},{\"id\":\"not-pseudo-class\",\"title\":\"`:not()` Negation List Pseudo-Class\",\"description\":\"A pseudo-class for ignoring elements in a selector list\",\"specification\":\"https://www.w3.org/TR/selectors-4/#negation-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"84\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"84\",\"ios_saf\":\"9\",\"oculus\":\"14.0\",\"opera\":\"74\",\"safari\":\"9\",\"samsung\":\"15.0\",\"webview_ios\":\"9\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\"},\"example\":\"p:not(:first-child, .special) {\\n  margin-top: 1em;\\n}\",\"interoperable_at\":1611187200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-selector-not\"}],\"vendors_implementations\":3},{\"id\":\"oklab-function\",\"title\":\"`oklab` and `oklch` color functions\",\"description\":\"Functions that allow colors to be expressed in OKLab and OKLCH.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch\",\"stage\":2,\"browser_support\":{\"and_chr\":\"116\",\"and_ff\":\"113\",\"android\":\"116\",\"chrome\":\"116\",\"edge\":\"116\",\"firefox\":\"113\",\"ios_saf\":\"16.2\",\"op_mob\":\"78\",\"opera\":\"102\",\"safari\":\"16.2\",\"samsung\":\"24.0\",\"webview_ios\":\"16.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklab\"},\"example\":\"p {\\n  color: oklab(72.322% -0.0465 -0.1150);\\n  color: oklch(72.322% 0.12403 247.996);\\n}\",\"interoperable_at\":1692576000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-oklab-function\"}],\"vendors_implementations\":3,\"web-feature\":\"oklab\"},{\"id\":\"opacity-percentage\",\"title\":\"Support for percentages for `opacity`\",\"description\":\"Syntactic sugar to use percentages instead of a float between 0 and 1.\",\"specification\":\"https://www.w3.org/TR/css-color-4/#transparency\",\"stage\":2,\"browser_support\":{\"and_chr\":\"78\",\"and_ff\":\"79\",\"android\":\"78\",\"chrome\":\"78\",\"edge\":\"79\",\"firefox\":\"70\",\"ios_saf\":\"13.4\",\"oculus\":\"8.0\",\"op_mob\":\"56\",\"opera\":\"65\",\"safari\":\"13.1\",\"samsung\":\"12.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\"},\"example\":\"img {\\n  opacity: 90%;\\n}\",\"interoperable_at\":1595894400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/mrcgrtz/postcss-opacity-percentage\"}],\"vendors_implementations\":3},{\"id\":\"overflow-property\",\"title\":\"`overflow` Shorthand Property\",\"description\":\"A property for defining `overflow-x` and `overflow-y`\",\"specification\":\"https://www.w3.org/TR/css-overflow-3/#propdef-overflow\",\"stage\":2,\"browser_support\":{\"and_chr\":\"68\",\"and_ff\":\"61\",\"android\":\"68\",\"chrome\":\"68\",\"edge\":\"79\",\"firefox\":\"61\",\"ios_saf\":\"13.4\",\"oculus\":\"6.0\",\"op_mob\":\"48\",\"opera\":\"55\",\"safari\":\"13.1\",\"samsung\":\"10.0\",\"webview_ios\":\"13.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\"},\"example\":\"html {\\n  overflow: hidden auto;\\n}\",\"interoperable_at\":1585008000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-overflow-shorthand\"}],\"vendors_implementations\":3},{\"id\":\"overflow-wrap-property\",\"title\":\"`overflow-wrap` Property\",\"description\":\"A property for defining whether to insert line breaks within words to prevent overflowing\",\"specification\":\"https://www.w3.org/TR/css-text-3/#overflow-wrap-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"25\",\"and_ff\":\"49\",\"android\":\"4.4\",\"chrome\":\"23\",\"edge\":\"18\",\"firefox\":\"49\",\"ios_saf\":\"7\",\"oculus\":\"5.0\",\"op_mob\":\"12.1\",\"opera\":\"12.1\",\"safari\":\"7\",\"samsung\":\"1.5\",\"webview_ios\":\"7\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap\"},\"example\":\"p {\\n  overflow-wrap: break-word;\\n}\",\"interoperable_at\":1538438400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/mattdimu/postcss-replace-overflow-wrap\"}],\"vendors_implementations\":3},{\"id\":\"overscroll-behavior-property\",\"title\":\"`overscroll-behavior` Property\",\"description\":\"Properties for controlling when the scroll position of a scroll container reaches the edge of a scrollport\",\"specification\":\"https://www.w3.org/TR/css-overscroll-1/\",\"stage\":2,\"browser_support\":{\"and_chr\":\"63\",\"and_ff\":\"59\",\"android\":\"63\",\"chrome\":\"63\",\"edge\":\"18\",\"firefox\":\"59\",\"ios_saf\":\"16\",\"oculus\":\"5.0\",\"op_mob\":\"46\",\"opera\":\"50\",\"safari\":\"16\",\"samsung\":\"8.0\",\"webview_ios\":\"16\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior\"},\"example\":\".messages {\\n  height: 220px;\\n  overflow: auto;\\n  overscroll-behavior-y: contain;\\n}\\n\\nbody {\\n  margin: 0;\\n  overscroll-behavior: none;\\n}\",\"interoperable_at\":1662940800,\"vendors_implementations\":3},{\"id\":\"place-properties\",\"title\":\"Place Properties\",\"description\":\"Properties for defining alignment within a layout\",\"specification\":\"https://www.w3.org/TR/css-align-3/#place-items-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"59\",\"and_ff\":\"53\",\"android\":\"59\",\"chrome\":\"59\",\"edge\":\"79\",\"firefox\":\"53\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"46\",\"safari\":\"11\",\"samsung\":\"7.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/place-content\"},\"example\":\".example {\\n  place-content: flex-end;\\n  place-items: center / space-between;\\n  place-self: flex-start / center;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-place\"}],\"vendors_implementations\":3},{\"id\":\"prefers-color-scheme-query\",\"title\":\"`prefers-color-scheme` Media Query\",\"description\":\"A media query to detect if the user has requested the system use a light or dark color theme\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#prefers-color-scheme\",\"stage\":2,\"browser_support\":{\"and_chr\":\"76\",\"and_ff\":\"67\",\"android\":\"76\",\"chrome\":\"76\",\"edge\":\"79\",\"firefox\":\"67\",\"ios_saf\":\"13\",\"oculus\":\"7.0\",\"op_mob\":\"54\",\"opera\":\"62\",\"safari\":\"12.1\",\"samsung\":\"14.2\",\"webview_ios\":\"13\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\"},\"example\":\"body {\\n  background-color: white;\\n  color: black;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  body {\\n    background-color: black;\\n    color: white;\\n  }\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"JavaScript Library\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-prefers-color-scheme\"},{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/css-prefers-color-scheme\"}],\"vendors_implementations\":3},{\"id\":\"prefers-reduced-motion-query\",\"title\":\"`prefers-reduced-motion` Media Query\",\"description\":\"A media query to detect if the user has requested less animation and general motion on the page\",\"specification\":\"https://www.w3.org/TR/mediaqueries-5/#prefers-reduced-motion\",\"stage\":2,\"browser_support\":{\"and_chr\":\"74\",\"and_ff\":\"64\",\"android\":\"74\",\"chrome\":\"74\",\"edge\":\"79\",\"firefox\":\"63\",\"ios_saf\":\"10.3\",\"oculus\":\"6.0\",\"op_mob\":\"53\",\"opera\":\"62\",\"safari\":\"10.1\",\"samsung\":\"11.0\",\"webview_ios\":\"10.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion\"},\"example\":\".animation {\\n  animation: vibrate 0.3s linear infinite both; \\n}\\n\\n@media (prefers-reduced-motion: reduce) {\\n  .animation {\\n    animation: none;\\n  }\\n}\",\"interoperable_at\":1579046400,\"vendors_implementations\":3},{\"id\":\"random-function\",\"title\":\"`random()` function\",\"description\":\"Represents a random value between a minimum and maximum value, drawn from a uniform distribution, optionally limiting the possible values to a step between those limits\",\"specification\":\"https://drafts.csswg.org/css-values-5/#random\",\"stage\":2,\"browser_support\":{},\"docs\":{},\"example\":\"div {\\n  color: oklch(0.7, 0.2, random(120deg, 240deg));\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-random-function\"}],\"vendors_implementations\":0},{\"id\":\"read-only-write-pseudo-class\",\"title\":\"`:read-only` and `:read-write` selectors\",\"description\":\"Pseudo-classes to match elements which are considered user-alterable\",\"specification\":\"https://www.w3.org/TR/selectors-4/#rw-pseudos\",\"stage\":2,\"browser_support\":{\"and_chr\":\"18\",\"and_ff\":\"79\",\"android\":\"4.4\",\"chrome\":\"1\",\"edge\":\"13\",\"firefox\":\"78\",\"ios_saf\":\"3.2\",\"oculus\":\"5.0\",\"op_mob\":\"10.1\",\"opera\":\"9\",\"safari\":\"4\",\"samsung\":\"1.0\",\"webview_ios\":\"3.2\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only\"},\"example\":\"input:read-only {\\n  background-color: #ccc;\\n}\",\"interoperable_at\":1595894400,\"vendors_implementations\":3,\"web-feature\":\"read-write-pseudos\"},{\"id\":\"rebeccapurple-color\",\"title\":\"`rebeccapurple` Color\",\"description\":\"A particularly lovely shade of purple in memory of Rebecca Alison Meyer\",\"specification\":\"https://www.w3.org/TR/css-color-4/#valdef-color-rebeccapurple\",\"stage\":2,\"browser_support\":{\"and_chr\":\"38\",\"and_ff\":\"33\",\"android\":\"38\",\"chrome\":\"38\",\"edge\":\"12\",\"firefox\":\"33\",\"ie\":\"11\",\"ios_saf\":\"8\",\"oculus\":\"5.0\",\"op_mob\":\"25\",\"opera\":\"25\",\"safari\":\"9\",\"samsung\":\"3.0\",\"webview_ios\":\"8\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\"},\"example\":\"html {\\n  color: rebeccapurple;\\n}\",\"interoperable_at\":1443571200,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-color-rebeccapurple\"}],\"vendors_implementations\":3},{\"id\":\"relative-color-syntax\",\"title\":\"Relative Colors\",\"description\":\"Modify existing colors using color functions\",\"specification\":\"https://www.w3.org/TR/css-color-5/#relative-colors\",\"stage\":2,\"browser_support\":{\"and_chr\":\"125\",\"and_ff\":\"128\",\"android\":\"125\",\"chrome\":\"125\",\"edge\":\"125\",\"firefox\":\"128\",\"ios_saf\":\"18\",\"op_mob\":\"83\",\"opera\":\"111\",\"safari\":\"18\",\"samsung\":\"27.0\",\"webview_ios\":\"18\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_colors/Relative_colors\"},\"example\":\"p {\\n  color: lch(from peru calc(l * 0.8) c h);\\n}\",\"interoperable_at\":1726444800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-relative-color-syntax\"}],\"vendors_implementations\":3,\"web-feature\":\"relative-color\"},{\"id\":\"scope-pseudo-class\",\"title\":\"`:scope()` Reference Element Pseudo-class\",\"description\":\"A pseudo-class for matching one or more scoping roots\",\"specification\":\"https://www.w3.org/TR/selectors-4/#the-scope-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"27\",\"and_ff\":\"32\",\"android\":\"4.4\",\"chrome\":\"27\",\"edge\":\"79\",\"firefox\":\"32\",\"ios_saf\":\"7\",\"oculus\":\"5.0\",\"op_mob\":\"15\",\"opera\":\"15\",\"safari\":\"7\",\"samsung\":\"1.5\",\"webview_ios\":\"7\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:scope\"},\"example\":\":scope {\\n  background-color: pink;\\n}\",\"interoperable_at\":1579046400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-scope-pseudo-class\"}],\"vendors_implementations\":3},{\"id\":\"sign-functions\",\"title\":\"`abs()` and `sign()` functions\",\"description\":\"The sign-related functions—abs() and sign()—compute various functions related to the sign of their argument\",\"specification\":\"https://www.w3.org/TR/css-values-4/#sign-funcs\",\"stage\":2,\"browser_support\":{\"and_ff\":\"118\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"safari\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/sign\"},\"example\":\"div {\\n  order: abs(-10);\\n  order: sign(-10);\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-sign-functions\"}],\"vendors_implementations\":2},{\"id\":\"src-function\",\"title\":\"`src()` function\",\"description\":\"The argument of `src()` can be provided by functions, such as var(). Otherwise this behaves the same as `url()`\",\"specification\":\"https://www.w3.org/TR/css-values-4/#funcdef-src\",\"stage\":2,\"browser_support\":{},\"example\":\"div {\\n  background: src('./image.jpg');\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/google/postcss-src\"}],\"vendors_implementations\":0},{\"id\":\"stepped-value-functions\",\"title\":\"`round()`, `mod()` and `rem()` functions\",\"description\":\"The stepped-value functions, `round()`, `mod()`, and `rem()`, all transform a given value according to another \\\"step value\\\", in different ways\",\"specification\":\"https://www.w3.org/TR/css-values-4/#round-func\",\"stage\":2,\"browser_support\":{\"and_chr\":\"125\",\"and_ff\":\"118\",\"android\":\"125\",\"chrome\":\"125\",\"edge\":\"125\",\"firefox\":\"118\",\"ios_saf\":\"15.4\",\"op_mob\":\"83\",\"opera\":\"111\",\"safari\":\"15.4\",\"samsung\":\"27.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/round\"},\"example\":\"div {\\n  left: mod(18px, 5px);\\n  top: rem(18px, 5px);\\n  right: round(2.5px, 1px);\\n  bottom: round(up, 15px, 7px);\\n}\",\"interoperable_at\":1715904000,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-stepped-value-functions\"}],\"vendors_implementations\":3},{\"id\":\"system-ui-font-family\",\"title\":\"`system-ui` Font Family\",\"description\":\"A generic font used to match the user’s interface\",\"specification\":\"https://www.w3.org/TR/css-fonts-4/#system-ui-def\",\"stage\":2,\"browser_support\":{\"and_chr\":\"56\",\"and_ff\":\"92\",\"android\":\"56\",\"chrome\":\"56\",\"edge\":\"79\",\"firefox\":\"92\",\"ios_saf\":\"11\",\"oculus\":\"5.0\",\"op_mob\":\"43\",\"opera\":\"43\",\"safari\":\"11\",\"samsung\":\"6.0\",\"webview_ios\":\"11\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Syntax\"},\"example\":\"body {\\n  font-family: system-ui;\\n}\",\"interoperable_at\":1630972800,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/JLHwung/postcss-font-family-system-ui\"}],\"vendors_implementations\":3},{\"id\":\"text-decoration-shorthand\",\"title\":\"`text-decoration` shorthand\",\"description\":\"A property for defining `text-decoration-line`, `text-decoration-thickness`, `text-decoration-style` and `text-decoration-color`\",\"specification\":\"https://www.w3.org/TR/css-text-decor-4/#text-decoration-property\",\"stage\":2,\"browser_support\":{\"and_chr\":\"87\",\"and_ff\":\"79\",\"android\":\"87\",\"chrome\":\"87\",\"edge\":\"87\",\"firefox\":\"70\",\"oculus\":\"13.0\",\"op_mob\":\"62\",\"opera\":\"73\",\"samsung\":\"14.0\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration\"},\"example\":\"p {\\n  text-decoration: green wavy underline 2px;\\n}\",\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-text-decoration-shorthand\"}],\"vendors_implementations\":2},{\"id\":\"trigonometric-functions\",\"title\":\"`sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()` and `atan2()` functions\",\"description\":\"Functions to calculate various basic trigonometric relationships\",\"specification\":\"https://www.w3.org/TR/css-values-4/#trig-funcs\",\"stage\":2,\"browser_support\":{\"and_chr\":\"111\",\"and_ff\":\"108\",\"android\":\"111\",\"chrome\":\"111\",\"edge\":\"111\",\"firefox\":\"108\",\"ios_saf\":\"15.4\",\"op_mob\":\"75\",\"opera\":\"97\",\"safari\":\"15.4\",\"samsung\":\"22.0\",\"webview_ios\":\"15.4\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/sin\"},\"example\":\"body {\\n  left: sin(45deg);\\n  left: cos(45deg);\\n  left: tan(45deg);\\n  left: asin(0.5);\\n  left: acos(0.5);\\n  left: atan(10);\\n  left: atan2(-1, 1);\\n}\",\"interoperable_at\":1678665600,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-trigonometric-functions\"}],\"vendors_implementations\":3},{\"id\":\"unset-value\",\"title\":\"`unset` Keyword\",\"description\":\"The unset CSS keyword resets a property to its inherited value if the property naturally inherits from its parent, and to its initial value if not.\",\"specification\":\"https://www.w3.org/TR/css-cascade-4/#inherit-initial\",\"stage\":3,\"browser_support\":{\"and_chr\":\"41\",\"and_ff\":\"27\",\"android\":\"41\",\"chrome\":\"41\",\"edge\":\"13\",\"firefox\":\"27\",\"ios_saf\":\"9.3\",\"oculus\":\"5.0\",\"op_mob\":\"28\",\"opera\":\"28\",\"safari\":\"9.1\",\"samsung\":\"4.0\",\"webview_ios\":\"9.3\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/unset\"},\"example\":\"div {\\n  border-color: unset;\\n  color: unset;\\n}\",\"interoperable_at\":1458518400,\"polyfills\":[{\"type\":\"PostCSS Plugin\",\"link\":\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-unset-value\"}],\"vendors_implementations\":3},{\"id\":\"when-else-rules\",\"title\":\"When/Else Rules\",\"description\":\"At-rules for specifying media queries and support queries in a single grammar\",\"specification\":\"https://www.w3.org/TR/2021/WD-css-conditional-5-20211221/\",\"stage\":2,\"browser_support\":{},\"example\":\"@when media(width >= 640px) and (supports(display: flex) or supports(display: grid)) {\\n  /* A */\\n} @else media(pointer: coarse) {\\n  /* B */\\n} @else {\\n  /* C */\\n}\",\"vendors_implementations\":0},{\"id\":\"where-pseudo-class\",\"title\":\"`:where()` Zero-Specificity Pseudo-Class\",\"description\":\"A pseudo-class for matching elements in a selector list without contributing specificity\",\"specification\":\"https://www.w3.org/TR/selectors-4/#where-pseudo\",\"stage\":2,\"browser_support\":{\"and_chr\":\"88\",\"and_ff\":\"82\",\"android\":\"88\",\"chrome\":\"88\",\"edge\":\"88\",\"firefox\":\"82\",\"ios_saf\":\"14\",\"oculus\":\"14.0\",\"op_mob\":\"63\",\"opera\":\"74\",\"safari\":\"14\",\"samsung\":\"15.0\",\"webview_ios\":\"14\"},\"docs\":{\"mdn\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/:where\"},\"example\":\"a:where(:not(:hover)) {\\n  text-decoration: none;\\n}\",\"interoperable_at\":1611187200,\"vendors_implementations\":3,\"web-feature\":\"where\"}]"));}}),
"[project]/node_modules/@csstools/postcss-initial/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const o = new Map([
    [
        "animation",
        "none 0s ease 0s 1 normal none running"
    ],
    [
        "animation-delay",
        "0s"
    ],
    [
        "animation-direction",
        "normal"
    ],
    [
        "animation-duration",
        "0s"
    ],
    [
        "animation-fill-mode",
        "none"
    ],
    [
        "animation-iteration-count",
        "1"
    ],
    [
        "animation-name",
        "none"
    ],
    [
        "animation-play-state",
        "running"
    ],
    [
        "animation-timing-function",
        "ease"
    ],
    [
        "backface-visibility",
        "visible"
    ],
    [
        "background",
        "transparent none repeat 0 0 / auto auto padding-box border-box scroll"
    ],
    [
        "background-attachment",
        "scroll"
    ],
    [
        "background-clip",
        "border-box"
    ],
    [
        "background-color",
        "transparent"
    ],
    [
        "background-image",
        "none"
    ],
    [
        "background-origin",
        "padding-box"
    ],
    [
        "background-position",
        "0 0"
    ],
    [
        "background-position-x",
        "0"
    ],
    [
        "background-position-y",
        "0"
    ],
    [
        "background-repeat",
        "repeat"
    ],
    [
        "background-size",
        "auto auto"
    ],
    [
        "border",
        "medium none currentcolor"
    ],
    [
        "border-style",
        "none"
    ],
    [
        "border-width",
        "medium"
    ],
    [
        "border-color",
        "currentcolor"
    ],
    [
        "border-bottom",
        "0"
    ],
    [
        "border-bottom-color",
        "currentcolor"
    ],
    [
        "border-bottom-left-radius",
        "0"
    ],
    [
        "border-bottom-right-radius",
        "0"
    ],
    [
        "border-bottom-style",
        "none"
    ],
    [
        "border-bottom-width",
        "medium"
    ],
    [
        "border-collapse",
        "separate"
    ],
    [
        "border-image",
        "none"
    ],
    [
        "border-left",
        "0"
    ],
    [
        "border-left-color",
        "currentcolor"
    ],
    [
        "border-left-style",
        "none"
    ],
    [
        "border-left-width",
        "medium"
    ],
    [
        "border-radius",
        "0"
    ],
    [
        "border-right",
        "0"
    ],
    [
        "border-right-color",
        "currentcolor"
    ],
    [
        "border-right-style",
        "none"
    ],
    [
        "border-right-width",
        "medium"
    ],
    [
        "border-spacing",
        "0"
    ],
    [
        "border-top",
        "0"
    ],
    [
        "border-top-color",
        "currentcolor"
    ],
    [
        "border-top-left-radius",
        "0"
    ],
    [
        "border-top-right-radius",
        "0"
    ],
    [
        "border-top-style",
        "none"
    ],
    [
        "border-top-width",
        "medium"
    ],
    [
        "bottom",
        "auto"
    ],
    [
        "box-shadow",
        "none"
    ],
    [
        "box-sizing",
        "content-box"
    ],
    [
        "caption-side",
        "top"
    ],
    [
        "clear",
        "none"
    ],
    [
        "clip",
        "auto"
    ],
    [
        "color",
        "#000"
    ],
    [
        "columns",
        "auto"
    ],
    [
        "column-count",
        "auto"
    ],
    [
        "column-fill",
        "balance"
    ],
    [
        "column-gap",
        "normal"
    ],
    [
        "column-rule",
        "medium none currentcolor"
    ],
    [
        "column-rule-color",
        "currentcolor"
    ],
    [
        "column-rule-style",
        "none"
    ],
    [
        "column-rule-width",
        "medium"
    ],
    [
        "column-span",
        "1"
    ],
    [
        "column-width",
        "auto"
    ],
    [
        "content",
        "normal"
    ],
    [
        "counter-increment",
        "none"
    ],
    [
        "counter-reset",
        "none"
    ],
    [
        "cursor",
        "auto"
    ],
    [
        "direction",
        "ltr"
    ],
    [
        "display",
        "inline"
    ],
    [
        "empty-cells",
        "show"
    ],
    [
        "float",
        "none"
    ],
    [
        "font-family",
        "serif"
    ],
    [
        "font-size",
        "medium"
    ],
    [
        "font-style",
        "normal"
    ],
    [
        "font-variant",
        "normal"
    ],
    [
        "font-weight",
        "normal"
    ],
    [
        "font-stretch",
        "normal"
    ],
    [
        "line-height",
        "normal"
    ],
    [
        "height",
        "auto"
    ],
    [
        "hyphens",
        "none"
    ],
    [
        "left",
        "auto"
    ],
    [
        "letter-spacing",
        "normal"
    ],
    [
        "list-style",
        "disc outside none"
    ],
    [
        "list-style-image",
        "none"
    ],
    [
        "list-style-position",
        "outside"
    ],
    [
        "list-style-type",
        "disc"
    ],
    [
        "margin",
        "0"
    ],
    [
        "margin-bottom",
        "0"
    ],
    [
        "margin-left",
        "0"
    ],
    [
        "margin-right",
        "0"
    ],
    [
        "margin-top",
        "0"
    ],
    [
        "max-height",
        "none"
    ],
    [
        "max-width",
        "none"
    ],
    [
        "min-height",
        "0"
    ],
    [
        "min-width",
        "0"
    ],
    [
        "opacity",
        "1"
    ],
    [
        "orphans",
        "2"
    ],
    [
        "outline",
        "medium none currentcolor"
    ],
    [
        "outline-color",
        "currentcolor"
    ],
    [
        "outline-style",
        "none"
    ],
    [
        "outline-width",
        "medium"
    ],
    [
        "overflow",
        "visible"
    ],
    [
        "overflow-x",
        "visible"
    ],
    [
        "overflow-y",
        "visible"
    ],
    [
        "padding",
        "0"
    ],
    [
        "padding-bottom",
        "0"
    ],
    [
        "padding-left",
        "0"
    ],
    [
        "padding-right",
        "0"
    ],
    [
        "padding-top",
        "0"
    ],
    [
        "page-break-after",
        "auto"
    ],
    [
        "page-break-before",
        "auto"
    ],
    [
        "page-break-inside",
        "auto"
    ],
    [
        "perspective",
        "none"
    ],
    [
        "perspective-origin",
        "50% 50%"
    ],
    [
        "position",
        "static"
    ],
    [
        "quotes",
        '"“" "”" "‘" "’"'
    ],
    [
        "right",
        "auto"
    ],
    [
        "tab-size",
        "8"
    ],
    [
        "table-layout",
        "auto"
    ],
    [
        "text-align",
        "left"
    ],
    [
        "text-align-last",
        "auto"
    ],
    [
        "text-decoration",
        "none"
    ],
    [
        "text-decoration-color",
        "currentcolor"
    ],
    [
        "text-decoration-line",
        "none"
    ],
    [
        "text-decoration-style",
        "solid"
    ],
    [
        "text-indent",
        "0"
    ],
    [
        "text-shadow",
        "none"
    ],
    [
        "text-transform",
        "none"
    ],
    [
        "top",
        "auto"
    ],
    [
        "transform",
        "none"
    ],
    [
        "transform-origin",
        "50% 50% 0"
    ],
    [
        "transform-style",
        "flat"
    ],
    [
        "transition",
        "none 0s ease 0s"
    ],
    [
        "transition-delay",
        "0s"
    ],
    [
        "transition-duration",
        "0s"
    ],
    [
        "transition-property",
        "none"
    ],
    [
        "transition-timing-function",
        "ease"
    ],
    [
        "unicode-bidi",
        "normal"
    ],
    [
        "vertical-align",
        "baseline"
    ],
    [
        "visibility",
        "visible"
    ],
    [
        "white-space",
        "normal"
    ],
    [
        "widows",
        "2"
    ],
    [
        "width",
        "auto"
    ],
    [
        "word-spacing",
        "normal"
    ],
    [
        "z-index",
        "auto"
    ]
]), t = [
    "animation",
    "backface-visibility",
    "background",
    "border",
    "border-collapse",
    "border-image",
    "border-radius",
    "border-spacing",
    "bottom",
    "box-shadow",
    "box-sizing",
    "caption-side",
    "clear",
    "clip",
    "color",
    "columns",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-span",
    "column-width",
    "content",
    "counter-increment",
    "counter-reset",
    "cursor",
    "display",
    "empty-cells",
    "float",
    "font-family",
    "font-size",
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "line-height",
    "font",
    "height",
    "hyphens",
    "left",
    "letter-spacing",
    "list-style",
    "margin",
    "max-height",
    "max-width",
    "min-height",
    "min-width",
    "opacity",
    "orphans",
    "outline",
    "overflow",
    "overflow-x",
    "overflow-y",
    "padding",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "perspective",
    "perspective-origin",
    "position",
    "right",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-last",
    "text-decoration",
    "text-indent",
    "text-shadow",
    "text-transform",
    "top",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "vertical-align",
    "visibility",
    "white-space",
    "widows",
    "width",
    "word-spacing",
    "z-index"
];
function hasExactFallback(o, t) {
    const e = o.parent;
    if (!e) return !1;
    const n = o.prop.toLowerCase();
    for(let r = e.index(o) - 1; r >= 0; r--){
        const o = e.nodes[r];
        if ("decl" === o.type && o.prop.toLowerCase() === n) return o.value === t;
    }
    return !1;
}
const e = /^\s?initial\s?$/i, n = /^font$/i, r = /^all$/i, i = [
    "font-family",
    "font-size",
    "font-style",
    "font-variant",
    "font-weight",
    "font-stretch",
    "line-height"
], creator = (a)=>{
    const l = Object.assign({
        preserve: !0
    }, a);
    return {
        postcssPlugin: "postcss-initial",
        Declaration (a) {
            if (a.variable) return;
            if (!e.test(a.value)) return;
            let s;
            s = n.test(a.prop) ? i : r.test(a.prop) ? t : [
                a.prop.toLowerCase()
            ];
            let c = !1;
            s.forEach((t)=>{
                const e = o.get(t);
                e && (hasExactFallback(a, e) || (c = !0, a.cloneBefore({
                    prop: t,
                    value: e
                })));
            }), !l.preserve && c && a.remove();
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-pseudo-class-any-link/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-pseudo-class-any-link/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const t = e().astSync(":link").nodes[0], s = e().astSync(":visited").nodes[0], n = e().astSync("area[href]").nodes[0], o = e().astSync("[href]").nodes[0];
function replaceAnyLink(e, t, s, n) {
    const o = [], r = [];
    try {
        for(let t = 0; t < e.selectors.length; t++){
            const s = e.selectors[t], l = modifiedSelector(s, n);
            l.length ? o.push(...l) : r.push(s);
        }
    } catch (s) {
        return e.warn(t, `Failed to parse selector : "${e.selector}" with message: "${s instanceof Error ? s.message : s}"`), !1;
    }
    return !!o.length && (e.cloneBefore({
        selectors: o
    }), r.length && e.cloneBefore({
        selectors: r
    }), s || e.remove(), !0);
}
function modifiedSelector(r, l) {
    const c = [];
    return e((e)=>{
        const r = [];
        if (e.walkPseudos((e)=>{
            if (":not" === e.value.toLowerCase()) return !1;
            if (":any-link" !== e.value.toLowerCase() || e.nodes && e.nodes.length) return;
            if (!l) return void r.push([
                t.clone(),
                s.clone()
            ]);
            const c = getTagElementsNextToPseudo(e);
            c.includes("area") ? r.push([
                t.clone(),
                s.clone(),
                o.clone()
            ]) : c.length ? r.push([
                t.clone(),
                s.clone()
            ]) : r.push([
                t.clone(),
                s.clone(),
                n.clone()
            ]);
        }), !r.length) return;
        cartesianProduct(...r).forEach((t)=>{
            const s = e.clone();
            s.walkPseudos((e)=>{
                ":any-link" !== e.value.toLowerCase() || e.nodes && e.nodes.length || (insertNode(e.parent, e, t.shift()), e.remove());
            }), c.push(s.toString());
        });
    }).processSync(r), c;
}
function cartesianProduct(...e) {
    const t = [], s = e.length - 1;
    return function helper(n, o) {
        for(let r = 0, l = e[o].length; r < l; r++){
            const l = n.slice(0);
            l.push(e[o][r]), o == s ? t.push(l) : helper(l, o + 1);
        }
    }([], 0), t;
}
function getTagElementsNextToPseudo(t) {
    const s = [];
    let n = t.prev();
    for(; n && "combinator" !== n.type && !e.isPseudoElement(n);)"tag" === n.type && s.push(n.value.toLowerCase()), n = n.prev();
    let o = t.next();
    for(; o && "combinator" !== o.type && !e.isPseudoElement(o);)"tag" === o.type && s.push(o.value.toLowerCase()), o = o.next();
    return s;
}
function insertNode(t, s, n) {
    if (!t || !n) return;
    let o = n.type;
    "selector" === n.type && n.nodes && n.nodes.length && (o = n.nodes[0].type);
    let r = -1, l = -1;
    const c = t.index(s);
    for(let s = c; s >= 0 && "combinator" !== t.nodes[s].type && !e.isPseudoElement(t.nodes[s].type); s--)r = s;
    if ("tag" !== o) {
        for(let s = c; s < t.nodes.length && "combinator" !== t.nodes[s].type && !e.isPseudoElement(t.nodes[s].type); s++)l = s;
        for(let e = r; e <= l; e++)if (t.nodes[e].type === o) return void t.insertAfter(t.at(e), n);
        t.insertAfter(t.at(r), n);
    } else t.insertBefore(t.at(r), n);
}
const creator = (e)=>{
    const t = {
        preserve: e?.preserve ?? !0,
        subFeatures: {
            areaHrefNeedsFixing: e?.subFeatures?.areaHrefNeedsFixing ?? !1
        }
    };
    return {
        postcssPlugin: "postcss-pseudo-class-any-link",
        prepare () {
            const e = new WeakSet;
            return {
                postcssPlugin: "postcss-pseudo-class-any-link",
                Rule (s, { result: n }) {
                    if (!s.selector.toLowerCase().includes(":any-link")) return;
                    if (e.has(s)) return;
                    if ((s.raws.selector && s.raws.selector.raw || s.selector).endsWith(":")) return;
                    replaceAnyLink(s, n, t.preserve, t.subFeatures.areaHrefNeedsFixing) && e.add(s);
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/css-blank-pseudo/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-blank-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = [
    " ",
    ">",
    "~",
    ":",
    "+",
    "@",
    "#",
    "(",
    ")"
];
function isValidReplacement(e) {
    let n = !0;
    for(let t = 0, o = s.length; t < o && n; t++)e.indexOf(s[t]) > -1 && (n = !1);
    return n;
}
const n = "js-blank-pseudo", t = ":blank", creator = (s)=>{
    const o = Object.assign({
        preserve: !0,
        replaceWith: "[blank]",
        disablePolyfillReadyClass: !1
    }, s), r = e().astSync(o.replaceWith);
    return isValidReplacement(o.replaceWith) ? {
        postcssPlugin: "css-blank-pseudo",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "css-blank-pseudo",
                Rule (l, { result: a }) {
                    if (s.has(l)) return;
                    if (!l.selector.toLowerCase().includes(t)) return;
                    const i = l.selectors.flatMap((s)=>{
                        if (!s.toLowerCase().includes(t)) return [
                            s
                        ];
                        let i;
                        try {
                            i = e().astSync(s);
                        } catch (e) {
                            return l.warn(a, `Failed to parse selector : "${s}" with message: "${e instanceof Error ? e.message : e}"`), [
                                s
                            ];
                        }
                        if (void 0 === i) return [
                            s
                        ];
                        let c = !1;
                        if (i.walkPseudos((e)=>{
                            e.value.toLowerCase() === t && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(r.clone({}))));
                        }), !c) return [
                            s
                        ];
                        const d = i.clone();
                        if (!o.disablePolyfillReadyClass) {
                            if (i.nodes?.[0]?.nodes?.length) for(let s = 0; s < i.nodes[0].nodes.length; s++){
                                const t = i.nodes[0].nodes[s];
                                if ("combinator" === t.type || e.isPseudoElement(t)) {
                                    i.nodes[0].insertBefore(t, e.className({
                                        value: n
                                    }));
                                    break;
                                }
                                if (s === i.nodes[0].nodes.length - 1) {
                                    i.nodes[0].append(e.className({
                                        value: n
                                    }));
                                    break;
                                }
                            }
                            return i.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: n
                            }))), [
                                i.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            i.toString()
                        ];
                    });
                    i.join(",") !== l.selectors.join(",") && (s.add(l), l.cloneBefore({
                        selectors: i
                    }), o.preserve || l.remove());
                }
            };
        }
    } : {
        postcssPlugin: "css-blank-pseudo",
        Once (e, { result: s }) {
            e.warn(s, `${o.replaceWith} is not a valid replacement since it can't be applied to single elements.`);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-page-break/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function(options) {
    return {
        postcssPlugin: 'postcss-page-break',
        Declaration (decl) {
            if (decl.prop.startsWith('break-') && /^break-(inside|before|after)/.test(decl.prop)) {
                // do not process column|region related properties
                if (decl.value.search(/column|region/) >= 0) {
                    return;
                }
                let newValue;
                switch(decl.value){
                    case 'page':
                        newValue = 'always';
                        break;
                    case 'avoid-page':
                        newValue = 'avoid';
                        break;
                    default:
                        newValue = decl.value;
                }
                const newProperty = 'page-' + decl.prop;
                if (decl.parent.every((sibling)=>sibling.prop !== newProperty)) {
                    decl.cloneBefore({
                        prop: newProperty,
                        value: newValue
                    });
                }
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/css-has-pseudo/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function compare(e, t) {
    return e.a === t.a ? e.b === t.b ? e.c - t.c : e.b - t.b : e.a - t.a;
}
function selectorSpecificity(t, s) {
    const i = s?.customSpecificity?.(t);
    if (i) return i;
    if (!t) return {
        a: 0,
        b: 0,
        c: 0
    };
    let c = 0, n = 0, o = 0;
    if ("universal" == t.type) return {
        a: 0,
        b: 0,
        c: 0
    };
    if ("id" === t.type) c += 1;
    else if ("tag" === t.type) o += 1;
    else if ("class" === t.type) n += 1;
    else if ("attribute" === t.type) n += 1;
    else if (isPseudoElement(t)) switch(t.value.toLowerCase()){
        case "::slotted":
            if (o += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case "::view-transition-group":
        case "::view-transition-image-pair":
        case "::view-transition-old":
        case "::view-transition-new":
            return t.nodes && 1 === t.nodes.length && "selector" === t.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t.nodes[0]) ? {
                a: 0,
                b: 0,
                c: 0
            } : {
                a: 0,
                b: 0,
                c: 1
            };
        default:
            o += 1;
    }
    else if (e.isPseudoClass(t)) switch(t.value.toLowerCase()){
        case ":-webkit-any":
        case ":any":
        default:
            n += 1;
            break;
        case ":-moz-any":
        case ":has":
        case ":is":
        case ":matches":
        case ":not":
            if (t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":where":
            break;
        case ":nth-child":
        case ":nth-last-child":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const i = t.nodes[0].nodes.findIndex((e)=>"tag" === e.type && "of" === e.value.toLowerCase());
                if (i > -1) {
                    const a = e.selector({
                        nodes: [],
                        value: ""
                    });
                    t.nodes[0].nodes.slice(i + 1).forEach((e)=>{
                        a.append(e.clone());
                    });
                    const r = [
                        a
                    ];
                    t.nodes.length > 1 && r.push(...t.nodes.slice(1));
                    const l = specificityOfMostSpecificListItem(r, s);
                    c += l.a, n += l.b, o += l.c;
                }
            }
            break;
        case ":local":
        case ":global":
            t.nodes && t.nodes.length > 0 && t.nodes.forEach((e)=>{
                const t = selectorSpecificity(e, s);
                c += t.a, n += t.b, o += t.c;
            });
            break;
        case ":host":
        case ":host-context":
            if (n += 1, t.nodes && t.nodes.length > 0) {
                const e = specificityOfMostSpecificListItem(t.nodes, s);
                c += e.a, n += e.b, o += e.c;
            }
            break;
        case ":active-view-transition":
        case ":active-view-transition-type":
            return {
                a: 0,
                b: 1,
                c: 0
            };
    }
    else e.isContainer(t) && t.nodes?.length > 0 && t.nodes.forEach((e)=>{
        const t = selectorSpecificity(e, s);
        c += t.a, n += t.b, o += t.c;
    });
    return {
        a: c,
        b: n,
        c: o
    };
}
function specificityOfMostSpecificListItem(e, t) {
    let s = {
        a: 0,
        b: 0,
        c: 0
    };
    return e.forEach((e)=>{
        const i = selectorSpecificity(e, t);
        compare(i, s) < 0 || (s = i);
    }), s;
}
function isPseudoElement(t) {
    return e.isPseudoElement(t);
}
function selectorNodeContainsNothingOrOnlyUniversal(e) {
    if (!e) return !1;
    if (!e.nodes) return !1;
    const t = e.nodes.filter((e)=>"comment" !== e.type);
    return 0 === t.length || 1 === t.length && "universal" === t[0].type;
}
exports.compare = compare, exports.selectorSpecificity = selectorSpecificity, exports.specificityOfMostSpecificListItem = specificityOfMostSpecificListItem;
}}),
"[project]/node_modules/@csstools/postcss-cascade-layers/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
const t = "csstools-invalid-layer", a = "csstools-layer-with-selector-rules", s = "6efdb677-bb05-44e5-840f-29d2175862fd", n = "b147acf6-11a6-4338-a4d0-80aef4cd1a2f", o = [
    "media",
    "supports"
], l = [
    "keyframes"
], i = /^revert-layer$/i, c = /^import$/i, u = /^layer$/i, m = /layer/i, y = new Set([
    "layer",
    "supports",
    "media",
    "container",
    "scope"
]);
function isProcessableLayerRule(e) {
    if ("atrule" !== e.type) return !1;
    if (!u.test(e.name)) return !1;
    let r = e.parent;
    for(; r;){
        if ("rule" === r.type) return !1;
        if ("atrule" === r.type && !y.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
class Model {
    anonymousLayerCount = 0;
    layerCount = 0;
    layerOrder;
    layerParamsParsed;
    layerNameParts;
    constructor(){
        this.anonymousLayerCount = 0, this.layerCount = 0, this.layerOrder = new Map, this.layerParamsParsed = new Map, this.layerNameParts = new Map;
    }
    createAnonymousLayerName() {
        const e = `anonymous-${this.anonymousLayerCount}-${s}`;
        return this.addLayerNameParts(e), this.layerParamsParsed.set(e, [
            e
        ]), this.anonymousLayerCount++, e;
    }
    createImplicitLayerName(e) {
        const r = this.layerNameParts.get(e) ?? [], t = `implicit-${r[r.length - 1]}-${n}`;
        return this.addLayerNameParts([
            ...r,
            t
        ]), this.layerParamsParsed.set(t, [
            t
        ]), t;
    }
    addLayerParams(e, r) {
        r ? "string" != typeof r ? this.layerParamsParsed.set(e, r) : this.layerParamsParsed.set(e, [
            r
        ]) : this.layerParamsParsed.set(e, [
            e
        ]);
    }
    addLayerNameParts(e) {
        "string" != typeof e ? this.layerNameParts.set(e.join("."), e) : this.layerNameParts.set(e, [
            e
        ]);
    }
    getLayerParams(e) {
        const r = [
            ...this.layerParamsParsed.get(e.params) ?? []
        ];
        let t = e.parent;
        for(; t;)"atrule" === t.type ? (isProcessableLayerRule(t) && r.push(...this.layerParamsParsed.get(t.params) ?? []), t = t.parent) : t = t.parent;
        return r.reverse(), r.flatMap((e)=>this.layerNameParts.get(e) ?? []);
    }
    getLayerNameList(e) {
        const r = this.layerNameParts.get(e) ?? [], t = [];
        for(let e = 0; e < r.length; e++){
            const a = r.slice(0, e + 1).join(".");
            this.layerParamsParsed.has(a) || this.layerParamsParsed.set(a, [
                a
            ]), this.layerNameParts.has(a) || this.layerNameParts.set(a, r.slice(0, e + 1)), t.push(r.slice(0, e + 1).join("."));
        }
        return t;
    }
    sortLayerNames() {
        for (const [e, r] of this.layerOrder){
            const t = this.layerNameParts.get(e) ?? [];
            for(let e = 1; e < t.length; e++){
                const a = t.slice(0, e).join(".");
                this.layerOrder.has(a) || this.layerOrder.set(a, r);
            }
        }
        let e = Array.from(this.layerOrder.entries());
        e = e.sort((e, r)=>{
            const t = this.layerNameParts.get(e[0]) ?? [], a = this.layerNameParts.get(r[0]) ?? [];
            if (t[0] !== a[0]) return (this.layerOrder.get(t[0]) ?? 0) - (this.layerOrder.get(a[0]) ?? 0);
            const s = Math.max(t.length, a.length);
            for(let e = 0; e < s; e++){
                const r = t[e], s = a[e];
                if (r !== s) return r ? s ? (this.layerOrder.get(t.slice(0, e).join(".")) ?? 0) - (this.layerOrder.get(a.slice(0, e).join(".")) ?? 0) : -1 : 1;
            }
            return 0;
        }), this.layerOrder.clear(), e.forEach((e, r)=>{
            this.layerOrder.set(e[0], r);
        });
    }
}
function adjustSelectorSpecificity(r, t) {
    const a = e().astSync(r), s = e().astSync(generateNot(t));
    let n = !1;
    for(let r = 0; r < a.nodes[0].nodes.length; r++)if ("combinator" === a.nodes[0].nodes[r].type || e.isPseudoElement(a.nodes[0].nodes[r])) {
        a.nodes[0].insertBefore(a.nodes[0].nodes[r], s), n = !0;
        break;
    }
    return n || a.nodes[0].insertAfter(a.nodes[0].nodes[a.nodes[0].nodes.length - 1], s), a.toString();
}
function generateNot(e) {
    if (0 === e) return "";
    let r = "";
    for(let t = 0; t < e; t++)r += ":not(#\\#)";
    return r;
}
function someInTree(e, r) {
    let t = !1;
    return e.walk((e)=>{
        if (r(e)) return t = !0, !1;
    }), t;
}
function someAtRuleInTree(e, r) {
    let t = !1;
    return e.walkAtRules((e)=>{
        if (r(e)) return t = !0, !1;
    }), t;
}
function getLayerAtRuleAncestor(e) {
    let r = e.parent;
    for(; r;)if ("atrule" === r.type) {
        if (isProcessableLayerRule(r)) return r;
        r = r.parent;
    } else r = r.parent;
    return null;
}
function removeEmptyDescendantBlocks(e) {
    e && (e.walk((e)=>{
        ("rule" === e.type || "atrule" === e.type && [
            "layer",
            ...o
        ].includes(e.name.toLowerCase())) && 0 === e.nodes?.length && e.remove();
    }), 0 === e.nodes?.length && e.remove());
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (void 0 === r.nodes) return;
        if (r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function desugarAndParseLayerNames(r, a) {
    r.walkAtRules((r)=>{
        if (!isProcessableLayerRule(r)) return;
        if (r.params) {
            const s = [];
            let n = !1;
            if (e().astSync(r.params).each((e)=>{
                const r = [];
                e.walk((e)=>{
                    switch(e.type){
                        case "class":
                        case "tag":
                            r.push(e.value);
                            break;
                        default:
                            n = !0;
                    }
                }), n || (s.push(r.join(".")), a.addLayerNameParts(r));
            }), a.addLayerParams(r.params, s), r.nodes && s.length > 1 && (n = !0), n) return void (r.name = t);
            if (!r.nodes || 0 === r.nodes.length) {
                if (s.length <= 1) return;
                return s.slice(0, -1).forEach((e)=>{
                    a.addLayerParams(e, e), r.cloneBefore({
                        params: e
                    });
                }), a.addLayerParams(s[s.length - 1], s[s.length - 1]), void (r.params = s[s.length - 1]);
            }
        }
        r.params || (r.raws.afterName = " ", r.params = a.createAnonymousLayerName());
        const s = someAtRuleInTree(r, (e)=>isProcessableLayerRule(e)), n = someInTree(r, (e)=>{
            if ("rule" !== e.type) return !1;
            return getLayerAtRuleAncestor(e) === r;
        });
        if (s && n) {
            const e = a.createImplicitLayerName(r.params), t = r.clone({
                params: e
            });
            t.walkAtRules((e)=>{
                isProcessableLayerRule(e) && e.remove();
            }), r.walk((e)=>{
                if ("atrule" === e.type && isProcessableLayerRule(e)) return;
                if ("atrule" === e.type && o.includes(e.name.toLowerCase())) return;
                getLayerAtRuleAncestor(e) === r && e.remove();
            }), r.append(t), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }
    });
}
function desugarNestedLayers(e, r) {
    for(; someAtRuleInTree(e, (e)=>!!e.nodes && someAtRuleInTree(e, (e)=>isProcessableLayerRule(e)));){
        let t = !1;
        if (e.walkAtRules((a)=>{
            if (isProcessableLayerRule(a) && a.parent !== e) {
                if ("atrule" === a.parent?.type && isProcessableLayerRule(a.parent)) {
                    const e = a.parent;
                    {
                        const t = r.layerNameParts.get(e.params), s = r.layerNameParts.get(a.params);
                        if (!t || !s) return;
                        r.layerNameParts.set(`${e.params}.${a.params}`, [
                            ...t,
                            ...s
                        ]), r.layerParamsParsed.set(`${e.params}.${a.params}`, [
                            `${e.params}.${a.params}`
                        ]);
                    }
                    return a.params = `${e.params}.${a.params}`, e.before(a), removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
                }
                if ("atrule" === a.parent?.type) {
                    const e = a.parent, r = e.clone(), t = a.clone();
                    return r.removeAll(), t.removeAll(), r.append(a.nodes), t.append(r), e.before(t), a.remove(), removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
                }
                t = !0;
            }
        }), t) break;
    }
}
function sortRootNodes(e, r) {
    e.nodes && (e.walkAtRules((e)=>{
        if (!isProcessableLayerRule(e)) return;
        const r = e.clone(), t = e.clone();
        r.walkAtRules((e)=>{
            if (l.includes(e.name.toLowerCase())) {
                const r = e.parent;
                return e.remove(), removeEmptyDescendantBlocks(r), void removeEmptyAncestorBlocks(r);
            }
            if (someInTree(e, (e)=>"rule" === e.type)) return;
            const r = e.parent;
            e.remove(), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }), t.walkRules((e)=>{
            if (e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase())) return;
            const r = e.parent;
            e.remove(), removeEmptyDescendantBlocks(r), removeEmptyAncestorBlocks(r);
        }), t.walkAtRules((e)=>{
            if (o.includes(e.name.toLowerCase())) return removeEmptyDescendantBlocks(e), void removeEmptyAncestorBlocks(e);
        }), r.name = a, e.replaceWith(r, t), r.nodes?.length || r.remove(), t.nodes?.length || t.remove();
    }), e.nodes.sort((e, t)=>{
        const a = "atrule" === e.type && u.test(e.name), s = "atrule" === t.type && u.test(t.name);
        if (a && s) {
            return (r.layerOrder.get(e.params) ?? 0) - (r.layerOrder.get(t.params) ?? 0);
        }
        return a !== s ? a ? -1 : 1 : 0;
    }), e.walkAtRules(a, (e)=>{
        e.name = "layer";
    }));
}
function getConditionalAtRuleAncestor(e) {
    let r = e.parent;
    for(; r;)if ("atrule" === r.type) {
        if (o.includes(r.name.toLowerCase())) return r;
        r = r.parent;
    } else r = r.parent;
    return null;
}
function recordLayerOrder(e, r, { result: t, options: a }) {
    e.walkAtRules((e)=>{
        if (!isProcessableLayerRule(e)) return;
        const o = r.getLayerParams(e), l = o.join(".");
        r.layerOrder.has(l) || (a.onConditionalRulesChangingLayerOrder && getConditionalAtRuleAncestor(e) && !e.params.endsWith(n) && !e.params.endsWith(s) && e.warn(t, "handling different layer orders in conditional rules is unsupported by this plugin and will cause style differences between browser versions."), r.layerParamsParsed.has(l) || r.layerParamsParsed.set(l, [
            l
        ]), r.layerNameParts.has(l) || r.layerNameParts.set(l, [
            ...o
        ]), r.getLayerNameList(l).forEach((e)=>{
            r.layerOrder.has(e) || (r.layerOrder.set(e, r.layerCount), r.layerCount += 1);
        })), e.nodes && 0 !== e.nodes.length || e.remove();
    });
}
function splitImportantStyles(e) {
    e.walkDecls((e)=>{
        if (!e.important) return;
        const r = e.parent;
        if (!r) return;
        if ("atrule" === r?.parent?.type && l.includes(r.parent.name.toLowerCase())) return;
        const t = r.clone();
        t.each((e)=>{
            "decl" === e.type && e.important || e.remove();
        }), r.each((e)=>{
            "decl" === e.type && e.important && e.remove();
        }), r.before(t), removeEmptyDescendantBlocks(r);
    });
}
const creator = (a)=>{
    const s = Object.assign({
        onRevertLayerKeyword: "warn",
        onConditionalRulesChangingLayerOrder: "warn",
        onImportLayerRule: "warn"
    }, a);
    return {
        postcssPlugin: "postcss-cascade-layers",
        OnceExit (a, { result: n }) {
            let o = !1;
            if ((s.onRevertLayerKeyword || s.onImportLayerRule) && a.walk((e)=>"decl" === e.type ? i.test(e.value) ? void e.warn(n, 'handling "revert-layer" is unsupported by this plugin and will cause style differences between browser versions.') : void 0 : "atrule" === e.type ? c.test(e.name) && m.test(e.params) ? void e.warn(n, "To use @import with layers, the postcss-import plugin is also required. This plugin alone will not support using the @import at-rule.") : u.test(e.name) ? void (o = !0) : void 0 : void 0), !o) return;
            splitImportantStyles(a);
            const y = new Model;
            if (desugarAndParseLayerNames(a, y), recordLayerOrder(a, y, {
                result: n,
                options: s
            }), !y.layerCount) return void a.walkAtRules(t, (e)=>{
                e.name = "layer";
            });
            let d = 0;
            for(a.walkRules((t)=>{
                t.selectors.forEach((a)=>{
                    try {
                        const t = r.selectorSpecificity(e().astSync(a));
                        d = Math.max(d, t.a + 1);
                    } catch (e) {
                        t.warn(n, `Failed to parse selector : "${a}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                });
            }), a.walkRules((e)=>{
                e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase()) || getLayerAtRuleAncestor(e) || e.some((e)=>"decl" === e.type && e.important) || (e.selectors = e.selectors.map((r)=>{
                    try {
                        return adjustSelectorSpecificity(r, y.layerCount * d);
                    } catch (t) {
                        e.warn(n, `Failed to parse selector : "${r}" with message: "${t instanceof Error ? t.message : t}"`);
                    }
                    return r;
                }));
            }), y.sortLayerNames(), desugarNestedLayers(a, y), sortRootNodes(a, y), a.walkRules((e)=>{
                if (e.parent && "atrule" === e.parent.type && l.includes(e.parent.name.toLowerCase())) return;
                const r = getLayerAtRuleAncestor(e);
                if (!r) return;
                const t = y.getLayerParams(r).join(".");
                let a = (y.layerOrder.get(t) ?? 0) * d;
                e.some((e)=>"decl" === e.type && e.important) && (a = y.layerCount - a), e.selectors = e.selectors.map((e)=>adjustSelectorSpecificity(e, a));
            }); someAtRuleInTree(a, (e)=>isProcessableLayerRule(e));)a.walkAtRules((e)=>{
                isProcessableLayerRule(e) && (e.nodes ? e.replaceWith(e.nodes) : e.remove());
            });
            a.walkAtRules(t, (e)=>{
                e.name = "layer";
            });
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-attribute-case-insensitive/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-attribute-case-insensitive/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function nodeIsInsensitiveAttribute(e) {
    return "attribute" === e.type && (e.insensitive ?? !1);
}
function selectorHasInsensitiveAttribute(e) {
    return e.some(nodeIsInsensitiveAttribute);
}
function transformString(e, t, s) {
    const r = s.charAt(t);
    if ("" === r) return e;
    let n = e.map((e)=>e + r);
    const o = r.toLocaleUpperCase();
    return o !== r && (n = n.concat(e.map((e)=>e + o))), transformString(n, t + 1, s);
}
function createNewSelectors(t) {
    let s = [
        e.selector({
            value: "",
            nodes: []
        })
    ];
    return t.each((e)=>{
        if (!nodeIsInsensitiveAttribute(e)) return void s.forEach((t)=>{
            t.append(e.clone());
        });
        const t = transformString([
            ""
        ], 0, (r = e).value ?? "").map((e)=>{
            const t = r.clone({
                spaces: {
                    after: r.spaces.after,
                    before: r.spaces.before
                },
                insensitive: !1
            });
            return t.setValue(e), t;
        });
        var r;
        const n = [];
        t.forEach((e)=>{
            s.forEach((t)=>{
                const s = t.clone({});
                s.append(e), n.push(s);
            });
        }), s = n;
    }), s;
}
const creator = (t)=>{
    const s = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-attribute-case-insensitive",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "postcss-attribute-case-insensitive",
                Rule (r, { result: n }) {
                    if (t.has(r)) return;
                    if (!/i\s*\]/i.test(r.selector)) return;
                    let o;
                    try {
                        o = e((e)=>{
                            let t = [];
                            e.each((e)=>{
                                selectorHasInsensitiveAttribute(e) && (t = t.concat(createNewSelectors(e)), e.remove());
                            }), t.length && t.forEach((t)=>e.append(t));
                        }).processSync(r.selector);
                    } catch (e) {
                        return void r.warn(n, `Failed to parse selector : "${r.selector}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                    o !== r.selector && (t.add(r), r.cloneBefore({
                        selector: o
                    }), s.preserve || r.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-clamp/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
let valueParser = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function parseValue(value) {
    let parsed = value.match(/([\d.-]+)(.*)/);
    if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {
        return undefined;
    }
    return [
        parseFloat(parsed[1]),
        parsed[2]
    ];
}
function compose(first, second, third) {
    if (first && second && third) {
        return `max(${first}, min(${second}, ${third}))`;
    }
    if (first && second) {
        return `max(${first}, ${second})`;
    }
    return first;
}
function updateValue(declaration, value, preserve) {
    let newValue = value;
    let newValueAst = valueParser(value);
    let valueAST = valueParser(declaration.value);
    // Walk can't be interrupted, so we only care about first
    let foundClamp = false;
    valueAST.walk((node, index, nodes)=>{
        let isClamp = node.type === 'function' && node.value === 'clamp';
        if (!isClamp || foundClamp) {
            return;
        }
        foundClamp = true;
        nodes[index] = newValueAst;
    });
    if (foundClamp) {
        newValue = valueAST.toString();
    }
    if (preserve) {
        declaration.cloneBefore({
            value: newValue
        });
    } else {
        declaration.value = newValue;
    }
}
module.exports = (opts)=>{
    opts = opts || {};
    let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false;
    let preserve = opts.preserve ? Boolean(opts.preserve) : false;
    return {
        postcssPlugin: 'postcss-clamp',
        Declaration (decl) {
            if (!decl || !decl.value.includes('clamp')) {
                return;
            }
            valueParser(decl.value).walk((node)=>{
                let nodes = node.nodes;
                if (node.type !== 'function' || node.value !== 'clamp' || nodes.length !== 5) {
                    return;
                }
                let first = nodes[0];
                let second = nodes[2];
                let third = nodes[4];
                let naive = compose(valueParser.stringify(first), valueParser.stringify(second), valueParser.stringify(third));
                if (!precalculate || second.type !== 'word' || third.type !== 'word') {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let parsedSecond = parseValue(second.value);
                let parsedThird = parseValue(third.value);
                if (parsedSecond === undefined || parsedThird === undefined) {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let [secondValue, secondUnit] = parsedSecond;
                let [thirdValue, thirdUnit] = parsedThird;
                if (secondUnit !== thirdUnit) {
                    updateValue(decl, naive, preserve);
                    return;
                }
                let parsedFirst = parseValue(first.value);
                if (parsedFirst === undefined) {
                    let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;
                    updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);
                    return;
                }
                let [firstValue, firstUnit] = parsedFirst;
                if (firstUnit !== secondUnit) {
                    let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;
                    updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);
                    return;
                }
                updateValue(decl, compose(`${firstValue + secondValue + thirdValue}${secondUnit}`), preserve);
            });
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
const a = [
    "at",
    "bottom",
    "center",
    "circle",
    "closest-corner",
    "closest-side",
    "ellipse",
    "farthest-corner",
    "farthest-side",
    "from",
    "in",
    "left",
    "right",
    "to",
    "top"
];
function doublePositionGradients(e) {
    const p = [], r = e.value.toLowerCase();
    if ("function" === e.type && ("conic-gradient" === r || "linear-gradient" === r || "radial-gradient" === r || "repeating-conic-gradient" === r || "repeating-linear-gradient" === r || "repeating-radial-gradient" === r)) {
        let r = 0, t = !1, i = !1;
        e: for(let o = 0; o < e.nodes.length; o++){
            const s = e.nodes[o];
            if ("word" === s.type && a.includes(s.value.toLowerCase()) && (t = !0), "div" !== s.type || "," !== s.value.trim()) if ("word" !== s.type || "in" !== s.value.toLowerCase()) {
                if ("word" !== s.type && "function" !== s.type || r++, i) switch(e.value.toLowerCase()){
                    case "conic-gradient":
                        p.push("(background: conic-gradient(in oklch, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "linear-gradient":
                        p.push("(background: linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "radial-gradient":
                        p.push("(background: radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                        break e;
                    case "repeating-conic-gradient":
                        p.push("(background: repeating-conic-gradient(in oklch from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "repeating-linear-gradient":
                        p.push("(background: repeating-linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "repeating-radial-gradient":
                        p.push("(background: repeating-radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                        break e;
                }
                if (!t && 3 === r) switch(e.value.toLowerCase()){
                    case "conic-gradient":
                        p.push("(background: conic-gradient(red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "linear-gradient":
                        p.push("(background: linear-gradient(red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "radial-gradient":
                        p.push("(background: radial-gradient(red, red 1px 2px, red 3px))");
                        break e;
                    case "repeating-conic-gradient":
                        p.push("(background: repeating-conic-gradient(from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                        break e;
                    case "repeating-linear-gradient":
                        p.push("(background: repeating-linear-gradient(red 0%, red 0% 1%, red 2%))");
                        break e;
                    case "repeating-radial-gradient":
                        p.push("(background: repeating-radial-gradient(red, red 1px 2px, red 3px))");
                        break e;
                }
            } else i = !0;
            else r = 0, t = !1;
        }
    }
    return p;
}
const p = [
    {
        supports: "color-mix(in lch, red, blue)",
        property: "color",
        sniff: "color-mix",
        matchers: [
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color-mix(in lch, red)",
        property: "color",
        sniff: "color-mix",
        matchers: [
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color-mix",
                nodes: [
                    {
                        type: "word",
                        value: "in"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        value: "hue"
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        anyRemainingArguments: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(from red l 1 1% / calc(alpha + 0.1))",
        property: "color",
        sniff: "from ",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "from"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(display-p3 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(display-p3 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "display-p3"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "display-p3"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb-linear"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "srgb-linear"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "a98-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "a98-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "prophoto-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "prophoto-rgb"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "rec2020"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "rec2020"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d50"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d50"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d65"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz-d65"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "color(xyz 0 0 0%)",
        property: "color",
        sniff: "color",
        matchers: [
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "color",
                nodes: [
                    {
                        type: "word",
                        value: "xyz"
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsl(0, 0%, 0%)",
        property: "color",
        sniff: "hsl",
        matchers: [
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsl(0 0% 0% / 0)",
        property: "color",
        sniff: "hsl",
        matchers: [
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hsl",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hsla(0 0% 0% / 0)",
        property: "color",
        sniff: "hsla",
        matchers: [
            {
                type: "function",
                value: "hsla",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "hwb(0 0% 0%)",
        property: "color",
        sniff: "hwb",
        matchers: [
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "hwb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(0% 0 0%)",
        property: "color",
        sniff: "lab",
        matchers: [
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "lab(0% 0 0%)",
        property: "color",
        sniff: "lch",
        matchers: [
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "lch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "oklab(0% 0 0%)",
        property: "color",
        sniff: "oklab",
        matchers: [
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklab",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "oklab(0% 0 0%)",
        property: "color",
        sniff: "oklch",
        matchers: [
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "oklch",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgb(0, 0, 0, 0)",
        property: "color",
        sniff: "rgb",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgb(0 0 0 / 0)",
        property: "color",
        sniff: "rgb",
        matchers: [
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "rgb",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "rgba(0 0 0 / 0)",
        property: "color",
        sniff: "rgba",
        matchers: [
            {
                type: "function",
                value: "rgba",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "space"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: "/"
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "light-dark(red, red)",
        property: "color",
        sniff: "light-dark",
        matchers: [
            {
                type: "function",
                value: "light-dark",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    },
                    {
                        type: "div",
                        value: ","
                    },
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "contrast-color(red)",
        property: "color",
        sniff: "contrast-color",
        matchers: [
            {
                type: "function",
                value: "contrast-color",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            },
            {
                type: "function",
                value: "contrast-color",
                nodes: [
                    {
                        type: "word",
                        isVariable: !0
                    }
                ]
            }
        ]
    },
    {
        supports: "1ic",
        property: "font-size",
        sniff: "ic",
        matchers: [
            {
                type: "word",
                value: "1ic",
                dimension: {
                    unit: "ic"
                }
            }
        ]
    },
    {
        supports: '"a" / "a"',
        property: "content",
        only_on_property: "content",
        sniff: "/",
        matchers: [
            {
                type: "div",
                value: "/"
            }
        ]
    }
];
function matches(e, a) {
    if (e.isVariable && a && ("word" === a.type || "string" === a.type || "function" === a.type)) return !0;
    if (e.type !== a.type) return !1;
    if (doesNotMatchValue(e, a)) return !1;
    if (e.nodes && a.nodes) {
        for(let p = 0; p < Math.max(e.nodes.length, a.nodes.length); p++){
            let r = p, t = p;
            for(; e.nodes[r] && "space" === e.nodes[r].type;)r++;
            for(; a.nodes[t] && "space" === a.nodes[t].type;)t++;
            if (!!e.nodes[r] != !!a.nodes[t]) return !1;
            if (e.nodes[r].anyRemainingArguments && a.nodes[t]) return !0;
            if (!matches(e.nodes[r], a.nodes[t])) return !1;
        }
        return !0;
    }
    return !0;
}
function doesNotMatchValue(e, a) {
    return ("space" !== e.type || "space" !== a.type || e.value?.trim() !== a.value?.trim()) && (e.dimension && a.dimension ? e.dimension.unit !== a.dimension.unit : "string" === e.type ? e.value !== a.value : e.value?.toLowerCase() !== a.value?.toLowerCase());
}
const r = /^var$/i;
function conditionsFromValue(a, t = !1) {
    const i = a.value, o = [], s = p.filter((e)=>i.includes(e.sniff) && (e.only_on_property ?? a.prop) === a.prop);
    let y = !1;
    try {
        e(i).walk((a)=>{
            "function" === a.type && r.test(a.value) && (y = !0);
            try {
                const p = e.unit(a.value);
                !1 !== p && (a.dimension = p);
            } catch  {}
            for(let e = 0; e < s.length; e++){
                const p = s[e];
                for(let e = 0; e < p.matchers.length; e++){
                    if (matches(p.matchers[e], a)) return void o.push(`(${p.property}: ${p.supports})`);
                }
            }
            o.push(...doublePositionGradients(a));
        });
    } catch  {}
    return t && !y ? {
        support: []
    } : {
        support: Array.from(new Set(o)).sort()
    };
}
const t = /var\(/i, i = /^initial$/i, o = /^\s*$/, creator = ()=>({
        postcssPlugin: "postcss-progressive-custom-properties",
        prepare () {
            const e = new WeakMap;
            return {
                postcssPlugin: "postcss-progressive-custom-properties",
                OnceExit (a, { postcss: p }) {
                    a.walkDecls((a)=>{
                        if (!a.parent) return;
                        const r = e.get(a.parent) || {
                            conditionalRules: [],
                            propNames: new Set,
                            lastConditionParams: {
                                support: void 0
                            },
                            lastConditionalRule: void 0
                        };
                        if (e.set(a.parent, r), a.variable) {
                            if (!r.propNames.has(a.prop)) return void r.propNames.add(a.prop);
                        } else {
                            const e = a.prop.toLowerCase();
                            if (!r.propNames.has(e)) return void r.propNames.add(e);
                        }
                        if (!a.variable && !t.test(a.value)) return;
                        if (i.test(a.value)) return;
                        if (o.test(a.value)) return;
                        const s = conditionsFromValue(a, !a.variable).support.join(" and ");
                        if (!s) return;
                        if (r.lastConditionParams.support !== s && (r.lastConditionalRule = void 0), r.lastConditionalRule) return r.lastConditionalRule.append(a.clone()), void a.remove();
                        const y = [];
                        if (s && y.push(p.atRule({
                            name: "supports",
                            params: s,
                            source: a.parent.source,
                            raws: {
                                before: "\n\n",
                                after: "\n"
                            }
                        })), !y.length) return;
                        for(let e = 0; e < y.length - 1; e++){
                            const a = y[e], p = y[e + 1];
                            a.append(p);
                        }
                        const l = y[0], d = y[y.length - 1], n = a.parent.clone();
                        n.removeAll(), n.raws.before = "\n", n.append(a.clone()), a.remove(), r.lastConditionParams.support = s, r.lastConditionalRule = n, d.append(n), r.conditionalRules.push(l);
                    }), a.walk((a)=>{
                        const p = e.get(a);
                        p && 0 !== p.conditionalRules.length && p.conditionalRules.reverse().forEach((e)=>{
                            a.after(e);
                        });
                    });
                }
            };
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
class ParseError extends Error {
    sourceStart;
    sourceEnd;
    parserState;
    constructor(e, n, o, t){
        super(e), this.name = "ParseError", this.sourceStart = n, this.sourceEnd = o, this.parserState = t;
    }
}
class ParseErrorWithToken extends ParseError {
    token;
    constructor(e, n, o, t, r){
        super(e, n, o, t), this.token = r;
    }
}
const e = {
    UnexpectedNewLineInString: "Unexpected newline while consuming a string token.",
    UnexpectedEOFInString: "Unexpected EOF while consuming a string token.",
    UnexpectedEOFInComment: "Unexpected EOF while consuming a comment.",
    UnexpectedEOFInURL: "Unexpected EOF while consuming a url token.",
    UnexpectedEOFInEscapedCodePoint: "Unexpected EOF while consuming an escaped code point.",
    UnexpectedCharacterInURL: "Unexpected character while consuming a url token.",
    InvalidEscapeSequenceInURL: "Invalid escape sequence while consuming a url token.",
    InvalidEscapeSequenceAfterBackslash: 'Invalid escape sequence after "\\"'
}, n = "undefined" != typeof globalThis && "structuredClone" in globalThis;
const o = 13, t = 45, r = 10, s = 43, i = 65533;
function checkIfFourCodePointsWouldStartCDO(e) {
    return 60 === e.source.codePointAt(e.cursor) && 33 === e.source.codePointAt(e.cursor + 1) && e.source.codePointAt(e.cursor + 2) === t && e.source.codePointAt(e.cursor + 3) === t;
}
function isDigitCodePoint(e) {
    return e >= 48 && e <= 57;
}
function isUppercaseLetterCodePoint(e) {
    return e >= 65 && e <= 90;
}
function isLowercaseLetterCodePoint(e) {
    return e >= 97 && e <= 122;
}
function isHexDigitCodePoint(e) {
    return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function isLetterCodePoint(e) {
    return isLowercaseLetterCodePoint(e) || isUppercaseLetterCodePoint(e);
}
function isIdentStartCodePoint(e) {
    return isLetterCodePoint(e) || isNonASCII_IdentCodePoint(e) || 95 === e;
}
function isIdentCodePoint(e) {
    return isIdentStartCodePoint(e) || isDigitCodePoint(e) || e === t;
}
function isNonASCII_IdentCodePoint(e) {
    return 183 === e || 8204 === e || 8205 === e || 8255 === e || 8256 === e || 8204 === e || 192 <= e && e <= 214 || 216 <= e && e <= 246 || 248 <= e && e <= 893 || 895 <= e && e <= 8191 || 8304 <= e && e <= 8591 || 11264 <= e && e <= 12271 || 12289 <= e && e <= 55295 || 63744 <= e && e <= 64975 || 65008 <= e && e <= 65533 || 0 === e || !!isSurrogate(e) || e >= 65536;
}
function isNewLine(e) {
    return e === r || e === o || 12 === e;
}
function isWhitespace(e) {
    return 32 === e || e === r || 9 === e || e === o || 12 === e;
}
function isSurrogate(e) {
    return e >= 55296 && e <= 57343;
}
function checkIfTwoCodePointsAreAValidEscape(e) {
    return 92 === e.source.codePointAt(e.cursor) && !isNewLine(e.source.codePointAt(e.cursor + 1) ?? -1);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e, n) {
    return n.source.codePointAt(n.cursor) === t ? n.source.codePointAt(n.cursor + 1) === t || !!isIdentStartCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1) || 92 === n.source.codePointAt(n.cursor + 1) && !isNewLine(n.source.codePointAt(n.cursor + 2) ?? -1) : !!isIdentStartCodePoint(n.source.codePointAt(n.cursor) ?? -1) || checkIfTwoCodePointsAreAValidEscape(n);
}
function checkIfThreeCodePointsWouldStartANumber(e) {
    return e.source.codePointAt(e.cursor) === s || e.source.codePointAt(e.cursor) === t ? !!isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) || 46 === e.source.codePointAt(e.cursor + 1) && isDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1) : 46 === e.source.codePointAt(e.cursor) ? isDigitCodePoint(e.source.codePointAt(e.cursor + 1) ?? -1) : isDigitCodePoint(e.source.codePointAt(e.cursor) ?? -1);
}
function checkIfTwoCodePointsStartAComment(e) {
    return 47 === e.source.codePointAt(e.cursor) && 42 === e.source.codePointAt(e.cursor + 1);
}
function checkIfThreeCodePointsWouldStartCDC(e) {
    return e.source.codePointAt(e.cursor) === t && e.source.codePointAt(e.cursor + 1) === t && 62 === e.source.codePointAt(e.cursor + 2);
}
var c, a, u;
function consumeComment(n, o) {
    for(o.advanceCodePoint(2);;){
        const t = o.readCodePoint();
        if (void 0 === t) {
            const t = [
                exports.TokenType.Comment,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInComment, o.representationStart, o.representationEnd, [
                "4.3.2. Consume comments",
                "Unexpected EOF"
            ], t)), t;
        }
        if (42 === t && void 0 !== o.source.codePointAt(o.cursor) && 47 === o.source.codePointAt(o.cursor)) {
            o.advanceCodePoint();
            break;
        }
    }
    return [
        exports.TokenType.Comment,
        o.source.slice(o.representationStart, o.representationEnd + 1),
        o.representationStart,
        o.representationEnd,
        void 0
    ];
}
function consumeEscapedCodePoint(n, t) {
    const s = t.readCodePoint();
    if (void 0 === s) return n.onParseError(new ParseError(e.UnexpectedEOFInEscapedCodePoint, t.representationStart, t.representationEnd, [
        "4.3.7. Consume an escaped code point",
        "Unexpected EOF"
    ])), i;
    if (isHexDigitCodePoint(s)) {
        const e = [
            s
        ];
        let n;
        for(; void 0 !== (n = t.source.codePointAt(t.cursor)) && isHexDigitCodePoint(n) && e.length < 6;)e.push(n), t.advanceCodePoint();
        isWhitespace(t.source.codePointAt(t.cursor) ?? -1) && (t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r && t.advanceCodePoint(), t.advanceCodePoint());
        const c = parseInt(String.fromCodePoint(...e), 16);
        return 0 === c || isSurrogate(c) || c > 1114111 ? i : c;
    }
    return 0 === s || isSurrogate(s) ? i : s;
}
function consumeIdentSequence(e, n) {
    const o = [];
    for(;;){
        const t = n.source.codePointAt(n.cursor) ?? -1;
        if (0 === t || isSurrogate(t)) o.push(i), n.advanceCodePoint(+(t > 65535) + 1);
        else if (isIdentCodePoint(t)) o.push(t), n.advanceCodePoint(+(t > 65535) + 1);
        else {
            if (!checkIfTwoCodePointsAreAValidEscape(n)) return o;
            n.advanceCodePoint(), o.push(consumeEscapedCodePoint(e, n));
        }
    }
}
function consumeHashToken(e, n) {
    n.advanceCodePoint();
    const o = n.source.codePointAt(n.cursor);
    if (void 0 !== o && (isIdentCodePoint(o) || checkIfTwoCodePointsAreAValidEscape(n))) {
        let o = exports.HashType.Unrestricted;
        checkIfThreeCodePointsWouldStartAnIdentSequence(0, n) && (o = exports.HashType.ID);
        const t = consumeIdentSequence(e, n);
        return [
            exports.TokenType.Hash,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: String.fromCodePoint(...t),
                type: o
            }
        ];
    }
    return [
        exports.TokenType.Delim,
        "#",
        n.representationStart,
        n.representationEnd,
        {
            value: "#"
        }
    ];
}
function consumeNumber(e, n) {
    let o = exports.NumberType.Integer;
    for(n.source.codePointAt(n.cursor) !== s && n.source.codePointAt(n.cursor) !== t || n.advanceCodePoint(); isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (46 === n.source.codePointAt(n.cursor) && isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(2), o = exports.NumberType.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    if (101 === n.source.codePointAt(n.cursor) || 69 === n.source.codePointAt(n.cursor)) {
        if (isDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) n.advanceCodePoint(2);
        else {
            if (n.source.codePointAt(n.cursor + 1) !== t && n.source.codePointAt(n.cursor + 1) !== s || !isDigitCodePoint(n.source.codePointAt(n.cursor + 2) ?? -1)) return o;
            n.advanceCodePoint(3);
        }
        for(o = exports.NumberType.Number; isDigitCodePoint(n.source.codePointAt(n.cursor) ?? -1);)n.advanceCodePoint();
    }
    return o;
}
function consumeNumericToken(e, n) {
    let o;
    {
        const e = n.source.codePointAt(n.cursor);
        e === t ? o = "-" : e === s && (o = "+");
    }
    const r = consumeNumber(0, n), i = parseFloat(n.source.slice(n.representationStart, n.representationEnd + 1));
    if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, n)) {
        const t = consumeIdentSequence(e, n);
        return [
            exports.TokenType.Dimension,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                value: i,
                signCharacter: o,
                type: r,
                unit: String.fromCodePoint(...t)
            }
        ];
    }
    return 37 === n.source.codePointAt(n.cursor) ? (n.advanceCodePoint(), [
        exports.TokenType.Percentage,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: i,
            signCharacter: o
        }
    ]) : [
        exports.TokenType.Number,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: i,
            signCharacter: o,
            type: r
        }
    ];
}
function consumeWhiteSpace(e) {
    for(; isWhitespace(e.source.codePointAt(e.cursor) ?? -1);)e.advanceCodePoint();
    return [
        exports.TokenType.Whitespace,
        e.source.slice(e.representationStart, e.representationEnd + 1),
        e.representationStart,
        e.representationEnd,
        void 0
    ];
}
exports.TokenType = void 0, (c = exports.TokenType || (exports.TokenType = {})).Comment = "comment", c.AtKeyword = "at-keyword-token", c.BadString = "bad-string-token", c.BadURL = "bad-url-token", c.CDC = "CDC-token", c.CDO = "CDO-token", c.Colon = "colon-token", c.Comma = "comma-token", c.Delim = "delim-token", c.Dimension = "dimension-token", c.EOF = "EOF-token", c.Function = "function-token", c.Hash = "hash-token", c.Ident = "ident-token", c.Number = "number-token", c.Percentage = "percentage-token", c.Semicolon = "semicolon-token", c.String = "string-token", c.URL = "url-token", c.Whitespace = "whitespace-token", c.OpenParen = "(-token", c.CloseParen = ")-token", c.OpenSquare = "[-token", c.CloseSquare = "]-token", c.OpenCurly = "{-token", c.CloseCurly = "}-token", c.UnicodeRange = "unicode-range-token", exports.NumberType = void 0, (a = exports.NumberType || (exports.NumberType = {})).Integer = "integer", a.Number = "number", exports.HashType = void 0, (u = exports.HashType || (exports.HashType = {})).Unrestricted = "unrestricted", u.ID = "id";
class Reader {
    cursor = 0;
    source = "";
    representationStart = 0;
    representationEnd = -1;
    constructor(e){
        this.source = e;
    }
    advanceCodePoint(e = 1) {
        this.cursor = this.cursor + e, this.representationEnd = this.cursor - 1;
    }
    readCodePoint() {
        const e = this.source.codePointAt(this.cursor);
        if (void 0 !== e) return this.cursor = this.cursor + 1, this.representationEnd = this.cursor - 1, e;
    }
    unreadCodePoint(e = 1) {
        this.cursor = this.cursor - e, this.representationEnd = this.cursor - 1;
    }
    resetRepresentation() {
        this.representationStart = this.cursor, this.representationEnd = -1;
    }
}
function consumeStringToken(n, t) {
    let s = "";
    const c = t.readCodePoint();
    for(;;){
        const a = t.readCodePoint();
        if (void 0 === a) {
            const o = [
                exports.TokenType.String,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                {
                    value: s
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInString, t.representationStart, t.representationEnd, [
                "4.3.5. Consume a string token",
                "Unexpected EOF"
            ], o)), o;
        }
        if (isNewLine(a)) {
            t.unreadCodePoint();
            const s = [
                exports.TokenType.BadString,
                t.source.slice(t.representationStart, t.representationEnd + 1),
                t.representationStart,
                t.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedNewLineInString, t.representationStart, t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r ? t.representationEnd + 2 : t.representationEnd + 1, [
                "4.3.5. Consume a string token",
                "Unexpected newline"
            ], s)), s;
        }
        if (a === c) return [
            exports.TokenType.String,
            t.source.slice(t.representationStart, t.representationEnd + 1),
            t.representationStart,
            t.representationEnd,
            {
                value: s
            }
        ];
        if (92 !== a) 0 === a || isSurrogate(a) ? s += String.fromCodePoint(i) : s += String.fromCodePoint(a);
        else {
            if (void 0 === t.source.codePointAt(t.cursor)) continue;
            if (isNewLine(t.source.codePointAt(t.cursor) ?? -1)) {
                t.source.codePointAt(t.cursor) === o && t.source.codePointAt(t.cursor + 1) === r && t.advanceCodePoint(), t.advanceCodePoint();
                continue;
            }
            s += String.fromCodePoint(consumeEscapedCodePoint(n, t));
        }
    }
}
function checkIfCodePointsMatchURLIdent(e) {
    return !(3 !== e.length || 117 !== e[0] && 85 !== e[0] || 114 !== e[1] && 82 !== e[1] || 108 !== e[2] && 76 !== e[2]);
}
function consumeBadURL(e, n) {
    for(;;){
        const o = n.source.codePointAt(n.cursor);
        if (void 0 === o) return;
        if (41 === o) return void n.advanceCodePoint();
        checkIfTwoCodePointsAreAValidEscape(n) ? (n.advanceCodePoint(), consumeEscapedCodePoint(e, n)) : n.advanceCodePoint();
    }
}
function consumeUrlToken(n, o) {
    for(; isWhitespace(o.source.codePointAt(o.cursor) ?? -1);)o.advanceCodePoint();
    let t = "";
    for(;;){
        if (void 0 === o.source.codePointAt(o.cursor)) {
            const r = [
                exports.TokenType.URL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                {
                    value: t
                }
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected EOF"
            ], r)), r;
        }
        if (41 === o.source.codePointAt(o.cursor)) return o.advanceCodePoint(), [
            exports.TokenType.URL,
            o.source.slice(o.representationStart, o.representationEnd + 1),
            o.representationStart,
            o.representationEnd,
            {
                value: t
            }
        ];
        if (isWhitespace(o.source.codePointAt(o.cursor) ?? -1)) {
            for(o.advanceCodePoint(); isWhitespace(o.source.codePointAt(o.cursor) ?? -1);)o.advanceCodePoint();
            if (void 0 === o.source.codePointAt(o.cursor)) {
                const r = [
                    exports.TokenType.URL,
                    o.source.slice(o.representationStart, o.representationEnd + 1),
                    o.representationStart,
                    o.representationEnd,
                    {
                        value: t
                    }
                ];
                return n.onParseError(new ParseErrorWithToken(e.UnexpectedEOFInURL, o.representationStart, o.representationEnd, [
                    "4.3.6. Consume a url token",
                    "Consume as much whitespace as possible",
                    "Unexpected EOF"
                ], r)), r;
            }
            return 41 === o.source.codePointAt(o.cursor) ? (o.advanceCodePoint(), [
                exports.TokenType.URL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                {
                    value: t
                }
            ]) : (consumeBadURL(n, o), [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ]);
        }
        const s = o.source.codePointAt(o.cursor);
        if (34 === s || 39 === s || 40 === s || 11 === (r = s ?? -1) || 127 === r || 0 <= r && r <= 8 || 14 <= r && r <= 31) {
            consumeBadURL(n, o);
            const t = [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.UnexpectedCharacterInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "Unexpected U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point"
            ], t)), t;
        }
        if (92 === s) {
            if (checkIfTwoCodePointsAreAValidEscape(o)) {
                o.advanceCodePoint(), t += String.fromCodePoint(consumeEscapedCodePoint(n, o));
                continue;
            }
            consumeBadURL(n, o);
            const r = [
                exports.TokenType.BadURL,
                o.source.slice(o.representationStart, o.representationEnd + 1),
                o.representationStart,
                o.representationEnd,
                void 0
            ];
            return n.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceInURL, o.representationStart, o.representationEnd, [
                "4.3.6. Consume a url token",
                "U+005C REVERSE SOLIDUS (\\)",
                "The input stream does not start with a valid escape sequence"
            ], r)), r;
        }
        0 === o.source.codePointAt(o.cursor) || isSurrogate(o.source.codePointAt(o.cursor) ?? -1) ? (t += String.fromCodePoint(i), o.advanceCodePoint()) : (t += o.source[o.cursor], o.advanceCodePoint());
    }
    var r;
}
function consumeIdentLikeToken(e, n) {
    const o = consumeIdentSequence(e, n);
    if (40 !== n.source.codePointAt(n.cursor)) return [
        exports.TokenType.Ident,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...o)
        }
    ];
    if (checkIfCodePointsMatchURLIdent(o)) {
        n.advanceCodePoint();
        let t = 0;
        for(;;){
            const e = isWhitespace(n.source.codePointAt(n.cursor) ?? -1), r = isWhitespace(n.source.codePointAt(n.cursor + 1) ?? -1);
            if (e && r) {
                t += 1, n.advanceCodePoint(1);
                continue;
            }
            const s = e ? n.source.codePointAt(n.cursor + 1) : n.source.codePointAt(n.cursor);
            if (34 === s || 39 === s) return t > 0 && n.unreadCodePoint(t), [
                exports.TokenType.Function,
                n.source.slice(n.representationStart, n.representationEnd + 1),
                n.representationStart,
                n.representationEnd,
                {
                    value: String.fromCodePoint(...o)
                }
            ];
            break;
        }
        return consumeUrlToken(e, n);
    }
    return n.advanceCodePoint(), [
        exports.TokenType.Function,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            value: String.fromCodePoint(...o)
        }
    ];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e) {
    return !(117 !== e.source.codePointAt(e.cursor) && 85 !== e.source.codePointAt(e.cursor) || e.source.codePointAt(e.cursor + 1) !== s || 63 !== e.source.codePointAt(e.cursor + 2) && !isHexDigitCodePoint(e.source.codePointAt(e.cursor + 2) ?? -1));
}
function consumeUnicodeRangeToken(e, n) {
    n.advanceCodePoint(2);
    const o = [], r = [];
    let s;
    for(; void 0 !== (s = n.source.codePointAt(n.cursor)) && o.length < 6 && isHexDigitCodePoint(s);)o.push(s), n.advanceCodePoint();
    for(; void 0 !== (s = n.source.codePointAt(n.cursor)) && o.length < 6 && 63 === s;)0 === r.length && r.push(...o), o.push(48), r.push(70), n.advanceCodePoint();
    if (!r.length && n.source.codePointAt(n.cursor) === t && isHexDigitCodePoint(n.source.codePointAt(n.cursor + 1) ?? -1)) for(n.advanceCodePoint(); void 0 !== (s = n.source.codePointAt(n.cursor)) && r.length < 6 && isHexDigitCodePoint(s);)r.push(s), n.advanceCodePoint();
    if (!r.length) {
        const e = parseInt(String.fromCodePoint(...o), 16);
        return [
            exports.TokenType.UnicodeRange,
            n.source.slice(n.representationStart, n.representationEnd + 1),
            n.representationStart,
            n.representationEnd,
            {
                startOfRange: e,
                endOfRange: e
            }
        ];
    }
    const i = parseInt(String.fromCodePoint(...o), 16), c = parseInt(String.fromCodePoint(...r), 16);
    return [
        exports.TokenType.UnicodeRange,
        n.source.slice(n.representationStart, n.representationEnd + 1),
        n.representationStart,
        n.representationEnd,
        {
            startOfRange: i,
            endOfRange: c
        }
    ];
}
function tokenizer(n, i) {
    const c = n.css.valueOf(), a = n.unicodeRangesAllowed ?? !1, u = new Reader(c), d = {
        onParseError: i?.onParseError ?? noop
    };
    return {
        nextToken: function nextToken() {
            u.resetRepresentation();
            const n = u.source.codePointAt(u.cursor);
            if (void 0 === n) return [
                exports.TokenType.EOF,
                "",
                -1,
                -1,
                void 0
            ];
            if (47 === n && checkIfTwoCodePointsStartAComment(u)) return consumeComment(d, u);
            if (a && (117 === n || 85 === n) && checkIfThreeCodePointsWouldStartAUnicodeRange(u)) return consumeUnicodeRangeToken(0, u);
            if (isIdentStartCodePoint(n)) return consumeIdentLikeToken(d, u);
            if (isDigitCodePoint(n)) return consumeNumericToken(d, u);
            switch(n){
                case 44:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Comma,
                        ",",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 58:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Colon,
                        ":",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 59:
                    return u.advanceCodePoint(), [
                        exports.TokenType.Semicolon,
                        ";",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 40:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenParen,
                        "(",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 41:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseParen,
                        ")",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 91:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenSquare,
                        "[",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 93:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseSquare,
                        "]",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 123:
                    return u.advanceCodePoint(), [
                        exports.TokenType.OpenCurly,
                        "{",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 125:
                    return u.advanceCodePoint(), [
                        exports.TokenType.CloseCurly,
                        "}",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ];
                case 39:
                case 34:
                    return consumeStringToken(d, u);
                case 35:
                    return consumeHashToken(d, u);
                case s:
                case 46:
                    return checkIfThreeCodePointsWouldStartANumber(u) ? consumeNumericToken(d, u) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        u.source[u.representationStart],
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: u.source[u.representationStart]
                        }
                    ]);
                case r:
                case o:
                case 12:
                case 9:
                case 32:
                    return consumeWhiteSpace(u);
                case t:
                    return checkIfThreeCodePointsWouldStartANumber(u) ? consumeNumericToken(d, u) : checkIfThreeCodePointsWouldStartCDC(u) ? (u.advanceCodePoint(3), [
                        exports.TokenType.CDC,
                        "--\x3e",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, u) ? consumeIdentLikeToken(d, u) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        "-",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "-"
                        }
                    ]);
                case 60:
                    return checkIfFourCodePointsWouldStartCDO(u) ? (u.advanceCodePoint(4), [
                        exports.TokenType.CDO,
                        "\x3c!--",
                        u.representationStart,
                        u.representationEnd,
                        void 0
                    ]) : (u.advanceCodePoint(), [
                        exports.TokenType.Delim,
                        "<",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "<"
                        }
                    ]);
                case 64:
                    if (u.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, u)) {
                        const e = consumeIdentSequence(d, u);
                        return [
                            exports.TokenType.AtKeyword,
                            u.source.slice(u.representationStart, u.representationEnd + 1),
                            u.representationStart,
                            u.representationEnd,
                            {
                                value: String.fromCodePoint(...e)
                            }
                        ];
                    }
                    return [
                        exports.TokenType.Delim,
                        "@",
                        u.representationStart,
                        u.representationEnd,
                        {
                            value: "@"
                        }
                    ];
                case 92:
                    {
                        if (checkIfTwoCodePointsAreAValidEscape(u)) return consumeIdentLikeToken(d, u);
                        u.advanceCodePoint();
                        const n = [
                            exports.TokenType.Delim,
                            "\\",
                            u.representationStart,
                            u.representationEnd,
                            {
                                value: "\\"
                            }
                        ];
                        return d.onParseError(new ParseErrorWithToken(e.InvalidEscapeSequenceAfterBackslash, u.representationStart, u.representationEnd, [
                            "4.3.1. Consume a token",
                            "U+005C REVERSE SOLIDUS (\\)",
                            "The input stream does not start with a valid escape sequence"
                        ], n)), n;
                    }
            }
            return u.advanceCodePoint(), [
                exports.TokenType.Delim,
                u.source[u.representationStart],
                u.representationStart,
                u.representationEnd,
                {
                    value: u.source[u.representationStart]
                }
            ];
        },
        endOfFile: function endOfFile() {
            return void 0 === u.source.codePointAt(u.cursor);
        }
    };
}
function noop() {}
function serializeIdent(e) {
    let n = 0;
    if (0 === e[0]) e.splice(0, 1, i), n = 1;
    else if (e[0] === t && e[1] === t) n = 2;
    else if (e[0] === t && e[1]) n = 2, isIdentStartCodePoint(e[1]) || (n += insertEscapedCodePoint(e, 1, e[1]));
    else {
        if (e[0] === t && !e[1]) return [
            92,
            e[0]
        ];
        isIdentStartCodePoint(e[0]) ? n = 1 : (n = 1, n += insertEscapedCodePoint(e, 0, e[0]));
    }
    for(let o = n; o < e.length; o++)0 !== e[o] ? isIdentCodePoint(e[o]) || (o += insertEscapedCharacter(e, o, e[o])) : (e.splice(o, 1, i), o++);
    return e;
}
function insertEscapedCharacter(e, n, o) {
    return e.splice(n, 1, 92, o), 1;
}
function insertEscapedCodePoint(e, n, o) {
    const t = o.toString(16), r = [];
    for (const e of t)r.push(e.codePointAt(0));
    return e.splice(n, 1, 92, ...r, 32), 1 + r.length;
}
const d = Object.values(exports.TokenType);
exports.ParseError = ParseError, exports.ParseErrorMessage = e, exports.ParseErrorWithToken = ParseErrorWithToken, exports.cloneTokens = function cloneTokens(e) {
    return n ? structuredClone(e) : JSON.parse(JSON.stringify(e));
}, exports.isToken = function isToken(e) {
    return !!Array.isArray(e) && !(e.length < 4) && !!d.includes(e[0]) && "string" == typeof e[1] && "number" == typeof e[2] && "number" == typeof e[3];
}, exports.isTokenAtKeyword = function isTokenAtKeyword(e) {
    return !!e && e[0] === exports.TokenType.AtKeyword;
}, exports.isTokenBadString = function isTokenBadString(e) {
    return !!e && e[0] === exports.TokenType.BadString;
}, exports.isTokenBadURL = function isTokenBadURL(e) {
    return !!e && e[0] === exports.TokenType.BadURL;
}, exports.isTokenCDC = function isTokenCDC(e) {
    return !!e && e[0] === exports.TokenType.CDC;
}, exports.isTokenCDO = function isTokenCDO(e) {
    return !!e && e[0] === exports.TokenType.CDO;
}, exports.isTokenCloseCurly = function isTokenCloseCurly(e) {
    return !!e && e[0] === exports.TokenType.CloseCurly;
}, exports.isTokenCloseParen = function isTokenCloseParen(e) {
    return !!e && e[0] === exports.TokenType.CloseParen;
}, exports.isTokenCloseSquare = function isTokenCloseSquare(e) {
    return !!e && e[0] === exports.TokenType.CloseSquare;
}, exports.isTokenColon = function isTokenColon(e) {
    return !!e && e[0] === exports.TokenType.Colon;
}, exports.isTokenComma = function isTokenComma(e) {
    return !!e && e[0] === exports.TokenType.Comma;
}, exports.isTokenComment = function isTokenComment(e) {
    return !!e && e[0] === exports.TokenType.Comment;
}, exports.isTokenDelim = function isTokenDelim(e) {
    return !!e && e[0] === exports.TokenType.Delim;
}, exports.isTokenDimension = function isTokenDimension(e) {
    return !!e && e[0] === exports.TokenType.Dimension;
}, exports.isTokenEOF = function isTokenEOF(e) {
    return !!e && e[0] === exports.TokenType.EOF;
}, exports.isTokenFunction = function isTokenFunction(e) {
    return !!e && e[0] === exports.TokenType.Function;
}, exports.isTokenHash = function isTokenHash(e) {
    return !!e && e[0] === exports.TokenType.Hash;
}, exports.isTokenIdent = function isTokenIdent(e) {
    return !!e && e[0] === exports.TokenType.Ident;
}, exports.isTokenNumber = function isTokenNumber(e) {
    return !!e && e[0] === exports.TokenType.Number;
}, exports.isTokenNumeric = function isTokenNumeric(e) {
    if (!e) return !1;
    switch(e[0]){
        case exports.TokenType.Dimension:
        case exports.TokenType.Number:
        case exports.TokenType.Percentage:
            return !0;
        default:
            return !1;
    }
}, exports.isTokenOpenCurly = function isTokenOpenCurly(e) {
    return !!e && e[0] === exports.TokenType.OpenCurly;
}, exports.isTokenOpenParen = function isTokenOpenParen(e) {
    return !!e && e[0] === exports.TokenType.OpenParen;
}, exports.isTokenOpenSquare = function isTokenOpenSquare(e) {
    return !!e && e[0] === exports.TokenType.OpenSquare;
}, exports.isTokenPercentage = function isTokenPercentage(e) {
    return !!e && e[0] === exports.TokenType.Percentage;
}, exports.isTokenSemicolon = function isTokenSemicolon(e) {
    return !!e && e[0] === exports.TokenType.Semicolon;
}, exports.isTokenString = function isTokenString(e) {
    return !!e && e[0] === exports.TokenType.String;
}, exports.isTokenURL = function isTokenURL(e) {
    return !!e && e[0] === exports.TokenType.URL;
}, exports.isTokenUnicodeRange = function isTokenUnicodeRange(e) {
    return !!e && e[0] === exports.TokenType.UnicodeRange;
}, exports.isTokenWhiteSpaceOrComment = function isTokenWhiteSpaceOrComment(e) {
    if (!e) return !1;
    switch(e[0]){
        case exports.TokenType.Whitespace:
        case exports.TokenType.Comment:
            return !0;
        default:
            return !1;
    }
}, exports.isTokenWhitespace = function isTokenWhitespace(e) {
    return !!e && e[0] === exports.TokenType.Whitespace;
}, exports.mirrorVariant = function mirrorVariant(e) {
    switch(e[0]){
        case exports.TokenType.OpenParen:
            return [
                exports.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseParen:
            return [
                exports.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.OpenCurly:
            return [
                exports.TokenType.CloseCurly,
                "}",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseCurly:
            return [
                exports.TokenType.OpenCurly,
                "{",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.OpenSquare:
            return [
                exports.TokenType.CloseSquare,
                "]",
                -1,
                -1,
                void 0
            ];
        case exports.TokenType.CloseSquare:
            return [
                exports.TokenType.OpenSquare,
                "[",
                -1,
                -1,
                void 0
            ];
        default:
            return null;
    }
}, exports.mirrorVariantType = function mirrorVariantType(e) {
    switch(e){
        case exports.TokenType.OpenParen:
            return exports.TokenType.CloseParen;
        case exports.TokenType.CloseParen:
            return exports.TokenType.OpenParen;
        case exports.TokenType.OpenCurly:
            return exports.TokenType.CloseCurly;
        case exports.TokenType.CloseCurly:
            return exports.TokenType.OpenCurly;
        case exports.TokenType.OpenSquare:
            return exports.TokenType.CloseSquare;
        case exports.TokenType.CloseSquare:
            return exports.TokenType.OpenSquare;
        default:
            return null;
    }
}, exports.mutateIdent = function mutateIdent(e, n) {
    const o = [];
    for (const e of n)o.push(e.codePointAt(0));
    const t = String.fromCodePoint(...serializeIdent(o));
    e[1] = t, e[4].value = n;
}, exports.mutateUnit = function mutateUnit(e, n) {
    const o = [];
    for (const e of n)o.push(e.codePointAt(0));
    const t = serializeIdent(o);
    101 === t[0] && insertEscapedCodePoint(t, 0, t[0]);
    const r = String.fromCodePoint(...t), s = "+" === e[4].signCharacter ? e[4].signCharacter : "", i = e[4].value.toString();
    e[1] = `${s}${i}${r}`, e[4].unit = n;
}, exports.stringify = function stringify(...e) {
    let n = "";
    for(let o = 0; o < e.length; o++)n += e[o][1];
    return n;
}, exports.tokenize = function tokenize(e, n) {
    const o = tokenizer(e, n), t = [];
    for(; !o.endOfFile();)t.push(o.nextToken());
    return t.push(o.nextToken()), t;
}, exports.tokenizer = tokenizer;
}}),
"[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function multiplyMatrices(t, n) {
    return [
        t[0] * n[0] + t[1] * n[1] + t[2] * n[2],
        t[3] * n[0] + t[4] * n[1] + t[5] * n[2],
        t[6] * n[0] + t[7] * n[1] + t[8] * n[2]
    ];
}
const t = [
    .955473421488075,
    -.02309845494876471,
    .06325924320057072,
    -.0283697093338637,
    1.0099953980813041,
    .021041441191917323,
    .012314014864481998,
    -.020507649298898964,
    1.330365926242124
];
/**
 * Bradford chromatic adaptation from D50 to D65
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function D50_to_D65(n) {
    return multiplyMatrices(t, n);
}
const n = [
    1.0479297925449969,
    .022946870601609652,
    -.05019226628920524,
    .02962780877005599,
    .9904344267538799,
    -.017073799063418826,
    -.009243040646204504,
    .015055191490298152,
    .7518742814281371
];
/**
 * Bradford chromatic adaptation from D65 to D50
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html
 */ function D65_to_D50(t) {
    return multiplyMatrices(n, t);
}
/**
 * @param {number} hue - Hue as degrees 0..360
 * @param {number} sat - Saturation as percentage 0..100
 * @param {number} light - Lightness as percentage 0..100
 * @return {number[]} Array of sRGB components; in-gamut colors in range [0..1]
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js
 */ function HSL_to_sRGB(t) {
    let n = t[0] % 360;
    const _ = t[1] / 100, o = t[2] / 100;
    return n < 0 && (n += 360), [
        HSL_to_sRGB_channel(0, n, _, o),
        HSL_to_sRGB_channel(8, n, _, o),
        HSL_to_sRGB_channel(4, n, _, o)
    ];
}
function HSL_to_sRGB_channel(t, n, _, o) {
    const e = (t + n / 30) % 12;
    return o - _ * Math.min(o, 1 - o) * Math.max(-1, Math.min(e - 3, 9 - e, 1));
}
/**
 * @param {number} hue -  Hue as degrees 0..360
 * @param {number} white -  Whiteness as percentage 0..100
 * @param {number} black -  Blackness as percentage 0..100
 * @return {number[]} Array of RGB components 0..1
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js
 */ function HWB_to_sRGB(t) {
    const n = t[0], _ = t[1] / 100, o = t[2] / 100;
    if (_ + o >= 1) {
        const t = _ / (_ + o);
        return [
            t,
            t,
            t
        ];
    }
    const e = HSL_to_sRGB([
        n,
        100,
        50
    ]), r = 1 - _ - o;
    return [
        e[0] * r + _,
        e[1] * r + _,
        e[2] * r + _
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function LCH_to_Lab(t) {
    const n = t[2] * Math.PI / 180;
    return [
        t[0],
        t[1] * Math.cos(n),
        t[1] * Math.sin(n)
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function Lab_to_LCH(t) {
    const n = 180 * Math.atan2(t[2], t[1]) / Math.PI;
    return [
        t[0],
        Math.sqrt(Math.pow(t[1], 2) + Math.pow(t[2], 2)),
        n >= 0 ? n : n + 360
    ];
}
const _ = [
    .3457 / .3585,
    1,
    .2958 / .3585
];
/**
 * Convert Lab to D50-adapted XYZ
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ function Lab_to_XYZ(t) {
    const n = 24389 / 27, o = 216 / 24389, e = (t[0] + 16) / 116, r = t[1] / 500 + e, a = e - t[2] / 200;
    return [
        (Math.pow(r, 3) > o ? Math.pow(r, 3) : (116 * r - 16) / n) * _[0],
        (t[0] > 8 ? Math.pow((t[0] + 16) / 116, 3) : t[0] / n) * _[1],
        (Math.pow(a, 3) > o ? Math.pow(a, 3) : (116 * a - 16) / n) * _[2]
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLCH_to_OKLab(t) {
    const n = t[2] * Math.PI / 180;
    return [
        t[0],
        t[1] * Math.cos(n),
        t[1] * Math.sin(n)
    ];
}
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLab_to_OKLCH(t) {
    const n = 180 * Math.atan2(t[2], t[1]) / Math.PI;
    return [
        t[0],
        Math.sqrt(t[1] ** 2 + t[2] ** 2),
        n >= 0 ? n : n + 360
    ];
}
const o = [
    1.2268798758459243,
    -.5578149944602171,
    .2813910456659647,
    -.0405757452148008,
    1.112286803280317,
    -.0717110580655164,
    -.0763729366746601,
    -.4214933324022432,
    1.5869240198367816
], e = [
    1,
    .3963377773761749,
    .2158037573099136,
    1,
    -.1055613458156586,
    -.0638541728258133,
    1,
    -.0894841775298119,
    -1.2914855480194092
];
/**
 * Given OKLab, convert to XYZ relative to D65
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
 */ function OKLab_to_XYZ(t) {
    const n = multiplyMatrices(e, t);
    return multiplyMatrices(o, [
        n[0] ** 3,
        n[1] ** 3,
        n[2] ** 3
    ]);
}
/**
 * Assuming XYZ is relative to D50, convert to CIE Lab
 * from CIE standard, which now defines these as a rational fraction
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_Lab(t) {
    const n = compute_f(t[0] / _[0]), o = compute_f(t[1] / _[1]);
    return [
        116 * o - 16,
        500 * (n - o),
        200 * (o - compute_f(t[2] / _[2]))
    ];
}
const r = 216 / 24389, a = 24389 / 27;
function compute_f(t) {
    return t > r ? Math.cbrt(t) : (a * t + 16) / 116;
}
const i = [
    .819022437996703,
    .3619062600528904,
    -.1288737815209879,
    .0329836539323885,
    .9292868615863434,
    .0361446663506424,
    .0481771893596242,
    .2642395317527308,
    .6335478284694309
], l = [
    .210454268309314,
    .7936177747023054,
    -.0040720430116193,
    1.9779985324311684,
    -2.42859224204858,
    .450593709617411,
    .0259040424655478,
    .7827717124575296,
    -.8086757549230774
];
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 *
 * XYZ <-> LMS matrices recalculated for consistent reference white
 * @see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
 */ function XYZ_to_OKLab(t) {
    const n = multiplyMatrices(i, t);
    return multiplyMatrices(l, [
        Math.cbrt(n[0]),
        Math.cbrt(n[1]),
        Math.cbrt(n[2])
    ]);
}
const s = [
    30757411 / 17917100,
    -6372589 / 17917100,
    -4539589 / 17917100,
    -.666684351832489,
    1.616481236634939,
    467509 / 29648200,
    792561 / 44930125,
    -1921689 / 44930125,
    .942103121235474
];
/**
 * Convert XYZ to linear-light rec2020
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const c = [
    446124 / 178915,
    -333277 / 357830,
    -72051 / 178915,
    -14852 / 17905,
    63121 / 35810,
    423 / 17905,
    11844 / 330415,
    -50337 / 660830,
    316169 / 330415
];
/**
 * Convert XYZ to linear-light P3
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_lin_P3(t) {
    return multiplyMatrices(c, t);
}
const u = [
    1.3457868816471583,
    -.25557208737979464,
    -.05110186497554526,
    -.5446307051249019,
    1.5082477428451468,
    .02052744743642139,
    0,
    0,
    1.2119675456389452
];
/**
 * Convert D50 XYZ to linear-light prophoto-rgb
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ const h = [
    1829569 / 896150,
    -506331 / 896150,
    -308931 / 896150,
    -851781 / 878810,
    1648619 / 878810,
    36519 / 878810,
    16779 / 1248040,
    -147721 / 1248040,
    1266979 / 1248040
];
/**
 * Convert XYZ to linear-light a98-rgb
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const m = [
    12831 / 3959,
    -329 / 214,
    -1974 / 3959,
    -851781 / 878810,
    1648619 / 878810,
    36519 / 878810,
    705 / 12673,
    -2585 / 12673,
    705 / 667
];
/**
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function XYZ_to_lin_sRGB(t) {
    return multiplyMatrices(m, t);
}
/**
 * Convert an array of linear-light rec2020 RGB  in the range 0.0-1.0
 * to gamma corrected form ITU-R BT.2020-2 p.4
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const p = 1.09929682680944, D = .018053968510807;
function gam_2020_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ > D ? n * (p * Math.pow(_, .45) - (p - 1)) : 4.5 * t;
}
/**
 * Convert an array of linear-light sRGB values in the range 0.0-1.0 to gamma corrected form
 * Extended transfer function:
 *  For negative values, linear portion extends on reflection
 *  of axis, then uses reflected pow below that
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://en.wikipedia.org/wiki/SRGB
 */ function gam_sRGB(t) {
    return [
        gam_sRGB_channel(t[0]),
        gam_sRGB_channel(t[1]),
        gam_sRGB_channel(t[2])
    ];
}
function gam_sRGB_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ > .0031308 ? n * (1.055 * Math.pow(_, 1 / 2.4) - .055) : 12.92 * t;
}
/**
 * Convert an array of linear-light display-p3 RGB in the range 0.0-1.0
 * to gamma corrected form
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function gam_P3(t) {
    return gam_sRGB(t);
}
/**
 * Convert an array of linear-light prophoto-rgb in the range 0.0-1.0
 * to gamma corrected form.
 * Transfer curve is gamma 1.8 with a small linear portion.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const b = 1 / 512;
function gam_ProPhoto_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ >= b ? n * Math.pow(_, 1 / 1.8) : 16 * t;
}
/**
 * Convert an array of linear-light a98-rgb in the range 0.0-1.0
 * to gamma corrected form. Negative values are also now accepted
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function gam_a98rgb_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return n * Math.pow(_, 256 / 563);
}
/**
 * Convert an array of rec2020 RGB values in the range 0.0 - 1.0
 * to linear light (un-companded) form.
 * ITU-R BT.2020-2 p.4
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const g = 1.09929682680944, X = .018053968510807;
function lin_2020_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ < 4.5 * X ? t / 4.5 : n * Math.pow((_ + g - 1) / g, 1 / .45);
}
const Y = [
    63426534 / 99577255,
    20160776 / 139408157,
    47086771 / 278816314,
    26158966 / 99577255,
    .677998071518871,
    8267143 / 139408157,
    0,
    19567812 / 697040785,
    1.0609850577107909
];
/**
 * Convert an array of linear-light rec2020 values to CIE XYZ
 * using  D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ /**
 * Convert an array of of sRGB values where in-gamut values are in the range
 * [0 - 1] to linear light (un-companded) form.
 * Extended transfer function:
 *  For negative values, linear portion is extended on reflection of axis,
 *  then reflected power function is used.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://en.wikipedia.org/wiki/SRGB
 */ function lin_sRGB(t) {
    return [
        lin_sRGB_channel(t[0]),
        lin_sRGB_channel(t[1]),
        lin_sRGB_channel(t[2])
    ];
}
function lin_sRGB_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ <= .04045 ? t / 12.92 : n * Math.pow((_ + .055) / 1.055, 2.4);
}
/**
 * Convert an array of display-p3 RGB values in the range 0.0 - 1.0
 * to linear light (un-companded) form.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function lin_P3(t) {
    return lin_sRGB(t);
}
const Z = [
    608311 / 1250200,
    189793 / 714400,
    198249 / 1000160,
    35783 / 156275,
    247089 / 357200,
    198249 / 2500400,
    0,
    32229 / 714400,
    5220557 / 5000800
];
/**
 * Convert an array of linear-light display-p3 values to CIE XYZ
 * using D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 */ function lin_P3_to_XYZ(t) {
    return multiplyMatrices(Z, t);
}
/**
 * Convert an array of prophoto-rgb values where in-gamut Colors are in the
 * range [0.0 - 1.0] to linear light (un-companded) form. Transfer curve is
 * gamma 1.8 with a small linear portion. Extended transfer function
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ const f = 16 / 512;
function lin_ProPhoto_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return _ <= f ? t / 16 : n * Math.pow(_, 1.8);
}
const L = [
    .7977666449006423,
    .13518129740053308,
    .0313477341283922,
    .2880748288194013,
    .711835234241873,
    8993693872564e-17,
    0,
    0,
    .8251046025104602
];
/**
 * Convert an array of linear-light prophoto-rgb values to CIE D50 XYZ.
 * Matrix cannot be expressed in rational form, but is calculated to 64 bit accuracy.
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see see https://github.com/w3c/csswg-drafts/issues/7675
 */ function lin_a98rgb_channel(t) {
    const n = t < 0 ? -1 : 1, _ = Math.abs(t);
    return n * Math.pow(_, 563 / 256);
}
const M = [
    573536 / 994567,
    263643 / 1420810,
    187206 / 994567,
    591459 / 1989134,
    6239551 / 9945670,
    374412 / 4972835,
    53769 / 1989134,
    351524 / 4972835,
    4929758 / 4972835
];
/**
 * Convert an array of linear-light a98-rgb values to CIE XYZ
 * http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 * has greater numerical precision than section 4.3.5.3 of
 * https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
 * but the values below were calculated from first principles
 * from the chromaticity coordinates of R G B W
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 * @see https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/matrixmaker.html
 */ const d = [
    506752 / 1228815,
    87881 / 245763,
    12673 / 70218,
    87098 / 409605,
    175762 / 245763,
    12673 / 175545,
    7918 / 409605,
    87881 / 737289,
    1001167 / 1053270
];
/**
 * Convert an array of linear-light sRGB values to CIE XYZ
 * using sRGB's own white, D65 (no chromatic adaptation)
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ function lin_sRGB_to_XYZ(t) {
    return multiplyMatrices(d, t);
}
/**
 * Convert an array of gamma-corrected sRGB values in the 0.0 to 1.0 range to HSL.
 *
 * @param {Color} RGB [r, g, b]
 * - Red component 0..1
 * - Green component 0..1
 * - Blue component 0..1
 * @return {number[]} Array of HSL values: Hue as degrees 0..360, Saturation and Lightness as percentages 0..100
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/utilities.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 *
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/better-rgbToHsl.js
 */ function sRGB_to_HSL(t) {
    const n = t[0], _ = t[1], o = t[2], e = Math.max(n, _, o), r = Math.min(n, _, o), a = (r + e) / 2, i = e - r;
    let l = Number.NaN, s = 0;
    if (0 !== Math.round(1e5 * i)) {
        const t = Math.round(1e5 * a);
        switch(s = 0 === t || 1e5 === t ? 0 : (e - a) / Math.min(a, 1 - a), e){
            case n:
                l = (_ - o) / i + (_ < o ? 6 : 0);
                break;
            case _:
                l = (o - n) / i + 2;
                break;
            case o:
                l = (n - _) / i + 4;
        }
        l *= 60;
    }
    return s < 0 && (l += 180, s = Math.abs(s)), l >= 360 && (l -= 360), [
        l,
        100 * s,
        100 * a
    ];
}
function sRGB_to_Hue(t) {
    const n = t[0], _ = t[1], o = t[2], e = Math.max(n, _, o), r = Math.min(n, _, o);
    let a = Number.NaN;
    const i = e - r;
    if (0 !== i) {
        switch(e){
            case n:
                a = (_ - o) / i + (_ < o ? 6 : 0);
                break;
            case _:
                a = (o - n) / i + 2;
                break;
            case o:
                a = (n - _) / i + 4;
        }
        a *= 60;
    }
    return a >= 360 && (a -= 360), a;
}
function inGamut(t) {
    return t[0] >= -1e-4 && t[0] <= 1.0001 && t[1] >= -1e-4 && t[1] <= 1.0001 && t[2] >= -1e-4 && t[2] <= 1.0001;
}
function clip(t) {
    return [
        t[0] < 0 ? 0 : t[0] > 1 ? 1 : t[0],
        t[1] < 0 ? 0 : t[1] > 1 ? 1 : t[1],
        t[2] < 0 ? 0 : t[2] > 1 ? 1 : t[2]
    ];
}
/**
 * @description Calculate deltaE OK which is the simple root sum of squares
 * @param {number[]} reference - Array of OKLab values: L as 0..1, a and b as -1..1
 * @param {number[]} sample - Array of OKLab values: L as 0..1, a and b as -1..1
 * @return {number} How different a color sample is from reference
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js
 */ function deltaEOK(t, n) {
    const [_, o, e] = t, [r, a, i] = n, l = _ - r, s = o - a, c = e - i;
    return Math.sqrt(l ** 2 + s ** 2 + c ** 2);
}
const B = .02, G = 1e-4;
function rayTraceBox(t, n) {
    let _ = 1 / 0, o = -1 / 0;
    const e = [
        0,
        0,
        0
    ];
    for(let r = 0; r < 3; r++){
        const a = t[r], i = n[r] - a;
        e[r] = i;
        const l = 0, s = 1;
        if (i) {
            const t = 1 / i, n = (l - a) * t, e = (s - a) * t;
            o = Math.max(Math.min(n, e), o), _ = Math.min(Math.max(n, e), _);
        } else if (a < l || a > s) return !1;
    }
    return !(o > _ || _ < 0) && (o < 0 && (o = _), !!isFinite(o) && [
        t[0] + e[0] * o,
        t[1] + e[1] * o,
        t[2] + e[2] * o
    ]);
}
function luminance(t) {
    const [n, _, o] = t.map((t)=>t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4));
    return .2126 * n + .7152 * _ + .0722 * o;
}
exports.HSL_to_XYZ_D50 = function HSL_to_XYZ_D50(t) {
    let n = t;
    return n = HSL_to_sRGB(n), n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.HWB_to_XYZ_D50 = function HWB_to_XYZ_D50(t) {
    let n = t;
    return n = HWB_to_sRGB(n), n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.LCH_to_XYZ_D50 = function LCH_to_XYZ_D50(t) {
    let n = t;
    return n = LCH_to_Lab(n), n = Lab_to_XYZ(n), n;
}, exports.Lab_to_XYZ_D50 = function Lab_to_XYZ_D50(t) {
    let n = t;
    return n = Lab_to_XYZ(n), n;
}, exports.OKLCH_to_OKLab = OKLCH_to_OKLab, exports.OKLCH_to_XYZ_D50 = function OKLCH_to_XYZ_D50(t) {
    let n = t;
    return n = OKLCH_to_OKLab(n), n = OKLab_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.OKLab_to_OKLCH = OKLab_to_OKLCH, exports.OKLab_to_XYZ = OKLab_to_XYZ, exports.OKLab_to_XYZ_D50 = function OKLab_to_XYZ_D50(t) {
    let n = t;
    return n = OKLab_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.P3_to_XYZ_D50 = function P3_to_XYZ_D50(t) {
    let n = t;
    return n = lin_P3(n), n = lin_P3_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.ProPhoto_RGB_to_XYZ_D50 = function ProPhoto_RGB_to_XYZ_D50(t) {
    let n = t;
    var _;
    return n = [
        lin_ProPhoto_channel((_ = n)[0]),
        lin_ProPhoto_channel(_[1]),
        lin_ProPhoto_channel(_[2])
    ], n = multiplyMatrices(L, n), n;
}, exports.XYZ_D50_to_HSL = function XYZ_D50_to_HSL(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n = gam_sRGB(n), n = sRGB_to_HSL(n), n;
}, exports.XYZ_D50_to_HWB = function XYZ_D50_to_HWB(t) {
    let n = t;
    n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n);
    const _ = gam_sRGB(n), o = Math.min(_[0], _[1], _[2]), e = 1 - Math.max(_[0], _[1], _[2]);
    return [
        sRGB_to_Hue(_),
        100 * o,
        100 * e
    ];
}, exports.XYZ_D50_to_LCH = function XYZ_D50_to_LCH(t) {
    let n = t;
    return n = XYZ_to_Lab(n), n = Lab_to_LCH(n), n;
}, exports.XYZ_D50_to_Lab = function XYZ_D50_to_Lab(t) {
    let n = t;
    return n = XYZ_to_Lab(n), n;
}, exports.XYZ_D50_to_OKLCH = function XYZ_D50_to_OKLCH(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_OKLab(n), n = OKLab_to_OKLCH(n), n;
}, exports.XYZ_D50_to_OKLab = function XYZ_D50_to_OKLab(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_OKLab(n), n;
}, exports.XYZ_D50_to_P3 = function XYZ_D50_to_P3(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_P3(n), n = gam_P3(n), n;
}, exports.XYZ_D50_to_ProPhoto = function XYZ_D50_to_ProPhoto(t) {
    let n = t;
    var _;
    return n = multiplyMatrices(u, n), n = [
        gam_ProPhoto_channel((_ = n)[0]),
        gam_ProPhoto_channel(_[1]),
        gam_ProPhoto_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_XYZ_D50 = function XYZ_D50_to_XYZ_D50(t) {
    return t;
}, exports.XYZ_D50_to_XYZ_D65 = function XYZ_D50_to_XYZ_D65(t) {
    let n = t;
    return n = D50_to_D65(n), n;
}, exports.XYZ_D50_to_a98_RGB = function XYZ_D50_to_a98_RGB(t) {
    let n = t;
    var _;
    return n = D50_to_D65(n), n = multiplyMatrices(h, n), n = [
        gam_a98rgb_channel((_ = n)[0]),
        gam_a98rgb_channel(_[1]),
        gam_a98rgb_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_lin_sRGB = function XYZ_D50_to_lin_sRGB(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n;
}, exports.XYZ_D50_to_rec_2020 = function XYZ_D50_to_rec_2020(t) {
    let n = t;
    var _;
    return n = D50_to_D65(n), n = multiplyMatrices(s, n), n = [
        gam_2020_channel((_ = n)[0]),
        gam_2020_channel(_[1]),
        gam_2020_channel(_[2])
    ], n;
}, exports.XYZ_D50_to_sRGB = function XYZ_D50_to_sRGB(t) {
    let n = t;
    return n = D50_to_D65(n), n = XYZ_to_lin_sRGB(n), n = gam_sRGB(n), n;
}, exports.XYZ_D65_to_XYZ_D50 = function XYZ_D65_to_XYZ_D50(t) {
    let n = t;
    return n = D65_to_D50(n), n;
}, exports.XYZ_to_OKLab = XYZ_to_OKLab, exports.XYZ_to_lin_P3 = XYZ_to_lin_P3, exports.XYZ_to_lin_sRGB = XYZ_to_lin_sRGB, exports.a98_RGB_to_XYZ_D50 = function a98_RGB_to_XYZ_D50(t) {
    let n = t;
    /**
 * Convert an array of a98-rgb values in the range 0.0 - 1.0
 * to linear light (un-companded) form. Negative values are also now accepted
 *
 * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
 */ var _;
    return n = [
        lin_a98rgb_channel((_ = n)[0]),
        lin_a98rgb_channel(_[1]),
        lin_a98rgb_channel(_[2])
    ], n = multiplyMatrices(M, n), n = D65_to_D50(n), n;
}, exports.clip = clip, exports.contrast_ratio_wcag_2_1 = function contrast_ratio_wcag_2_1(t, n) {
    const _ = luminance(t), o = luminance(n);
    return (Math.max(_, o) + .05) / (Math.min(_, o) + .05);
}, exports.gam_P3 = gam_P3, exports.gam_sRGB = gam_sRGB, exports.inGamut = inGamut, exports.lin_P3 = lin_P3, exports.lin_P3_to_XYZ = lin_P3_to_XYZ, exports.lin_sRGB = lin_sRGB, exports.lin_sRGB_to_XYZ = lin_sRGB_to_XYZ, exports.lin_sRGB_to_XYZ_D50 = function lin_sRGB_to_XYZ_D50(t) {
    let n = t;
    return n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
}, exports.mapGamut = function mapGamut(t, n, _) {
    const o = t;
    let e = clip(n(o)), r = deltaEOK(OKLCH_to_OKLab(_(e)), OKLCH_to_OKLab(o));
    if (r < B) return e;
    let a = 0, i = o[1], l = !0;
    for(; i - a > G;){
        const t = (a + i) / 2;
        if (o[1] = t, l && inGamut(n(o))) a = t;
        else if (e = clip(n(o)), r = deltaEOK(OKLCH_to_OKLab(_(e)), OKLCH_to_OKLab(o)), r < B) {
            if (B - r < G) return e;
            l = !1, a = t;
        } else i = t;
    }
    return clip(n([
        ...o
    ]));
}, exports.mapGamutRayTrace = function mapGamutRayTrace(t, n, _) {
    const o = t[0], e = t[2];
    let r = n(t);
    const a = n([
        o,
        0,
        e
    ]);
    for(let t = 0; t < 4; t++){
        if (t > 0) {
            const t = _(r);
            t[0] = o, t[2] = e, r = n(t);
        }
        const i = rayTraceBox(a, r);
        if (!i) break;
        r = i;
    }
    return clip(r);
}, exports.namedColors = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, exports.rec_2020_to_XYZ_D50 = function rec_2020_to_XYZ_D50(t) {
    let n = t;
    var _;
    return n = [
        lin_2020_channel((_ = n)[0]),
        lin_2020_channel(_[1]),
        lin_2020_channel(_[2])
    ], n = multiplyMatrices(Y, n), n = D65_to_D50(n), n;
}, exports.sRGB_to_XYZ_D50 = function sRGB_to_XYZ_D50(t) {
    let n = t;
    return n = lin_sRGB(n), n = lin_sRGB_to_XYZ(n), n = D65_to_D50(n), n;
};
}}),
"[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function walkerIndexGenerator(e) {
    let n = e.slice();
    return (e, o, t)=>{
        let s = -1;
        for(let i = n.indexOf(o); i < n.length && (s = e.indexOf(n[i]), -1 === s || s < t); i++);
        return -1 === s || s === t && o === e[t] && (s++, s >= e.length) ? -1 : (n = e.slice(), s);
    };
}
function consumeComponentValue(e, o) {
    const t = o[0];
    if (n.isTokenOpenParen(t) || n.isTokenOpenCurly(t) || n.isTokenOpenSquare(t)) {
        const n = consumeSimpleBlock(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenFunction(t)) {
        const n = consumeFunction(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenWhitespace(t)) {
        const n = consumeWhitespace(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    if (n.isTokenComment(t)) {
        const n = consumeComment(e, o);
        return {
            advance: n.advance,
            node: n.node
        };
    }
    return {
        advance: 1,
        node: new TokenNode(t)
    };
}
exports.ComponentValueType = void 0, (e = exports.ComponentValueType || (exports.ComponentValueType = {})).Function = "function", e.SimpleBlock = "simple-block", e.Whitespace = "whitespace", e.Comment = "comment", e.Token = "token";
class ContainerNodeBaseClass {
    value = [];
    indexOf(e) {
        return this.value.indexOf(e);
    }
    at(e) {
        if ("number" == typeof e) return e < 0 && (e = this.value.length + e), this.value[e];
    }
    forEach(e, n) {
        if (0 === this.value.length) return;
        const o = walkerIndexGenerator(this.value);
        let t = 0;
        for(; t < this.value.length;){
            const s = this.value[t];
            let i;
            if (n && (i = {
                ...n
            }), !1 === e({
                node: s,
                parent: this,
                state: i
            }, t)) return !1;
            if (t = o(this.value, s, t), -1 === t) break;
        }
    }
    walk(e, n) {
        0 !== this.value.length && this.forEach((n, o)=>!1 !== e(n, o) && (!("walk" in n.node) || !this.value.includes(n.node) || !1 !== n.node.walk(e, n.state)) && void 0, n);
    }
}
class FunctionNode extends ContainerNodeBaseClass {
    type = exports.ComponentValueType.Function;
    name;
    endToken;
    constructor(e, n, o){
        super(), this.name = e, this.endToken = n, this.value = o;
    }
    getName() {
        return this.name[4].value;
    }
    normalize() {
        n.isTokenEOF(this.endToken) && (this.endToken = [
            n.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]);
    }
    tokens() {
        return n.isTokenEOF(this.endToken) ? [
            this.name,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.name,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>n.isToken(e) ? n.stringify(e) : e.toString()).join("");
        return n.stringify(this.name) + e + n.stringify(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.getName(),
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isFunctionNode() {
        return FunctionNode.isFunctionNode(this);
    }
    static isFunctionNode(e) {
        return !!e && e instanceof FunctionNode && e.type === exports.ComponentValueType.Function;
    }
}
function consumeFunction(e, o) {
    const t = [];
    let s = 1;
    for(;;){
        const i = o[s];
        if (!i || n.isTokenEOF(i)) return e.onParseError(new n.ParseError("Unexpected EOF while consuming a function.", o[0][2], o[o.length - 1][3], [
            "5.4.9. Consume a function",
            "Unexpected EOF"
        ])), {
            advance: o.length,
            node: new FunctionNode(o[0], i, t)
        };
        if (n.isTokenCloseParen(i)) return {
            advance: s + 1,
            node: new FunctionNode(o[0], i, t)
        };
        if (n.isTokenWhiteSpaceOrComment(i)) {
            const n = consumeAllCommentsAndWhitespace(e, o.slice(s));
            s += n.advance, t.push(...n.nodes);
            continue;
        }
        const r = consumeComponentValue(e, o.slice(s));
        s += r.advance, t.push(r.node);
    }
}
class SimpleBlockNode extends ContainerNodeBaseClass {
    type = exports.ComponentValueType.SimpleBlock;
    startToken;
    endToken;
    constructor(e, n, o){
        super(), this.startToken = e, this.endToken = n, this.value = o;
    }
    normalize() {
        if (n.isTokenEOF(this.endToken)) {
            const e = n.mirrorVariant(this.startToken);
            e && (this.endToken = e);
        }
    }
    tokens() {
        return n.isTokenEOF(this.endToken) ? [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens())
        ] : [
            this.startToken,
            ...this.value.flatMap((e)=>e.tokens()),
            this.endToken
        ];
    }
    toString() {
        const e = this.value.map((e)=>n.isToken(e) ? n.stringify(e) : e.toString()).join("");
        return n.stringify(this.startToken) + e + n.stringify(this.endToken);
    }
    toJSON() {
        return {
            type: this.type,
            startToken: this.startToken,
            tokens: this.tokens(),
            value: this.value.map((e)=>e.toJSON())
        };
    }
    isSimpleBlockNode() {
        return SimpleBlockNode.isSimpleBlockNode(this);
    }
    static isSimpleBlockNode(e) {
        return !!e && e instanceof SimpleBlockNode && e.type === exports.ComponentValueType.SimpleBlock;
    }
}
function consumeSimpleBlock(e, o) {
    const t = n.mirrorVariantType(o[0][0]);
    if (!t) throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
    const s = [];
    let i = 1;
    for(;;){
        const r = o[i];
        if (!r || n.isTokenEOF(r)) return e.onParseError(new n.ParseError("Unexpected EOF while consuming a simple block.", o[0][2], o[o.length - 1][3], [
            "5.4.8. Consume a simple block",
            "Unexpected EOF"
        ])), {
            advance: o.length,
            node: new SimpleBlockNode(o[0], r, s)
        };
        if (r[0] === t) return {
            advance: i + 1,
            node: new SimpleBlockNode(o[0], r, s)
        };
        if (n.isTokenWhiteSpaceOrComment(r)) {
            const n = consumeAllCommentsAndWhitespace(e, o.slice(i));
            i += n.advance, s.push(...n.nodes);
            continue;
        }
        const a = consumeComponentValue(e, o.slice(i));
        i += a.advance, s.push(a.node);
    }
}
class WhitespaceNode {
    type = exports.ComponentValueType.Whitespace;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return this.value;
    }
    toString() {
        return n.stringify(...this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isWhitespaceNode() {
        return WhitespaceNode.isWhitespaceNode(this);
    }
    static isWhitespaceNode(e) {
        return !!e && e instanceof WhitespaceNode && e.type === exports.ComponentValueType.Whitespace;
    }
}
function consumeWhitespace(e, o) {
    let t = 0;
    for(;;){
        const e = o[t];
        if (!n.isTokenWhitespace(e)) return {
            advance: t,
            node: new WhitespaceNode(o.slice(0, t))
        };
        t++;
    }
}
class CommentNode {
    type = exports.ComponentValueType.Comment;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return n.stringify(this.value);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isCommentNode() {
        return CommentNode.isCommentNode(this);
    }
    static isCommentNode(e) {
        return !!e && e instanceof CommentNode && e.type === exports.ComponentValueType.Comment;
    }
}
function consumeComment(e, n) {
    return {
        advance: 1,
        node: new CommentNode(n[0])
    };
}
function consumeAllCommentsAndWhitespace(e, o) {
    const t = [];
    let s = 0;
    for(;;)if (n.isTokenWhitespace(o[s])) {
        const e = consumeWhitespace(0, o.slice(s));
        s += e.advance, t.push(e.node);
    } else {
        if (!n.isTokenComment(o[s])) return {
            advance: s,
            nodes: t
        };
        t.push(new CommentNode(o[s])), s++;
    }
}
class TokenNode {
    type = exports.ComponentValueType.Token;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return [
            this.value
        ];
    }
    toString() {
        return this.value[1];
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isTokenNode() {
        return TokenNode.isTokenNode(this);
    }
    static isTokenNode(e) {
        return !!e && e instanceof TokenNode && e.type === exports.ComponentValueType.Token;
    }
}
function forEach(e, n, o) {
    if (0 === e.length) return;
    const t = walkerIndexGenerator(e);
    let s = 0;
    for(; s < e.length;){
        const i = e[s];
        let r;
        if (o && (r = {
            ...o
        }), !1 === n({
            node: i,
            parent: {
                value: e
            },
            state: r
        }, s)) return !1;
        if (s = t(e, i, s), -1 === s) break;
    }
}
function walk(e, n, o) {
    0 !== e.length && forEach(e, (o, t)=>!1 !== n(o, t) && (!("walk" in o.node) || !e.includes(o.node) || !1 !== o.node.walk(n, o.state)) && void 0, o);
}
function isWhitespaceNode(e) {
    return WhitespaceNode.isWhitespaceNode(e);
}
function isCommentNode(e) {
    return CommentNode.isCommentNode(e);
}
exports.CommentNode = CommentNode, exports.ContainerNodeBaseClass = ContainerNodeBaseClass, exports.FunctionNode = FunctionNode, exports.SimpleBlockNode = SimpleBlockNode, exports.TokenNode = TokenNode, exports.WhitespaceNode = WhitespaceNode, exports.forEach = forEach, exports.gatherNodeAncestry = function gatherNodeAncestry(e) {
    const n = new Map;
    return e.walk((e)=>{
        Array.isArray(e.node) ? e.node.forEach((o)=>{
            n.set(o, e.parent);
        }) : n.set(e.node, e.parent);
    }), n;
}, exports.isCommentNode = isCommentNode, exports.isFunctionNode = function isFunctionNode(e) {
    return FunctionNode.isFunctionNode(e);
}, exports.isSimpleBlockNode = function isSimpleBlockNode(e) {
    return SimpleBlockNode.isSimpleBlockNode(e);
}, exports.isTokenNode = function isTokenNode(e) {
    return TokenNode.isTokenNode(e);
}, exports.isWhiteSpaceOrCommentNode = function isWhiteSpaceOrCommentNode(e) {
    return isWhitespaceNode(e) || isCommentNode(e);
}, exports.isWhitespaceNode = isWhitespaceNode, exports.parseCommaSeparatedListOfComponentValues = function parseCommaSeparatedListOfComponentValues(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    if (0 === e.length) return [];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = [];
    let r = [], a = 0;
    for(;;){
        if (!s[a] || n.isTokenEOF(s[a])) return r.length && i.push(r), i;
        if (n.isTokenComma(s[a])) {
            i.push(r), r = [], a++;
            continue;
        }
        const o = consumeComponentValue(t, e.slice(a));
        r.push(o.node), a += o.advance;
    }
}, exports.parseComponentValue = function parseComponentValue(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = consumeComponentValue(t, s);
    if (n.isTokenEOF(s[Math.min(i.advance, s.length - 1)])) return i.node;
    t.onParseError(new n.ParseError("Expected EOF after parsing a component value.", e[0][2], e[e.length - 1][3], [
        "5.3.9. Parse a component value",
        "Expected EOF"
    ]));
}, exports.parseListOfComponentValues = function parseListOfComponentValues(e, o) {
    const t = {
        onParseError: o?.onParseError ?? (()=>{})
    }, s = [
        ...e
    ];
    n.isTokenEOF(s[s.length - 1]) && s.push([
        n.TokenType.EOF,
        "",
        s[s.length - 1][2],
        s[s.length - 1][3],
        void 0
    ]);
    const i = [];
    let r = 0;
    for(;;){
        if (!s[r] || n.isTokenEOF(s[r])) return i;
        const e = consumeComponentValue(t, s.slice(r));
        i.push(e.node), r += e.advance;
    }
}, exports.replaceComponentValues = function replaceComponentValues(e, n) {
    for(let o = 0; o < e.length; o++){
        walk(e[o], (e, o)=>{
            if ("number" != typeof o) return;
            const t = n(e.node);
            t && (Array.isArray(t) ? e.parent.value.splice(o, 1, ...t) : e.parent.value.splice(o, 1, t));
        });
    }
    return e;
}, exports.sourceIndices = function sourceIndices(e) {
    if (Array.isArray(e)) {
        const n = e[0];
        if (!n) return [
            0,
            0
        ];
        const o = e[e.length - 1] || n;
        return [
            sourceIndices(n)[0],
            sourceIndices(o)[1]
        ];
    }
    const n = e.tokens(), o = n[0], t = n[n.length - 1];
    return o && t ? [
        o[2],
        t[3]
    ] : [
        0,
        0
    ];
}, exports.stringify = function stringify(e) {
    return e.map((e)=>e.map((e)=>n.stringify(...e.tokens())).join("")).join(",");
}, exports.walk = walk, exports.walkerIndexGenerator = walkerIndexGenerator;
}}),
"[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const t = /[A-Z]/g;
function toLowerCaseAZ(e) {
    return e.replace(t, (e)=>String.fromCharCode(e.charCodeAt(0) + 32));
}
const o = {
    cm: "px",
    in: "px",
    mm: "px",
    pc: "px",
    pt: "px",
    px: "px",
    q: "px",
    deg: "deg",
    grad: "deg",
    rad: "deg",
    turn: "deg",
    ms: "s",
    s: "s",
    hz: "hz",
    khz: "hz"
}, r = new Map([
    [
        "cm",
        (e)=>e
    ],
    [
        "mm",
        (e)=>10 * e
    ],
    [
        "q",
        (e)=>40 * e
    ],
    [
        "in",
        (e)=>e / 2.54
    ],
    [
        "pc",
        (e)=>e / 2.54 * 6
    ],
    [
        "pt",
        (e)=>e / 2.54 * 72
    ],
    [
        "px",
        (e)=>e / 2.54 * 96
    ]
]), i = new Map([
    [
        "deg",
        (e)=>e
    ],
    [
        "grad",
        (e)=>e / .9
    ],
    [
        "rad",
        (e)=>e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>e / 360
    ]
]), u = new Map([
    [
        "deg",
        (e)=>.9 * e
    ],
    [
        "grad",
        (e)=>e
    ],
    [
        "rad",
        (e)=>.9 * e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>.9 * e / 360
    ]
]), a = new Map([
    [
        "hz",
        (e)=>e
    ],
    [
        "khz",
        (e)=>e / 1e3
    ]
]), s = new Map([
    [
        "cm",
        (e)=>2.54 * e
    ],
    [
        "mm",
        (e)=>25.4 * e
    ],
    [
        "q",
        (e)=>25.4 * e * 4
    ],
    [
        "in",
        (e)=>e
    ],
    [
        "pc",
        (e)=>6 * e
    ],
    [
        "pt",
        (e)=>72 * e
    ],
    [
        "px",
        (e)=>96 * e
    ]
]), l = new Map([
    [
        "hz",
        (e)=>1e3 * e
    ],
    [
        "khz",
        (e)=>e
    ]
]), c = new Map([
    [
        "cm",
        (e)=>e / 10
    ],
    [
        "mm",
        (e)=>e
    ],
    [
        "q",
        (e)=>4 * e
    ],
    [
        "in",
        (e)=>e / 25.4
    ],
    [
        "pc",
        (e)=>e / 25.4 * 6
    ],
    [
        "pt",
        (e)=>e / 25.4 * 72
    ],
    [
        "px",
        (e)=>e / 25.4 * 96
    ]
]), m = new Map([
    [
        "ms",
        (e)=>e
    ],
    [
        "s",
        (e)=>e / 1e3
    ]
]), v = new Map([
    [
        "cm",
        (e)=>e / 6 * 2.54
    ],
    [
        "mm",
        (e)=>e / 6 * 25.4
    ],
    [
        "q",
        (e)=>e / 6 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 6
    ],
    [
        "pc",
        (e)=>e
    ],
    [
        "pt",
        (e)=>e / 6 * 72
    ],
    [
        "px",
        (e)=>e / 6 * 96
    ]
]), T = new Map([
    [
        "cm",
        (e)=>e / 72 * 2.54
    ],
    [
        "mm",
        (e)=>e / 72 * 25.4
    ],
    [
        "q",
        (e)=>e / 72 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 72
    ],
    [
        "pc",
        (e)=>e / 72 * 6
    ],
    [
        "pt",
        (e)=>e
    ],
    [
        "px",
        (e)=>e / 72 * 96
    ]
]), p = new Map([
    [
        "cm",
        (e)=>e / 96 * 2.54
    ],
    [
        "mm",
        (e)=>e / 96 * 25.4
    ],
    [
        "q",
        (e)=>e / 96 * 25.4 * 4
    ],
    [
        "in",
        (e)=>e / 96
    ],
    [
        "pc",
        (e)=>e / 96 * 6
    ],
    [
        "pt",
        (e)=>e / 96 * 72
    ],
    [
        "px",
        (e)=>e
    ]
]), N = new Map([
    [
        "cm",
        (e)=>e / 4 / 10
    ],
    [
        "mm",
        (e)=>e / 4
    ],
    [
        "q",
        (e)=>e
    ],
    [
        "in",
        (e)=>e / 4 / 25.4
    ],
    [
        "pc",
        (e)=>e / 4 / 25.4 * 6
    ],
    [
        "pt",
        (e)=>e / 4 / 25.4 * 72
    ],
    [
        "px",
        (e)=>e / 4 / 25.4 * 96
    ]
]), f = new Map([
    [
        "deg",
        (e)=>180 * e / Math.PI
    ],
    [
        "grad",
        (e)=>180 * e / Math.PI / .9
    ],
    [
        "rad",
        (e)=>e
    ],
    [
        "turn",
        (e)=>180 * e / Math.PI / 360
    ]
]), d = new Map([
    [
        "ms",
        (e)=>1e3 * e
    ],
    [
        "s",
        (e)=>e
    ]
]), k = new Map([
    [
        "deg",
        (e)=>360 * e
    ],
    [
        "grad",
        (e)=>360 * e / .9
    ],
    [
        "rad",
        (e)=>360 * e / 180 * Math.PI
    ],
    [
        "turn",
        (e)=>e
    ]
]), C = new Map([
    [
        "cm",
        r
    ],
    [
        "mm",
        c
    ],
    [
        "q",
        N
    ],
    [
        "in",
        s
    ],
    [
        "pc",
        v
    ],
    [
        "pt",
        T
    ],
    [
        "px",
        p
    ],
    [
        "ms",
        m
    ],
    [
        "s",
        d
    ],
    [
        "deg",
        i
    ],
    [
        "grad",
        u
    ],
    [
        "rad",
        f
    ],
    [
        "turn",
        k
    ],
    [
        "hz",
        a
    ],
    [
        "khz",
        l
    ]
]);
function convertUnit(e, t) {
    if (!n.isTokenDimension(e)) return t;
    if (!n.isTokenDimension(t)) return t;
    const o = toLowerCaseAZ(e[4].unit), r = toLowerCaseAZ(t[4].unit);
    if (o === r) return t;
    const i = C.get(r);
    if (!i) return t;
    const u = i.get(o);
    if (!u) return t;
    const a = u(t[4].value), s = [
        n.TokenType.Dimension,
        "",
        t[2],
        t[3],
        {
            ...t[4],
            signCharacter: a < 0 ? "-" : void 0,
            type: Number.isInteger(a) ? n.NumberType.Integer : n.NumberType.Number,
            value: a
        }
    ];
    return n.mutateUnit(s, e[4].unit), s;
}
function toCanonicalUnit(e) {
    if (!n.isTokenDimension(e)) return e;
    const t = toLowerCaseAZ(e[4].unit), r = o[t];
    if (t === r) return e;
    const i = C.get(t);
    if (!i) return e;
    const u = i.get(r);
    if (!u) return e;
    const a = u(e[4].value), s = [
        n.TokenType.Dimension,
        "",
        e[2],
        e[3],
        {
            ...e[4],
            signCharacter: a < 0 ? "-" : void 0,
            type: Number.isInteger(a) ? n.NumberType.Integer : n.NumberType.Number,
            value: a
        }
    ];
    return n.mutateUnit(s, r), s;
}
function addition(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value;
    let r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenPercentage(r)) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenDimension(r) && (r = convertUnit(o, r), toLowerCaseAZ(o[4].unit) === toLowerCaseAZ(r[4].unit))) {
        const t = o[4].value + r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function division(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value, r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: Number.isInteger(t) ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenNumber(r)) {
        const t = o[4].value / r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: Number.isInteger(t) ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function isCalculation(e) {
    return !!e && "object" == typeof e && "inputs" in e && Array.isArray(e.inputs) && "operation" in e;
}
function solve(n) {
    if (-1 === n) return -1;
    const t = [];
    for(let o = 0; o < n.inputs.length; o++){
        const r = n.inputs[o];
        if (e.isTokenNode(r)) {
            t.push(r);
            continue;
        }
        const i = solve(r);
        if (-1 === i) return -1;
        t.push(i);
    }
    return n.operation(t);
}
function multiplication(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value, r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenNumber(o) && n.isTokenPercentage(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenNumber(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    if (n.isTokenNumber(o) && n.isTokenDimension(r)) {
        const t = o[4].value * r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + r[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: r[4].unit
            }
        ]);
    }
    return -1;
}
function resolveGlobalsAndConstants(t, o) {
    for(let r = 0; r < t.length; r++){
        const i = t[r];
        if (!e.isTokenNode(i)) continue;
        const u = i.value;
        if (!n.isTokenIdent(u)) continue;
        const a = toLowerCaseAZ(u[4].value);
        switch(a){
            case "e":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    Math.E.toString(),
                    u[2],
                    u[3],
                    {
                        value: Math.E,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "pi":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    Math.PI.toString(),
                    u[2],
                    u[3],
                    {
                        value: Math.PI,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "infinity":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "infinity",
                    u[2],
                    u[3],
                    {
                        value: 1 / 0,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "-infinity":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "-infinity",
                    u[2],
                    u[3],
                    {
                        value: -1 / 0,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            case "nan":
                t.splice(r, 1, new e.TokenNode([
                    n.TokenType.Number,
                    "NaN",
                    u[2],
                    u[3],
                    {
                        value: Number.NaN,
                        type: n.NumberType.Number
                    }
                ]));
                break;
            default:
                if (o.has(a)) {
                    const n = o.get(a);
                    t.splice(r, 1, new e.TokenNode(n));
                }
        }
    }
    return t;
}
function unary(e) {
    if (1 !== e.length) return -1;
    const t = e[0].value;
    return n.isTokenNumeric(t) ? e[0] : -1;
}
function resultToCalculation(e, t, o) {
    return n.isTokenDimension(t) ? dimensionToCalculation(e, t[4].unit, o) : n.isTokenPercentage(t) ? percentageToCalculation(e, o) : n.isTokenNumber(t) ? numberToCalculation(e, o) : -1;
}
function dimensionToCalculation(t, o, r) {
    const i = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Dimension,
                r.toString() + o,
                i[0][2],
                i[i.length - 1][3],
                {
                    value: r,
                    type: Number.isInteger(r) ? n.NumberType.Integer : n.NumberType.Number,
                    unit: o
                }
            ])
        ],
        operation: unary
    };
}
function percentageToCalculation(t, o) {
    const r = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Percentage,
                o.toString() + "%",
                r[0][2],
                r[r.length - 1][3],
                {
                    value: o
                }
            ])
        ],
        operation: unary
    };
}
function numberToCalculation(t, o) {
    const r = t.tokens();
    return {
        inputs: [
            new e.TokenNode([
                n.TokenType.Number,
                o.toString(),
                r[0][2],
                r[r.length - 1][3],
                {
                    value: o,
                    type: Number.isInteger(o) ? n.NumberType.Integer : n.NumberType.Number
                }
            ])
        ],
        operation: unary
    };
}
function solveACos(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.acos(o[4].value));
}
function solveASin(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.asin(o[4].value));
}
function solveATan(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return dimensionToCalculation(e, "rad", Math.atan(o[4].value));
}
function isDimensionOrNumber(e) {
    return n.isTokenDimension(e) || n.isTokenNumber(e);
}
function arrayOfSameNumeric(e) {
    if (0 === e.length) return !0;
    const t = e[0];
    if (!n.isTokenNumeric(t)) return !1;
    if (1 === e.length) return !0;
    if (n.isTokenDimension(t)) {
        const n = toLowerCaseAZ(t[4].unit);
        for(let o = 1; o < e.length; o++){
            const r = e[o];
            if (t[0] !== r[0]) return !1;
            if (n !== toLowerCaseAZ(r[4].unit)) return !1;
        }
        return !0;
    }
    for(let n = 1; n < e.length; n++){
        const o = e[n];
        if (t[0] !== o[0]) return !1;
    }
    return !0;
}
function twoOfSameNumeric(e, t) {
    return !!n.isTokenNumeric(e) && (n.isTokenDimension(e) ? e[0] === t[0] && toLowerCaseAZ(e[4].unit) === toLowerCaseAZ(t[4].unit) : e[0] === t[0]);
}
function solveATan2(e, n, t) {
    const o = n.value;
    if (!isDimensionOrNumber(o)) return -1;
    const r = convertUnit(o, t.value);
    if (!twoOfSameNumeric(o, r)) return -1;
    return dimensionToCalculation(e, "rad", Math.atan2(o[4].value, r[4].value));
}
function solveAbs(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    if (!o.rawPercentages && n.isTokenPercentage(r)) return -1;
    return resultToCalculation(e, r, Math.abs(r[4].value));
}
function solveClamp(t, o, r, i, u) {
    if (!e.isTokenNode(o) || !e.isTokenNode(r) || !e.isTokenNode(i)) return -1;
    const a = o.value;
    if (!n.isTokenNumeric(a)) return -1;
    if (!u.rawPercentages && n.isTokenPercentage(a)) return -1;
    const s = convertUnit(a, r.value);
    if (!twoOfSameNumeric(a, s)) return -1;
    const l = convertUnit(a, i.value);
    if (!twoOfSameNumeric(a, l)) return -1;
    return resultToCalculation(t, a, Math.max(a[4].value, Math.min(s[4].value, l[4].value)));
}
function solveCos(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    let r = o[4].value;
    if (n.isTokenDimension(o)) switch(o[4].unit.toLowerCase()){
        case "rad":
            break;
        case "deg":
            r = i.get("rad")(o[4].value);
            break;
        case "grad":
            r = u.get("rad")(o[4].value);
            break;
        case "turn":
            r = k.get("rad")(o[4].value);
            break;
        default:
            return -1;
    }
    return r = Math.cos(r), numberToCalculation(e, r);
}
function solveExp(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return numberToCalculation(e, Math.exp(o[4].value));
}
function solveHypot(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.hypot(...a);
    return resultToCalculation(t, i, s);
}
function solveMax(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.max(...a);
    return resultToCalculation(t, i, s);
}
function solveMin(t, o, r) {
    if (!o.every(e.isTokenNode)) return -1;
    const i = o[0].value;
    if (!n.isTokenNumeric(i)) return -1;
    if (!r.rawPercentages && n.isTokenPercentage(i)) return -1;
    const u = o.map((e)=>convertUnit(i, e.value));
    if (!arrayOfSameNumeric(u)) return -1;
    const a = u.map((e)=>e[4].value), s = Math.min(...a);
    return resultToCalculation(t, i, s);
}
function solveMod(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    const i = convertUnit(r, o.value);
    if (!twoOfSameNumeric(r, i)) return -1;
    let u;
    return u = 0 === i[4].value ? Number.NaN : Number.isFinite(r[4].value) && (Number.isFinite(i[4].value) || (i[4].value !== Number.POSITIVE_INFINITY || r[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r[4].value, -0)) && (i[4].value !== Number.NEGATIVE_INFINITY || r[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r[4].value, 0))) ? Number.isFinite(i[4].value) ? (r[4].value % i[4].value + i[4].value) % i[4].value : r[4].value : Number.NaN, resultToCalculation(e, r, u);
}
function solvePow(e, t, o) {
    const r = t.value, i = o.value;
    if (!n.isTokenNumber(r)) return -1;
    if (!twoOfSameNumeric(r, i)) return -1;
    return numberToCalculation(e, Math.pow(r[4].value, i[4].value));
}
function solveRem(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    const i = convertUnit(r, o.value);
    if (!twoOfSameNumeric(r, i)) return -1;
    let u;
    return u = 0 === i[4].value ? Number.NaN : Number.isFinite(r[4].value) ? Number.isFinite(i[4].value) ? r[4].value % i[4].value : r[4].value : Number.NaN, resultToCalculation(e, r, u);
}
function solveRound(e, t, o, r, i) {
    const u = o.value;
    if (!n.isTokenNumeric(u)) return -1;
    if (!i.rawPercentages && n.isTokenPercentage(u)) return -1;
    const a = convertUnit(u, r.value);
    if (!twoOfSameNumeric(u, a)) return -1;
    let s;
    if (0 === a[4].value) s = Number.NaN;
    else if (Number.isFinite(u[4].value) || Number.isFinite(a[4].value)) if (!Number.isFinite(u[4].value) && Number.isFinite(a[4].value)) s = u[4].value;
    else if (Number.isFinite(u[4].value) && !Number.isFinite(a[4].value)) switch(t){
        case "down":
            s = u[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * u[4].value) ? -0 : 0;
            break;
        case "up":
            s = u[4].value > 0 ? 1 / 0 : Object.is(0, 0 * u[4].value) ? 0 : -0;
            break;
        default:
            s = Object.is(0, 0 * u[4].value) ? 0 : -0;
    }
    else if (Number.isFinite(a[4].value)) switch(t){
        case "down":
            s = Math.floor(u[4].value / a[4].value) * a[4].value;
            break;
        case "up":
            s = Math.ceil(u[4].value / a[4].value) * a[4].value;
            break;
        case "to-zero":
            s = Math.trunc(u[4].value / a[4].value) * a[4].value;
            break;
        default:
            {
                let e = Math.floor(u[4].value / a[4].value) * a[4].value, n = Math.ceil(u[4].value / a[4].value) * a[4].value;
                if (e > n) {
                    const t = e;
                    e = n, n = t;
                }
                const t = Math.abs(u[4].value - e), o = Math.abs(u[4].value - n);
                s = t === o ? n : t < o ? e : n;
                break;
            }
    }
    else s = u[4].value;
    else s = Number.NaN;
    return resultToCalculation(e, u, s);
}
function solveSign(e, t, o) {
    const r = t.value;
    if (!n.isTokenNumeric(r)) return -1;
    if (!o.rawPercentages && n.isTokenPercentage(r)) return -1;
    return numberToCalculation(e, Math.sign(r[4].value));
}
function solveSin(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    let r = o[4].value;
    if (n.isTokenDimension(o)) switch(toLowerCaseAZ(o[4].unit)){
        case "rad":
            break;
        case "deg":
            r = i.get("rad")(o[4].value);
            break;
        case "grad":
            r = u.get("rad")(o[4].value);
            break;
        case "turn":
            r = k.get("rad")(o[4].value);
            break;
        default:
            return -1;
    }
    return r = Math.sin(r), numberToCalculation(e, r);
}
function solveSqrt(e, t) {
    const o = t.value;
    if (!n.isTokenNumber(o)) return -1;
    return numberToCalculation(e, Math.sqrt(o[4].value));
}
function solveTan(e, t) {
    const o = t.value;
    if (!isDimensionOrNumber(o)) return -1;
    const r = o[4].value;
    let a = 0, s = o[4].value;
    if (n.isTokenDimension(o)) switch(toLowerCaseAZ(o[4].unit)){
        case "rad":
            a = f.get("deg")(r);
            break;
        case "deg":
            a = r, s = i.get("rad")(r);
            break;
        case "grad":
            a = u.get("deg")(r), s = u.get("rad")(r);
            break;
        case "turn":
            a = k.get("deg")(r), s = k.get("rad")(r);
            break;
        default:
            return -1;
    }
    const l = a / 90;
    return s = a % 90 == 0 && l % 2 != 0 ? l > 0 ? 1 / 0 : -1 / 0 : Math.tan(s), numberToCalculation(e, s);
}
function subtraction(t) {
    if (2 !== t.length) return -1;
    const o = t[0].value;
    let r = t[1].value;
    if (n.isTokenNumber(o) && n.isTokenNumber(r)) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Number,
            t.toString(),
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number
            }
        ]);
    }
    if (n.isTokenPercentage(o) && n.isTokenPercentage(r)) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Percentage,
            t.toString() + "%",
            o[2],
            r[3],
            {
                value: t
            }
        ]);
    }
    if (n.isTokenDimension(o) && n.isTokenDimension(r) && (r = convertUnit(o, r), toLowerCaseAZ(o[4].unit) === toLowerCaseAZ(r[4].unit))) {
        const t = o[4].value - r[4].value;
        return new e.TokenNode([
            n.TokenType.Dimension,
            t.toString() + o[4].unit,
            o[2],
            r[3],
            {
                value: t,
                type: o[4].type === n.NumberType.Integer && r[4].type === n.NumberType.Integer ? n.NumberType.Integer : n.NumberType.Number,
                unit: o[4].unit
            }
        ]);
    }
    return -1;
}
function solveLog(t, o) {
    if (1 === o.length) {
        const r = o[0];
        if (!r || !e.isTokenNode(r)) return -1;
        const i = r.value;
        if (!n.isTokenNumber(i)) return -1;
        return numberToCalculation(t, Math.log(i[4].value));
    }
    if (2 === o.length) {
        const r = o[0];
        if (!r || !e.isTokenNode(r)) return -1;
        const i = r.value;
        if (!n.isTokenNumber(i)) return -1;
        const u = o[1];
        if (!u || !e.isTokenNode(u)) return -1;
        const a = u.value;
        if (!n.isTokenNumber(a)) return -1;
        return numberToCalculation(t, Math.log(i[4].value) / Math.log(a[4].value));
    }
    return -1;
}
const g = /^none$/i;
function isNone(t) {
    if (Array.isArray(t)) {
        const n = t.filter((n)=>!(e.isWhitespaceNode(n) && e.isCommentNode(n)));
        return 1 === n.length && isNone(n[0]);
    }
    if (!e.isTokenNode(t)) return !1;
    const o = t.value;
    return !!n.isTokenIdent(o) && g.test(o[4].value);
}
const D = String.fromCodePoint(0);
function solveRandom(e, t, o, r, i, u) {
    if (-1 === t.fixed && !u.randomCaching) return -1;
    u.randomCaching || (u.randomCaching = {
        propertyName: "",
        propertyN: 0,
        elementID: "",
        documentID: ""
    }), u.randomCaching && !u.randomCaching.propertyN && (u.randomCaching.propertyN = 0);
    const a = o.value;
    if (!n.isTokenNumeric(a)) return -1;
    const s = convertUnit(a, r.value);
    if (!twoOfSameNumeric(a, s)) return -1;
    let l = null;
    if (i && (l = convertUnit(a, i.value), !twoOfSameNumeric(a, l))) return -1;
    if (!Number.isFinite(a[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (!Number.isFinite(s[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (!Number.isFinite(s[4].value - a[4].value)) return resultToCalculation(e, a, Number.NaN);
    if (l && !Number.isFinite(l[4].value)) return resultToCalculation(e, a, a[4].value);
    const c = -1 === t.fixed ? sfc32(crc32([
        t.dashedIdent ? t.dashedIdent : `${u.randomCaching?.propertyName} ${u.randomCaching.propertyN++}`,
        t.elementShared ? "" : u.randomCaching.elementID,
        u.randomCaching.documentID
    ].join(D))) : ()=>t.fixed;
    let m = a[4].value, v = s[4].value;
    if (m > v && ([m, v] = [
        v,
        m
    ]), l && (l[4].value <= 0 || Math.abs(m - v) / l[4].value > 1e10) && (l = null), l) {
        const n = Math.max(l[4].value / 1e3, 1e-9), t = [
            m
        ];
        let o = 0;
        for(;;){
            o += l[4].value;
            const e = m + o;
            if (!(e + n < v)) {
                t.push(v);
                break;
            }
            if (t.push(e), e + l[4].value - n > v) break;
        }
        const r = c();
        return resultToCalculation(e, a, Number(t[Math.floor(t.length * r)].toFixed(5)));
    }
    const T = c();
    return resultToCalculation(e, a, Number((T * (v - m) + m).toFixed(5)));
}
function sfc32(e = .34944106645296036, n = .19228640875738723, t = .8784393832007205, o = .04850964319275053) {
    return ()=>{
        const r = ((e |= 0) + (n |= 0) | 0) + (o |= 0) | 0;
        return o = o + 1 | 0, e = n ^ n >>> 9, n = (t |= 0) + (t << 3) | 0, t = (t = t << 21 | t >>> 11) + r | 0, (r >>> 0) / 4294967296;
    };
}
function crc32(e) {
    let n = 0, t = 0, o = 0;
    n ^= -1;
    for(let r = 0, i = e.length; r < i; r++)o = 255 & (n ^ e.charCodeAt(r)), t = Number("0x" + "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".substring(9 * o, 9 * o + 8)), n = n >>> 8 ^ t;
    return (-1 ^ n) >>> 0;
}
const b = new Map([
    [
        "abs",
        function abs(e, n, t) {
            return singleNodeSolver(e, n, t, solveAbs);
        }
    ],
    [
        "acos",
        function acos(e, n, t) {
            return singleNodeSolver(e, n, t, solveACos);
        }
    ],
    [
        "asin",
        function asin(e, n, t) {
            return singleNodeSolver(e, n, t, solveASin);
        }
    ],
    [
        "atan",
        function atan(e, n, t) {
            return singleNodeSolver(e, n, t, solveATan);
        }
    ],
    [
        "atan2",
        function atan2(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveATan2);
        }
    ],
    [
        "calc",
        calc$1
    ],
    [
        "clamp",
        function clamp(t, o, r) {
            const i = resolveGlobalsAndConstants([
                ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
            ], o), u = [], a = [], s = [];
            {
                let t = u;
                for(let o = 0; o < i.length; o++){
                    const r = i[o];
                    if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                        if (t === s) return -1;
                        if (t === a) {
                            t = s;
                            continue;
                        }
                        if (t === u) {
                            t = a;
                            continue;
                        }
                        return -1;
                    }
                    t.push(r);
                }
            }
            const l = isNone(u), c = isNone(s);
            if (l && c) return calc$1(calcWrapper(a), o, r);
            const m = solve(calc$1(calcWrapper(a), o, r));
            if (-1 === m) return -1;
            if (l) {
                const t = solve(calc$1(calcWrapper(s), o, r));
                return -1 === t ? -1 : solveMin((v = m, T = t, new e.FunctionNode([
                    n.TokenType.Function,
                    "min(",
                    -1,
                    -1,
                    {
                        value: "min"
                    }
                ], [
                    n.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ], [
                    v,
                    new e.TokenNode([
                        n.TokenType.Comma,
                        ",",
                        -1,
                        -1,
                        void 0
                    ]),
                    T
                ])), [
                    m,
                    t
                ], r);
            }
            if (c) {
                const e = solve(calc$1(calcWrapper(u), o, r));
                return -1 === e ? -1 : solveMax(maxWrapper(e, m), [
                    e,
                    m
                ], r);
            }
            var v, T;
            const p = solve(calc$1(calcWrapper(u), o, r));
            if (-1 === p) return -1;
            const N = solve(calc$1(calcWrapper(s), o, r));
            if (-1 === N) return -1;
            return solveClamp(t, p, m, N, r);
        }
    ],
    [
        "cos",
        function cos(e, n, t) {
            return singleNodeSolver(e, n, t, solveCos);
        }
    ],
    [
        "exp",
        function exp(e, n, t) {
            return singleNodeSolver(e, n, t, solveExp);
        }
    ],
    [
        "hypot",
        function hypot(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveHypot);
        }
    ],
    [
        "log",
        function log(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveLog);
        }
    ],
    [
        "max",
        function max(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveMax);
        }
    ],
    [
        "min",
        function min(e, n, t) {
            return variadicNodesSolver(e, e.value, n, t, solveMin);
        }
    ],
    [
        "mod",
        function mod(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveMod);
        }
    ],
    [
        "pow",
        function pow(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solvePow);
        }
    ],
    [
        "random",
        function random(n, t, o) {
            const r = parseRandomValueSharing(n.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n)), t, o);
            if (-1 === r) return -1;
            const [i, u] = r, a = variadicArguments(u, t, o);
            if (-1 === a) return -1;
            const [s, l, c] = a;
            if (!s || !l) return -1;
            return solveRandom(n, i, s, l, c, o);
        }
    ],
    [
        "rem",
        function rem(e, n, t) {
            return twoCommaSeparatedNodesSolver(e, n, t, solveRem);
        }
    ],
    [
        "round",
        function round(t, o, r) {
            const i = resolveGlobalsAndConstants([
                ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
            ], o);
            let u = "", a = !1;
            const s = [], l = [];
            {
                let t = s;
                for(let o = 0; o < i.length; o++){
                    const r = i[o];
                    if (!u && 0 === s.length && 0 === l.length && e.isTokenNode(r) && n.isTokenIdent(r.value)) {
                        const e = r.value[4].value.toLowerCase();
                        if (y.has(e)) {
                            u = e;
                            continue;
                        }
                    }
                    if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                        if (t === l) return -1;
                        if (t === s && u && 0 === s.length) continue;
                        if (t === s) {
                            a = !0, t = l;
                            continue;
                        }
                        return -1;
                    }
                    t.push(r);
                }
            }
            const c = solve(calc$1(calcWrapper(s), o, r));
            if (-1 === c) return -1;
            a || 0 !== l.length || l.push(new e.TokenNode([
                n.TokenType.Number,
                "1",
                -1,
                -1,
                {
                    value: 1,
                    type: n.NumberType.Integer
                }
            ]));
            const m = solve(calc$1(calcWrapper(l), o, r));
            if (-1 === m) return -1;
            u || (u = "nearest");
            return solveRound(t, u, c, m, r);
        }
    ],
    [
        "sign",
        function sign(e, n, t) {
            return singleNodeSolver(e, n, t, solveSign);
        }
    ],
    [
        "sin",
        function sin(e, n, t) {
            return singleNodeSolver(e, n, t, solveSin);
        }
    ],
    [
        "sqrt",
        function sqrt(e, n, t) {
            return singleNodeSolver(e, n, t, solveSqrt);
        }
    ],
    [
        "tan",
        function tan(e, n, t) {
            return singleNodeSolver(e, n, t, solveTan);
        }
    ]
]);
function calc$1(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.value.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o);
    if (1 === i.length && e.isTokenNode(i[0])) return {
        inputs: [
            i[0]
        ],
        operation: unary
    };
    let u = 0;
    for(; u < i.length;){
        const t = i[u];
        if (e.isSimpleBlockNode(t) && n.isTokenOpenParen(t.startToken)) {
            const e = calc$1(t, o, r);
            if (-1 === e) return -1;
            i.splice(u, 1, e);
        } else if (e.isFunctionNode(t)) {
            const e = b.get(t.getName().toLowerCase());
            if (!e) return -1;
            const n = e(t, o, r);
            if (-1 === n) return -1;
            i.splice(u, 1, n);
        } else u++;
    }
    if (u = 0, 1 === i.length && isCalculation(i[0])) return i[0];
    for(; u < i.length;){
        const t = i[u];
        if (!t || !e.isTokenNode(t) && !isCalculation(t)) {
            u++;
            continue;
        }
        const o = i[u + 1];
        if (!o || !e.isTokenNode(o)) {
            u++;
            continue;
        }
        const r = o.value;
        if (!n.isTokenDelim(r) || "*" !== r[4].value && "/" !== r[4].value) {
            u++;
            continue;
        }
        const a = i[u + 2];
        if (!a || !e.isTokenNode(a) && !isCalculation(a)) return -1;
        "*" !== r[4].value ? "/" !== r[4].value ? u++ : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: division
        }) : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: multiplication
        });
    }
    if (u = 0, 1 === i.length && isCalculation(i[0])) return i[0];
    for(; u < i.length;){
        const t = i[u];
        if (!t || !e.isTokenNode(t) && !isCalculation(t)) {
            u++;
            continue;
        }
        const o = i[u + 1];
        if (!o || !e.isTokenNode(o)) {
            u++;
            continue;
        }
        const r = o.value;
        if (!n.isTokenDelim(r) || "+" !== r[4].value && "-" !== r[4].value) {
            u++;
            continue;
        }
        const a = i[u + 2];
        if (!a || !e.isTokenNode(a) && !isCalculation(a)) return -1;
        "+" !== r[4].value ? "-" !== r[4].value ? u++ : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: subtraction
        }) : i.splice(u, 3, {
            inputs: [
                t,
                a
            ],
            operation: addition
        });
    }
    return 1 === i.length && isCalculation(i[0]) ? i[0] : -1;
}
function singleNodeSolver(e, n, t, o) {
    const r = singleArgument(e.value, n, t);
    return -1 === r ? -1 : o(e, r, t);
}
function singleArgument(n, t, o) {
    const r = solve(calc$1(calcWrapper(resolveGlobalsAndConstants([
        ...n.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], t)), t, o));
    return -1 === r ? -1 : r;
}
function twoCommaSeparatedNodesSolver(e, n, t, o) {
    const r = twoCommaSeparatedArguments(e.value, n, t);
    if (-1 === r) return -1;
    const [i, u] = r;
    return o(e, i, u, t);
}
function twoCommaSeparatedArguments(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o), u = [], a = [];
    {
        let t = u;
        for(let o = 0; o < i.length; o++){
            const r = i[o];
            if (e.isTokenNode(r) && n.isTokenComma(r.value)) {
                if (t === a) return -1;
                if (t === u) {
                    t = a;
                    continue;
                }
                return -1;
            }
            t.push(r);
        }
    }
    const s = solve(calc$1(calcWrapper(u), o, r));
    if (-1 === s) return -1;
    const l = solve(calc$1(calcWrapper(a), o, r));
    return -1 === l ? -1 : [
        s,
        l
    ];
}
function variadicNodesSolver(e, n, t, o, r) {
    const i = variadicArguments(e.value, t, o);
    return -1 === i ? -1 : r(e, i, o);
}
function variadicArguments(t, o, r) {
    const i = resolveGlobalsAndConstants([
        ...t.filter((n)=>!e.isWhiteSpaceOrCommentNode(n))
    ], o), u = [];
    {
        const t = [];
        let a = [];
        for(let o = 0; o < i.length; o++){
            const r = i[o];
            e.isTokenNode(r) && n.isTokenComma(r.value) ? (t.push(a), a = []) : a.push(r);
        }
        t.push(a);
        for(let e = 0; e < t.length; e++){
            if (0 === t[e].length) return -1;
            const n = solve(calc$1(calcWrapper(t[e]), o, r));
            if (-1 === n) return -1;
            u.push(n);
        }
    }
    return u;
}
const y = new Set([
    "nearest",
    "up",
    "down",
    "to-zero"
]);
function parseRandomValueSharing(t, o, r) {
    const i = {
        isAuto: !1,
        dashedIdent: "",
        fixed: -1,
        elementShared: !1
    }, u = t[0];
    if (!e.isTokenNode(u) || !n.isTokenIdent(u.value)) return [
        i,
        t
    ];
    for(let u = 0; u < t.length; u++){
        const a = t[u];
        if (!e.isTokenNode(a)) return -1;
        if (n.isTokenComma(a.value)) return [
            i,
            t.slice(u + 1)
        ];
        if (!n.isTokenIdent(a.value)) return -1;
        const s = a.value[4].value.toLowerCase();
        if ("element-shared" !== s) if ("fixed" !== s) if ("auto" !== s) if (s.startsWith("--")) {
            if (-1 !== i.fixed || i.isAuto) return -1;
            i.dashedIdent = s;
        } else ;
        else {
            if (-1 !== i.fixed || i.dashedIdent) return -1;
            i.isAuto = !0;
        }
        else {
            if (i.elementShared || i.dashedIdent || i.isAuto) return -1;
            u++;
            const e = t[u];
            if (!e) return -1;
            const a = solve(calc$1(calcWrapper([
                e
            ]), o, r));
            if (-1 === a) return -1;
            if (!n.isTokenNumber(a.value)) return -1;
            if (a.value[4].value < 0 || a.value[4].value > 1) return -1;
            i.fixed = Math.max(0, Math.min(a.value[4].value, 1 - 1e-9));
        }
        else {
            if (-1 !== i.fixed) return -1;
            i.elementShared = !0;
        }
    }
    return -1;
}
function calcWrapper(t) {
    return new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        -1,
        -1,
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], t);
}
function maxWrapper(t, o) {
    return new e.FunctionNode([
        n.TokenType.Function,
        "max(",
        -1,
        -1,
        {
            value: "max"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], [
        t,
        new e.TokenNode([
            n.TokenType.Comma,
            ",",
            -1,
            -1,
            void 0
        ]),
        o
    ]);
}
function patchNaN(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    return n.isTokenNumeric(o) && Number.isNaN(o[4].value) ? n.isTokenNumber(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ])
    ]) : n.isTokenDimension(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Dimension,
            "1" + o[4].unit,
            o[2],
            o[3],
            {
                value: 1,
                type: n.NumberType.Integer,
                unit: o[4].unit
            }
        ])
    ]) : n.isTokenPercentage(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            "NaN",
            o[2],
            o[3],
            {
                value: "NaN"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Percentage,
            "1%",
            o[2],
            o[3],
            {
                value: 1
            }
        ])
    ]) : -1 : t;
}
function patchInfinity(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    if (!n.isTokenNumeric(o)) return t;
    if (Number.isFinite(o[4].value) || Number.isNaN(o[4].value)) return t;
    let r = "";
    return Number.NEGATIVE_INFINITY === o[4].value && (r = "-"), n.isTokenNumber(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ])
    ]) : n.isTokenDimension(o) ? new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Dimension,
            "1" + o[4].unit,
            o[2],
            o[3],
            {
                value: 1,
                type: n.NumberType.Integer,
                unit: o[4].unit
            }
        ])
    ]) : new e.FunctionNode([
        n.TokenType.Function,
        "calc(",
        o[2],
        o[3],
        {
            value: "calc"
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        o[2],
        o[3],
        void 0
    ], [
        new e.TokenNode([
            n.TokenType.Ident,
            r + "infinity",
            o[2],
            o[3],
            {
                value: r + "infinity"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Delim,
            "*",
            o[2],
            o[3],
            {
                value: "*"
            }
        ]),
        new e.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                o[2],
                o[3],
                void 0
            ]
        ]),
        new e.TokenNode([
            n.TokenType.Percentage,
            "1%",
            o[2],
            o[3],
            {
                value: 1
            }
        ])
    ]);
}
function patchMinusZero(t) {
    if (-1 === t) return -1;
    if (e.isFunctionNode(t)) return t;
    const o = t.value;
    return n.isTokenNumeric(o) && Object.is(-0, o[4].value) ? ("-0" === o[1] || (n.isTokenPercentage(o) ? o[1] = "-0%" : n.isTokenDimension(o) ? o[1] = "-0" + o[4].unit : o[1] = "-0"), t) : t;
}
function patchPrecision(t, o = 13) {
    if (-1 === t) return -1;
    if (o <= 0) return t;
    if (e.isFunctionNode(t)) return t;
    const r = t.value;
    if (!n.isTokenNumeric(r)) return t;
    if (Number.isInteger(r[4].value)) return t;
    const i = Number(r[4].value.toFixed(o)).toString();
    return n.isTokenNumber(r) ? r[1] = i : n.isTokenPercentage(r) ? r[1] = i + "%" : n.isTokenDimension(r) && (r[1] = i + r[4].unit), t;
}
function patchCanonicalUnit(t) {
    return -1 === t ? -1 : e.isFunctionNode(t) ? t : n.isTokenDimension(t.value) ? (t.value = toCanonicalUnit(t.value), t) : t;
}
function patchCalcResult(e, n) {
    let t = e;
    return n?.toCanonicalUnits && (t = patchCanonicalUnit(t)), t = patchPrecision(t, n?.precision), t = patchMinusZero(t), n?.censorIntoStandardRepresentableValues || (t = patchNaN(t), t = patchInfinity(t)), t;
}
function tokenizeGlobals(e) {
    const t = new Map;
    if (!e) return t;
    for (const [o, r] of e)if (n.isToken(r)) t.set(o, r);
    else if ("string" != typeof r) ;
    else {
        const e = n.tokenizer({
            css: r
        }), i = e.nextToken();
        if (e.nextToken(), !e.endOfFile()) continue;
        if (!n.isTokenNumeric(i)) continue;
        t.set(o, i);
    }
    return t;
}
function calcFromComponentValues(n, t) {
    const o = tokenizeGlobals(t?.globals);
    return e.replaceComponentValues(n, (n)=>{
        if (!e.isFunctionNode(n)) return;
        const r = b.get(n.getName().toLowerCase());
        if (!r) return;
        const i = patchCalcResult(solve(r(n, o, t ?? {})), t);
        return -1 !== i ? i : void 0;
    });
}
const h = new Set(b.keys());
exports.calc = function calc(t, o) {
    return calcFromComponentValues(e.parseCommaSeparatedListOfComponentValues(n.tokenize({
        css: t
    }), {}), o).map((e)=>e.map((e)=>n.stringify(...e.tokens())).join("")).join(",");
}, exports.calcFromComponentValues = calcFromComponentValues, exports.mathFunctionNames = h;
}}),
"[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, o, a = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
function convertNaNToZero(e) {
    return [
        Number.isNaN(e[0]) ? 0 : e[0],
        Number.isNaN(e[1]) ? 0 : e[1],
        Number.isNaN(e[2]) ? 0 : e[2]
    ];
}
function colorData_to_XYZ_D50(e) {
    switch(e.colorNotation){
        case exports.ColorNotation.HEX:
        case exports.ColorNotation.RGB:
        case exports.ColorNotation.sRGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.sRGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Linear_sRGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.lin_sRGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Display_P3:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.P3_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Rec2020:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.rec_2020_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.A98_RGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.a98_RGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.ProPhoto_RGB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.ProPhoto_RGB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.HSL:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.HSL_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.HWB:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.HWB_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.Lab:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.Lab_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.OKLab:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.OKLab_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.LCH:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.LCH_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.OKLCH:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.OKLCH_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.XYZ_D50:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.XYZ_D50_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        case exports.ColorNotation.XYZ_D65:
            return {
                ...e,
                colorNotation: exports.ColorNotation.XYZ_D50,
                channels: n.XYZ_D65_to_XYZ_D50(convertNaNToZero(e.channels))
            };
        default:
            throw new Error("Unsupported color notation");
    }
}
exports.ColorNotation = void 0, (e = exports.ColorNotation || (exports.ColorNotation = {})).A98_RGB = "a98-rgb", e.Display_P3 = "display-p3", e.HEX = "hex", e.HSL = "hsl", e.HWB = "hwb", e.LCH = "lch", e.Lab = "lab", e.Linear_sRGB = "srgb-linear", e.OKLCH = "oklch", e.OKLab = "oklab", e.ProPhoto_RGB = "prophoto-rgb", e.RGB = "rgb", e.sRGB = "srgb", e.Rec2020 = "rec2020", e.XYZ_D50 = "xyz-d50", e.XYZ_D65 = "xyz-d65", exports.SyntaxFlag = void 0, (o = exports.SyntaxFlag || (exports.SyntaxFlag = {})).ColorKeyword = "color-keyword", o.HasAlpha = "has-alpha", o.HasDimensionValues = "has-dimension-values", o.HasNoneKeywords = "has-none-keywords", o.HasNumberValues = "has-number-values", o.HasPercentageAlpha = "has-percentage-alpha", o.HasPercentageValues = "has-percentage-values", o.HasVariableAlpha = "has-variable-alpha", o.Hex = "hex", o.LegacyHSL = "legacy-hsl", o.LegacyRGB = "legacy-rgb", o.NamedColor = "named-color", o.RelativeColorSyntax = "relative-color-syntax", o.ColorMix = "color-mix", o.ColorMixVariadic = "color-mix-variadic", o.ContrastColor = "contrast-color", o.Experimental = "experimental";
const s = new Set([
    exports.ColorNotation.A98_RGB,
    exports.ColorNotation.Display_P3,
    exports.ColorNotation.HEX,
    exports.ColorNotation.Linear_sRGB,
    exports.ColorNotation.ProPhoto_RGB,
    exports.ColorNotation.RGB,
    exports.ColorNotation.sRGB,
    exports.ColorNotation.Rec2020,
    exports.ColorNotation.XYZ_D50,
    exports.ColorNotation.XYZ_D65
]);
function colorDataTo(e, o) {
    const a = {
        ...e
    };
    if (e.colorNotation !== o) {
        const e = colorData_to_XYZ_D50(a);
        switch(o){
            case exports.ColorNotation.HEX:
            case exports.ColorNotation.RGB:
                a.colorNotation = exports.ColorNotation.RGB, a.channels = n.XYZ_D50_to_sRGB(e.channels);
                break;
            case exports.ColorNotation.sRGB:
                a.colorNotation = exports.ColorNotation.sRGB, a.channels = n.XYZ_D50_to_sRGB(e.channels);
                break;
            case exports.ColorNotation.Linear_sRGB:
                a.colorNotation = exports.ColorNotation.Linear_sRGB, a.channels = n.XYZ_D50_to_lin_sRGB(e.channels);
                break;
            case exports.ColorNotation.Display_P3:
                a.colorNotation = exports.ColorNotation.Display_P3, a.channels = n.XYZ_D50_to_P3(e.channels);
                break;
            case exports.ColorNotation.Rec2020:
                a.colorNotation = exports.ColorNotation.Rec2020, a.channels = n.XYZ_D50_to_rec_2020(e.channels);
                break;
            case exports.ColorNotation.ProPhoto_RGB:
                a.colorNotation = exports.ColorNotation.ProPhoto_RGB, a.channels = n.XYZ_D50_to_ProPhoto(e.channels);
                break;
            case exports.ColorNotation.A98_RGB:
                a.colorNotation = exports.ColorNotation.A98_RGB, a.channels = n.XYZ_D50_to_a98_RGB(e.channels);
                break;
            case exports.ColorNotation.HSL:
                a.colorNotation = exports.ColorNotation.HSL, a.channels = n.XYZ_D50_to_HSL(e.channels);
                break;
            case exports.ColorNotation.HWB:
                a.colorNotation = exports.ColorNotation.HWB, a.channels = n.XYZ_D50_to_HWB(e.channels);
                break;
            case exports.ColorNotation.Lab:
                a.colorNotation = exports.ColorNotation.Lab, a.channels = n.XYZ_D50_to_Lab(e.channels);
                break;
            case exports.ColorNotation.LCH:
                a.colorNotation = exports.ColorNotation.LCH, a.channels = n.XYZ_D50_to_LCH(e.channels);
                break;
            case exports.ColorNotation.OKLCH:
                a.colorNotation = exports.ColorNotation.OKLCH, a.channels = n.XYZ_D50_to_OKLCH(e.channels);
                break;
            case exports.ColorNotation.OKLab:
                a.colorNotation = exports.ColorNotation.OKLab, a.channels = n.XYZ_D50_to_OKLab(e.channels);
                break;
            case exports.ColorNotation.XYZ_D50:
                a.colorNotation = exports.ColorNotation.XYZ_D50, a.channels = n.XYZ_D50_to_XYZ_D50(e.channels);
                break;
            case exports.ColorNotation.XYZ_D65:
                a.colorNotation = exports.ColorNotation.XYZ_D65, a.channels = n.XYZ_D50_to_XYZ_D65(e.channels);
                break;
            default:
                throw new Error("Unsupported color notation");
        }
    } else a.channels = convertNaNToZero(e.channels);
    if (o === e.colorNotation) a.channels = carryForwardMissingComponents(e.channels, [
        0,
        1,
        2
    ], a.channels, [
        0,
        1,
        2
    ]);
    else if (s.has(o) && s.has(e.colorNotation)) a.channels = carryForwardMissingComponents(e.channels, [
        0,
        1,
        2
    ], a.channels, [
        0,
        1,
        2
    ]);
    else switch(o){
        case exports.ColorNotation.HSL:
            switch(e.colorNotation){
                case exports.ColorNotation.HWB:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        2
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        2,
                        1,
                        0
                    ]);
            }
            break;
        case exports.ColorNotation.HWB:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
            }
            break;
        case exports.ColorNotation.Lab:
        case exports.ColorNotation.OKLab:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        0,
                        1,
                        2
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
            }
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            switch(e.colorNotation){
                case exports.ColorNotation.HSL:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        2,
                        1,
                        0
                    ]);
                    break;
                case exports.ColorNotation.HWB:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        2
                    ]);
                    break;
                case exports.ColorNotation.Lab:
                case exports.ColorNotation.OKLab:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0
                    ], a.channels, [
                        0
                    ]);
                    break;
                case exports.ColorNotation.LCH:
                case exports.ColorNotation.OKLCH:
                    a.channels = carryForwardMissingComponents(e.channels, [
                        0,
                        1,
                        2
                    ], a.channels, [
                        0,
                        1,
                        2
                    ]);
            }
    }
    return a.channels = convertPowerlessComponentsToMissingComponents(a.channels, o), a;
}
function convertPowerlessComponentsToMissingComponents(e, o) {
    const a = [
        ...e
    ];
    switch(o){
        case exports.ColorNotation.HSL:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 4) <= 0 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.HWB:
            Math.max(0, reducePrecision(a[1], 4)) + Math.max(0, reducePrecision(a[2], 4)) >= 100 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.LCH:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 4) <= 0 && (a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLCH:
            !Number.isNaN(a[1]) && reducePrecision(a[1], 6) <= 0 && (a[2] = Number.NaN);
    }
    return a;
}
function convertPowerlessComponentsToZeroValuesForDisplay(e, o) {
    const a = [
        ...e
    ];
    switch(o){
        case exports.ColorNotation.HSL:
            (reducePrecision(a[2]) <= 0 || reducePrecision(a[2]) >= 100) && (a[0] = Number.NaN, a[1] = Number.NaN), reducePrecision(a[1]) <= 0 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.HWB:
            Math.max(0, reducePrecision(a[1])) + Math.max(0, reducePrecision(a[2])) >= 100 && (a[0] = Number.NaN);
            break;
        case exports.ColorNotation.Lab:
            (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 100) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.LCH:
            reducePrecision(a[1]) <= 0 && (a[2] = Number.NaN), (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 100) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLab:
            (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 1) && (a[1] = Number.NaN, a[2] = Number.NaN);
            break;
        case exports.ColorNotation.OKLCH:
            reducePrecision(a[1]) <= 0 && (a[2] = Number.NaN), (reducePrecision(a[0]) <= 0 || reducePrecision(a[0]) >= 1) && (a[1] = Number.NaN, a[2] = Number.NaN);
    }
    return a;
}
function carryForwardMissingComponents(e, o, a, n) {
    const t = [
        ...a
    ];
    for (const a of o)Number.isNaN(e[o[a]]) && (t[n[a]] = Number.NaN);
    return t;
}
function normalizeRelativeColorDataChannels(e) {
    const o = new Map;
    switch(e.colorNotation){
        case exports.ColorNotation.RGB:
        case exports.ColorNotation.HEX:
            o.set("r", dummyNumberToken(255 * e.channels[0])), o.set("g", dummyNumberToken(255 * e.channels[1])), o.set("b", dummyNumberToken(255 * e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.HSL:
            o.set("h", dummyNumberToken(e.channels[0])), o.set("s", dummyNumberToken(e.channels[1])), o.set("l", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.HWB:
            o.set("h", dummyNumberToken(e.channels[0])), o.set("w", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.Lab:
        case exports.ColorNotation.OKLab:
            o.set("l", dummyNumberToken(e.channels[0])), o.set("a", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            o.set("l", dummyNumberToken(e.channels[0])), o.set("c", dummyNumberToken(e.channels[1])), o.set("h", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.sRGB:
        case exports.ColorNotation.A98_RGB:
        case exports.ColorNotation.Display_P3:
        case exports.ColorNotation.Rec2020:
        case exports.ColorNotation.Linear_sRGB:
        case exports.ColorNotation.ProPhoto_RGB:
            o.set("r", dummyNumberToken(e.channels[0])), o.set("g", dummyNumberToken(e.channels[1])), o.set("b", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
            break;
        case exports.ColorNotation.XYZ_D50:
        case exports.ColorNotation.XYZ_D65:
            o.set("x", dummyNumberToken(e.channels[0])), o.set("y", dummyNumberToken(e.channels[1])), o.set("z", dummyNumberToken(e.channels[2])), "number" == typeof e.alpha && o.set("alpha", dummyNumberToken(e.alpha));
    }
    return o;
}
function noneToZeroInRelativeColorDataChannels(e) {
    const o = new Map(e);
    for (const [a, n] of e)Number.isNaN(n[4].value) && o.set(a, dummyNumberToken(0));
    return o;
}
function dummyNumberToken(e) {
    return Number.isNaN(e) ? [
        a.TokenType.Number,
        "none",
        -1,
        -1,
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ] : [
        a.TokenType.Number,
        e.toString(),
        -1,
        -1,
        {
            value: e,
            type: a.NumberType.Number
        }
    ];
}
function reducePrecision(e, o = 7) {
    if (Number.isNaN(e)) return 0;
    const a = Math.pow(10, o);
    return Math.round(e * a) / a;
}
function normalize(e, o, a, n) {
    return Math.min(Math.max(e / o, a), n);
}
const l = /[A-Z]/g;
function toLowerCaseAZ(e) {
    return e.replace(l, (e)=>String.fromCharCode(e.charCodeAt(0) + 32));
}
function normalize_Color_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
const i = new Set([
    "srgb",
    "srgb-linear",
    "display-p3",
    "a98-rgb",
    "prophoto-rgb",
    "rec2020",
    "xyz",
    "xyz-d50",
    "xyz-d65"
]);
function color$1(e, o) {
    const n = [], s = [], l = [], u = [];
    let c, p, N = !1, m = !1;
    const h = {
        colorNotation: exports.ColorNotation.sRGB,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([])
    };
    let x = n;
    for(let y = 0; y < e.value.length; y++){
        let b = e.value[y];
        if (t.isWhitespaceNode(b) || t.isCommentNode(b)) for(; t.isWhitespaceNode(e.value[y + 1]) || t.isCommentNode(e.value[y + 1]);)y++;
        else if (x === n && n.length && (x = s), x === s && s.length && (x = l), t.isTokenNode(b) && a.isTokenDelim(b.value) && "/" === b.value[4].value) {
            if (x === u) return !1;
            x = u;
        } else {
            if (t.isFunctionNode(b)) {
                if (x === u && "var" === toLowerCaseAZ(b.getName())) {
                    h.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), x.push(b);
                    continue;
                }
                if (!r.mathFunctionNames.has(toLowerCaseAZ(b.getName()))) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        b
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    globals: p,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), b = e;
            }
            if (x === n && 0 === n.length && t.isTokenNode(b) && a.isTokenIdent(b.value) && i.has(toLowerCaseAZ(b.value[4].value))) {
                if (N) return !1;
                N = toLowerCaseAZ(b.value[4].value), h.colorNotation = colorSpaceNameToColorNotation(N), m && (m.colorNotation !== h.colorNotation && (m = colorDataTo(m, h.colorNotation)), c = normalizeRelativeColorDataChannels(m), p = noneToZeroInRelativeColorDataChannels(c));
            } else if (x === n && 0 === n.length && t.isTokenNode(b) && a.isTokenIdent(b.value) && "from" === toLowerCaseAZ(b.value[4].value)) {
                if (m) return !1;
                if (N) return !1;
                for(; t.isWhitespaceNode(e.value[y + 1]) || t.isCommentNode(e.value[y + 1]);)y++;
                if (y++, b = e.value[y], m = o(b), !1 === m) return !1;
                m.syntaxFlags.has(exports.SyntaxFlag.Experimental) && h.syntaxFlags.add(exports.SyntaxFlag.Experimental), h.syntaxFlags.add(exports.SyntaxFlag.RelativeColorSyntax);
            } else {
                if (!t.isTokenNode(b)) return !1;
                if (a.isTokenIdent(b.value) && c && c.has(toLowerCaseAZ(b.value[4].value))) {
                    x.push(new t.TokenNode(c.get(toLowerCaseAZ(b.value[4].value))));
                    continue;
                }
                x.push(b);
            }
        }
    }
    if (!N) return !1;
    if (1 !== x.length) return !1;
    if (1 !== n.length || 1 !== s.length || 1 !== l.length) return !1;
    if (!t.isTokenNode(n[0]) || !t.isTokenNode(s[0]) || !t.isTokenNode(l[0])) return !1;
    if (c && !c.has("alpha")) return !1;
    const y = normalize_Color_ChannelValues(n[0].value, 0, h);
    if (!y || !a.isTokenNumber(y)) return !1;
    const b = normalize_Color_ChannelValues(s[0].value, 1, h);
    if (!b || !a.isTokenNumber(b)) return !1;
    const C = normalize_Color_ChannelValues(l[0].value, 2, h);
    if (!C || !a.isTokenNumber(C)) return !1;
    const d = [
        y,
        b,
        C
    ];
    if (1 === u.length) if (h.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(u[0])) {
        const e = normalize_Color_ChannelValues(u[0].value, 3, h);
        if (!e || !a.isTokenNumber(e)) return !1;
        d.push(e);
    } else h.alpha = u[0];
    else if (c && c.has("alpha")) {
        const e = normalize_Color_ChannelValues(c.get("alpha"), 3, h);
        if (!e || !a.isTokenNumber(e)) return !1;
        d.push(e);
    }
    return h.channels = [
        d[0][4].value,
        d[1][4].value,
        d[2][4].value
    ], 4 === d.length && (h.alpha = d[3][4].value), h;
}
function colorSpaceNameToColorNotation(e) {
    switch(e){
        case "srgb":
            return exports.ColorNotation.sRGB;
        case "srgb-linear":
            return exports.ColorNotation.Linear_sRGB;
        case "display-p3":
            return exports.ColorNotation.Display_P3;
        case "a98-rgb":
            return exports.ColorNotation.A98_RGB;
        case "prophoto-rgb":
            return exports.ColorNotation.ProPhoto_RGB;
        case "rec2020":
            return exports.ColorNotation.Rec2020;
        case "xyz":
        case "xyz-d65":
            return exports.ColorNotation.XYZ_D65;
        case "xyz-d50":
            return exports.ColorNotation.XYZ_D50;
        default:
            throw new Error("Unknown color space name: " + e);
    }
}
const u = new Set([
    "srgb",
    "srgb-linear",
    "display-p3",
    "a98-rgb",
    "prophoto-rgb",
    "rec2020",
    "lab",
    "oklab",
    "xyz",
    "xyz-d50",
    "xyz-d65"
]), c = new Set([
    "hsl",
    "hwb",
    "lch",
    "oklch"
]), p = new Set([
    "shorter",
    "longer",
    "increasing",
    "decreasing"
]);
function colorMix(e, o) {
    let n = null, r = null, s = null, l = !1;
    for(let i = 0; i < e.value.length; i++){
        const N = e.value[i];
        if (!t.isWhiteSpaceOrCommentNode(N)) {
            if (t.isTokenNode(N) && a.isTokenIdent(N.value)) {
                if (!n && "in" === toLowerCaseAZ(N.value[4].value)) {
                    n = N;
                    continue;
                }
                if (n && !r) {
                    r = toLowerCaseAZ(N.value[4].value);
                    continue;
                }
                if (n && r && !s && c.has(r)) {
                    s = toLowerCaseAZ(N.value[4].value);
                    continue;
                }
                if (n && r && s && !l && "hue" === toLowerCaseAZ(N.value[4].value)) {
                    l = !0;
                    continue;
                }
                return !1;
            }
            return !(!t.isTokenNode(N) || !a.isTokenComma(N.value)) && !!r && (s || l ? !!(r && s && l && c.has(r) && p.has(s)) && colorMixPolar(r, s, colorMixComponents(e.value.slice(i + 1), o)) : u.has(r) ? colorMixRectangular(r, colorMixComponents(e.value.slice(i + 1), o)) : !!c.has(r) && colorMixPolar(r, "shorter", colorMixComponents(e.value.slice(i + 1), o)));
        }
    }
    return !1;
}
function colorMixComponents(e, o) {
    const n = [];
    let s = 1, l = !1, i = !1;
    for(let s = 0; s < e.length; s++){
        let u = e[s];
        if (!t.isWhiteSpaceOrCommentNode(u)) {
            if (!t.isTokenNode(u) || !a.isTokenComma(u.value)) {
                if (!l) {
                    const e = o(u);
                    if (e) {
                        l = e;
                        continue;
                    }
                }
                if (!i) {
                    if (t.isFunctionNode(u) && r.mathFunctionNames.has(toLowerCaseAZ(u.getName()))) {
                        if ([[u]] = r.calcFromComponentValues([
                            [
                                u
                            ]
                        ], {
                            censorIntoStandardRepresentableValues: !0,
                            precision: -1,
                            toCanonicalUnits: !0,
                            rawPercentages: !0
                        }), !u || !t.isTokenNode(u) || !a.isTokenNumeric(u.value)) return !1;
                        Number.isNaN(u.value[4].value) && (u.value[4].value = 0);
                    }
                    if (t.isTokenNode(u) && a.isTokenPercentage(u.value) && u.value[4].value >= 0) {
                        i = u.value[4].value;
                        continue;
                    }
                }
                return !1;
            }
            if (!l) return !1;
            n.push({
                color: l,
                percentage: i
            }), l = !1, i = !1;
        }
    }
    l && n.push({
        color: l,
        percentage: i
    });
    let u = 0, c = 0;
    for(let e = 0; e < n.length; e++){
        const o = n[e].percentage;
        if (!1 !== o) {
            if (o < 0 || o > 100) return !1;
            u += o;
        } else c++;
    }
    const p = Math.max(0, 100 - u);
    u = 0;
    for(let e = 0; e < n.length; e++)!1 === n[e].percentage && (n[e].percentage = p / c), u += n[e].percentage;
    if (0 === u) return {
        colors: [
            {
                color: {
                    channels: [
                        0,
                        0,
                        0
                    ],
                    colorNotation: exports.ColorNotation.sRGB,
                    alpha: 0,
                    syntaxFlags: new Set
                },
                percentage: 0
            }
        ],
        alphaMultiplier: 0
    };
    if (u > 100) for(let e = 0; e < n.length; e++){
        let o = n[e].percentage;
        o = o / u * 100, n[e].percentage = o;
    }
    if (u < 100) {
        s = u / 100;
        for(let e = 0; e < n.length; e++){
            let o = n[e].percentage;
            o = o / u * 100, n[e].percentage = o;
        }
    }
    return {
        colors: n,
        alphaMultiplier: s
    };
}
function colorMixRectangular(e, o) {
    if (!o || !o.colors.length) return !1;
    const a = o.colors.slice();
    a.reverse();
    let n = exports.ColorNotation.RGB;
    switch(e){
        case "srgb":
            n = exports.ColorNotation.RGB;
            break;
        case "srgb-linear":
            n = exports.ColorNotation.Linear_sRGB;
            break;
        case "display-p3":
            n = exports.ColorNotation.Display_P3;
            break;
        case "a98-rgb":
            n = exports.ColorNotation.A98_RGB;
            break;
        case "prophoto-rgb":
            n = exports.ColorNotation.ProPhoto_RGB;
            break;
        case "rec2020":
            n = exports.ColorNotation.Rec2020;
            break;
        case "lab":
            n = exports.ColorNotation.Lab;
            break;
        case "oklab":
            n = exports.ColorNotation.OKLab;
            break;
        case "xyz-d50":
            n = exports.ColorNotation.XYZ_D50;
            break;
        case "xyz":
        case "xyz-d65":
            n = exports.ColorNotation.XYZ_D65;
            break;
        default:
            return !1;
    }
    if (1 === a.length) {
        const e = colorDataTo(a[0].color, n);
        return e.colorNotation = n, e.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), "number" != typeof e.alpha ? !1 : (e.alpha = e.alpha * o.alphaMultiplier, e);
    }
    for(; a.length >= 2;){
        const e = a.pop(), o = a.pop();
        if (!e || !o) return !1;
        const t = colorMixRectangularPair(n, e.color, e.percentage, o.color, o.percentage);
        if (!t) return !1;
        a.push({
            color: t,
            percentage: e.percentage + o.percentage
        });
    }
    const t = a[0]?.color;
    return !!t && (o.colors.some((e)=>e.color.syntaxFlags.has(exports.SyntaxFlag.Experimental)) && t.syntaxFlags.add(exports.SyntaxFlag.Experimental), "number" == typeof t.alpha && (t.alpha = t.alpha * o.alphaMultiplier, 2 !== o.colors.length && t.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), t));
}
function colorMixRectangularPair(e, o, a, n, t) {
    const r = a / (a + t);
    let s = o.alpha;
    if ("number" != typeof s) return !1;
    let l = n.alpha;
    if ("number" != typeof l) return !1;
    s = Number.isNaN(s) ? l : s, l = Number.isNaN(l) ? s : l;
    const i = colorDataTo(o, e).channels, u = colorDataTo(n, e).channels;
    i[0] = fillInMissingComponent(i[0], u[0]), u[0] = fillInMissingComponent(u[0], i[0]), i[1] = fillInMissingComponent(i[1], u[1]), u[1] = fillInMissingComponent(u[1], i[1]), i[2] = fillInMissingComponent(i[2], u[2]), u[2] = fillInMissingComponent(u[2], i[2]), i[0] = premultiply(i[0], s), i[1] = premultiply(i[1], s), i[2] = premultiply(i[2], s), u[0] = premultiply(u[0], l), u[1] = premultiply(u[1], l), u[2] = premultiply(u[2], l);
    const c = interpolate(s, l, r);
    return {
        colorNotation: e,
        channels: [
            un_premultiply(interpolate(i[0], u[0], r), c),
            un_premultiply(interpolate(i[1], u[1], r), c),
            un_premultiply(interpolate(i[2], u[2], r), c)
        ],
        alpha: c,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorMix
        ])
    };
}
function colorMixPolar(e, o, a) {
    if (!a || !a.colors.length) return !1;
    const n = a.colors.slice();
    n.reverse();
    let t = exports.ColorNotation.HSL;
    switch(e){
        case "hsl":
            t = exports.ColorNotation.HSL;
            break;
        case "hwb":
            t = exports.ColorNotation.HWB;
            break;
        case "lch":
            t = exports.ColorNotation.LCH;
            break;
        case "oklch":
            t = exports.ColorNotation.OKLCH;
            break;
        default:
            return !1;
    }
    if (1 === n.length) {
        const e = colorDataTo(n[0].color, t);
        return e.colorNotation = t, e.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), "number" != typeof e.alpha ? !1 : (e.alpha = e.alpha * a.alphaMultiplier, e);
    }
    for(; n.length >= 2;){
        const e = n.pop(), a = n.pop();
        if (!e || !a) return !1;
        const r = colorMixPolarPair(t, o, e.color, e.percentage, a.color, a.percentage);
        if (!r) return !1;
        n.push({
            color: r,
            percentage: e.percentage + a.percentage
        });
    }
    const r = n[0]?.color;
    return !!r && (a.colors.some((e)=>e.color.syntaxFlags.has(exports.SyntaxFlag.Experimental)) && r.syntaxFlags.add(exports.SyntaxFlag.Experimental), "number" == typeof r.alpha && (r.alpha = r.alpha * a.alphaMultiplier, 2 !== a.colors.length && r.syntaxFlags.add(exports.SyntaxFlag.ColorMixVariadic), r));
}
function colorMixPolarPair(e, o, a, n, t, r) {
    const s = n / (n + r);
    let l = 0, i = 0, u = 0, c = 0, p = 0, N = 0, m = a.alpha;
    if ("number" != typeof m) return !1;
    let h = t.alpha;
    if ("number" != typeof h) return !1;
    m = Number.isNaN(m) ? h : m, h = Number.isNaN(h) ? m : h;
    const x = colorDataTo(a, e).channels, y = colorDataTo(t, e).channels;
    switch(e){
        case exports.ColorNotation.HSL:
        case exports.ColorNotation.HWB:
            l = x[0], i = y[0], u = x[1], c = y[1], p = x[2], N = y[2];
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            u = x[0], c = y[0], p = x[1], N = y[1], l = x[2], i = y[2];
    }
    l = fillInMissingComponent(l, i), Number.isNaN(l) && (l = 0), i = fillInMissingComponent(i, l), Number.isNaN(i) && (i = 0), u = fillInMissingComponent(u, c), c = fillInMissingComponent(c, u), p = fillInMissingComponent(p, N), N = fillInMissingComponent(N, p);
    const b = i - l;
    switch(o){
        case "shorter":
            b > 180 ? l += 360 : b < -180 && (i += 360);
            break;
        case "longer":
            -180 < b && b < 180 && (b > 0 ? l += 360 : i += 360);
            break;
        case "increasing":
            b < 0 && (i += 360);
            break;
        case "decreasing":
            b > 0 && (l += 360);
            break;
        default:
            throw new Error("Unknown hue interpolation method");
    }
    u = premultiply(u, m), p = premultiply(p, m), c = premultiply(c, h), N = premultiply(N, h);
    let C = [
        0,
        0,
        0
    ];
    const d = interpolate(m, h, s);
    switch(e){
        case exports.ColorNotation.HSL:
        case exports.ColorNotation.HWB:
            C = [
                interpolate(l, i, s),
                un_premultiply(interpolate(u, c, s), d),
                un_premultiply(interpolate(p, N, s), d)
            ];
            break;
        case exports.ColorNotation.LCH:
        case exports.ColorNotation.OKLCH:
            C = [
                un_premultiply(interpolate(u, c, s), d),
                un_premultiply(interpolate(p, N, s), d),
                interpolate(l, i, s)
            ];
    }
    return {
        colorNotation: e,
        channels: C,
        alpha: d,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorMix
        ])
    };
}
function fillInMissingComponent(e, o) {
    return Number.isNaN(e) ? o : e;
}
function interpolate(e, o, a) {
    return e * a + o * (1 - a);
}
function premultiply(e, o) {
    return Number.isNaN(o) ? e : Number.isNaN(e) ? Number.NaN : e * o;
}
function un_premultiply(e, o) {
    return 0 === o || Number.isNaN(o) ? e : Number.isNaN(e) ? Number.NaN : e / o;
}
function hex(e) {
    const o = toLowerCaseAZ(e[4].value);
    if (o.match(/[^a-f0-9]/)) return !1;
    const a = {
        colorNotation: exports.ColorNotation.HEX,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.Hex
        ])
    }, n = o.length;
    if (3 === n) {
        const e = o[0], n = o[1], t = o[2];
        return a.channels = [
            parseInt(e + e, 16) / 255,
            parseInt(n + n, 16) / 255,
            parseInt(t + t, 16) / 255
        ], a;
    }
    if (6 === n) {
        const e = o[0] + o[1], n = o[2] + o[3], t = o[4] + o[5];
        return a.channels = [
            parseInt(e, 16) / 255,
            parseInt(n, 16) / 255,
            parseInt(t, 16) / 255
        ], a;
    }
    if (4 === n) {
        const e = o[0], n = o[1], t = o[2], r = o[3];
        return a.channels = [
            parseInt(e + e, 16) / 255,
            parseInt(n + n, 16) / 255,
            parseInt(t + t, 16) / 255
        ], a.alpha = parseInt(r + r, 16) / 255, a.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), a;
    }
    if (8 === n) {
        const e = o[0] + o[1], n = o[2] + o[3], t = o[4] + o[5], r = o[6] + o[7];
        return a.channels = [
            parseInt(e, 16) / 255,
            parseInt(n, 16) / 255,
            parseInt(t, 16) / 255
        ], a.alpha = parseInt(r, 16) / 255, a.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), a;
    }
    return !1;
}
function normalizeHue(e) {
    if (a.isTokenNumber(e)) return e[4].value = e[4].value % 360, e[1] = e[4].value.toString(), e;
    if (a.isTokenDimension(e)) {
        let o = e[4].value;
        switch(toLowerCaseAZ(e[4].unit)){
            case "deg":
                break;
            case "rad":
                o = 180 * e[4].value / Math.PI;
                break;
            case "grad":
                o = .9 * e[4].value;
                break;
            case "turn":
                o = 360 * e[4].value;
                break;
            default:
                return !1;
        }
        return o %= 360, [
            a.TokenType.Number,
            o.toString(),
            e[2],
            e[3],
            {
                value: o,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_legacy_HSL_ChannelValues(e, o, n) {
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        if (3 !== o) return !1;
        let n = normalize(e[4].value, 1, 0, 100);
        return 3 === o && (n = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            n.toString(),
            e[2],
            e[3],
            {
                value: n,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_modern_HSL_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = e[4].value;
        return 3 === o ? t = normalize(e[4].value, 100, 0, 1) : 1 === o && (t = normalize(e[4].value, 1, 0, 2147483647)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = e[4].value;
        return 3 === o ? t = normalize(e[4].value, 1, 0, 1) : 1 === o && (t = normalize(e[4].value, 1, 0, 2147483647)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function threeChannelLegacySyntax(e, o, n, s) {
    const l = [], i = [], u = [], c = [], p = {
        colorNotation: n,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set(s)
    };
    let N = l;
    for(let o = 0; o < e.value.length; o++){
        let n = e.value[o];
        if (!t.isWhitespaceNode(n) && !t.isCommentNode(n)) {
            if (t.isTokenNode(n) && a.isTokenComma(n.value)) {
                if (N === l) {
                    N = i;
                    continue;
                }
                if (N === i) {
                    N = u;
                    continue;
                }
                if (N === u) {
                    N = c;
                    continue;
                }
                if (N === c) return !1;
            }
            if (t.isFunctionNode(n)) {
                if (N === c && "var" === n.getName().toLowerCase()) {
                    p.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), N.push(n);
                    continue;
                }
                if (!r.mathFunctionNames.has(n.getName().toLowerCase())) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        n
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), n = e;
            }
            if (!t.isTokenNode(n)) return !1;
            N.push(n);
        }
    }
    if (1 !== N.length) return !1;
    if (1 !== l.length || 1 !== i.length || 1 !== u.length) return !1;
    if (!t.isTokenNode(l[0]) || !t.isTokenNode(i[0]) || !t.isTokenNode(u[0])) return !1;
    const m = o(l[0].value, 0, p);
    if (!m || !a.isTokenNumber(m)) return !1;
    const h = o(i[0].value, 1, p);
    if (!h || !a.isTokenNumber(h)) return !1;
    const x = o(u[0].value, 2, p);
    if (!x || !a.isTokenNumber(x)) return !1;
    const y = [
        m,
        h,
        x
    ];
    if (1 === c.length) if (p.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(c[0])) {
        const e = o(c[0].value, 3, p);
        if (!e || !a.isTokenNumber(e)) return !1;
        y.push(e);
    } else p.alpha = c[0];
    return p.channels = [
        y[0][4].value,
        y[1][4].value,
        y[2][4].value
    ], 4 === y.length && (p.alpha = y[3][4].value), p;
}
function threeChannelSpaceSeparated(e, o, n, s, l) {
    const i = [], u = [], c = [], p = [];
    let N, m, h = !1;
    const x = {
        colorNotation: n,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set(s)
    };
    let y = i;
    for(let o = 0; o < e.value.length; o++){
        let s = e.value[o];
        if (t.isWhitespaceNode(s) || t.isCommentNode(s)) for(; t.isWhitespaceNode(e.value[o + 1]) || t.isCommentNode(e.value[o + 1]);)o++;
        else if (y === i && i.length && (y = u), y === u && u.length && (y = c), t.isTokenNode(s) && a.isTokenDelim(s.value) && "/" === s.value[4].value) {
            if (y === p) return !1;
            y = p;
        } else {
            if (t.isFunctionNode(s)) {
                if (y === p && "var" === s.getName().toLowerCase()) {
                    x.syntaxFlags.add(exports.SyntaxFlag.HasVariableAlpha), y.push(s);
                    continue;
                }
                if (!r.mathFunctionNames.has(s.getName().toLowerCase())) return !1;
                const [[e]] = r.calcFromComponentValues([
                    [
                        s
                    ]
                ], {
                    censorIntoStandardRepresentableValues: !0,
                    globals: m,
                    precision: -1,
                    toCanonicalUnits: !0,
                    rawPercentages: !0
                });
                if (!e || !t.isTokenNode(e) || !a.isTokenNumeric(e.value)) return !1;
                Number.isNaN(e.value[4].value) && (e.value[4].value = 0), s = e;
            }
            if (y === i && 0 === i.length && t.isTokenNode(s) && a.isTokenIdent(s.value) && "from" === s.value[4].value.toLowerCase()) {
                if (h) return !1;
                for(; t.isWhitespaceNode(e.value[o + 1]) || t.isCommentNode(e.value[o + 1]);)o++;
                if (o++, s = e.value[o], h = l(s), !1 === h) return !1;
                h.syntaxFlags.has(exports.SyntaxFlag.Experimental) && x.syntaxFlags.add(exports.SyntaxFlag.Experimental), x.syntaxFlags.add(exports.SyntaxFlag.RelativeColorSyntax), h.colorNotation !== n && (h = colorDataTo(h, n)), N = normalizeRelativeColorDataChannels(h), m = noneToZeroInRelativeColorDataChannels(N);
            } else {
                if (!t.isTokenNode(s)) return !1;
                if (a.isTokenIdent(s.value) && N) {
                    const e = s.value[4].value.toLowerCase();
                    if (N.has(e)) {
                        y.push(new t.TokenNode(N.get(e)));
                        continue;
                    }
                }
                y.push(s);
            }
        }
    }
    if (1 !== y.length) return !1;
    if (1 !== i.length || 1 !== u.length || 1 !== c.length) return !1;
    if (!t.isTokenNode(i[0]) || !t.isTokenNode(u[0]) || !t.isTokenNode(c[0])) return !1;
    if (N && !N.has("alpha")) return !1;
    const b = o(i[0].value, 0, x);
    if (!b || !a.isTokenNumber(b)) return !1;
    const C = o(u[0].value, 1, x);
    if (!C || !a.isTokenNumber(C)) return !1;
    const d = o(c[0].value, 2, x);
    if (!d || !a.isTokenNumber(d)) return !1;
    const g = [
        b,
        C,
        d
    ];
    if (1 === p.length) if (x.syntaxFlags.add(exports.SyntaxFlag.HasAlpha), t.isTokenNode(p[0])) {
        const e = o(p[0].value, 3, x);
        if (!e || !a.isTokenNumber(e)) return !1;
        g.push(e);
    } else x.alpha = p[0];
    else if (N && N.has("alpha")) {
        const e = o(N.get("alpha"), 3, x);
        if (!e || !a.isTokenNumber(e)) return !1;
        g.push(e);
    }
    return x.channels = [
        g[0][4].value,
        g[1][4].value,
        g[2][4].value
    ], 4 === g.length && (x.alpha = g[3][4].value), x;
}
function hsl(e, o) {
    if (e.value.some((e)=>t.isTokenNode(e) && a.isTokenComma(e.value))) {
        const o = hslCommaSeparated(e);
        if (!1 !== o) return o;
    }
    {
        const a = hslSpaceSeparated(e, o);
        if (!1 !== a) return a;
    }
    return !1;
}
function hslCommaSeparated(e) {
    return threeChannelLegacySyntax(e, normalize_legacy_HSL_ChannelValues, exports.ColorNotation.HSL, [
        exports.SyntaxFlag.LegacyHSL
    ]);
}
function hslSpaceSeparated(e, o) {
    return threeChannelSpaceSeparated(e, normalize_modern_HSL_ChannelValues, exports.ColorNotation.HSL, [], o);
}
function normalize_HWB_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (0 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = e[4].value;
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = e[4].value;
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_Lab_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o || 2 === o ? t = normalize(e[4].value, .8, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 1, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function lab(e, o) {
    return threeChannelSpaceSeparated(e, normalize_Lab_ChannelValues, exports.ColorNotation.Lab, [], o);
}
function normalize_LCH_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (2 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o ? t = normalize(e[4].value, 100 / 150, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 100);
        return 1 === o ? t = normalize(e[4].value, 1, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function lch(e, o) {
    return threeChannelSpaceSeparated(e, normalize_LCH_ChannelValues, exports.ColorNotation.LCH, [], o);
}
const N = new Map;
for (const [e, o] of Object.entries(n.namedColors))N.set(e, o);
function namedColor(e) {
    const o = N.get(toLowerCaseAZ(e));
    return !!o && {
        colorNotation: exports.ColorNotation.RGB,
        channels: [
            o[0] / 255,
            o[1] / 255,
            o[2] / 255
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ColorKeyword,
            exports.SyntaxFlag.NamedColor
        ])
    };
}
function normalize_OKLab_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, 0, 1);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 250, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 1);
        return 1 === o || 2 === o ? t = normalize(e[4].value, 1, -2147483647, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function oklab(e, o) {
    return threeChannelSpaceSeparated(e, normalize_OKLab_ChannelValues, exports.ColorNotation.OKLab, [], o);
}
function normalize_OKLCH_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === toLowerCaseAZ(e[4].value)) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (2 === o) {
        const o = normalizeHue(e);
        return !1 !== o && (a.isTokenDimension(e) && n.syntaxFlags.add(exports.SyntaxFlag.HasDimensionValues), o);
    }
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, 0, 1);
        return 1 === o ? t = normalize(e[4].value, 250, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 1, 0, 1);
        return 1 === o ? t = normalize(e[4].value, 1, 0, 2147483647) : 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function oklch(e, o) {
    return threeChannelSpaceSeparated(e, normalize_OKLCH_ChannelValues, exports.ColorNotation.OKLCH, [], o);
}
function normalize_legacy_sRGB_ChannelValues(e, o, n) {
    if (a.isTokenPercentage(e)) {
        3 === o ? n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageAlpha) : n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        const t = normalize(e[4].value, 100, 0, 1);
        return [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 255, 0, 1);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function normalize_modern_sRGB_ChannelValues(e, o, n) {
    if (a.isTokenIdent(e) && "none" === e[4].value.toLowerCase()) return n.syntaxFlags.add(exports.SyntaxFlag.HasNoneKeywords), [
        a.TokenType.Number,
        "none",
        e[2],
        e[3],
        {
            value: Number.NaN,
            type: a.NumberType.Number
        }
    ];
    if (a.isTokenPercentage(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasPercentageValues);
        let t = normalize(e[4].value, 100, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 100, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    if (a.isTokenNumber(e)) {
        3 !== o && n.syntaxFlags.add(exports.SyntaxFlag.HasNumberValues);
        let t = normalize(e[4].value, 255, -2147483647, 2147483647);
        return 3 === o && (t = normalize(e[4].value, 1, 0, 1)), [
            a.TokenType.Number,
            t.toString(),
            e[2],
            e[3],
            {
                value: t,
                type: a.NumberType.Number
            }
        ];
    }
    return !1;
}
function rgb(e, o) {
    if (e.value.some((e)=>t.isTokenNode(e) && a.isTokenComma(e.value))) {
        const o = rgbCommaSeparated(e);
        if (!1 !== o) return (!o.syntaxFlags.has(exports.SyntaxFlag.HasNumberValues) || !o.syntaxFlags.has(exports.SyntaxFlag.HasPercentageValues)) && o;
    } else {
        const a = rgbSpaceSeparated(e, o);
        if (!1 !== a) return a;
    }
    return !1;
}
function rgbCommaSeparated(e) {
    return threeChannelLegacySyntax(e, normalize_legacy_sRGB_ChannelValues, exports.ColorNotation.RGB, [
        exports.SyntaxFlag.LegacyRGB
    ]);
}
function rgbSpaceSeparated(e, o) {
    return threeChannelSpaceSeparated(e, normalize_modern_sRGB_ChannelValues, exports.ColorNotation.RGB, [], o);
}
function XYZ_D50_to_sRGB_Gamut(e) {
    const o = n.XYZ_D50_to_sRGB(e);
    if (n.inGamut(o)) return n.clip(o);
    let a = e;
    return a = n.XYZ_D50_to_OKLCH(a), a[0] < 1e-6 && (a = [
        0,
        0,
        0
    ]), a[0] > .999999 && (a = [
        1,
        0,
        0
    ]), n.gam_sRGB(n.mapGamutRayTrace(a, oklch_to_lin_srgb, lin_srgb_to_oklch));
}
function oklch_to_lin_srgb(e) {
    return e = n.OKLCH_to_OKLab(e), e = n.OKLab_to_XYZ(e), n.XYZ_to_lin_sRGB(e);
}
function lin_srgb_to_oklch(e) {
    return e = n.lin_sRGB_to_XYZ(e), e = n.XYZ_to_OKLab(e), n.OKLab_to_OKLCH(e);
}
function contrastColor(e, o) {
    let a = !1;
    for(let n = 0; n < e.value.length; n++){
        const r = e.value[n];
        if (!t.isWhitespaceNode(r) && !t.isCommentNode(r) && (a || (a = o(r), !a))) return !1;
    }
    if (!a) return !1;
    a.channels = convertNaNToZero(a.channels), a.channels = XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(a).channels), a.colorNotation = exports.ColorNotation.sRGB;
    const r = {
        colorNotation: exports.ColorNotation.sRGB,
        channels: [
            0,
            0,
            0
        ],
        alpha: 1,
        syntaxFlags: new Set([
            exports.SyntaxFlag.ContrastColor,
            exports.SyntaxFlag.Experimental
        ])
    }, s = n.contrast_ratio_wcag_2_1(a.channels, [
        1,
        1,
        1
    ]), l = n.contrast_ratio_wcag_2_1(a.channels, [
        0,
        0,
        0
    ]);
    return r.channels = s > l ? [
        1,
        1,
        1
    ] : [
        0,
        0,
        0
    ], r;
}
function XYZ_D50_to_P3_Gamut(e) {
    const o = n.XYZ_D50_to_P3(e);
    if (n.inGamut(o)) return n.clip(o);
    let a = e;
    return a = n.XYZ_D50_to_OKLCH(a), a[0] < 1e-6 && (a = [
        0,
        0,
        0
    ]), a[0] > .999999 && (a = [
        1,
        0,
        0
    ]), n.gam_P3(n.mapGamutRayTrace(a, oklch_to_lin_p3, lin_p3_to_oklch));
}
function oklch_to_lin_p3(e) {
    return e = n.OKLCH_to_OKLab(e), e = n.OKLab_to_XYZ(e), n.XYZ_to_lin_P3(e);
}
function lin_p3_to_oklch(e) {
    return e = n.lin_P3_to_XYZ(e), e = n.XYZ_to_OKLab(e), n.OKLab_to_OKLCH(e);
}
function toPrecision(e, o = 7) {
    e = +e, o = +o;
    const a = (Math.floor(Math.abs(e)) + "").length;
    if (o > a) return +e.toFixed(o - a);
    {
        const n = 10 ** (a - o);
        return Math.round(e / n) * n;
    }
}
function serializeWithAlpha(e, o, n, r) {
    const s = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ];
    if ("number" == typeof e.alpha) {
        const l = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(l, 4) ? new t.FunctionNode(o, s, r) : new t.FunctionNode(o, s, [
            ...r,
            new t.WhitespaceNode([
                n
            ]),
            new t.TokenNode([
                a.TokenType.Delim,
                "/",
                -1,
                -1,
                {
                    value: "/"
                }
            ]),
            new t.WhitespaceNode([
                n
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(l, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Integer
                }
            ])
        ]);
    }
    return new t.FunctionNode(o, s, [
        ...r,
        new t.WhitespaceNode([
            n
        ]),
        new t.TokenNode([
            a.TokenType.Delim,
            "/",
            -1,
            -1,
            {
                value: "/"
            }
        ]),
        new t.WhitespaceNode([
            n
        ]),
        e.alpha
    ]);
}
exports.color = function color(e) {
    if (t.isFunctionNode(e)) {
        switch(toLowerCaseAZ(e.getName())){
            case "rgb":
            case "rgba":
                return rgb(e, color);
            case "hsl":
            case "hsla":
                return hsl(e, color);
            case "hwb":
                return o = color, threeChannelSpaceSeparated(e, normalize_HWB_ChannelValues, exports.ColorNotation.HWB, [], o);
            case "lab":
                return lab(e, color);
            case "lch":
                return lch(e, color);
            case "oklab":
                return oklab(e, color);
            case "oklch":
                return oklch(e, color);
            case "color":
                return color$1(e, color);
            case "color-mix":
                return colorMix(e, color);
            case "contrast-color":
                return contrastColor(e, color);
        }
    }
    var o;
    if (t.isTokenNode(e)) {
        if (a.isTokenHash(e.value)) return hex(e.value);
        if (a.isTokenIdent(e.value)) {
            const o = namedColor(e.value[4].value);
            return !1 !== o ? o : "transparent" === toLowerCaseAZ(e.value[4].value) && {
                colorNotation: exports.ColorNotation.RGB,
                channels: [
                    0,
                    0,
                    0
                ],
                alpha: 0,
                syntaxFlags: new Set([
                    exports.SyntaxFlag.ColorKeyword
                ])
            };
        }
    }
    return !1;
}, exports.colorDataFitsDisplayP3_Gamut = function colorDataFitsDisplayP3_Gamut(e) {
    const o = {
        ...e,
        channels: [
            ...e.channels
        ]
    };
    return o.channels = convertPowerlessComponentsToZeroValuesForDisplay(o.channels, o.colorNotation), !colorDataTo(o, exports.ColorNotation.Display_P3).channels.find((e)=>e < -1e-5 || e > 1.00001);
}, exports.colorDataFitsRGB_Gamut = function colorDataFitsRGB_Gamut(e) {
    const o = {
        ...e,
        channels: [
            ...e.channels
        ]
    };
    return o.channels = convertPowerlessComponentsToZeroValuesForDisplay(o.channels, o.colorNotation), !colorDataTo(o, exports.ColorNotation.RGB).channels.find((e)=>e < -1e-5 || e > 1.00001);
}, exports.serializeHSL = function serializeHSL(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    r = o ? n.XYZ_D50_to_HSL(n.sRGB_to_XYZ_D50(XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(e).channels))) : n.XYZ_D50_to_HSL(colorData_to_XYZ_D50(e).channels), r = r.map((e)=>Number.isNaN(e) ? 0 : e);
    const s = Math.min(360, Math.max(0, Math.round(toPrecision(r[0])))), l = Math.min(100, Math.max(0, Math.round(toPrecision(r[1])))), i = Math.min(100, Math.max(0, Math.round(toPrecision(r[2])))), u = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ], p = [
        a.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ], N = [
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: r[0],
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Percentage,
            l.toString() + "%",
            -1,
            -1,
            {
                value: r[1]
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Percentage,
            i.toString() + "%",
            -1,
            -1,
            {
                value: r[2]
            }
        ])
    ];
    if ("number" == typeof e.alpha) {
        const o = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(o, 4) ? new t.FunctionNode([
            a.TokenType.Function,
            "hsl(",
            -1,
            -1,
            {
                value: "hsl"
            }
        ], u, N) : new t.FunctionNode([
            a.TokenType.Function,
            "hsla(",
            -1,
            -1,
            {
                value: "hsla"
            }
        ], u, [
            ...N,
            new t.TokenNode(p),
            new t.WhitespaceNode([
                c
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(o, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Number
                }
            ])
        ]);
    }
    return new t.FunctionNode([
        a.TokenType.Function,
        "hsla(",
        -1,
        -1,
        {
            value: "hsla"
        }
    ], u, [
        ...N,
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        e.alpha
    ]);
}, exports.serializeOKLCH = function serializeOKLCH(e) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let o = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    e.colorNotation !== exports.ColorNotation.OKLCH && (o = n.XYZ_D50_to_OKLCH(colorData_to_XYZ_D50(e).channels));
    const r = toPrecision(o[0], 6), s = toPrecision(o[1], 6), l = toPrecision(o[2], 6), i = [
        a.TokenType.Function,
        "oklch(",
        -1,
        -1,
        {
            value: "oklch"
        }
    ], u = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ];
    return serializeWithAlpha(e, i, u, [
        new t.TokenNode([
            a.TokenType.Number,
            r.toString(),
            -1,
            -1,
            {
                value: o[0],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            u
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: o[1],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            u
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: o[2],
                type: a.NumberType.Number
            }
        ])
    ]);
}, exports.serializeP3 = function serializeP3(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    o ? r = XYZ_D50_to_P3_Gamut(colorData_to_XYZ_D50(e).channels) : e.colorNotation !== exports.ColorNotation.Display_P3 && (r = n.XYZ_D50_to_P3(colorData_to_XYZ_D50(e).channels));
    const s = o ? Math.min(1, Math.max(0, toPrecision(r[0], 6))) : toPrecision(r[0], 6), l = o ? Math.min(1, Math.max(0, toPrecision(r[1], 6))) : toPrecision(r[1], 6), i = o ? Math.min(1, Math.max(0, toPrecision(r[2], 6))) : toPrecision(r[2], 6), u = [
        a.TokenType.Function,
        "color(",
        -1,
        -1,
        {
            value: "color"
        }
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ];
    return serializeWithAlpha(e, u, c, [
        new t.TokenNode([
            a.TokenType.Ident,
            "display-p3",
            -1,
            -1,
            {
                value: "display-p3"
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: r[0],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: r[1],
                type: a.NumberType.Number
            }
        ]),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            i.toString(),
            -1,
            -1,
            {
                value: r[2],
                type: a.NumberType.Number
            }
        ])
    ]);
}, exports.serializeRGB = function serializeRGB(e, o = !0) {
    e.channels = convertPowerlessComponentsToZeroValuesForDisplay(e.channels, e.colorNotation);
    let r = e.channels.map((e)=>Number.isNaN(e) ? 0 : e);
    r = o ? XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(e).channels) : n.XYZ_D50_to_sRGB(colorData_to_XYZ_D50(e).channels);
    const s = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[0])))), l = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[1])))), i = Math.min(255, Math.max(0, Math.round(255 * toPrecision(r[2])))), u = [
        a.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], c = [
        a.TokenType.Whitespace,
        " ",
        -1,
        -1,
        void 0
    ], p = [
        a.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ], N = [
        new t.TokenNode([
            a.TokenType.Number,
            s.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[0])),
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            l.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[1])),
                type: a.NumberType.Integer
            }
        ]),
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        new t.TokenNode([
            a.TokenType.Number,
            i.toString(),
            -1,
            -1,
            {
                value: Math.min(255, 255 * Math.max(0, r[2])),
                type: a.NumberType.Integer
            }
        ])
    ];
    if ("number" == typeof e.alpha) {
        const o = Math.min(1, Math.max(0, toPrecision(Number.isNaN(e.alpha) ? 0 : e.alpha)));
        return 1 === toPrecision(o, 4) ? new t.FunctionNode([
            a.TokenType.Function,
            "rgb(",
            -1,
            -1,
            {
                value: "rgb"
            }
        ], u, N) : new t.FunctionNode([
            a.TokenType.Function,
            "rgba(",
            -1,
            -1,
            {
                value: "rgba"
            }
        ], u, [
            ...N,
            new t.TokenNode(p),
            new t.WhitespaceNode([
                c
            ]),
            new t.TokenNode([
                a.TokenType.Number,
                toPrecision(o, 4).toString(),
                -1,
                -1,
                {
                    value: e.alpha,
                    type: a.NumberType.Number
                }
            ])
        ]);
    }
    return new t.FunctionNode([
        a.TokenType.Function,
        "rgba(",
        -1,
        -1,
        {
            value: "rgba"
        }
    ], u, [
        ...N,
        new t.TokenNode(p),
        new t.WhitespaceNode([
            c
        ]),
        e.alpha
    ]);
};
}}),
"[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
exports.hasFallback = function hasFallback(t) {
    const e = t.parent;
    if (!e) return !1;
    const r = t.prop.toLowerCase(), s = e.index(t);
    for(let t = 0; t < s; t++){
        const s = e.nodes[t];
        if ("decl" === s.type && s.prop.toLowerCase() === r) return !0;
    }
    return !1;
}, exports.hasSupportsAtRuleAncestor = function hasSupportsAtRuleAncestor(t, e) {
    let r = t.parent;
    for(; r;)if ("atrule" === r.type && "supports" === r.name.toLowerCase()) {
        if (e.test(r.params)) return !0;
        r = r.parent;
    } else r = r.parent;
    return !1;
};
}}),
"[project]/node_modules/@csstools/postcss-color-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor\(/i, n = /^color$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-function",
        Declaration (i) {
            const c = i.value;
            if (!a.test(c)) return;
            if (r.hasFallback(i)) return;
            if (r.hasSupportsAtRuleAncestor(i, a)) return;
            const l = e.tokenize({
                css: c
            }), u = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(l), (s)=>{
                if (!t.isFunctionNode(s) || !n.test(s.getName())) return;
                const e = o.color(s);
                return e && !(e.syntaxFlags.has(o.SyntaxFlag.Experimental) || e.syntaxFlags.has(o.SyntaxFlag.HasNoneKeywords) || e.syntaxFlags.has(o.SyntaxFlag.RelativeColorSyntax)) ? o.serializeRGB(e) : void 0;
            }), p = t.stringify(u);
            p !== c && (i.cloneBefore({
                value: p
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const o = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return o.enableProgressiveCustomProperties && o.preserve ? {
        postcssPlugin: "postcss-color-function",
        plugins: [
            s(),
            basePlugin(o)
        ]
    } : basePlugin(o);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-color-functional-notation/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const r = /^(?:rgb|hsl)a?$/i, n = /\b(?:rgb|hsl)a?\(/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-functional-notation",
        Declaration (l) {
            const i = l.value;
            if (!n.test(i)) return;
            if (t.hasFallback(l)) return;
            if (t.hasSupportsAtRuleAncestor(l, n)) return;
            const c = o.replaceComponentValues(o.parseCommaSeparatedListOfComponentValues(a.tokenize({
                css: i
            })), (s)=>{
                if (!o.isFunctionNode(s) || !r.test(s.getName())) return;
                const t = e.color(s);
                return !t || t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) || (t.syntaxFlags.has(e.SyntaxFlag.LegacyRGB) || t.syntaxFlags.has(e.SyntaxFlag.LegacyHSL)) && !t.syntaxFlags.has(e.SyntaxFlag.HasPercentageAlpha) ? void 0 : t.colorNotation === e.ColorNotation.HSL ? e.serializeHSL(t) : e.serializeRGB(t);
            }), u = o.stringify(c);
            u !== i && (l.cloneBefore({
                value: u
            }), s?.preserve || l.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-color-functional-notation",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-color-mix-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor-mix\(/i, i = /^color-mix$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-color-mix-function",
        Declaration (n) {
            const l = n.value;
            if (!a.test(l)) return;
            if (r.hasFallback(n)) return;
            if (r.hasSupportsAtRuleAncestor(n, a)) return;
            const u = o.tokenize({
                css: l
            }), c = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return !r || r.syntaxFlags.has(e.SyntaxFlag.Experimental) || r.syntaxFlags.has(e.SyntaxFlag.ColorMixVariadic) ? void 0 : e.serializeRGB(r);
            }), p = t.stringify(c);
            if (p === l) return;
            let m = p;
            s?.subFeatures.displayP3 && (m = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) ? e.colorDataFitsRGB_Gamut(r) ? e.serializeRGB(r) : e.serializeP3(r) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && m !== p && n.cloneBefore({
                value: m
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return r.subFeatures = Object.assign({
        displayP3: !0
    }, r.subFeatures), r.enableProgressiveCustomProperties && (r.preserve || r.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-color-mix-function",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-color-mix-variadic-function-arguments/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bcolor-mix\(/i, i = /^color-mix$/i, basePlugin = (s)=>({
        postcssPlugin: "color-mix-variadic-function-arguments",
        Declaration (n) {
            const l = n.value;
            if (!a.test(l)) return;
            if (r.hasFallback(n)) return;
            if (r.hasSupportsAtRuleAncestor(n, a)) return;
            const u = o.tokenize({
                css: l
            }), c = t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) && r.syntaxFlags.has(e.SyntaxFlag.ColorMixVariadic) ? e.serializeRGB(r) : void 0;
            }), p = t.stringify(c);
            if (p === l) return;
            let m = p;
            s?.subFeatures.displayP3 && (m = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!t.isFunctionNode(s) || !i.test(s.getName())) return;
                const r = e.color(s);
                return r && !r.syntaxFlags.has(e.SyntaxFlag.Experimental) ? e.colorDataFitsRGB_Gamut(r) ? e.serializeRGB(r) : e.serializeP3(r) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && m !== p && n.cloneBefore({
                value: m
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return r.subFeatures = Object.assign({
        displayP3: !0
    }, r.subFeatures), r.enableProgressiveCustomProperties && (r.preserve || r.subFeatures.displayP3) ? {
        postcssPlugin: "color-mix-variadic-function-arguments",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-content-alt-text/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function transform(e, s) {
    const o = e[0];
    if (!o.length) return "";
    if (s) return t.stringify([
        o
    ]);
    const n = e[1].filter((e)=>!t.isWhiteSpaceOrCommentNode(e));
    return 1 === n.length && t.isTokenNode(n[0]) && r.isTokenString(n[0].value) && "" === n[0].value[4].value ? t.stringify([
        o
    ]) : t.stringify([
        [
            ...o,
            ...e[1]
        ]
    ]);
}
function parse(e) {
    const s = t.parseListOfComponentValues(r.tokenize({
        css: e
    })), o = [];
    let n = 0;
    for(let e = s.length - 1; e >= 0; e--){
        const i = s[e];
        if (!t.isTokenNode(i)) continue;
        const l = i.value;
        r.isTokenDelim(l) && "/" === l[4].value && (o.push(s.slice(n, e)), n = e + 1);
    }
    return 0 !== n && o.push(s.slice(n, s.length)), o;
}
const o = {
    test: (e)=>e.includes("content:") && e.includes("/")
}, basePlugin = (e)=>({
        postcssPlugin: "postcss-content-alt-text",
        Declaration (t) {
            if ("content" !== t.prop || !t.value.includes("/")) return;
            if (s.hasFallback(t)) return;
            if (s.hasSupportsAtRuleAncestor(t, o)) return;
            const r = parse(t.value);
            if (2 !== r.length) return;
            const n = transform(r, e?.stripAltText);
            n !== t.value && (t.cloneBefore({
                value: n
            }), !1 === e?.preserve && t.remove());
        }
    });
basePlugin.postcss = !0;
const creator = (s)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0,
        stripAltText: !1
    }, s);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-content-alt-text",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
class LayerName {
    parts;
    constructor(e){
        this.parts = e;
    }
    tokens() {
        return [
            ...this.parts
        ];
    }
    slice(r, n) {
        const t = [];
        for(let r = 0; r < this.parts.length; r++)e.isTokenIdent(this.parts[r]) && t.push(r);
        const s = t.slice(r, n);
        return new LayerName(this.parts.slice(s[0], s[s.length - 1] + 1));
    }
    concat(r) {
        const n = [
            e.TokenType.Delim,
            ".",
            -1,
            -1,
            {
                value: "."
            }
        ];
        return new LayerName([
            ...this.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r)),
            n,
            ...r.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r))
        ]);
    }
    segments() {
        return this.parts.filter((r)=>e.isTokenIdent(r)).map((e)=>e[4].value);
    }
    name() {
        return this.parts.filter((r)=>e.isTokenIdent(r) || e.isTokenDelim(r)).map((e)=>e[1]).join("");
    }
    equal(e) {
        const r = this.segments(), n = e.segments();
        if (r.length !== n.length) return !1;
        for(let e = 0; e < r.length; e++){
            if (r[e] !== n[e]) return !1;
        }
        return !0;
    }
    toString() {
        return e.stringify(...this.parts);
    }
    toJSON() {
        return {
            parts: this.parts,
            segments: this.segments(),
            name: this.name()
        };
    }
}
function parseFromTokens(n, t) {
    const s = r.parseCommaSeparatedListOfComponentValues(n, {
        onParseError: t?.onParseError
    }), a = t?.onParseError ?? (()=>{}), o = [
        "6.4.2. Layer Naming and Nesting",
        "Layer name syntax",
        "<layer-name> = <ident> [ '.' <ident> ]*"
    ], i = n[0][2], l = n[n.length - 1][3], m = [];
    for(let n = 0; n < s.length; n++){
        const t = s[n];
        for(let n = 0; n < t.length; n++){
            const s = t[n];
            if (!r.isTokenNode(s) && !r.isCommentNode(s) && !r.isWhitespaceNode(s)) return a(new e.ParseError(`Invalid cascade layer name. Invalid layer name part "${s.toString()}"`, i, l, o)), [];
        }
        const c = t.flatMap((e)=>e.tokens());
        let d = !1, p = !1, u = null;
        for(let r = 0; r < c.length; r++){
            const n = c[r];
            if (!(e.isTokenWhiteSpaceOrComment(n) || e.isTokenIdent(n) || e.isTokenDelim(n) && "." === n[4].value)) return a(new e.ParseError(`Invalid cascade layer name. Invalid character "${n[1]}"`, i, l, o)), [];
            if (!d && e.isTokenDelim(n)) return a(new e.ParseError("Invalid cascade layer name. Layer names can not start with a dot.", i, l, o)), [];
            if (d) {
                if (e.isTokenWhitespace(n)) {
                    p = !0;
                    continue;
                }
                if (p && e.isTokenComment(n)) continue;
                if (p) return a(new e.ParseError("Invalid cascade layer name. Encountered unexpected whitespace between layer name parts.", i, l, o)), [];
                if (e.isTokenIdent(u) && e.isTokenIdent(n)) return a(new e.ParseError("Invalid cascade layer name. Layer name parts must be separated by dots.", i, l, o)), [];
                if (e.isTokenDelim(u) && e.isTokenDelim(n)) return a(new e.ParseError("Invalid cascade layer name. Layer name parts must not be empty.", i, l, o)), [];
            }
            e.isTokenIdent(n) && (d = !0), (e.isTokenIdent(n) || e.isTokenDelim(n)) && (u = n);
        }
        if (!u) return a(new e.ParseError("Invalid cascade layer name. Empty layer name.", i, l, o)), [];
        if (e.isTokenDelim(u)) return a(new e.ParseError("Invalid cascade layer name. Layer name must not end with a dot.", i, l, o)), [];
        m.push(new LayerName(c));
    }
    return m;
}
exports.LayerName = LayerName, exports.addLayerToModel = function addLayerToModel(e, r) {
    r.forEach((r)=>{
        const n = r.segments();
        e: for(let t = 0; t < n.length; t++){
            const n = r.slice(0, t + 1), s = n.segments();
            let a = -1, o = 0;
            for(let r = 0; r < e.length; r++){
                const n = e[r].segments();
                let t = 0;
                r: for(let e = 0; e < n.length; e++){
                    const r = n[e], a = s[e];
                    if (a === r && e + 1 === s.length) continue e;
                    if (a !== r) {
                        if (a !== r) break r;
                    } else t++;
                }
                t >= o && (a = r, o = t);
            }
            -1 === a ? e.push(n) : e.splice(a + 1, 0, n);
        }
    });
}, exports.parse = function parse(r, n) {
    return parseFromTokens(e.tokenize({
        css: r
    }, {
        onParseError: n?.onParseError
    }), n);
}, exports.parseFromTokens = parseFromTokens;
}}),
"[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e, t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
exports.NodeType = void 0, (e = exports.NodeType || (exports.NodeType = {})).CustomMedia = "custom-media", e.GeneralEnclosed = "general-enclosed", e.MediaAnd = "media-and", e.MediaCondition = "media-condition", e.MediaConditionListWithAnd = "media-condition-list-and", e.MediaConditionListWithOr = "media-condition-list-or", e.MediaFeature = "media-feature", e.MediaFeatureBoolean = "mf-boolean", e.MediaFeatureName = "mf-name", e.MediaFeaturePlain = "mf-plain", e.MediaFeatureRangeNameValue = "mf-range-name-value", e.MediaFeatureRangeValueName = "mf-range-value-name", e.MediaFeatureRangeValueNameValue = "mf-range-value-name-value", e.MediaFeatureValue = "mf-value", e.MediaInParens = "media-in-parens", e.MediaNot = "media-not", e.MediaOr = "media-or", e.MediaQueryWithType = "media-query-with-type", e.MediaQueryWithoutType = "media-query-without-type", e.MediaQueryInvalid = "media-query-invalid";
class MediaCondition {
    type = exports.NodeType.MediaCondition;
    media;
    constructor(e){
        this.media = e;
    }
    tokens() {
        return this.media.tokens();
    }
    toString() {
        return this.media.toString();
    }
    hasLeadingSpace() {
        return this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            media: this.media.toJSON()
        };
    }
    isMediaCondition() {
        return MediaCondition.isMediaCondition(this);
    }
    static isMediaCondition(e) {
        return !!e && e instanceof MediaCondition && e.type === exports.NodeType.MediaCondition;
    }
}
class MediaInParens {
    type = exports.NodeType.MediaInParens;
    media;
    before;
    after;
    constructor(e, t = [], i = []){
        this.media = e, this.before = t, this.after = i;
    }
    tokens() {
        return [
            ...this.before,
            ...this.media.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.media.toString() + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && ("walk" in this.media ? this.media.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            media: this.media.toJSON(),
            before: this.before,
            after: this.after
        };
    }
    isMediaInParens() {
        return MediaInParens.isMediaInParens(this);
    }
    static isMediaInParens(e) {
        return !!e && e instanceof MediaInParens && e.type === exports.NodeType.MediaInParens;
    }
}
class MediaQueryWithType {
    type = exports.NodeType.MediaQueryWithType;
    modifier;
    mediaType;
    and = void 0;
    media = void 0;
    constructor(e, t, i, a){
        this.modifier = e, this.mediaType = t, i && a && (this.and = i, this.media = a);
    }
    getModifier() {
        if (!this.modifier.length) return "";
        for(let e = 0; e < this.modifier.length; e++){
            const t = this.modifier[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    negateQuery() {
        const e = "not" === this.getModifier().toLowerCase(), t = this.getMediaType();
        return this.and && this.media ? e ? [
            new MediaQueryWithType([], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ]),
            new MediaQueryWithoutType(this.media)
        ] : [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ]),
            ...new MediaQueryWithoutType(this.media).negateQuery()
        ] : e ? [
            new MediaQueryWithType([], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ])
        ] : [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    t,
                    -1,
                    -1,
                    {
                        value: t
                    }
                ]
            ])
        ];
    }
    getMediaType() {
        if (!this.mediaType.length) return "";
        for(let e = 0; e < this.mediaType.length; e++){
            const t = this.mediaType[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    tokens() {
        return this.and && this.media ? [
            ...this.modifier,
            ...this.mediaType,
            ...this.and,
            ...this.media.tokens()
        ] : [
            ...this.modifier,
            ...this.mediaType
        ];
    }
    toString() {
        return this.and && this.media ? i.stringify(...this.modifier) + i.stringify(...this.mediaType) + i.stringify(...this.and) + this.media.toString() : i.stringify(...this.modifier) + i.stringify(...this.mediaType);
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        if (t && (i = {
            ...t
        }), this.media) return !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            modifier: this.modifier,
            mediaType: this.mediaType,
            and: this.and,
            media: this.media
        };
    }
    isMediaQueryWithType() {
        return MediaQueryWithType.isMediaQueryWithType(this);
    }
    static isMediaQueryWithType(e) {
        return !!e && e instanceof MediaQueryWithType && e.type === exports.NodeType.MediaQueryWithType;
    }
}
class MediaQueryWithoutType {
    type = exports.NodeType.MediaQueryWithoutType;
    media;
    constructor(e){
        this.media = e;
    }
    negateQuery() {
        let e = this.media;
        if (e.media.type === exports.NodeType.MediaNot) return [
            new MediaQueryWithoutType(new MediaCondition(e.media.media))
        ];
        e.media.type !== exports.NodeType.MediaConditionListWithOr && e.media.type !== exports.NodeType.MediaConditionListWithAnd || (e = new MediaCondition(new MediaInParens(e, [
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ],
            [
                i.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ]
        ], [
            [
                i.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ]
        ]))), "before" in e.media && (e.media.hasLeadingSpace() || e.media.before.splice(0, 0, [
            i.TokenType.Whitespace,
            " ",
            -1,
            -1,
            void 0
        ]));
        return [
            new MediaQueryWithType([
                [
                    i.TokenType.Ident,
                    "not",
                    -1,
                    -1,
                    {
                        value: "not"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    "all",
                    -1,
                    -1,
                    {
                        value: "all"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ]
            ], e)
        ];
    }
    tokens() {
        return this.media.tokens();
    }
    toString() {
        return this.media.toString();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            media: this.media
        };
    }
    isMediaQueryWithoutType() {
        return MediaQueryWithoutType.isMediaQueryWithoutType(this);
    }
    static isMediaQueryWithoutType(e) {
        return !!e && e instanceof MediaQueryWithoutType && e.type === exports.NodeType.MediaQueryWithoutType;
    }
}
class MediaQueryInvalid {
    type = exports.NodeType.MediaQueryInvalid;
    media;
    constructor(e){
        this.media = e;
    }
    negateQuery() {
        return [
            new MediaQueryInvalid(this.media)
        ];
    }
    tokens() {
        return this.media.flatMap((e)=>e.tokens());
    }
    toString() {
        return this.media.map((e)=>e.toString()).join("");
    }
    walk(e, i) {
        if (0 === this.media.length) return;
        const a = t.walkerIndexGenerator(this.media);
        let r = 0;
        for(; r < this.media.length;){
            const t = this.media[r];
            let n;
            if (i && (n = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: n
            }, r)) return !1;
            if ("walk" in t && this.media.includes(t) && !1 === t.walk(e, n)) return !1;
            if (r = a(this.media, t, r), -1 === r) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            media: this.media
        };
    }
    isMediaQueryInvalid() {
        return MediaQueryInvalid.isMediaQueryInvalid(this);
    }
    static isMediaQueryInvalid(e) {
        return !!e && e instanceof MediaQueryInvalid && e.type === exports.NodeType.MediaQueryInvalid;
    }
}
class GeneralEnclosed {
    type = exports.NodeType.GeneralEnclosed;
    value;
    constructor(e){
        this.value = e;
    }
    tokens() {
        return this.value.tokens();
    }
    toString() {
        return this.value.toString();
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.value.tokens()[0]);
    }
    indexOf(e) {
        return e === this.value ? "value" : -1;
    }
    at(e) {
        if ("value" === e) return this.value;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            tokens: this.tokens()
        };
    }
    isGeneralEnclosed() {
        return GeneralEnclosed.isGeneralEnclosed(this);
    }
    static isGeneralEnclosed(e) {
        return !!e && e instanceof GeneralEnclosed && e.type === exports.NodeType.GeneralEnclosed;
    }
}
class MediaAnd {
    type = exports.NodeType.MediaAnd;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.modifier[0]);
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        return "media" === e ? this.media : null;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaAnd() {
        return MediaAnd.isMediaAnd(this);
    }
    static isMediaAnd(e) {
        return !!e && e instanceof MediaAnd && e.type === exports.NodeType.MediaAnd;
    }
}
class MediaConditionListWithAnd {
    type = exports.NodeType.MediaConditionListWithAnd;
    leading;
    list;
    before;
    after;
    constructor(e, t, i = [], a = []){
        this.leading = e, this.list = t, this.before = i, this.after = a;
    }
    tokens() {
        return [
            ...this.before,
            ...this.leading.tokens(),
            ...this.list.flatMap((e)=>e.tokens()),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.leading.toString() + this.list.map((e)=>e.toString()).join("") + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.leading.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.leading ? "leading" : e.type === exports.NodeType.MediaAnd ? this.list.indexOf(e) : -1;
    }
    at(e) {
        return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }
    walk(e, i) {
        let a;
        if (i && (a = {
            ...i
        }), !1 === e({
            node: this.leading,
            parent: this,
            state: a
        }, "leading")) return !1;
        if ("walk" in this.leading && !1 === this.leading.walk(e, a)) return !1;
        if (0 === this.list.length) return;
        const r = t.walkerIndexGenerator(this.list);
        let n = 0;
        for(; n < this.list.length;){
            const t = this.list[n];
            if (i && (a = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: a
            }, n)) return !1;
            if ("walk" in t && this.list.includes(t) && !1 === t.walk(e, a)) return !1;
            if (n = r(this.list, t, n), -1 === n) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            leading: this.leading.toJSON(),
            list: this.list.map((e)=>e.toJSON()),
            before: this.before,
            after: this.after
        };
    }
    isMediaConditionListWithAnd() {
        return MediaConditionListWithAnd.isMediaConditionListWithAnd(this);
    }
    static isMediaConditionListWithAnd(e) {
        return !!e && e instanceof MediaConditionListWithAnd && e.type === exports.NodeType.MediaConditionListWithAnd;
    }
}
class MediaConditionListWithOr {
    type = exports.NodeType.MediaConditionListWithOr;
    leading;
    list;
    before;
    after;
    constructor(e, t, i = [], a = []){
        this.leading = e, this.list = t, this.before = i, this.after = a;
    }
    tokens() {
        return [
            ...this.before,
            ...this.leading.tokens(),
            ...this.list.flatMap((e)=>e.tokens()),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.leading.toString() + this.list.map((e)=>e.toString()).join("") + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return this.before.length ? i.isTokenWhiteSpaceOrComment(this.before[0]) : this.leading.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.leading ? "leading" : e.type === exports.NodeType.MediaOr ? this.list.indexOf(e) : -1;
    }
    at(e) {
        return "leading" === e ? this.leading : "number" == typeof e ? (e < 0 && (e = this.list.length + e), this.list[e]) : void 0;
    }
    walk(e, i) {
        let a;
        if (i && (a = {
            ...i
        }), !1 === e({
            node: this.leading,
            parent: this,
            state: a
        }, "leading")) return !1;
        if ("walk" in this.leading && !1 === this.leading.walk(e, a)) return !1;
        if (0 === this.list.length) return;
        const r = t.walkerIndexGenerator(this.list);
        let n = 0;
        for(; n < this.list.length;){
            const t = this.list[n];
            if (i && (a = {
                ...i
            }), !1 === e({
                node: t,
                parent: this,
                state: a
            }, n)) return !1;
            if ("walk" in t && this.list.includes(t) && !1 === t.walk(e, a)) return !1;
            if (n = r(this.list, t, n), -1 === n) break;
        }
    }
    toJSON() {
        return {
            type: this.type,
            leading: this.leading.toJSON(),
            list: this.list.map((e)=>e.toJSON()),
            before: this.before,
            after: this.after
        };
    }
    isMediaConditionListWithOr() {
        return MediaConditionListWithOr.isMediaConditionListWithOr(this);
    }
    static isMediaConditionListWithOr(e) {
        return !!e && e instanceof MediaConditionListWithOr && e.type === exports.NodeType.MediaConditionListWithOr;
    }
}
function isNumber(e) {
    return !!(t.isTokenNode(e) && i.isTokenNumber(e.value) || t.isFunctionNode(e) && a.has(e.getName().toLowerCase()));
}
const a = new Set([
    "abs",
    "acos",
    "asin",
    "atan",
    "atan2",
    "calc",
    "clamp",
    "cos",
    "exp",
    "hypot",
    "log",
    "max",
    "min",
    "mod",
    "pow",
    "rem",
    "round",
    "sign",
    "sin",
    "sqrt",
    "tan"
]);
function isDimension(e) {
    return t.isTokenNode(e) && i.isTokenDimension(e.value);
}
function isIdent(e) {
    return t.isTokenNode(e) && i.isTokenIdent(e.value);
}
function isEnvironmentVariable(e) {
    return t.isFunctionNode(e) && "env" === e.getName().toLowerCase();
}
class MediaFeatureName {
    type = exports.NodeType.MediaFeatureName;
    name;
    before;
    after;
    constructor(e, t = [], i = []){
        this.name = e, this.before = t, this.after = i;
    }
    getName() {
        return this.name.value[4].value;
    }
    getNameToken() {
        return this.name.value;
    }
    tokens() {
        return [
            ...this.before,
            ...this.name.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.name.toString() + i.stringify(...this.after);
    }
    indexOf(e) {
        return e === this.name ? "name" : -1;
    }
    at(e) {
        if ("name" === e) return this.name;
    }
    toJSON() {
        return {
            type: this.type,
            name: this.getName(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureName() {
        return MediaFeatureName.isMediaFeatureName(this);
    }
    static isMediaFeatureName(e) {
        return !!e && e instanceof MediaFeatureName && e.type === exports.NodeType.MediaFeatureName;
    }
}
function parseMediaFeatureName(e) {
    let i = -1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (!isIdent(r)) return !1;
            if (-1 !== i) return !1;
            i = a;
        }
    }
    return -1 !== i && new MediaFeatureName(e[i], e.slice(0, i).flatMap((e)=>e.tokens()), e.slice(i + 1).flatMap((e)=>e.tokens()));
}
class MediaFeatureBoolean {
    type = exports.NodeType.MediaFeatureBoolean;
    name;
    constructor(e){
        this.name = e;
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return this.name.tokens();
    }
    toString() {
        return this.name.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : -1;
    }
    at(e) {
        if ("name" === e) return this.name;
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureBoolean() {
        return MediaFeatureBoolean.isMediaFeatureBoolean(this);
    }
    static isMediaFeatureBoolean(e) {
        return !!e && e instanceof MediaFeatureBoolean && e.type === exports.NodeType.MediaFeatureBoolean;
    }
}
function parseMediaFeatureBoolean(e) {
    const t = parseMediaFeatureName(e);
    return !1 === t ? t : new MediaFeatureBoolean(t);
}
class MediaFeatureValue {
    type = exports.NodeType.MediaFeatureValue;
    value;
    before;
    after;
    constructor(e, t = [], i = []){
        Array.isArray(e) && 1 === e.length ? this.value = e[0] : this.value = e, this.before = t, this.after = i;
    }
    tokens() {
        return Array.isArray(this.value) ? [
            ...this.before,
            ...this.value.flatMap((e)=>e.tokens()),
            ...this.after
        ] : [
            ...this.before,
            ...this.value.tokens(),
            ...this.after
        ];
    }
    toString() {
        return Array.isArray(this.value) ? i.stringify(...this.before) + this.value.map((e)=>e.toString()).join("") + i.stringify(...this.after) : i.stringify(...this.before) + this.value.toString() + i.stringify(...this.after);
    }
    indexOf(e) {
        return e === this.value ? "value" : -1;
    }
    at(e) {
        return "value" === e ? this.value : Array.isArray(this.value) && "number" == typeof e ? (e < 0 && (e = this.value.length + e), this.value[e]) : void 0;
    }
    walk(e, i) {
        if (Array.isArray(this.value)) {
            if (0 === this.value.length) return;
            const a = t.walkerIndexGenerator(this.value);
            let r = 0;
            for(; r < this.value.length;){
                const t = this.value[r];
                let n;
                if (i && (n = {
                    ...i
                }), !1 === e({
                    node: t,
                    parent: this,
                    state: n
                }, r)) return !1;
                if ("walk" in t && this.value.includes(t) && !1 === t.walk(e, n)) return !1;
                if (r = a(this.value, t, r), -1 === r) break;
            }
        } else {
            let t;
            if (i && (t = {
                ...i
            }), !1 === e({
                node: this.value,
                parent: this,
                state: t
            }, "value")) return !1;
            if ("walk" in this.value) return this.value.walk(e, t);
        }
    }
    toJSON() {
        return Array.isArray(this.value) ? {
            type: this.type,
            value: this.value.map((e)=>e.toJSON()),
            tokens: this.tokens()
        } : {
            type: this.type,
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureValue() {
        return MediaFeatureValue.isMediaFeatureValue(this);
    }
    static isMediaFeatureValue(e) {
        return !!e && e instanceof MediaFeatureValue && e.type === exports.NodeType.MediaFeatureValue;
    }
}
function parseMediaFeatureValue(e, i = !1) {
    let a = -1, r = -1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (s.type !== t.ComponentValueType.Whitespace && s.type !== t.ComponentValueType.Comment) {
            if (-1 !== a) return !1;
            if (isNumber(s)) {
                const t = matchesRatioExactly(e.slice(n));
                if (-1 !== t) {
                    a = t[0] + n, r = t[1] + n, n += t[1] - t[0];
                    continue;
                }
                a = n, r = n;
            } else if (isEnvironmentVariable(s)) a = n, r = n;
            else if (isDimension(s)) a = n, r = n;
            else {
                if (i || !isIdent(s)) return !1;
                a = n, r = n;
            }
        }
    }
    return -1 !== a && new MediaFeatureValue(e.slice(a, r + 1), e.slice(0, a).flatMap((e)=>e.tokens()), e.slice(r + 1).flatMap((e)=>e.tokens()));
}
function matchesRatioExactly(e) {
    let i = -1, a = -1;
    const r = matchesRatio(e);
    if (-1 === r) return -1;
    i = r[0], a = r[1];
    for(let i = a + 1; i < e.length; i++){
        const a = e[i];
        if (!t.isWhiteSpaceOrCommentNode(a)) return -1;
    }
    return [
        i,
        a
    ];
}
function matchesRatio(e) {
    let a = -1, r = -1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (!t.isWhiteSpaceOrCommentNode(s)) {
            if (t.isTokenNode(s)) {
                const e = s.value;
                if (i.isTokenDelim(e) && "/" === e[4].value) {
                    if (-1 === a) return -1;
                    if (-1 !== r) return -1;
                    r = n;
                    continue;
                }
            }
            if (!isNumber(s)) return -1;
            if (-1 !== r) return [
                a,
                n
            ];
            if (-1 !== a) return -1;
            a = n;
        }
    }
    return -1;
}
class MediaFeaturePlain {
    type = exports.NodeType.MediaFeaturePlain;
    name;
    colon;
    value;
    constructor(e, t, i){
        this.name = e, this.colon = t, this.value = i;
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.name.tokens(),
            this.colon,
            ...this.value.tokens()
        ];
    }
    toString() {
        return this.name.toString() + i.stringify(this.colon) + this.value.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && this.value.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeaturePlain() {
        return MediaFeaturePlain.isMediaFeaturePlain(this);
    }
    static isMediaFeaturePlain(e) {
        return !!e && e instanceof MediaFeaturePlain && e.type === exports.NodeType.MediaFeaturePlain;
    }
}
function parseMediaFeaturePlain(e) {
    let a = [], r = [], n = null;
    for(let s = 0; s < e.length; s++){
        const o = e[s];
        if (o.type === t.ComponentValueType.Token) {
            const t = o.value;
            if (i.isTokenColon(t)) {
                a = e.slice(0, s), r = e.slice(s + 1), n = t;
                break;
            }
        }
    }
    if (!a.length || !r.length || !n) return !1;
    const s = parseMediaFeatureName(a);
    if (!1 === s) return !1;
    const o = parseMediaFeatureValue(r);
    return !1 !== o && new MediaFeaturePlain(s, n, o);
}
var r, n, s;
function matchesComparison(e) {
    let a = -1;
    for(let r = 0; r < e.length; r++){
        const n = e[r];
        if (n.type === t.ComponentValueType.Token) {
            const e = n.value;
            if (i.isTokenDelim(e)) {
                if (e[4].value === exports.MediaFeatureEQ.EQ) return -1 !== a ? [
                    a,
                    r
                ] : [
                    r,
                    r
                ];
                if (e[4].value === exports.MediaFeatureLT.LT) {
                    a = r;
                    continue;
                }
                if (e[4].value === exports.MediaFeatureGT.GT) {
                    a = r;
                    continue;
                }
            }
        }
        break;
    }
    return -1 !== a && [
        a,
        a
    ];
}
function comparisonFromTokens(e) {
    if (1 !== e.length && 2 !== e.length) return !1;
    if (!i.isTokenDelim(e[0])) return !1;
    if (1 === e.length) switch(e[0][4].value){
        case exports.MediaFeatureEQ.EQ:
            return exports.MediaFeatureEQ.EQ;
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureLT.LT;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureGT.GT;
        default:
            return !1;
    }
    if (!i.isTokenDelim(e[1])) return !1;
    if (e[1][4].value !== exports.MediaFeatureEQ.EQ) return !1;
    switch(e[0][4].value){
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureLT.LT_OR_EQ;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureGT.GT_OR_EQ;
        default:
            return !1;
    }
}
exports.MediaFeatureLT = void 0, (r = exports.MediaFeatureLT || (exports.MediaFeatureLT = {})).LT = "<", r.LT_OR_EQ = "<=", exports.MediaFeatureGT = void 0, (n = exports.MediaFeatureGT || (exports.MediaFeatureGT = {})).GT = ">", n.GT_OR_EQ = ">=", exports.MediaFeatureEQ = void 0, (exports.MediaFeatureEQ || (exports.MediaFeatureEQ = {})).EQ = "=";
class MediaFeatureRangeNameValue {
    type = exports.NodeType.MediaFeatureRangeNameValue;
    name;
    operator;
    value;
    constructor(e, t, i){
        this.name = e, this.operator = t, this.value = i;
    }
    operatorKind() {
        return comparisonFromTokens(this.operator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.name.tokens(),
            ...this.operator,
            ...this.value.tokens()
        ];
    }
    toString() {
        return this.name.toString() + i.stringify(...this.operator) + this.value.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeNameValue() {
        return MediaFeatureRangeNameValue.isMediaFeatureRangeNameValue(this);
    }
    static isMediaFeatureRangeNameValue(e) {
        return !!e && e instanceof MediaFeatureRangeNameValue && e.type === exports.NodeType.MediaFeatureRangeNameValue;
    }
}
class MediaFeatureRangeValueName {
    type = exports.NodeType.MediaFeatureRangeValueName;
    name;
    operator;
    value;
    constructor(e, t, i){
        this.name = e, this.operator = t, this.value = i;
    }
    operatorKind() {
        return comparisonFromTokens(this.operator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.value.tokens(),
            ...this.operator,
            ...this.name.tokens()
        ];
    }
    toString() {
        return this.value.toString() + i.stringify(...this.operator) + this.name.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.value ? "value" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "value" === e ? this.value : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.value,
            parent: this,
            state: i
        }, "value") && ("walk" in this.value ? this.value.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            value: this.value.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeValueName() {
        return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(this);
    }
    static isMediaFeatureRangeValueName(e) {
        return !!e && e instanceof MediaFeatureRangeValueName && e.type === exports.NodeType.MediaFeatureRangeValueName;
    }
}
class MediaFeatureRangeValueNameValue {
    type = exports.NodeType.MediaFeatureRangeValueNameValue;
    name;
    valueOne;
    valueOneOperator;
    valueTwo;
    valueTwoOperator;
    constructor(e, t, i, a, r){
        this.name = e, this.valueOne = t, this.valueOneOperator = i, this.valueTwo = a, this.valueTwoOperator = r;
    }
    valueOneOperatorKind() {
        return comparisonFromTokens(this.valueOneOperator);
    }
    valueTwoOperatorKind() {
        return comparisonFromTokens(this.valueTwoOperator);
    }
    getName() {
        return this.name.getName();
    }
    getNameToken() {
        return this.name.getNameToken();
    }
    tokens() {
        return [
            ...this.valueOne.tokens(),
            ...this.valueOneOperator,
            ...this.name.tokens(),
            ...this.valueTwoOperator,
            ...this.valueTwo.tokens()
        ];
    }
    toString() {
        return this.valueOne.toString() + i.stringify(...this.valueOneOperator) + this.name.toString() + i.stringify(...this.valueTwoOperator) + this.valueTwo.toString();
    }
    indexOf(e) {
        return e === this.name ? "name" : e === this.valueOne ? "valueOne" : e === this.valueTwo ? "valueTwo" : -1;
    }
    at(e) {
        return "name" === e ? this.name : "valueOne" === e ? this.valueOne : "valueTwo" === e ? this.valueTwo : void 0;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.valueOne,
            parent: this,
            state: i
        }, "valueOne") && (!("walk" in this.valueOne) || !1 !== this.valueOne.walk(e, i)) && (t && (i = {
            ...t
        }), !1 !== e({
            node: this.valueTwo,
            parent: this,
            state: i
        }, "valueTwo") && (!("walk" in this.valueTwo) || !1 !== this.valueTwo.walk(e, i)) && void 0);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name.toJSON(),
            valueOne: this.valueOne.toJSON(),
            valueTwo: this.valueTwo.toJSON(),
            tokens: this.tokens()
        };
    }
    isMediaFeatureRangeValueNameValue() {
        return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(this);
    }
    static isMediaFeatureRangeValueNameValue(e) {
        return !!e && e instanceof MediaFeatureRangeValueNameValue && e.type === exports.NodeType.MediaFeatureRangeValueNameValue;
    }
}
function parseMediaFeatureRange(e) {
    let a = !1, r = !1;
    for(let n = 0; n < e.length; n++){
        const s = e[n];
        if (s.type === t.ComponentValueType.Token) {
            const t = s.value;
            if (i.isTokenDelim(t)) {
                const t = matchesComparison(e.slice(n));
                if (!1 !== t) {
                    if (!1 !== a) {
                        r = [
                            t[0] + n,
                            t[1] + n
                        ];
                        break;
                    }
                    a = [
                        t[0] + n,
                        t[1] + n
                    ], n += t[1];
                }
            }
        }
    }
    if (!1 === a) return !1;
    const n = [
        e[a[0]].value
    ];
    if (a[0] !== a[1] && n.push(e[a[1]].value), !1 === r) {
        const t = e.slice(0, a[0]), i = e.slice(a[1] + 1), r = parseMediaFeatureName(t);
        if (r) {
            const e = parseMediaFeatureValue(i, !0);
            return !!e && new MediaFeatureRangeNameValue(r, n, e);
        }
        const s = parseMediaFeatureName(i);
        if (s) {
            const e = parseMediaFeatureValue(t, !0);
            return !!e && new MediaFeatureRangeValueName(s, n, e);
        }
        return !1;
    }
    const s = [
        e[r[0]].value
    ];
    r[0] !== r[1] && s.push(e[r[1]].value);
    const o = e.slice(0, a[0]), u = e.slice(a[1] + 1, r[0]), d = e.slice(r[1] + 1), l = parseMediaFeatureValue(o, !0), p = parseMediaFeatureName(u), h = parseMediaFeatureValue(d, !0);
    if (!l || !p || !h) return !1;
    {
        const e = comparisonFromTokens(n);
        if (!1 === e || e === exports.MediaFeatureEQ.EQ) return !1;
        const t = comparisonFromTokens(s);
        if (!1 === t || t === exports.MediaFeatureEQ.EQ) return !1;
        if (!(e !== exports.MediaFeatureLT.LT && e !== exports.MediaFeatureLT.LT_OR_EQ || t !== exports.MediaFeatureGT.GT && t !== exports.MediaFeatureGT.GT_OR_EQ)) return !1;
        if (!(e !== exports.MediaFeatureGT.GT && e !== exports.MediaFeatureGT.GT_OR_EQ || t !== exports.MediaFeatureLT.LT && t !== exports.MediaFeatureLT.LT_OR_EQ)) return !1;
    }
    return new MediaFeatureRangeValueNameValue(p, l, n, h, s);
}
class MediaFeature {
    type = exports.NodeType.MediaFeature;
    feature;
    before;
    after;
    constructor(e, t = [], i = []){
        this.feature = e, this.before = t, this.after = i;
    }
    getName() {
        return this.feature.getName();
    }
    getNameToken() {
        return this.feature.getNameToken();
    }
    tokens() {
        return [
            ...this.before,
            ...this.feature.tokens(),
            ...this.after
        ];
    }
    toString() {
        return i.stringify(...this.before) + this.feature.toString() + i.stringify(...this.after);
    }
    hasLeadingSpace() {
        return i.isTokenWhiteSpaceOrComment(this.before[0]);
    }
    indexOf(e) {
        return e === this.feature ? "feature" : -1;
    }
    at(e) {
        if ("feature" === e) return this.feature;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.feature,
            parent: this,
            state: i
        }, "feature") && ("walk" in this.feature ? this.feature.walk(e, i) : void 0);
    }
    toJSON() {
        return {
            type: this.type,
            feature: this.feature.toJSON(),
            before: this.before,
            after: this.after
        };
    }
    isMediaFeature() {
        return MediaFeature.isMediaFeature(this);
    }
    static isMediaFeature(e) {
        return !!e && e instanceof MediaFeature && e.type === exports.NodeType.MediaFeature;
    }
}
function parseMediaFeature(e, t = [], a = []) {
    if (!i.isTokenOpenParen(e.startToken)) return !1;
    const r = parseMediaFeatureBoolean(e.value);
    if (!1 !== r) return new MediaFeature(r, t, a);
    const n = parseMediaFeaturePlain(e.value);
    if (!1 !== n) return new MediaFeature(n, t, a);
    const s = parseMediaFeatureRange(e.value);
    return !1 !== s && new MediaFeature(s, t, a);
}
class MediaNot {
    type = exports.NodeType.MediaNot;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    hasLeadingSpace() {
        return this.modifier.length ? i.isTokenWhiteSpaceOrComment(this.modifier[0]) : this.media.hasLeadingSpace();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaNot() {
        return MediaNot.isMediaNot(this);
    }
    static isMediaNot(e) {
        return !!e && e instanceof MediaNot && e.type === exports.NodeType.MediaNot;
    }
}
class MediaOr {
    type = exports.NodeType.MediaOr;
    modifier;
    media;
    constructor(e, t){
        this.modifier = e, this.media = t;
    }
    tokens() {
        return [
            ...this.modifier,
            ...this.media.tokens()
        ];
    }
    toString() {
        return i.stringify(...this.modifier) + this.media.toString();
    }
    indexOf(e) {
        return e === this.media ? "media" : -1;
    }
    at(e) {
        if ("media" === e) return this.media;
    }
    walk(e, t) {
        let i;
        return t && (i = {
            ...t
        }), !1 !== e({
            node: this.media,
            parent: this,
            state: i
        }, "media") && this.media.walk(e, i);
    }
    toJSON() {
        return {
            type: this.type,
            modifier: this.modifier,
            media: this.media.toJSON()
        };
    }
    isMediaOr() {
        return MediaOr.isMediaOr(this);
    }
    static isMediaOr(e) {
        return !!e && e instanceof MediaOr && e.type === exports.NodeType.MediaOr;
    }
}
function modifierFromToken(e) {
    if (!i.isTokenIdent(e)) return !1;
    switch(e[4].value.toLowerCase()){
        case exports.MediaQueryModifier.Not:
            return exports.MediaQueryModifier.Not;
        case exports.MediaQueryModifier.Only:
            return exports.MediaQueryModifier.Only;
        default:
            return !1;
    }
}
function parseMediaQuery(e) {
    {
        const t = parseMediaCondition(e);
        if (!1 !== t) return new MediaQueryWithoutType(t);
    }
    {
        let a = -1, r = -1, n = -1;
        for(let s = 0; s < e.length; s++){
            const o = e[s];
            if (!t.isWhitespaceNode(o) && !t.isCommentNode(o)) {
                if (t.isTokenNode(o)) {
                    const t = o.value;
                    if (-1 === a && i.isTokenIdent(t) && modifierFromToken(t)) {
                        a = s;
                        continue;
                    }
                    if (-1 === r && i.isTokenIdent(t) && !modifierFromToken(t)) {
                        r = s;
                        continue;
                    }
                    if (-1 === n && i.isTokenIdent(t) && d.test(t[4].value)) {
                        n = s;
                        if (!1 === parseMediaConditionWithoutOr(e.slice(s + 1))) return !1;
                        break;
                    }
                    return !1;
                }
                return !1;
            }
        }
        let s = [], o = [];
        -1 !== a ? (s = e.slice(0, a + 1).flatMap((e)=>e.tokens()), -1 !== r && (o = e.slice(a + 1, r + 1).flatMap((e)=>e.tokens()))) : -1 !== r && (o = e.slice(0, r + 1).flatMap((e)=>e.tokens()));
        const u = parseMediaConditionWithoutOr(e.slice(Math.max(a, r, n) + 1));
        return !1 === u ? new MediaQueryWithType(s, [
            ...o,
            ...e.slice(r + 1).flatMap((e)=>e.tokens())
        ]) : new MediaQueryWithType(s, o, e.slice(r + 1, n + 1).flatMap((e)=>e.tokens()), u);
    }
}
function parseMediaConditionListWithOr(e) {
    let i = !1;
    const a = [];
    let r = -1, n = -1;
    for(let s = 0; s < e.length; s++){
        if (i) {
            const t = parseMediaOr(e.slice(s));
            if (!1 !== t) {
                s += t.advance, a.push(t.node), n = s;
                continue;
            }
        }
        const o = e[s];
        if (o.type !== t.ComponentValueType.Whitespace && o.type !== t.ComponentValueType.Comment) {
            if (i) return !1;
            if (!1 !== i || !t.isSimpleBlockNode(o)) return !1;
            if (o.normalize(), i = parseMediaInParensFromSimpleBlock(o), !1 === i) return !1;
            r = s;
        }
    }
    return !(!i || !a.length) && new MediaConditionListWithOr(i, a, e.slice(0, r).flatMap((e)=>e.tokens()), e.slice(n + 1).flatMap((e)=>e.tokens()));
}
function parseMediaConditionListWithAnd(e) {
    let i = !1;
    const a = [];
    let r = -1, n = -1;
    for(let s = 0; s < e.length; s++){
        if (i) {
            const t = parseMediaAnd(e.slice(s));
            if (!1 !== t) {
                s += t.advance, a.push(t.node), n = s;
                continue;
            }
        }
        const o = e[s];
        if (o.type !== t.ComponentValueType.Whitespace && o.type !== t.ComponentValueType.Comment) {
            if (i) return !1;
            if (!1 !== i || !t.isSimpleBlockNode(o)) return !1;
            if (o.normalize(), i = parseMediaInParensFromSimpleBlock(o), !1 === i) return !1;
            r = s;
        }
    }
    return !(!i || !a.length) && new MediaConditionListWithAnd(i, a, e.slice(0, r).flatMap((e)=>e.tokens()), e.slice(n + 1).flatMap((e)=>e.tokens()));
}
function parseMediaCondition(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaConditionListWithOr(e);
    if (!1 !== a) return new MediaCondition(a);
    const r = parseMediaInParens(e);
    return !1 !== r && new MediaCondition(r);
}
function parseMediaConditionWithoutOr(e) {
    const t = parseMediaNot(e);
    if (!1 !== t) return new MediaCondition(t);
    const i = parseMediaConditionListWithAnd(e);
    if (!1 !== i) return new MediaCondition(i);
    const a = parseMediaInParens(e);
    return !1 !== a && new MediaCondition(a);
}
function parseMediaInParens(e) {
    let a = -1;
    for(let i = 0; i < e.length; i++){
        const r = e[i];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (!t.isSimpleBlockNode(r)) return !1;
            if (-1 !== a) return !1;
            a = i;
        }
    }
    if (-1 === a) return !1;
    const r = e[a];
    if (!i.isTokenOpenParen(r.startToken)) return !1;
    r.normalize();
    const n = [
        ...e.slice(0, a).flatMap((e)=>e.tokens()),
        r.startToken
    ], s = [
        r.endToken,
        ...e.slice(a + 1).flatMap((e)=>e.tokens())
    ], o = parseMediaFeature(r, n, s);
    if (!1 !== o) return new MediaInParens(o);
    const u = parseMediaCondition(r.value);
    return !1 !== u ? new MediaInParens(u, n, s) : new MediaInParens(new GeneralEnclosed(r), e.slice(0, a).flatMap((e)=>e.tokens()), e.slice(a + 1).flatMap((e)=>e.tokens()));
}
function parseMediaInParensFromSimpleBlock(e) {
    if (!i.isTokenOpenParen(e.startToken)) return !1;
    const t = parseMediaFeature(e, [
        e.startToken
    ], [
        e.endToken
    ]);
    if (!1 !== t) return new MediaInParens(t);
    const a = parseMediaCondition(e.value);
    return !1 !== a ? new MediaInParens(a, [
        e.startToken
    ], [
        e.endToken
    ]) : new MediaInParens(new GeneralEnclosed(e));
}
exports.MediaQueryModifier = void 0, (s = exports.MediaQueryModifier || (exports.MediaQueryModifier = {})).Not = "not", s.Only = "only";
const o = /^not$/i;
function parseMediaNot(e) {
    let i = !1, a = null;
    for(let r = 0; r < e.length; r++){
        const n = e[r];
        if (n.type !== t.ComponentValueType.Whitespace && n.type !== t.ComponentValueType.Comment) {
            if (isIdent(n)) {
                const e = n.value;
                if (o.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (!i || !t.isSimpleBlockNode(n)) return !1;
            {
                n.normalize();
                const t = parseMediaInParensFromSimpleBlock(n);
                if (!1 === t) return !1;
                a = new MediaNot(e.slice(0, r).flatMap((e)=>e.tokens()), t);
            }
        }
    }
    return a || !1;
}
const u = /^or$/i;
function parseMediaOr(e) {
    let i = !1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (isIdent(r)) {
                const e = r.value;
                if (u.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (i && t.isSimpleBlockNode(r)) {
                r.normalize();
                const t = parseMediaInParensFromSimpleBlock(r);
                return !1 !== t && {
                    advance: a,
                    node: new MediaOr(e.slice(0, a).flatMap((e)=>e.tokens()), t)
                };
            }
            return !1;
        }
    }
    return !1;
}
const d = /^and$/i;
function parseMediaAnd(e) {
    let i = !1;
    for(let a = 0; a < e.length; a++){
        const r = e[a];
        if (r.type !== t.ComponentValueType.Whitespace && r.type !== t.ComponentValueType.Comment) {
            if (isIdent(r)) {
                const e = r.value;
                if (d.test(e[4].value)) {
                    if (i) return !1;
                    i = !0;
                    continue;
                }
                return !1;
            }
            if (i && t.isSimpleBlockNode(r)) {
                r.normalize();
                const t = parseMediaInParensFromSimpleBlock(r);
                return !1 !== t && {
                    advance: a,
                    node: new MediaAnd(e.slice(0, a).flatMap((e)=>e.tokens()), t)
                };
            }
            return !1;
        }
    }
    return !1;
}
function parseFromTokens(e, i) {
    const a = t.parseCommaSeparatedListOfComponentValues(e, {
        onParseError: i?.onParseError
    });
    return a.map((e, t)=>{
        const r = parseMediaQuery(e);
        return !1 === r && !0 === i?.preserveInvalidMediaQueries ? new MediaQueryInvalid(a[t]) : r;
    }).filter((e)=>!!e);
}
class CustomMedia {
    type = exports.NodeType.CustomMedia;
    name;
    mediaQueryList = null;
    trueOrFalseKeyword = null;
    constructor(e, t, i){
        this.name = e, this.mediaQueryList = t, this.trueOrFalseKeyword = i ?? null;
    }
    getName() {
        for(let e = 0; e < this.name.length; e++){
            const t = this.name[e];
            if (i.isTokenIdent(t)) return t[4].value;
        }
        return "";
    }
    getNameToken() {
        for(let e = 0; e < this.name.length; e++){
            const t = this.name[e];
            if (i.isTokenIdent(t)) return t;
        }
        return null;
    }
    hasMediaQueryList() {
        return !!this.mediaQueryList;
    }
    hasTrueKeyword() {
        if (!this.trueOrFalseKeyword) return !1;
        for(let e = 0; e < this.trueOrFalseKeyword.length; e++){
            const t = this.trueOrFalseKeyword[e];
            if (!i.isTokenWhiteSpaceOrComment(t)) return !!i.isTokenIdent(t) && "true" === t[4].value.toLowerCase();
        }
        return !1;
    }
    hasFalseKeyword() {
        if (!this.trueOrFalseKeyword) return !1;
        for(let e = 0; e < this.trueOrFalseKeyword.length; e++){
            const t = this.trueOrFalseKeyword[e];
            if (!i.isTokenWhiteSpaceOrComment(t)) return !!i.isTokenIdent(t) && "false" === t[4].value.toLowerCase();
        }
        return !1;
    }
    tokens() {
        if (this.trueOrFalseKeyword) return [
            ...this.name,
            ...this.trueOrFalseKeyword
        ];
        if (!this.mediaQueryList) return [
            ...this.name
        ];
        const e = [];
        for(let t = 0; t < this.mediaQueryList.length; t++){
            const a = this.mediaQueryList[t];
            0 !== t && e.push([
                i.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]), e.push(...a.tokens());
        }
        return [
            ...this.name,
            ...e
        ];
    }
    toString() {
        return i.stringify(...this.tokens());
    }
    toJSON() {
        return {
            type: this.type,
            string: this.toString(),
            nameValue: this.getName(),
            name: this.name,
            hasFalseKeyword: this.hasFalseKeyword(),
            hasTrueKeyword: this.hasTrueKeyword(),
            trueOrFalseKeyword: this.trueOrFalseKeyword,
            mediaQueryList: this.mediaQueryList?.map((e)=>e.toJSON())
        };
    }
    isCustomMedia() {
        return CustomMedia.isCustomMedia(this);
    }
    static isCustomMedia(e) {
        return !!e && e instanceof CustomMedia && e.type === exports.NodeType.CustomMedia;
    }
}
function parseCustomMediaFromTokens(e, t) {
    let a = [], r = e;
    for(let t = 0; t < e.length; t++)if (!i.isTokenWhiteSpaceOrComment(e[t])) {
        if (i.isTokenIdent(e[t])) {
            if (e[t][4].value.startsWith("--")) {
                a = e.slice(0, t + 1), r = e.slice(t + 1);
                break;
            }
        }
        return !1;
    }
    let n = !0;
    for(let e = 0; e < r.length; e++)if (!i.isTokenWhiteSpaceOrComment(r[e])) {
        if (i.isTokenIdent(r[e])) {
            const t = r[e][4].value.toLowerCase();
            if ("false" === t) continue;
            if ("true" === t) continue;
        }
        if (i.isTokenEOF(r[e])) break;
        n = !1;
    }
    return n ? new CustomMedia(a, null, r) : new CustomMedia(a, parseFromTokens(i.cloneTokens(r), t));
}
function isMediaConditionListWithAnd(e) {
    return MediaConditionListWithAnd.isMediaConditionListWithAnd(e);
}
function isMediaConditionListWithOr(e) {
    return MediaConditionListWithOr.isMediaConditionListWithOr(e);
}
function isMediaFeatureRangeNameValue(e) {
    return MediaFeatureRangeNameValue.isMediaFeatureRangeNameValue(e);
}
function isMediaFeatureRangeValueName(e) {
    return MediaFeatureRangeValueName.isMediaFeatureRangeValueName(e);
}
function isMediaFeatureRangeValueNameValue(e) {
    return MediaFeatureRangeValueNameValue.isMediaFeatureRangeValueNameValue(e);
}
function isMediaQueryWithType(e) {
    return MediaQueryWithType.isMediaQueryWithType(e);
}
function isMediaQueryWithoutType(e) {
    return MediaQueryWithoutType.isMediaQueryWithoutType(e);
}
function isMediaQueryInvalid(e) {
    return MediaQueryInvalid.isMediaQueryInvalid(e);
}
var l;
exports.MediaType = void 0, (l = exports.MediaType || (exports.MediaType = {})).All = "all", l.Print = "print", l.Screen = "screen", l.Tty = "tty", l.Tv = "tv", l.Projection = "projection", l.Handheld = "handheld", l.Braille = "braille", l.Embossed = "embossed", l.Aural = "aural", l.Speech = "speech", exports.CustomMedia = CustomMedia, exports.GeneralEnclosed = GeneralEnclosed, exports.MediaAnd = MediaAnd, exports.MediaCondition = MediaCondition, exports.MediaConditionListWithAnd = MediaConditionListWithAnd, exports.MediaConditionListWithOr = MediaConditionListWithOr, exports.MediaFeature = MediaFeature, exports.MediaFeatureBoolean = MediaFeatureBoolean, exports.MediaFeatureName = MediaFeatureName, exports.MediaFeaturePlain = MediaFeaturePlain, exports.MediaFeatureRangeNameValue = MediaFeatureRangeNameValue, exports.MediaFeatureRangeValueName = MediaFeatureRangeValueName, exports.MediaFeatureRangeValueNameValue = MediaFeatureRangeValueNameValue, exports.MediaFeatureValue = MediaFeatureValue, exports.MediaInParens = MediaInParens, exports.MediaNot = MediaNot, exports.MediaOr = MediaOr, exports.MediaQueryInvalid = MediaQueryInvalid, exports.MediaQueryWithType = MediaQueryWithType, exports.MediaQueryWithoutType = MediaQueryWithoutType, exports.cloneMediaQuery = function cloneMediaQuery(e) {
    const t = i.cloneTokens(e.tokens()), a = parseFromTokens(t, {
        preserveInvalidMediaQueries: !0
    })[0];
    if (!a) throw new Error(`Failed to clone media query for : "${i.stringify(...t)}"`);
    if (isMediaQueryInvalid(e) && isMediaQueryInvalid(a)) return a;
    if (isMediaQueryWithType(e) && isMediaQueryWithType(a)) return a;
    if (isMediaQueryWithoutType(e) && isMediaQueryWithoutType(a)) return a;
    throw new Error(`Failed to clone media query for : "${i.stringify(...t)}"`);
}, exports.comparisonFromTokens = comparisonFromTokens, exports.invertComparison = function invertComparison(e) {
    switch(e){
        case exports.MediaFeatureEQ.EQ:
            return exports.MediaFeatureEQ.EQ;
        case exports.MediaFeatureLT.LT:
            return exports.MediaFeatureGT.GT;
        case exports.MediaFeatureLT.LT_OR_EQ:
            return exports.MediaFeatureGT.GT_OR_EQ;
        case exports.MediaFeatureGT.GT:
            return exports.MediaFeatureLT.LT;
        case exports.MediaFeatureGT.GT_OR_EQ:
            return exports.MediaFeatureLT.LT_OR_EQ;
        default:
            return !1;
    }
}, exports.isCustomMedia = function isCustomMedia(e) {
    return CustomMedia.isCustomMedia(e);
}, exports.isGeneralEnclosed = function isGeneralEnclosed(e) {
    return GeneralEnclosed.isGeneralEnclosed(e);
}, exports.isMediaAnd = function isMediaAnd(e) {
    return MediaAnd.isMediaAnd(e);
}, exports.isMediaCondition = function isMediaCondition(e) {
    return MediaCondition.isMediaCondition(e);
}, exports.isMediaConditionList = function isMediaConditionList(e) {
    return isMediaConditionListWithAnd(e) || isMediaConditionListWithOr(e);
}, exports.isMediaConditionListWithAnd = isMediaConditionListWithAnd, exports.isMediaConditionListWithOr = isMediaConditionListWithOr, exports.isMediaFeature = function isMediaFeature(e) {
    return MediaFeature.isMediaFeature(e);
}, exports.isMediaFeatureBoolean = function isMediaFeatureBoolean(e) {
    return MediaFeatureBoolean.isMediaFeatureBoolean(e);
}, exports.isMediaFeatureName = function isMediaFeatureName(e) {
    return MediaFeatureName.isMediaFeatureName(e);
}, exports.isMediaFeaturePlain = function isMediaFeaturePlain(e) {
    return MediaFeaturePlain.isMediaFeaturePlain(e);
}, exports.isMediaFeatureRange = function isMediaFeatureRange(e) {
    return isMediaFeatureRangeNameValue(e) || isMediaFeatureRangeValueName(e) || isMediaFeatureRangeValueNameValue(e);
}, exports.isMediaFeatureRangeNameValue = isMediaFeatureRangeNameValue, exports.isMediaFeatureRangeValueName = isMediaFeatureRangeValueName, exports.isMediaFeatureRangeValueNameValue = isMediaFeatureRangeValueNameValue, exports.isMediaFeatureValue = function isMediaFeatureValue(e) {
    return MediaFeatureValue.isMediaFeatureValue(e);
}, exports.isMediaInParens = function isMediaInParens(e) {
    return MediaInParens.isMediaInParens(e);
}, exports.isMediaNot = function isMediaNot(e) {
    return MediaNot.isMediaNot(e);
}, exports.isMediaOr = function isMediaOr(e) {
    return MediaOr.isMediaOr(e);
}, exports.isMediaQuery = function isMediaQuery(e) {
    return isMediaQueryWithType(e) || isMediaQueryWithoutType(e) || isMediaQueryInvalid(e);
}, exports.isMediaQueryInvalid = isMediaQueryInvalid, exports.isMediaQueryWithType = isMediaQueryWithType, exports.isMediaQueryWithoutType = isMediaQueryWithoutType, exports.matchesComparison = matchesComparison, exports.matchesRatio = matchesRatio, exports.matchesRatioExactly = matchesRatioExactly, exports.modifierFromToken = modifierFromToken, exports.newMediaFeatureBoolean = function newMediaFeatureBoolean(e) {
    const a = [
        i.TokenType.Ident,
        "",
        -1,
        -1,
        {
            value: ""
        }
    ];
    return i.mutateIdent(a, e), new MediaFeature(new MediaFeatureBoolean(new MediaFeatureName(new t.TokenNode(a))), [
        [
            i.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ]
    ], [
        [
            i.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]
    ]);
}, exports.newMediaFeaturePlain = function newMediaFeaturePlain(e, ...a) {
    const r = [
        i.TokenType.Ident,
        "",
        -1,
        -1,
        {
            value: ""
        }
    ];
    i.mutateIdent(r, e);
    const n = t.parseListOfComponentValues(a);
    return new MediaFeature(new MediaFeaturePlain(new MediaFeatureName(new t.TokenNode(r)), [
        i.TokenType.Colon,
        ":",
        -1,
        -1,
        void 0
    ], new MediaFeatureValue(1 === n.length ? n[0] : n)), [
        [
            i.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ]
    ], [
        [
            i.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ]
    ]);
}, exports.parse = function parse(e, t) {
    return parseFromTokens(i.tokenize({
        css: e
    }, {
        onParseError: t?.onParseError
    }), t);
}, exports.parseCustomMedia = function parseCustomMedia(e, t) {
    return parseCustomMediaFromTokens(i.tokenize({
        css: e
    }, {
        onParseError: t?.onParseError
    }), t);
}, exports.parseCustomMediaFromTokens = parseCustomMediaFromTokens, exports.parseFromTokens = parseFromTokens, exports.typeFromToken = function typeFromToken(e) {
    if (!i.isTokenIdent(e)) return !1;
    switch(e[4].value.toLowerCase()){
        case exports.MediaType.All:
            return exports.MediaType.All;
        case exports.MediaType.Print:
            return exports.MediaType.Print;
        case exports.MediaType.Screen:
            return exports.MediaType.Screen;
        case exports.MediaType.Tty:
            return exports.MediaType.Tty;
        case exports.MediaType.Tv:
            return exports.MediaType.Tv;
        case exports.MediaType.Projection:
            return exports.MediaType.Projection;
        case exports.MediaType.Handheld:
            return exports.MediaType.Handheld;
        case exports.MediaType.Braille:
            return exports.MediaType.Braille;
        case exports.MediaType.Embossed:
            return exports.MediaType.Embossed;
        case exports.MediaType.Aural:
            return exports.MediaType.Aural;
        case exports.MediaType.Speech:
            return exports.MediaType.Speech;
        default:
            return !1;
    }
};
}}),
"[project]/node_modules/postcss-custom-media/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)");
const n = e.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(r) {
    const t = new Map, a = new Map, o = [];
    r.walkAtRules((r)=>{
        if ("layer" !== r.name.toLowerCase()) return;
        {
            let e = r.parent;
            for(; e;){
                if ("atrule" !== e.type || "layer" !== e.name.toLowerCase()) {
                    if (e === r.root()) break;
                    return;
                }
                e = e.parent;
            }
        }
        let s;
        if (r.nodes) s = normalizeLayerName(r.params, 1);
        else {
            if (!r.params.trim()) return;
            s = r.params;
        }
        let i = e.parse(s);
        if (i?.length) {
            {
                let e = r.parent;
                for(; e && "atrule" === e.type && "layer" === e.name.toLowerCase();){
                    const r = a.get(e);
                    r ? (i = i.map((e)=>r.concat(e)), e = e.parent) : e = e.parent;
                }
            }
            if (e.addLayerToModel(o, i), r.nodes) {
                const e = i[0].concat(n);
                t.set(r, e), a.set(r, i[0]);
            }
        }
    });
    for (const r of t.values())e.addLayerToModel(o, [
        r
    ]);
    const s = new WeakMap;
    for (const [e, r] of t)s.set(e, o.findIndex((e)=>r.equal(e)));
    return s;
}
function normalizeLayerName(e, r) {
    return e.trim() ? e : "csstools-anon-layer--" + r++;
}
const a = new Set([
    "scope",
    "container",
    "layer"
]);
function isProcessableCustomMediaRule(e) {
    if ("custom-media" !== e.name.toLowerCase()) return !1;
    if (!e.params || !e.params.includes("--")) return !1;
    if (e.nodes && e.nodes.length > 0) return !1;
    let r = e.parent;
    for(; r;){
        if ("atrule" === r.type && !a.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
function removeCyclicReferences(e, r) {
    const t = new Set;
    for(; e.size > 0;){
        const n = findCyclicNode(Array.from(e.keys()), r);
        if (!n) return t;
        e.delete(n), t.add(n), r = r.filter((e)=>-1 === e.indexOf(n));
    }
    return t;
}
function findCyclicNode(e, r) {
    let t = e.length;
    const n = new Array(t), a = {};
    let o = t;
    const s = makeOutgoingEdges(r), i = makeNodesHash(e);
    for(; o--;)if (!a[o]) {
        const r = visit(e[o], o, new Set);
        if (!r) continue;
        return r;
    }
    function visit(e, r, o) {
        if (o.has(e)) return e;
        if (!i.has(e)) return;
        if (a[r]) return;
        a[r] = !0;
        const l = Array.from(s.get(e) || new Set);
        if (r = l.length) {
            o.add(e);
            do {
                const e = l[--r], t = visit(e, i.get(e), o);
                if (t) return t;
            }while (r)
            o.delete(e);
        }
        n[--t] = e;
    }
}
function makeOutgoingEdges(e) {
    const r = new Map;
    for(let t = 0, n = e.length; t < n; t++){
        const n = e[t];
        r.has(n[0]) || r.set(n[0], new Set), r.has(n[1]) || r.set(n[1], new Set), r.get(n[0]).add(n[1]);
    }
    return r;
}
function makeNodesHash(e) {
    const r = new Map;
    for(let t = 0, n = e.length; t < n; t++)r.set(e[t], t);
    return r;
}
function atMediaParamsTokens(e) {
    const t = r.tokenizer({
        css: e
    }, {
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${e}"`);
        }
    }), n = [];
    for(; !t.endOfFile();)n.push(t.nextToken());
    return n;
}
const o = [
    [
        r.TokenType.Ident,
        "max-color",
        0,
        0,
        {
            value: "max-color"
        }
    ],
    [
        r.TokenType.Colon,
        ":",
        0,
        0,
        void 0
    ],
    [
        r.TokenType.Number,
        "2147477350",
        0,
        0,
        {
            value: 2147477350,
            type: r.NumberType.Integer
        }
    ]
], s = [
    [
        r.TokenType.Ident,
        "color",
        0,
        0,
        {
            value: "color"
        }
    ],
    [
        r.TokenType.Colon,
        ":",
        0,
        0,
        void 0
    ],
    [
        r.TokenType.Number,
        "2147477350",
        0,
        0,
        {
            value: 2147477350,
            type: r.NumberType.Integer
        }
    ]
];
function replaceTrueAndFalseTokens(e) {
    let t, n = [];
    for(let a = 0; a < e.length; a++)if (!r.isTokenWhiteSpaceOrComment(e[a])) {
        if (r.isTokenIdent(e[a])) {
            const r = e[a];
            if ("true" === r[4].value.toLowerCase()) {
                t = "true", n = e.slice(a + 1);
                break;
            }
            if ("false" === r[4].value.toLowerCase()) {
                t = "false", n = e.slice(a + 1);
                break;
            }
        }
        return e;
    }
    if (!t) return e;
    for(let t = 0; t < n.length; t++)if (!r.isTokenWhiteSpaceOrComment(n[t])) return e;
    return "true" === t ? [
        [
            r.TokenType.Whitespace,
            " ",
            0,
            0,
            void 0
        ],
        [
            r.TokenType.OpenParen,
            "(",
            0,
            0,
            void 0
        ],
        ...o,
        [
            r.TokenType.CloseParen,
            ")",
            0,
            0,
            void 0
        ]
    ] : [
        [
            r.TokenType.Whitespace,
            " ",
            0,
            0,
            void 0
        ],
        [
            r.TokenType.OpenParen,
            "(",
            0,
            0,
            void 0
        ],
        ...s,
        [
            r.TokenType.CloseParen,
            ")",
            0,
            0,
            void 0
        ]
    ];
}
function parseCustomMedia(e) {
    const n = atMediaParamsTokens(e), a = new Set;
    let o = "", s = n;
    for(let e = 0; e < n.length; e++)if (!r.isTokenWhiteSpaceOrComment(n[e])) {
        if (r.isTokenIdent(n[e])) {
            const r = n[e];
            if (r[4].value.startsWith("--")) {
                o = r[4].value, s = n.slice(e + 1);
                break;
            }
        }
        return !1;
    }
    for(let e = 0; e < s.length; e++)if (r.isTokenIdent(s[e])) {
        const r = s[e];
        r[4].value.startsWith("--") && a.add(r[4].value);
    }
    s = replaceTrueAndFalseTokens(s);
    const i = t.parseFromTokens(r.cloneTokens(s), {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r.stringify(...s)}"`);
        }
    }), l = t.parseFromTokens(r.cloneTokens(s), {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r.stringify(...s)}"`);
        }
    }).map((e)=>e.negateQuery());
    return {
        name: o,
        truthy: i,
        falsy: l,
        dependencies: Array.from(a).map((e)=>[
                o,
                e
            ])
    };
}
function getCustomMedia(e, r, t) {
    const n = new Map, a = new Map, o = [], s = collectCascadeLayerOrder(e);
    e.walkAtRules((e)=>{
        if (!isProcessableCustomMediaRule(e)) return;
        const r = parseCustomMedia(e.params);
        if (!r) return;
        if (0 === r.truthy.length) return;
        const i = (u = s, (l = e).parent && "atrule" === l.parent.type && "layer" === l.parent.name.toLowerCase() ? u.has(l.parent) ? u.get(l.parent) + 1 : 0 : 1e7);
        var l, u;
        const c = a.get(r.name) ?? -1;
        if (i && i >= c && (a.set(r.name, i), n.set(r.name, {
            truthy: r.truthy,
            falsy: r.falsy
        }), o.push(...r.dependencies)), !t.preserve) {
            const r = e.parent;
            e.remove(), removeEmptyAncestorBlocks(r);
        }
    });
    const i = removeCyclicReferences(n, o);
    for (const t of i.values())e.warn(r, `@custom-media rules have cyclic dependencies for "${t}"`);
    return n;
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (r.nodes && r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function transformAtMediaListTokens(e, r) {
    const n = t.parse(e, {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${e}"`);
        }
    }), a = n.map((e)=>e.toString());
    for(let e = 0; e < n.length; e++){
        const t = n[e], o = a[e];
        {
            const n = transformSimpleMediaQuery(t, r);
            if (n && n.replaceWith !== o) return a.map((r, t)=>t === e ? n : {
                    replaceWith: r
                });
        }
        const s = transformComplexMediaQuery(t, r);
        if (s && 0 !== s.length && s[0].replaceWith !== o) return a.flatMap((r, t)=>t === e ? s : [
                {
                    replaceWith: r
                }
            ]);
    }
    return [];
}
function transformSimpleMediaQuery(e, r) {
    if (!mediaQueryIsSimple(e)) return null;
    let n = null;
    return e.walk((e)=>{
        const a = e.node;
        if (!t.isMediaFeatureBoolean(a)) return;
        const o = a.getName();
        if (!o.startsWith("--")) return;
        const s = r.get(o);
        return s ? (n = {
            replaceWith: s.truthy.map((e)=>e.toString().trim()).join(",")
        }, !1) : void 0;
    }), n;
}
function transformComplexMediaQuery(e, r) {
    let n = [];
    return e.walk((a)=>{
        const i = a.node;
        if (!t.isMediaFeatureBoolean(i)) return;
        const l = a.parent;
        if (!t.isMediaFeature(l)) return;
        const u = i.getName();
        if (!u.startsWith("--")) return;
        const c = r.get(u);
        if (c) {
            if (1 === c.truthy.length && mediaQueryIsSimple(c.truthy[0])) {
                let r = null;
                if (c.truthy[0].walk((e)=>{
                    if (t.isMediaFeature(e.node)) return r = e.node, !1;
                }), r && r.feature) return l.feature = r.feature, n = [
                    {
                        replaceWith: e.toString()
                    }
                ], !1;
            }
            const r = t.newMediaFeaturePlain(o[0][4].value, o[2]);
            l.feature = r.feature;
            const a = e.toString(), i = t.newMediaFeaturePlain(s[0][4].value, s[2]);
            l.feature = i.feature;
            const u = e.toString();
            return n = [
                {
                    replaceWith: a,
                    encapsulateWith: [
                        c.truthy.map((e)=>e.toString().trim()).join(",")
                    ]
                },
                {
                    replaceWith: u,
                    encapsulateWith: c.falsy.map((e)=>e.map((e)=>e.toString().trim()).join(",").toString().trim())
                }
            ], !1;
        }
    }), n;
}
function mediaQueryIsSimple(e) {
    if (t.isMediaQueryInvalid(e)) return !1;
    if (t.isMediaQueryWithType(e)) return !1;
    let r = !0;
    return e.walk((e)=>{
        if (t.isMediaAnd(e.node) || t.isMediaOr(e.node) || t.isMediaNot(e.node) || t.isMediaConditionList(e.node) || t.isGeneralEnclosed(e.node)) return r = !1, !1;
    }), r;
}
const creator = (e)=>{
    const r = e?.preserve ?? !1;
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-media] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-media] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-media",
        prepare () {
            const e = new WeakSet;
            let t = new Map;
            return {
                postcssPlugin: "postcss-custom-media",
                Once (e, { result: n }) {
                    t = getCustomMedia(e, n, {
                        preserve: r
                    });
                },
                AtRule (n, { result: a }) {
                    if (e.has(n)) return;
                    if ("media" !== n.name.toLowerCase()) return;
                    if (!n.params) return;
                    if (!n.params.includes("--")) return;
                    let o = [];
                    try {
                        o = transformAtMediaListTokens(n.params, t);
                    } catch (e) {
                        return void n.warn(a, `Failed to parse @custom-media params with error message: "${e instanceof Error ? e.message : e}"`);
                    }
                    if (!o || 0 === o.length) return;
                    if (1 === o.length) {
                        if (n.params.trim() === o[0].replaceWith.trim()) return;
                        return e.add(n), n.cloneBefore({
                            params: o[0].replaceWith.trim()
                        }), r ? void 0 : void n.remove();
                    }
                    if (!!!o.find((e)=>!!e.encapsulateWith?.length)) return e.add(n), n.cloneBefore({
                        params: o.map((e)=>e.replaceWith).join(",").trim()
                    }), void (r || n.remove());
                    o.forEach((r)=>{
                        if (!r.encapsulateWith?.length) return void n.cloneBefore({
                            params: r.replaceWith.trim()
                        });
                        const t = n.clone({
                            params: r.replaceWith
                        });
                        t.parent = void 0;
                        let a = n.clone({
                            params: r.encapsulateWith[0],
                            nodes: []
                        });
                        a.parent = void 0, a.append(t), r.encapsulateWith.slice(1).forEach((e)=>{
                            const r = n.clone({
                                params: e,
                                nodes: []
                            });
                            r.parent = void 0, r.append(a), a = r;
                        }), e.add(n), n.before(a);
                    }), r || n.remove();
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-custom-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const n = e.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(t) {
    const r = new Map, o = new Map, s = [];
    t.walkAtRules((t)=>{
        if ("layer" !== t.name.toLowerCase()) return;
        {
            let e = t.parent;
            for(; e;){
                if ("atrule" !== e.type || "layer" !== e.name.toLowerCase()) {
                    if (e === t.root()) break;
                    return;
                }
                e = e.parent;
            }
        }
        let a;
        if (t.nodes) a = normalizeLayerName(t.params, 1);
        else {
            if (!t.params.trim()) return;
            a = t.params;
        }
        let i = e.parse(a);
        if (i?.length) {
            {
                let e = t.parent;
                for(; e && "atrule" === e.type && "layer" === e.name.toLowerCase();){
                    const t = o.get(e);
                    t ? (i = i.map((e)=>t.concat(e)), e = e.parent) : e = e.parent;
                }
            }
            if (e.addLayerToModel(s, i), t.nodes) {
                const e = i[0].concat(n);
                r.set(t, e), o.set(t, i[0]);
            }
        }
    });
    for (const t of r.values())e.addLayerToModel(s, [
        t
    ]);
    const a = new WeakMap;
    for (const [e, t] of r)a.set(e, s.findIndex((e)=>t.equal(e)));
    return a;
}
function normalizeLayerName(e, t) {
    return e.trim() ? e : "csstools-anon-layer--" + t++;
}
const o = /(?:!\s*)?postcss-custom-properties:\s*off\b/i, s = new WeakMap;
function isBlockIgnored(e) {
    if (!e || !e.nodes) return !1;
    if (s.has(e)) return s.get(e);
    const t = e.some((e)=>isIgnoreComment(e, o));
    return s.set(e, t), t;
}
const a = /(?:!\s*)?postcss-custom-properties:\s*ignore\s+next\b/i;
function isDeclarationIgnored(e) {
    return !!e && (!!isBlockIgnored(e.parent) || isIgnoreComment(e.prev(), a));
}
function isIgnoreComment(e, t) {
    return !!e && "comment" === e.type && t.test(e.text);
}
const i = new Set([
    "layer"
]);
function isProcessableRule(e) {
    let t = e.parent;
    for(; t;){
        if ("atrule" === t.type && !i.has(t.name.toLowerCase())) return !1;
        t = t.parent;
    }
    return !0;
}
const c = /^html$/i, l = /^:where\(html\)$/i, u = /^:root$/i, p = /^:where\(:root\)$/i, f = /(html|:root)/i, d = /^var$/i;
function isVarFunction(e) {
    return "function" === e.type && d.test(e.value) && e.nodes?.length > 0;
}
const m = /\bvar\(/i;
function parseOrCached(e, r) {
    let n = r.get(e);
    return n || (n = t(e), r.set(e, n), n);
}
function toposort(e, t) {
    let r = e.length;
    const n = new Array(r), o = {};
    let s = r;
    const a = makeOutgoingEdges(t), i = makeNodesHash(e);
    for(; s--;)o[s] || visit(e[s], s, new Set);
    return n;
    "TURBOPACK unreachable";
    function visit(e, t, s) {
        if (s.has(e)) {
            let t;
            try {
                t = ", node was:" + JSON.stringify(e);
            } catch  {
                t = "";
            }
            throw new Error("Cyclic dependency" + t);
        }
        if (!i.has(e)) throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(e));
        if (o[t]) return;
        o[t] = !0;
        const c = Array.from(a.get(e) || new Set);
        if (t = c.length) {
            s.add(e);
            do {
                const e = c[--t];
                visit(e, i.get(e), s);
            }while (t)
            s.delete(e);
        }
        n[--r] = e;
    }
}
function removeCyclicReferences(e, t) {
    const r = new Set;
    for(; e.size > 0;){
        const n = findCyclicNode(Array.from(e.keys()), t);
        if (!n) return r;
        e.delete(n), r.add(n), t = t.filter((e)=>-1 === e.indexOf(n));
    }
    return r;
}
function findCyclicNode(e, t) {
    let r = e.length;
    const n = new Array(r), o = {};
    let s = r;
    const a = makeOutgoingEdges(t), i = makeNodesHash(e);
    for(; s--;)if (!o[s]) {
        const t = visit(e[s], s, new Set);
        if (!t) continue;
        return t;
    }
    function visit(e, t, s) {
        if (s.has(e)) return e;
        if (!i.has(e)) return;
        if (o[t]) return;
        o[t] = !0;
        const c = Array.from(a.get(e) || new Set);
        if (t = c.length) {
            s.add(e);
            do {
                const e = c[--t], r = visit(e, i.get(e), s);
                if (r) return r;
            }while (t)
            s.delete(e);
        }
        n[--r] = e;
    }
}
function makeOutgoingEdges(e) {
    const t = new Map;
    for(let r = 0, n = e.length; r < n; r++){
        const n = e[r];
        t.has(n[0]) || t.set(n[0], new Set), t.has(n[1]) || t.set(n[1], new Set), t.get(n[0]).add(n[1]);
    }
    return t;
}
function makeNodesHash(e) {
    const t = new Map;
    for(let r = 0, n = e.length; r < n; r++)t.set(e[r], r);
    return t;
}
function parseVarFunction(e) {
    let t, r, n = !1;
    for (const o of e.nodes)if (t || "word" !== o.type) if (!t || n || "div" !== o.type || "," !== o.value) {
        if (n && Array.isArray(r)) r.push(o);
        else if ("space" !== o.type && ("div" !== o.type || "" !== o.value.trim())) return;
    } else n = !0, r = [];
    else t = o;
    if (t) return {
        name: t,
        fallback: r
    };
}
function transformValueAST(e, r) {
    return e.nodes?.length ? (walk(e.nodes, (e, n, o)=>{
        if (!isVarFunction(e)) return;
        const s = parseVarFunction(e);
        if (!s) return;
        let a = !1;
        s.fallback && t.walk(s.fallback, (e)=>{
            if (!isVarFunction(e)) return;
            const t = parseVarFunction(e);
            return t ? t.fallback || r.has(t.name.value) ? void 0 : (a = !0, !1) : void 0;
        });
        let i = r.get(s.name.value)?.nodes;
        i || !s.fallback || a || (i = s.fallback), void 0 !== i && (i.length ? o.splice(n, 1, ...i) : o.splice(n, 1, {
            type: "div",
            value: " ",
            before: "",
            after: "",
            sourceIndex: e.sourceIndex,
            sourceEndIndex: e.sourceEndIndex
        }));
    }), t.stringify(e.nodes)) : "";
}
function walk(e, t) {
    let r, n, o;
    for(r = 0, n = e.length; r < n; r += 1)o = e[r], "function" === o.type && Array.isArray(o.nodes) && walk(o.nodes, t), t(o, r, e), n = e.length;
}
const w = /^initial$/i;
function isInitial(e) {
    const t = e.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
    return 1 === t.length && "word" === t[0].type && w.test(t[0].value);
}
function buildCustomPropertiesMap(e, r, n) {
    if (!e.size) return r;
    const o = new Map(r);
    {
        const s = [];
        for (const [a, i] of e.entries()){
            const c = parseOrCached(i, n);
            let l = !1;
            t.walk(c.nodes, (t)=>{
                if (!isVarFunction(t)) return;
                const n = parseVarFunction(t);
                n && (n.fallback || e.has(n.name.value) || r.has(n.name.value) ? s.push([
                    n.name.value,
                    a
                ]) : l = !0);
            }), l || o.set(a, c);
        }
        removeCyclicReferences(o, s);
    }
    {
        const e = [];
        for (const [r, n] of o.entries())t.walk(n.nodes, (t)=>{
            if (!isVarFunction(t)) return;
            const n = parseVarFunction(t);
            n && (n.fallback || o.has(n.name.value) ? e.push([
                n.name.value,
                r
            ]) : o.delete(r));
        });
        for(let t = 0; t < e.length; t++){
            const [r, n] = e[t];
            o.has(r) && o.has(n) || e.splice(t--, 1);
        }
        const r = toposort(Array.from(o.keys()), e);
        for (const e of r){
            const t = o.get(e);
            if (!t) continue;
            const r = parseOrCached(transformValueAST(t, o), n);
            o.set(e, r);
        }
    }
    for (const [e, t] of o.entries())isInitial(t) && o.delete(e);
    return o;
}
function getCustomPropertiesFromRoot(e, t) {
    const r = new Map, n = new Map, o = collectCascadeLayerOrder(e);
    return e.walkRules((e)=>{
        f.test(e.selector) && e.nodes?.length && isProcessableRule(e) && (isBlockIgnored(e) || e.selectors.forEach((t)=>{
            let s = -1;
            if (l.test(t) || p.test(t)) s = 0;
            else if (c.test(t)) s = 1;
            else {
                if (!u.test(t)) return;
                s = 2;
            }
            const a = (f = o, ((i = e).parent && "atrule" === i.parent.type && "layer" === i.parent.name.toLowerCase() ? f.has(i.parent) ? f.get(i.parent) + 1 : 0 : 1e7) + 10 + s);
            var i, f;
            e.each((e)=>{
                if ("decl" !== e.type) return;
                if (!e.variable || isDeclarationIgnored(e)) return;
                if ("initial" === e.value.toLowerCase().trim()) return;
                const t = n.get(e.prop) ?? -1;
                a >= t && (n.set(e.prop, a), r.set(e.prop, e.value));
            });
        }));
    }), buildCustomPropertiesMap(r, new Map, t);
}
function getCustomPropertiesFromSiblings(e, t, r) {
    if (!e.parent) return t;
    const n = new Map;
    return e.parent.each((t)=>{
        "decl" === t.type && t.variable && e !== t && (isDeclarationIgnored(t) || n.set(t.prop, t.value));
    }), n.size ? buildCustomPropertiesMap(n, t, r) : t;
}
function transformProperties(e, r, n) {
    if (isTransformableDecl(e) && !isDeclarationIgnored(e)) {
        const o = e.raws?.value?.raw ?? e.value, s = transformValueAST(t(o), r);
        if (s === o) return;
        if (parentHasExactFallback(e, s)) return void (n.preserve || e.remove());
        const a = e.cloneBefore({
            value: s
        });
        a.raws?.value?.raw && (a.raws.value.raw = ""), n?.preserve || e.remove();
    }
}
const isTransformableDecl = (e)=>!e.variable && e.value.includes("--") && e.value.toLowerCase().includes("var(");
function parentHasExactFallback(e, t) {
    if (!e || !e.parent) return !1;
    let r = !1;
    const n = e.parent.index(e);
    return e.parent.each((o, s)=>o !== e && !(s >= n) && void ("decl" === o.type && o.prop.toLowerCase() === e.prop.toLowerCase() && o.value === t && (r = !0))), r;
}
const v = /\bvar\(|\(top: var\(--f\)/i, creator = (e)=>{
    const t = !("preserve" in Object(e)) || Boolean(e?.preserve);
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-properties] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-properties] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-properties",
        prepare () {
            let e = new Map;
            const n = new WeakMap, o = new Map;
            return {
                postcssPlugin: "postcss-custom-properties",
                Once (t) {
                    e = getCustomPropertiesFromRoot(t, o);
                },
                Declaration (s) {
                    if (!m.test(s.value)) return;
                    if (r.hasSupportsAtRuleAncestor(s, v)) return;
                    let a = e;
                    t && s.parent && (a = n.get(s.parent) ?? getCustomPropertiesFromSiblings(s, e, o), n.set(s.parent, a)), transformProperties(s, a, {
                        preserve: t
                    });
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-custom-selectors/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-custom-selectors/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/cascade-layer-name-parser/dist/index.cjs [postcss] (ecmascript)");
const t = r.parse("csstools-implicit-layer")[0];
function collectCascadeLayerOrder(e) {
    const s = new Map, o = new Map, n = [];
    e.walkAtRules((e)=>{
        if ("layer" !== e.name.toLowerCase()) return;
        {
            let r = e.parent;
            for(; r;){
                if ("atrule" !== r.type || "layer" !== r.name.toLowerCase()) {
                    if (r === e.root()) break;
                    return;
                }
                r = r.parent;
            }
        }
        let a;
        if (e.nodes) a = normalizeLayerName(e.params, 1);
        else {
            if (!e.params.trim()) return;
            a = e.params;
        }
        let c = r.parse(a);
        if (c?.length) {
            {
                let r = e.parent;
                for(; r && "atrule" === r.type && "layer" === r.name.toLowerCase();){
                    const e = o.get(r);
                    e ? (c = c.map((r)=>e.concat(r)), r = r.parent) : r = r.parent;
                }
            }
            if (r.addLayerToModel(n, c), e.nodes) {
                const r = c[0].concat(t);
                s.set(e, r), o.set(e, c[0]);
            }
        }
    });
    for (const e of s.values())r.addLayerToModel(n, [
        e
    ]);
    const a = new WeakMap;
    for (const [e, r] of s)a.set(e, n.findIndex((e)=>r.equal(e)));
    return a;
}
function normalizeLayerName(e, r) {
    return e.trim() ? e : "csstools-anon-layer--" + r++;
}
const s = new Set([
    "scope",
    "container",
    "layer"
]);
function isProcessableCustomSelectorRule(e) {
    if ("atrule" !== e.type) return !1;
    if ("custom-selector" !== e.name.toLowerCase()) return !1;
    if (!e.params || !e.params.includes(":--")) return !1;
    if (e.nodes && e.nodes.length > 0) return !1;
    let r = e.parent;
    for(; r;){
        if ("rule" === r.type) return !1;
        if ("atrule" === r.type && !s.has(r.name.toLowerCase())) return !1;
        r = r.parent;
    }
    return !0;
}
function getCustomSelectors(r, t, s) {
    const o = new Map, n = new Map, a = collectCascadeLayerOrder(r);
    return r.walkAtRules((r)=>{
        var c, l;
        if (isProcessableCustomSelectorRule(r)) try {
            const t = r.params.trim(), p = e().astSync(t), u = p?.nodes?.[0]?.nodes?.[0];
            if (!u || "pseudo" !== u.type || !u.value.startsWith(":--")) return;
            const i = u.toString(), m = (l = a, (c = r).parent && "atrule" === c.parent.type && "layer" === c.parent.name.toLowerCase() ? l.has(c.parent) ? l.get(c.parent) + 1 : 0 : 1e7), f = n.get(i) ?? -1;
            if (m && m >= f && (n.set(i, m), o.set(i, e().astSync(t.slice(i.length).trim()))), !s.preserve) {
                const e = r.parent;
                r.remove(), removeEmptyAncestorBlocks(e);
            }
        } catch (e) {
            r.warn(t, `Failed to parse selector : "${r.params}" with message: "${e instanceof Error ? e.message : e}"`);
        }
    }), o;
}
function removeEmptyAncestorBlocks(e) {
    if (!e) return;
    let r = e;
    for(; r;){
        if (r.nodes && r.nodes.length > 0) return;
        const e = r.parent;
        r.remove(), r = e;
    }
}
function transformRule(r, t, s) {
    let o = r.selector;
    try {
        o = e((r)=>{
            r.walkPseudos((r)=>{
                if (!s.has(r.value)) return;
                const t = e.pseudo({
                    value: ":is",
                    nodes: []
                }), o = s.get(r.value);
                o && (o.each((e)=>{
                    t.append(e.clone());
                }), r.replaceWith(t));
            });
        }).processSync(r.selector);
    } catch (e) {
        return r.warn(t, `Failed to parse selector : "${o}" with message: "${e instanceof Error ? e.message : e}"`), r.selector;
    }
    return o;
}
const creator = (e)=>{
    const r = e?.preserve ?? !1;
    if ("importFrom" in Object(e)) throw new Error('[postcss-custom-selectors] "importFrom" is no longer supported');
    if ("exportTo" in Object(e)) throw new Error('[postcss-custom-selectors] "exportTo" is no longer supported');
    return {
        postcssPlugin: "postcss-custom-selectors",
        prepare () {
            const e = new WeakSet;
            let t = new Map;
            return {
                postcssPlugin: "postcss-custom-selectors",
                Once (e, { result: s }) {
                    t = getCustomSelectors(e, s, {
                        preserve: r
                    });
                },
                Rule (s, { result: o }) {
                    if (e.has(s)) return;
                    if (!s.selector?.includes(":--")) return;
                    const n = transformRule(s, o, t);
                    n !== s.selector && (e.add(s), s.cloneBefore({
                        selector: n
                    }), r || s.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-dir-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-dir-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const creator = (t)=>{
    const r = Object.assign({
        dir: null,
        preserve: !1,
        shadow: !1
    }, t);
    return {
        postcssPlugin: "postcss-dir-pseudo-class",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "postcss-dir-pseudo-class",
                Rule (o, { result: s }) {
                    if (t.has(o)) return;
                    let a, n = !1;
                    if (o.selector.toLowerCase().includes(":dir(")) {
                        try {
                            a = e((t)=>{
                                t.nodes.forEach((t)=>{
                                    t.walk((t)=>{
                                        if ("pseudo" !== t.type) return;
                                        if (":dir" !== t.value.toLowerCase()) return;
                                        if (!t.nodes || !t.nodes.length) return;
                                        const a = t.nodes.toString().toLowerCase();
                                        if ("rtl" !== a && "ltr" !== a) return;
                                        const l = t.parent;
                                        if (!l) return;
                                        l.nodes.filter((e)=>"pseudo" === e.type && ":dir" === e.value.toLowerCase()).length > 1 && !n && (n = !0, o.warn(s, `Hierarchical :dir pseudo class usage can't be transformed correctly to [dir] attributes. This will lead to incorrect selectors for "${o.selector}"`));
                                        const c = t.prev(), p = t.next(), i = c && c.type && "combinator" !== c.type, u = p && p.type && "combinator" !== p.type, d = p && p.type && ("combinator" !== p.type || "combinator" === p.type && " " === p.value);
                                        i || u || 0 === l.nodes.indexOf(t) && d || 1 === l.nodes.length ? t.remove() : t.replaceWith(e.universal());
                                        const v = l.nodes[0], f = v && "combinator" === v.type && " " === v.value, w = v && "tag" === v.type && "html" === v.value.toLowerCase(), y = v && "pseudo" === v.type && ":root" === v.value.toLowerCase();
                                        !v || w || y || f || l.prepend(e.combinator({
                                            value: " "
                                        }));
                                        const h = r.dir === a, b = e.attribute({
                                            attribute: "dir",
                                            operator: "=",
                                            quoteMark: '"',
                                            value: `"${a}"`,
                                            raws: {}
                                        }), m = e.pseudo({
                                            value: ":host-context"
                                        });
                                        m.append(e.selector({
                                            value: "",
                                            nodes: [
                                                b
                                            ]
                                        }));
                                        const g = e.pseudo({
                                            value: (w || y ? "" : "html") + ":not"
                                        });
                                        g.append(e.selector({
                                            value: "",
                                            nodes: [
                                                e.attribute({
                                                    attribute: "dir",
                                                    operator: "=",
                                                    quoteMark: '"',
                                                    value: `"${"ltr" === a ? "rtl" : "ltr"}"`,
                                                    raws: {}
                                                })
                                            ]
                                        })), h ? w ? l.insertAfter(v, g) : l.prepend(g) : w ? l.insertAfter(v, b) : r.shadow && !y ? l.prepend(m) : l.prepend(b);
                                    });
                                });
                            }).processSync(o.selector);
                        } catch  {
                            return void o.warn(s, `Failed to parse selector : ${o.selector}`);
                        }
                        void 0 !== a && a !== o.selector && (t.add(o), o.cloneBefore({
                            selector: a
                        }), r.preserve || o.remove());
                    }
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-normalize-display-values/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), l = new Map([
    [
        "block,flex",
        "flex"
    ],
    [
        "block,flow",
        "block"
    ],
    [
        "block,flow-root",
        "flow-root"
    ],
    [
        "block,grid",
        "grid"
    ],
    [
        "block,table",
        "table"
    ],
    [
        "inline,flex",
        "inline-flex"
    ],
    [
        "inline,flow",
        "inline"
    ],
    [
        "inline,flow,list-item",
        "inline list-item"
    ],
    [
        "inline,flow-root",
        "inline-block"
    ],
    [
        "inline,grid",
        "inline-grid"
    ],
    [
        "inline,ruby",
        "ruby"
    ],
    [
        "inline,table",
        "inline-table"
    ],
    [
        "list-item,block,flow",
        "list-item"
    ],
    [
        "ruby-base,flow",
        "ruby-base"
    ],
    [
        "ruby-text,flow",
        "ruby-text"
    ],
    [
        "run-in,flow",
        "run-in"
    ],
    [
        "table-caption,flow",
        "table-caption"
    ],
    [
        "table-cell,flow",
        "table-cell"
    ]
]);
function transform(n) {
    if (!n.trim()) return n;
    const { nodes: i } = e(n);
    if (i.length <= 1) return n;
    const t = i.filter((e)=>"word" === e.type).map((e)=>e.value.toLowerCase());
    if (t.length <= 1) return n;
    const o = l.get(t.join(","));
    return o || n;
}
const n = /^display$/i, creator = (e)=>{
    const l = !("preserve" in Object(e)) || Boolean(e?.preserve);
    return {
        postcssPlugin: "postcss-normalize-display-values",
        Declaration (e) {
            if (!n.test(e.prop)) return;
            const i = e.value;
            if (!i) return;
            const t = transform(i);
            e.value !== t && (e.cloneBefore({
                value: t
            }), l || e.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-double-position-gradients/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const r = /(?:repeating-)?(?:conic|linear|radial)-gradient\(/i, o = /^(?:repeating-)?(?:conic|linear|radial)-gradient$/i, i = [
    "at",
    "bottom",
    "center",
    "circle",
    "closest-corner",
    "closest-side",
    "ellipse",
    "farthest-corner",
    "farthest-side",
    "from",
    "in",
    "left",
    "right",
    "to",
    "top"
];
function isPunctuationCommaNode(e) {
    return !!e && "div" === e.type && "," === e.value;
}
function isNumericNode(e) {
    if (!e) return !1;
    try {
        return !1 !== t.unit(e.value);
    } catch  {
        return !1;
    }
}
const basePlugin = (e)=>({
        postcssPlugin: "postcss-double-position-gradients",
        Declaration (n, { result: a }) {
            if (!r.test(n.value)) return;
            if (s.hasFallback(n)) return;
            if (s.hasSupportsAtRuleAncestor(n, r)) return;
            let u;
            try {
                u = t(n.value);
            } catch  {
                n.warn(a, `Failed to parse value '${n.value}' as a CSS gradient. Leaving the original value intact.`);
            }
            if (void 0 === u) return;
            u.walk((e)=>{
                if ("function" !== e.type || !o.test(e.value)) return;
                const t = e.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
                let s = !1;
                t.forEach((t, r, o)=>{
                    if ("word" === t.type && i.includes(t.value.toLowerCase()) && (s = !0), "div" === t.type && "," === t.value && (s = !1), s) return;
                    const n = o[r - 1], a = o[r - 2], u = o[r + 1];
                    if (a && a.type && isNumericNode(n) && isNumericNode(t)) {
                        const s = a, r = {
                            type: "div",
                            value: ",",
                            before: isPunctuationCommaNode(u) ? u.before : "",
                            after: isPunctuationCommaNode(u) ? "" : " ",
                            sourceIndex: 0,
                            sourceEndIndex: 0
                        };
                        e.nodes.splice(e.nodes.indexOf(t) - 1, 0, r, s);
                    }
                });
            });
            const c = u.toString();
            c !== n.value && (n.cloneBefore({
                value: c
            }), e?.preserve || n.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (t)=>{
    const s = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, t);
    return s.enableProgressiveCustomProperties && s.preserve ? {
        postcssPlugin: "postcss-double-position-gradients",
        plugins: [
            e(),
            basePlugin(s)
        ]
    } : basePlugin(s);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-exponential-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:exp|hypot|log|pow|sqrt)\(/i, creator = (t)=>{
    const o = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-exponential-functions",
        Declaration (t) {
            if (!s.test(t.value)) return;
            const c = e.calc(t.value);
            c !== t.value && (t.cloneBefore({
                value: c
            }), o.preserve || t.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-float-and-clear/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const t = "inline-start", o = "inline-end";
var e, i;
function directionFlowToAxes(t) {
    switch(t){
        case e.TopToBottom:
            return [
                i.Top,
                i.Bottom
            ];
        case e.BottomToTop:
            return [
                i.Bottom,
                i.Top
            ];
        case e.RightToLeft:
            return [
                i.Right,
                i.Left
            ];
        case e.LeftToRight:
            return [
                i.Left,
                i.Right
            ];
    }
}
function cloneDeclaration(t, o, e) {
    t.parent && t.parent.some((t)=>"decl" == t.type && t.prop === e && t.value === o) || t.cloneBefore({
        value: o,
        prop: e
    });
}
!function(t) {
    t.TopToBottom = "top-to-bottom", t.BottomToTop = "bottom-to-top", t.RightToLeft = "right-to-left", t.LeftToRight = "left-to-right";
}(e || (e = {})), function(t) {
    t.Top = "top", t.Right = "right", t.Bottom = "bottom", t.Left = "left";
}(i || (i = {}));
const creator = (i)=>{
    const n = Object.assign({
        inlineDirection: e.LeftToRight
    }, i), c = Object.values(e);
    if (!c.includes(n.inlineDirection)) throw new Error(`[postcss-logical-float-and-clear] "inlineDirection" must be one of ${c.join(", ")}`);
    if (![
        e.LeftToRight,
        e.RightToLeft
    ].includes(n.inlineDirection)) return {
        postcssPlugin: "postcss-logical-float-and-clear",
        Once () {}
    };
    const [r, l] = directionFlowToAxes(n.inlineDirection), makeTransform = (e)=>{
        const i = e.value.toLowerCase();
        if (![
            t,
            o
        ].includes(i)) return;
        cloneDeclaration(e, i === t ? r : l, e.prop), e.remove();
    };
    return {
        postcssPlugin: "postcss-logical-float-and-clear",
        Declaration: {
            float: makeTransform,
            clear: makeTransform
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-focus-visible/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-focus-visible/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = "js-focus-visible", o = ":focus-visible", creator = (r)=>{
    const t = Object.assign({
        preserve: !0,
        replaceWith: ".focus-visible",
        disablePolyfillReadyClass: !1
    }, r), n = e().astSync(t.replaceWith);
    return {
        postcssPlugin: "postcss-focus-visible",
        prepare () {
            const r = new WeakSet;
            return {
                postcssPlugin: "postcss-focus-visible",
                Rule (l, { result: a }) {
                    if (r.has(l)) return;
                    if (!l.selector.toLowerCase().includes(o)) return;
                    const i = l.selectors.flatMap((r)=>{
                        if (!r.toLowerCase().includes(o)) return [
                            r
                        ];
                        let i;
                        try {
                            i = e().astSync(r);
                        } catch (e) {
                            return l.warn(a, `Failed to parse selector : "${r}" with message: "${e instanceof Error ? e.message : e}"`), r;
                        }
                        if (void 0 === i) return [
                            r
                        ];
                        let c = !1;
                        if (i.walkPseudos((e)=>{
                            e.value.toLowerCase() === o && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(n.clone({}))));
                        }), !c) return [
                            r
                        ];
                        const d = i.clone();
                        if (!t.disablePolyfillReadyClass) {
                            if (i.nodes?.[0]?.nodes?.length) for(let o = 0; o < i.nodes[0].nodes.length; o++){
                                const r = i.nodes[0].nodes[o];
                                if ("combinator" === r.type || e.isPseudoElement(r)) {
                                    i.nodes[0].insertBefore(r, e.className({
                                        value: s
                                    }));
                                    break;
                                }
                                if (o === i.nodes[0].nodes.length - 1) {
                                    i.nodes[0].append(e.className({
                                        value: s
                                    }));
                                    break;
                                }
                            }
                            return i.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: s
                            }))), [
                                i.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            i.toString()
                        ];
                    });
                    i.join(",") !== l.selectors.join(",") && (r.add(l), l.cloneBefore({
                        selectors: i
                    }), t.preserve || l.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-focus-within/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-focus-within/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const s = [
    " ",
    ">",
    "~",
    ":",
    "+",
    "@",
    "#",
    "(",
    ")"
];
function isValidReplacement(e) {
    let t = !0;
    for(let n = 0, o = s.length; n < o && t; n++)e.indexOf(s[n]) > -1 && (t = !1);
    return t;
}
const t = "js-focus-within", n = ":focus-within", creator = (s)=>{
    const o = Object.assign({
        preserve: !0,
        replaceWith: "[focus-within]",
        disablePolyfillReadyClass: !1
    }, s), r = e().astSync(o.replaceWith);
    return isValidReplacement(o.replaceWith) ? {
        postcssPlugin: "postcss-focus-within",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "postcss-focus-within",
                Rule (l, { result: i }) {
                    if (s.has(l)) return;
                    if (!l.selector.toLowerCase().includes(n)) return;
                    const a = l.selectors.flatMap((s)=>{
                        if (!s.toLowerCase().includes(n)) return [
                            s
                        ];
                        let a;
                        try {
                            a = e().astSync(s);
                        } catch (e) {
                            return l.warn(i, `Failed to parse selector : "${s}" with message: "${e instanceof Error ? e.message : e}"`), s;
                        }
                        if (void 0 === a) return [
                            s
                        ];
                        let c = !1;
                        if (a.walkPseudos((e)=>{
                            e.value.toLowerCase() === n && (e.nodes && e.nodes.length || (c = !0, e.replaceWith(r.clone({}))));
                        }), !c) return [
                            s
                        ];
                        const d = a.clone();
                        if (!o.disablePolyfillReadyClass) {
                            if (a.nodes?.[0]?.nodes?.length) for(let s = 0; s < a.nodes[0].nodes.length; s++){
                                const n = a.nodes[0].nodes[s];
                                if ("combinator" === n.type || e.isPseudoElement(n)) {
                                    a.nodes[0].insertBefore(n, e.className({
                                        value: t
                                    }));
                                    break;
                                }
                                if (s === a.nodes[0].nodes.length - 1) {
                                    a.nodes[0].append(e.className({
                                        value: t
                                    }));
                                    break;
                                }
                            }
                            return a.nodes?.[0]?.nodes && (d.nodes[0].prepend(e.combinator({
                                value: " "
                            })), d.nodes[0].prepend(e.className({
                                value: t
                            }))), [
                                a.toString(),
                                d.toString()
                            ];
                        }
                        return [
                            a.toString()
                        ];
                    });
                    a.join(",") !== l.selectors.join(",") && (s.add(l), l.cloneBefore({
                        selectors: a
                    }), o.preserve || l.remove());
                }
            };
        }
    } : {
        postcssPlugin: "postcss-focus-within",
        Once (e, { result: s }) {
            e.warn(s, `${o.replaceWith} is not a valid replacement since it can't be applied to single elements.`);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-font-format-keywords/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const o = [
    "woff",
    "truetype",
    "opentype",
    "woff2",
    "embedded-opentype",
    "collection",
    "svg"
], creator = (r)=>{
    const s = "preserve" in Object(r) && Boolean(r?.preserve);
    return {
        postcssPlugin: "postcss-font-format-keywords",
        Declaration (r) {
            if ("src" !== r.prop.toLowerCase()) return;
            if (!r.value.toLowerCase().includes("format(")) return;
            if (t.hasFallback(r)) return;
            const a = r.parent;
            if (!a || "atrule" !== a.type) return;
            if ("font-face" !== a.name.toLowerCase()) return;
            const n = e(r.value);
            n.walk((t)=>{
                "function" === t.type && "format" === t.value.toLowerCase() && t.nodes.forEach((t)=>{
                    "word" === t.type && o.includes(t.value.toLowerCase()) && (t.value = e.stringify({
                        type: "string",
                        value: t.value,
                        quote: '"'
                    }));
                });
            }), n.toString() !== r.value && (r.cloneBefore({
                value: n.toString()
            }), s || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-font-variant/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * font variant convertion map
 *
 * @type {Object}
 */ const fontVariantProperties = {
    "font-variant-ligatures": {
        "common-ligatures": "\"liga\", \"clig\"",
        "no-common-ligatures": "\"liga\", \"clig off\"",
        "discretionary-ligatures": "\"dlig\"",
        "no-discretionary-ligatures": "\"dlig\" off",
        "historical-ligatures": "\"hlig\"",
        "no-historical-ligatures": "\"hlig\" off",
        contextual: "\"calt\"",
        "no-contextual": "\"calt\" off"
    },
    "font-variant-position": {
        sub: "\"subs\"",
        "super": "\"sups\"",
        normal: "\"subs\" off, \"sups\" off"
    },
    "font-variant-caps": {
        "small-caps": "\"smcp\"",
        "all-small-caps": "\"smcp\", \"c2sc\"",
        "petite-caps": "\"pcap\"",
        "all-petite-caps": "\"pcap\", \"c2pc\"",
        unicase: "\"unic\"",
        "titling-caps": "\"titl\""
    },
    "font-variant-numeric": {
        "lining-nums": "\"lnum\"",
        "oldstyle-nums": "\"onum\"",
        "proportional-nums": "\"pnum\"",
        "tabular-nums": "\"tnum\"",
        "diagonal-fractions": "\"frac\"",
        "stacked-fractions": "\"afrc\"",
        ordinal: "\"ordn\"",
        "slashed-zero": "\"zero\""
    },
    "font-kerning": {
        normal: "\"kern\"",
        none: "\"kern\" off"
    },
    "font-variant": {
        normal: "normal",
        inherit: "inherit"
    }
};
// The `font-variant` property is a shorthand for all the others.
for(const prop in fontVariantProperties){
    const keys = fontVariantProperties[prop];
    for(const key in keys){
        if (!(key in fontVariantProperties["font-variant"])) {
            fontVariantProperties["font-variant"][key] = keys[key];
        }
    }
}
// Find font-feature-settings declaration before given declaration,
// create if does not exist
function getFontFeatureSettingsPrevTo(decl) {
    let fontFeatureSettings = null;
    decl.parent.walkDecls((decl)=>{
        if (decl.prop === "font-feature-settings") {
            fontFeatureSettings = decl;
        }
    });
    if (fontFeatureSettings === null) {
        fontFeatureSettings = decl.clone();
        fontFeatureSettings.prop = "font-feature-settings";
        fontFeatureSettings.value = "";
        decl.parent.insertBefore(decl, fontFeatureSettings);
    }
    return fontFeatureSettings;
}
function walkRule(rule) {
    let fontFeatureSettings = null;
    // read custom media queries
    rule.walkDecls((decl)=>{
        if (!fontVariantProperties[decl.prop]) {
            return null;
        }
        let newValue = decl.value;
        if (decl.prop === "font-variant") {
            newValue = decl.value.split(/\s+/g).map((val)=>{
                return fontVariantProperties["font-variant"][val];
            }).join(", ");
        } else if (fontVariantProperties[decl.prop][decl.value]) {
            newValue = fontVariantProperties[decl.prop][decl.value];
        }
        if (fontFeatureSettings === null) {
            fontFeatureSettings = getFontFeatureSettingsPrevTo(decl);
        }
        if (fontFeatureSettings.value && fontFeatureSettings.value !== newValue) {
            fontFeatureSettings.value += ", " + newValue;
        } else {
            fontFeatureSettings.value = newValue;
        }
    });
}
/**
 * Expose the font-variant plugin.
 */ module.exports = ()=>{
    return {
        postcssPlugin: "postcss-font-variant",
        Once (root) {
            root.walkRules(walkRule);
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/@csstools/postcss-gamut-mapping/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)");
const t = /\bcolor-gamut\b/i;
function hasConditionalAncestor(e) {
    let o = e.parent;
    for(; o;)if ("atrule" === o.type) {
        if ("media" === o.name.toLowerCase() && t.test(o.params)) return !0;
        o = o.parent;
    } else o = o.parent;
    return !1;
}
function sameProperty(e) {
    const o = e.prop.toLowerCase(), a = [], t = e.parent?.nodes ?? [];
    for(let e = 0; e < t.length; e++){
        const s = t[e];
        "decl" === s.type && s.prop.toLowerCase() === o && a.push(s);
    }
    return a;
}
const s = /\b(?:color|lab|lch|oklab|oklch)\(/i, n = /^(?:color|lab|lch|oklab|oklch)$/i, creator = ()=>({
        postcssPlugin: "postcss-gamut-mapping",
        prepare () {
            const t = new WeakMap, r = new WeakSet;
            return {
                postcssPlugin: "postcss-gamut-mapping",
                OnceExit (i, { postcss: l }) {
                    i.walkDecls((i)=>{
                        if (r.has(i)) return;
                        if (!s.test(i.value)) return;
                        if (!i.parent || hasConditionalAncestor(i)) return;
                        const c = sameProperty(i).map((t, s)=>{
                            r.add(t);
                            let i = !1;
                            const l = t.value, c = o.replaceComponentValues(o.parseCommaSeparatedListOfComponentValues(e.tokenize({
                                css: l
                            })), (e)=>{
                                if (!o.isFunctionNode(e) || !n.test(e.getName())) return;
                                const t = a.color(e);
                                return !t || t.syntaxFlags.has(a.SyntaxFlag.HasNoneKeywords) || a.colorDataFitsRGB_Gamut(t) ? void 0 : (i || a.colorDataFitsDisplayP3_Gamut(t) || (i = !0), a.serializeRGB(t, !0));
                            }), p = o.stringify(c);
                            return {
                                isRec2020: i,
                                matchesOriginal: p === l,
                                modifiedValue: p,
                                hasFallback: s > 0,
                                item: t
                            };
                        }), p = [];
                        c.reverse();
                        for (const e of c){
                            if (e.matchesOriginal) break;
                            p.push(e);
                        }
                        p.reverse(), p.forEach(({ isRec2020: e, modifiedValue: o, hasFallback: a, item: s })=>{
                            const n = s.parent;
                            if (!n) return;
                            const i = t.get(n) || {
                                conditionalRules: [],
                                propNames: new Set,
                                lastConditionParams: {
                                    media: void 0
                                },
                                lastConditionalRule: void 0
                            };
                            t.set(n, i);
                            const c = `(color-gamut: ${e ? "rec2020" : "p3"})`;
                            if (i.lastConditionParams.media !== c && (i.lastConditionalRule = void 0), !a) {
                                const e = s.cloneBefore({
                                    value: o
                                });
                                r.add(e);
                            }
                            if (i.lastConditionalRule) {
                                const e = s.clone();
                                return i.lastConditionalRule.append(e), r.add(e), void s.remove();
                            }
                            const p = l.atRule({
                                name: "media",
                                params: c,
                                source: n.source,
                                raws: {
                                    before: "\n\n",
                                    after: "\n"
                                }
                            }), u = n.clone();
                            u.removeAll(), u.raws.before = "\n";
                            const d = s.clone();
                            u.append(d), s.remove(), r.add(d), i.lastConditionParams.media = p.params, i.lastConditionalRule = u, p.append(u), i.conditionalRules.push(p);
                        });
                    }), i.walk((e)=>{
                        const o = t.get(e);
                        o && 0 !== o.conditionalRules.length && o.conditionalRules.reverse().forEach((o)=>{
                            e.after(o);
                        });
                    });
                }
            };
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-gap-properties/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = [
    "column-gap",
    "gap",
    "row-gap"
], creator = (o)=>{
    const r = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-gap-properties",
        Declaration (o) {
            if (!e.includes(o.prop.toLowerCase())) return;
            if (!o.parent?.some((e)=>"decl" === e.type && "display" === e.prop.toLowerCase() && "grid" === e.value.toLowerCase())) return;
            const s = `grid-${o.prop.toLowerCase()}`, p = o.parent?.some((e)=>"decl" === e.type && e.prop.toLowerCase() === s);
            p || (o.cloneBefore({
                prop: s
            }), r.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-gradients-interpolation-method/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)");
const s = /(?:repeating-)?(?:linear|radial|conic)-gradient\(/i, r = /\bin\b/i, a = {
    test: (e)=>s.test(e) && r.test(e)
}, l = /^(repeating-)?(linear|radial|conic)-gradient$/i;
function interpolateColorsInColorStopsList(e, o, s, r = !1) {
    const a = [], l = [];
    for(let r = 0; r < e.length - 1; r++){
        const a = e[r], c = e[r + 1];
        if (l.push(a), s || n.serializeP3(a.colorData, !1).toString() !== n.serializeP3(c.colorData, !1).toString() && a.position.toString() !== c.position.toString()) for(let e = 1; e <= 9; e++){
            const r = 10 * e;
            let u = [];
            s && (u = [
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                s,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Ident,
                    "hue",
                    -1,
                    -1,
                    {
                        value: "hue"
                    }
                ])
            ]);
            const p = new t.FunctionNode([
                i.TokenType.Function,
                "color-mix(",
                -1,
                -1,
                {
                    value: "color-mix"
                }
            ], [
                i.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], [
                new t.TokenNode([
                    i.TokenType.Ident,
                    "in",
                    -1,
                    -1,
                    {
                        value: "in"
                    }
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                o,
                ...u,
                new t.TokenNode([
                    i.TokenType.Comma,
                    ",",
                    -1,
                    -1,
                    void 0
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                a.color,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Percentage,
                    100 - r + "%",
                    -1,
                    -1,
                    {
                        value: 100 - r
                    }
                ]),
                new t.TokenNode([
                    i.TokenType.Comma,
                    ",",
                    -1,
                    -1,
                    void 0
                ]),
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                c.color,
                new t.WhitespaceNode([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ]),
                new t.TokenNode([
                    i.TokenType.Percentage,
                    `${r}%`,
                    -1,
                    -1,
                    {
                        value: r
                    }
                ])
            ]), d = n.color(p);
            if (!d) return !1;
            l.push({
                colorData: d
            });
        }
        r === e.length - 2 && l.push(c);
    }
    for(let e = 0; e < l.length; e++)r && !n.colorDataFitsRGB_Gamut(l[e].colorData) ? l[e].color = n.serializeP3(l[e].colorData, !1) : l[e].color = n.serializeRGB(l[e].colorData, !1);
    for(let e = 0; e < l.length; e++){
        const o = l[e];
        o.position ? a.push(o.color, new t.WhitespaceNode([
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]), o.position) : a.push(o.color), e !== l.length - 1 && a.push(new t.TokenNode([
            i.TokenType.Comma,
            ",",
            -1,
            -1,
            void 0
        ]), new t.WhitespaceNode([
            [
                i.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]));
    }
    return a;
}
function parseColorStops(e) {
    const o = [];
    let s = {};
    for(let r = 0; r < e.length; r++){
        const a = e[r];
        if (t.isCommentNode(a) || t.isWhitespaceNode(a)) continue;
        if (t.isTokenNode(a) && i.isTokenComma(a.value)) {
            if (s.color && s.colorData && s.positionA) {
                o.push({
                    color: s.color,
                    colorData: s.colorData,
                    position: s.positionA
                }), s.positionB && o.push({
                    color: s.color,
                    colorData: s.colorData,
                    position: s.positionB
                }), s = {};
                continue;
            }
            return !1;
        }
        const l = n.color(a);
        if (l) {
            if (s.color) return !1;
            if (l.syntaxFlags.has(n.SyntaxFlag.Experimental)) return !1;
            s.color = a, s.colorData = l;
        } else {
            if (!s.color) return !1;
            if (s.positionA) {
                if (!s.positionA || s.positionB) return !1;
                s.positionB = a;
            } else s.positionA = a;
        }
    }
    return !(!s.color || !s.positionA) && (s.color && s.colorData && s.positionA && (o.push({
        color: s.color,
        colorData: s.colorData,
        position: s.positionA
    }), s.positionB && o.push({
        color: s.color,
        colorData: s.colorData,
        position: s.positionB
    })), !(o.length < 2) && o);
}
const c = /^(?:srgb|srgb-linear|lab|oklab|xyz|xyz-d50|xyz-d65|hsl|hwb|lch|oklch)$/i, u = /^(?:hsl|hwb|lch|oklch)$/i, p = /^(?:shorter|longer|increasing|decreasing)$/i, d = /^in$/i, v = /^hue$/i;
function modifyGradientFunctionComponentValues(e, o = !1) {
    const n = e.getName();
    if (!l.test(n)) return !1;
    let s = "srgb", r = null, a = null, h = null, T = null, f = null, m = [];
    {
        let o = 0, n = e.value[o];
        for(; n && !(t.isTokenNode(n) && i.isTokenIdent(n.value) && d.test(n.value[4].value));){
            if (t.isTokenNode(n) && i.isTokenComma(n.value)) return !1;
            o++, n = e.value[o];
        }
        for(r = n, o++, n = e.value[o]; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && c.test(n.value[4].value)) {
            if (a) return !1;
            a = n, s = n.value[4].value, o++, n = e.value[o];
        }
        for(; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && p.test(n.value[4].value) && u.test(s)) {
            if (h || !a) return !1;
            h = n, o++, n = e.value[o];
        }
        for(; t.isCommentNode(n) || t.isWhitespaceNode(n);)o++, n = e.value[o];
        if (t.isTokenNode(n) && i.isTokenIdent(n.value) && v.test(n.value[4].value)) {
            if (T || !a || !h) return !1;
            T = n, o++, n = e.value[o];
        }
        for(; n && (!t.isTokenNode(n) || !i.isTokenComma(n.value));)o++, n = e.value[o];
        if (f = n, !f) return !1;
        m = e.value.slice(o + 1);
    }
    if (!a) return !1;
    if (h && !T) return !1;
    if (T && !h) return !1;
    const k = parseColorStops(m);
    if (!k) return !1;
    const g = interpolateColorsInColorStopsList(k, a, h, o);
    if (!g) return !1;
    const N = trim([
        ...e.value.slice(0, e.value.indexOf(r)),
        ...e.value.slice(e.value.indexOf(T || a) + 1, e.value.indexOf(f))
    ]);
    return N.length > 0 && N.some((e)=>!t.isCommentNode(e)) && N.push(new t.TokenNode([
        i.TokenType.Comma,
        ",",
        -1,
        -1,
        void 0
    ]), new t.WhitespaceNode([
        [
            i.TokenType.Whitespace,
            " ",
            -1,
            -1,
            void 0
        ]
    ])), trim([
        ...N,
        ...trim(g)
    ]);
}
function trim(e) {
    let o = 0, i = e.length - 1;
    for(let i = 0; i < e.length; i++)if (!t.isWhitespaceNode(e[i])) {
        o = i;
        break;
    }
    for(let o = e.length - 1; o >= 0; o--)if (!t.isWhitespaceNode(e[o])) {
        i = o;
        break;
    }
    return e.slice(o, i + 1);
}
const basePlugin = (e)=>({
        postcssPlugin: "postcss-gradients-interpolation-method",
        Declaration (n) {
            if (!a.test(n.value)) return;
            if (o.hasFallback(n)) return;
            if (o.hasSupportsAtRuleAncestor(n, a)) return;
            const s = i.tokenize({
                css: n.value
            }), r = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(s), (e)=>{
                if (!t.isFunctionNode(e)) return;
                const o = modifyGradientFunctionComponentValues(e);
                o && (e.value = o);
            }));
            if (r === n.value) return;
            const l = t.stringify(t.replaceComponentValues(t.parseCommaSeparatedListOfComponentValues(s), (e)=>{
                if (!t.isFunctionNode(e)) return;
                const o = modifyGradientFunctionComponentValues(e, !0);
                o && (e.value = o);
            }));
            n.cloneBefore({
                value: r
            }), r !== l && n.cloneBefore({
                value: l
            }), e?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (o)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, o);
    return t.enableProgressiveCustomProperties ? {
        postcssPlugin: "postcss-gradients-interpolation-method",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/css-has-pseudo/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
function encodeCSS(e) {
    if ("" === e) return "";
    let t, s = "";
    for(let r = 0; r < e.length; r++)t = e.charCodeAt(r).toString(36), s += 0 === r ? t : "-" + t;
    return "csstools-has-" + s;
}
function isGuardedByAtSupportsFromAtRuleParams(e) {
    if (!e.toLowerCase().includes(":has(")) return !1;
    let s = !1;
    try {
        const r = new Set;
        t(e).walk((e)=>{
            if ("function" === e.type && "selector" === e.value.toLowerCase()) return r.add(t.stringify(e.nodes)), !1;
        }), r.forEach((e)=>{
            selectorContainsHasPseudo(e) && (s = !0);
        });
    } catch  {}
    return s;
}
function selectorContainsHasPseudo(t) {
    if (!t.toLowerCase().includes(":has(")) return !1;
    let s = !1;
    try {
        e().astSync(t).walk((e)=>{
            if ("pseudo" === e.type && ":has" === e.value.toLowerCase() && e.nodes && e.nodes.length > 0) return s = !0, !1;
        });
    } catch  {}
    return s;
}
const creator = (t)=>{
    const r = {
        preserve: !0,
        specificityMatchingName: "does-not-exist",
        ...t || {}
    }, o = ":not(#" + r.specificityMatchingName + ")", n = ":not(." + r.specificityMatchingName + ")", a = ":not(" + r.specificityMatchingName + ")";
    return {
        postcssPlugin: "css-has-pseudo",
        prepare () {
            const t = new WeakSet;
            return {
                postcssPlugin: "css-has-pseudo",
                RuleExit (c, { result: i }) {
                    if (t.has(c)) return;
                    if (!c.selector.toLowerCase().includes(":has(") || isWithinSupportCheck(c)) return;
                    const l = c.selectors.map((t)=>{
                        if (!t.toLowerCase().includes(":has(")) return t;
                        let l;
                        try {
                            l = e().astSync(t);
                        } catch (e) {
                            return c.warn(i, `Failed to parse selector : "${t}" with message: "${e instanceof Error ? e.message : e}"`), t;
                        }
                        if (void 0 === l) return t;
                        l.walkPseudos((t)=>{
                            let s = t.parent, o = !1;
                            for(; s;)e.isPseudoClass(s) && ":has" === s.value.toLowerCase() && (o = !0), s = s.parent;
                            o && (":visited" === t.value.toLowerCase() && t.replaceWith(e.className({
                                value: r.specificityMatchingName
                            })), ":any-link" === t.value.toLowerCase() && (t.value = ":link"));
                        }), l.walkPseudos((t)=>{
                            if (":has" !== t.value.toLowerCase() || !t.nodes) return;
                            const r = t.parent;
                            if (!r) return;
                            const c = e.selector({
                                value: "",
                                nodes: []
                            });
                            {
                                let t = r.nodes.length;
                                e: for(let s = 0; s < r.nodes.length; s++){
                                    const o = r.nodes[s];
                                    if (e.isPseudoElement(o)) {
                                        for(let e = s - 1; e >= 0; e--)if ("combinator" !== r.nodes[s].type && "comment" !== r.nodes[s].type) {
                                            t = e + 1;
                                            break e;
                                        }
                                    }
                                }
                                r.nodes.slice(0, t).forEach((e)=>{
                                    e.remove(), "selector" === e.type ? e.nodes.forEach((e)=>{
                                        delete e.parent, c.append(e);
                                    }) : (delete e.parent, c.append(e));
                                });
                            }
                            const i = "[" + encodeCSS(c.toString()) + "]", l = s.selectorSpecificity(c);
                            let u = i;
                            for(let e = 0; e < l.a; e++)u += o;
                            const p = Math.max(1, l.b) - 1;
                            for(let e = 0; e < p; e++)u += n;
                            for(let e = 0; e < l.c; e++)u += a;
                            const d = e().astSync(u).nodes[0].nodes;
                            for(let e = d.length - 1; e >= 0; e--)r.prepend(d[e]);
                        });
                        const u = l.toString();
                        return u !== t ? ".js-has-pseudo " + u : t;
                    });
                    l.join(",") !== c.selectors.join(",") && (t.add(c), c.cloneBefore({
                        selectors: l
                    }), r.preserve || c.remove());
                }
            };
        }
    };
};
function isWithinSupportCheck(e) {
    let t = e.parent;
    for(; t;){
        if ("atrule" === t.type && isGuardedByAtSupportsFromAtRuleParams(t.params)) return !0;
        t = t.parent;
    }
    return !1;
}
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-color-hex-alpha/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const creator = (a)=>{
    const l = Object.assign({
        preserve: !1
    }, a);
    return {
        postcssPlugin: "postcss-color-hex-alpha",
        Declaration (a) {
            if (!t.test(a.value)) return;
            if (s.hasFallback(a)) return;
            const { value: c } = a, n = e(c);
            n.walk((e)=>{
                if ("function" === e.type && "url" === e.value) return !1;
                "word" === e.type && r.test(e.value) && hexa2rgba(e);
            });
            const o = n.toString();
            o !== c && (a.cloneBefore({
                value: o
            }), l.preserve || a.remove());
        }
    };
};
creator.postcss = !0;
const t = /#[0-9a-f]{4}(?:[0-9a-f]{4})?\b/i, r = /^#[0-9a-f]{4}(?:[0-9a-f]{4})?$/i, a = 1e5, l = /[0-9a-f]/gi;
function hexa2rgba(e) {
    const s = e.value, t = `0x${5 === s.length ? s.slice(1).replace(l, "$&$&") : s.slice(1)}`, [r, c, n, o] = [
        parseInt(t.slice(2, 4), 16),
        parseInt(t.slice(4, 6), 16),
        parseInt(t.slice(6, 8), 16),
        Math.round(parseInt(t.slice(8, 10), 16) / 255 * a) / a
    ];
    e.value = `rgba(${r},${c},${n},${o})`;
}
module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-hwb-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const a = /\bhwb\(/i, n = /^hwb$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-hwb-function",
        Declaration (i) {
            const c = i.value;
            if (!a.test(c)) return;
            if (t.hasFallback(i)) return;
            if (t.hasSupportsAtRuleAncestor(i, a)) return;
            const l = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: c
            })), (s)=>{
                if (!r.isFunctionNode(s) || !n.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), u = r.stringify(l);
            u !== c && (i.cloneBefore({
                value: u
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-hwb-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-ic-unit/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const t = /ic\b/i, o = /\(font-size: \d+ic\)/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-ic-unit",
        Declaration (i) {
            if (!t.test(i.value)) return;
            if (r.hasFallback(i)) return;
            if (r.hasSupportsAtRuleAncestor(i, o)) return;
            const u = e(i.value);
            u.walk((s)=>{
                if (!s.type || "word" !== s.type) return;
                const r = e.unit(s.value);
                r && "ic" === r.unit.toLowerCase() && (s.value = `${r.number}em`);
            });
            const c = String(u);
            c !== i.value && (i.cloneBefore({
                value: c
            }), s?.preserve || i.remove());
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const r = Object.assign({
        preserve: !1,
        enableProgressiveCustomProperties: !0
    }, e);
    return r.enableProgressiveCustomProperties && r.preserve ? {
        postcssPlugin: "postcss-ic-unit",
        plugins: [
            s(),
            basePlugin(r)
        ]
    } : basePlugin(r);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-image-set-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const n = /^(?:cross-fade|image|(?:repeating-)?(?:conic|linear|radial)-gradient|url|var)$/i;
function getImage(t) {
    return !(!t || !t.type) && ("string" === t.type ? "url(" + e.stringify(t) + ")" : !("function" !== t.type || !n.test(t.value)) && e.stringify(t));
}
const i = new Map([
    [
        "dpcm",
        2.54
    ],
    [
        "dpi",
        1
    ],
    [
        "dppx",
        96
    ],
    [
        "x",
        96
    ]
]);
function getMedia(e, t, n) {
    if ("boolean" == typeof e) return !1;
    const i = Math.floor(e / 96 * 100) / 100;
    return t.atRule({
        name: "media",
        params: `(-webkit-min-device-pixel-ratio: ${i}), (min-resolution: ${e}dpi)`,
        source: n.source
    });
}
function getMediaDPI(t) {
    if (!t) return !1;
    if ("word" !== t.type) return !1;
    if (!isNumericNode(t)) return !1;
    const n = e.unit(t.value);
    if (!n) return !1;
    const r = i.get(n.unit.toLowerCase());
    return !!r && Number(n.number) * r;
}
function isNumericNode(t) {
    if (!t || !t.value) return !1;
    try {
        return !1 !== e.unit(t.value);
    } catch  {
        return !1;
    }
}
const handleInvalidation = (e, t, n)=>{
    if ("warn" === e.oninvalid) e.decl.warn(e.result, t, {
        word: String(n)
    });
    else if ("throw" === e.oninvalid) throw e.decl.error(t, {
        word: String(n)
    });
}, processImageSet = (t, n, i)=>{
    const r = n.parent;
    if (!r) return;
    const o = new Map, s = n.value;
    for(let r = 0; r < t.length; r++){
        const { imageSetFunction: l, imageSetOptionNodes: u } = t[r], c = new Map, f = u.length;
        let p = -1;
        for(; p < f;){
            const t = p < 0 || !!(a = u[p]) && "div" === a.type && "," === a.value, r = getImage(u[p + 1]), f = getMediaDPI(u[p + 2]), d = getMedia(f, i.postcss, n);
            if (!t) return void handleInvalidation(i, "expected a comma", e.stringify(u));
            if (!r) return void handleInvalidation(i, "unexpected image", e.stringify(u));
            if (!d || !f || c.has(f)) return void handleInvalidation(i, "unexpected resolution", e.stringify(u));
            if (c.set(f, d), o.has(f)) {
                const t = o.get(f);
                t.value = t.value.replace(e.stringify(l), r.trim()), o.set(f, t);
            } else o.set(f, {
                atRule: d,
                value: s.replace(e.stringify(l), r.trim())
            });
            p += 3;
        }
    }
    var a;
    for (const { atRule: e, value: t } of o.values()){
        const i = r.clone().removeAll(), o = n.clone({
            value: t
        });
        i.append(o), e.append(i);
    }
    const l = Array.from(o.keys()).sort((e, t)=>e - t), u = l.map((e)=>o.get(e)?.atRule).filter((e)=>!!e);
    if (!u.length) return;
    const c = o.get(l[0])?.value;
    if (!c) return;
    const f = u.slice(1);
    f.length && r.after(f), n.cloneBefore({
        value: c.trim()
    }), i.preserve || (n.remove(), r.nodes?.length || r.remove());
}, r = /(?:^|[^\w-])(?:-webkit-)?image-set\(/i, o = /^(?:-webkit-)?image-set$/i, creator = (n)=>{
    const i = !("preserve" in Object(n)) || Boolean(n?.preserve), s = "onInvalid" in Object(n) ? n?.onInvalid : "ignore";
    if ("oninvalid" in Object(n)) throw new Error('"oninvalid" was changed to "onInvalid" to match other plugins with similar options');
    return {
        postcssPlugin: "postcss-image-set-function",
        Declaration (n, { result: a, postcss: l }) {
            const u = n.value;
            if (!r.test(u)) return;
            if (t.hasFallback(n)) return;
            let c;
            try {
                c = e(u);
            } catch  {
                n.warn(a, `Failed to parse value '${u}' as an image-set function. Leaving the original value intact.`);
            }
            if (void 0 === c) return;
            const f = [];
            c.walk((t)=>{
                if ("function" !== t.type) return;
                if (!o.test(t.value)) return;
                let i = !1;
                if (e.walk(t.nodes, (e)=>{
                    "function" === e.type && o.test(e.value) && (i = !0);
                }), i) return handleInvalidation({
                    decl: n,
                    oninvalid: s,
                    result: a
                }, "nested image-set functions are not allowed", e.stringify(t)), !1;
                const r = t.nodes.filter((e)=>"comment" !== e.type && "space" !== e.type);
                f.push({
                    imageSetFunction: t,
                    imageSetOptionNodes: r
                });
            }), processImageSet(f, n, {
                decl: n,
                oninvalid: s,
                preserve: i,
                result: a,
                postcss: l
            });
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-is-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)");
function alwaysValidSelector(s) {
    const o = e().astSync(s);
    let n = !0;
    return o.walk((e)=>{
        if ("class" !== e.type && "comment" !== e.type && "id" !== e.type && "root" !== e.type && "selector" !== e.type && "string" !== e.type && "tag" !== e.type && "universal" !== e.type && ("attribute" !== e.type || e.insensitive) && ("combinator" !== e.type || "+" !== e.value && ">" !== e.value && "~" !== e.value && " " !== e.value) && ("pseudo" !== e.type || e.nodes?.length || ":hover" !== e.value.toLowerCase() && ":focus" !== e.value.toLowerCase())) {
            if ("pseudo" === e.type && 1 === e.nodes?.length && ":not" === e.value.toLowerCase()) {
                let s = !0;
                if (e.nodes[0].walkCombinators(()=>{
                    s = !1;
                }), s) return;
            }
            return n = !1, !1;
        }
    }), n;
}
function sortCompoundSelectorsInsideComplexSelector(s) {
    if (!s || !s.nodes || 1 === s.nodes.length) return;
    const o = [];
    let n = [];
    for(let t = 0; t < s.nodes.length; t++)"combinator" !== s.nodes[t].type ? e.isPseudoElement(s.nodes[t]) ? (o.push(n), n = [
        s.nodes[t]
    ]) : n.push(s.nodes[t]) : (o.push(n), o.push([
        s.nodes[t]
    ]), n = []);
    o.push(n);
    const t = [];
    for(let e = 0; e < o.length; e++){
        const s = o[e];
        s.sort((e, s)=>"selector" === e.type && "selector" === s.type && e.nodes.length && s.nodes.length ? selectorTypeOrder(e.nodes[0], e.nodes[0].type) - selectorTypeOrder(s.nodes[0], s.nodes[0].type) : "selector" === e.type && e.nodes.length ? selectorTypeOrder(e.nodes[0], e.nodes[0].type) - selectorTypeOrder(s, s.type) : "selector" === s.type && s.nodes.length ? selectorTypeOrder(e, e.type) - selectorTypeOrder(s.nodes[0], s.nodes[0].type) : selectorTypeOrder(e, e.type) - selectorTypeOrder(s, s.type));
        const n = new Set(s.map((e)=>e.type)), r = n.has("universal") && (n.has("tag") || n.has("attribute") || n.has("class") || n.has("id") || n.has("pseudo"));
        for(let e = 0; e < s.length; e++)"universal" === s[e].type && r ? s[e].remove() : t.push(s[e]);
    }
    s.removeAll();
    for(let o = t.length - 1; o >= 0; o--){
        const n = t[o - 1];
        if (t[o].remove(), n && "tag" === n.type && "tag" === t[o].type) {
            const n = e.pseudo({
                value: ":is",
                nodes: [
                    e.selector({
                        value: "",
                        nodes: [
                            t[o]
                        ]
                    })
                ]
            });
            n.parent = s, s.nodes.unshift(n);
        } else t[o].parent = s, s.nodes.unshift(t[o]);
    }
}
function selectorTypeOrder(s, n) {
    return e.isPseudoElement(s) ? o.pseudoElement : o[n];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    id: 3,
    class: 4,
    attribute: 5,
    pseudo: 6,
    selector: 7,
    string: 8,
    root: 9,
    comment: 10
};
function childAdjacentChild(e) {
    return !(!e || !e.nodes) && "selector" === e.type && 3 === e.nodes.length && !(!e.nodes[0] || "pseudo" !== e.nodes[0].type || ":-csstools-matches" !== e.nodes[0].value) && !(!e.nodes[1] || "combinator" !== e.nodes[1].type || "+" !== e.nodes[1].value && "~" !== e.nodes[1].value) && !(!e.nodes[2] || "pseudo" !== e.nodes[2].type || ":-csstools-matches" !== e.nodes[2].value) && !(!e.nodes[0].nodes || 1 !== e.nodes[0].nodes.length) && "selector" === e.nodes[0].nodes[0].type && !(!e.nodes[0].nodes[0].nodes || 3 !== e.nodes[0].nodes[0].nodes.length) && !(!e.nodes[0].nodes[0].nodes || "combinator" !== e.nodes[0].nodes[0].nodes[1].type || ">" !== e.nodes[0].nodes[0].nodes[1].value) && !(!e.nodes[2].nodes || 1 !== e.nodes[2].nodes.length) && "selector" === e.nodes[2].nodes[0].type && !(!e.nodes[2].nodes[0].nodes || 3 !== e.nodes[2].nodes[0].nodes.length) && !(!e.nodes[2].nodes[0].nodes || "combinator" !== e.nodes[2].nodes[0].nodes[1].type || ">" !== e.nodes[2].nodes[0].nodes[1].value) && (e.nodes[0].nodes[0].insertAfter(e.nodes[0].nodes[0].nodes[0], e.nodes[2].nodes[0].nodes[0].clone()), e.nodes[2].nodes[0].nodes[1].remove(), e.nodes[2].nodes[0].nodes[0].remove(), e.nodes[0].replaceWith(e.nodes[0].nodes[0]), e.nodes[2].replaceWith(e.nodes[2].nodes[0]), !0);
}
function isInCompoundWithOneOtherElement(s) {
    if (!s || !s.nodes) return !1;
    if (!e.isSelector(s)) return !1;
    if (2 !== s.nodes.length) return !1;
    let o = -1, n = -1;
    s.nodes[0] && e.isPseudoClass(s.nodes[0]) && ":-csstools-matches" === s.nodes[0].value ? (o = 0, n = 1) : s.nodes[1] && e.isPseudoClass(s.nodes[1]) && ":-csstools-matches" === s.nodes[1].value && (o = 1, n = 0);
    const t = s.nodes[o];
    if (!t || !e.isPseudoClass(t) || 1 !== t.nodes.length) return !1;
    const r = s.nodes[n];
    return !!r && !e.isCombinator(r) && !e.isPseudoElement(r) && (t.nodes[0].append(r.clone()), t.replaceWith(...t.nodes[0].nodes), r.remove(), !0);
}
function isPseudoInFirstCompound(s) {
    if (!s || !s.nodes) return !1;
    if (!e.isSelector(s)) return !1;
    let o = -1;
    for(let n = 0; n < s.nodes.length; n++){
        const t = s.nodes[n];
        if (e.isCombinator(t)) return !1;
        if (e.isPseudoElement(t)) return !1;
        if (e.isPseudoClass(t)) {
            const e = t;
            if (":-csstools-matches" === e.value) {
                if (!e.nodes || 1 !== e.nodes.length) return !1;
                o = n;
                break;
            }
        }
    }
    if (-1 === o) return !1;
    const n = s.nodes[o];
    if (!n || !e.isPseudoClass(n)) return !1;
    const t = s.nodes.slice(0, o), r = s.nodes.slice(o + 1);
    return t.forEach((e)=>{
        n.nodes[0].append(e.clone());
    }), r.forEach((e)=>{
        n.nodes[0].append(e.clone());
    }), n.replaceWith(...n.nodes), t.forEach((e)=>{
        e.remove();
    }), r.forEach((e)=>{
        e.remove();
    }), !0;
}
function samePrecedingElement(s) {
    if (!s || !s.nodes) return !1;
    if ("selector" !== s.type) return !1;
    let o = -1;
    for(let n = 0; n < s.nodes.length; n++){
        const t = s.nodes[n];
        if (e.isCombinator(t)) {
            o = n;
            break;
        }
        if (e.isPseudoElement(t)) return !1;
    }
    if (-1 === o) return !1;
    const n = o + 1;
    if (!s.nodes[o] || "combinator" !== s.nodes[o].type || ">" !== s.nodes[o].value && "+" !== s.nodes[o].value) return !1;
    const t = s.nodes[o].value;
    if (!s.nodes[n] || "pseudo" !== s.nodes[n].type || ":-csstools-matches" !== s.nodes[n].value) return !1;
    if (!s.nodes[n].nodes || 1 !== s.nodes[n].nodes.length) return !1;
    if ("selector" !== s.nodes[n].nodes[0].type) return !1;
    if (!s.nodes[n].nodes[0].nodes || 3 !== s.nodes[n].nodes[0].nodes.length) return !1;
    if (!s.nodes[n].nodes[0].nodes || "combinator" !== s.nodes[n].nodes[0].nodes[1].type || s.nodes[n].nodes[0].nodes[1].value !== t) return !1;
    const r = s.nodes[n];
    if (!r || !e.isPseudoClass(r)) return !1;
    const d = s.nodes.slice(0, o), l = s.nodes.slice(n + 1);
    return s.each((e)=>{
        e.remove();
    }), d.forEach((e)=>{
        s.append(e);
    }), r.nodes[0].nodes.forEach((e)=>{
        s.append(e);
    }), l.forEach((e)=>{
        s.append(e);
    }), !0;
}
function complexSelectors(s, o, n, t) {
    return s.flatMap((s)=>{
        if (-1 === s.indexOf(":-csstools-matches") && -1 === s.toLowerCase().indexOf(":is")) return s;
        const r = e().astSync(s);
        return r.walkPseudos((s)=>{
            if (":is" === s.value.toLowerCase() && s.nodes && s.nodes.length && "selector" === s.nodes[0].type && 0 === s.nodes[0].nodes.length) return s.value = ":not", void s.nodes[0].append(e.universal());
            if (":-csstools-matches" === s.value) if (!s.nodes || s.nodes.length) {
                if (s.walkPseudos((s)=>{
                    if (e.isPseudoElement(s)) {
                        let e = s.value;
                        if (e.startsWith("::-csstools-invalid-")) return;
                        for(; e.startsWith(":");)e = e.slice(1);
                        s.value = `::-csstools-invalid-${e}`, t();
                    }
                }), 1 === s.nodes.length && "selector" === s.nodes[0].type) {
                    if (1 === s.nodes[0].nodes.length) return void s.replaceWith(s.nodes[0].nodes[0]);
                    if (!s.nodes[0].some((e)=>"combinator" === e.type)) return void s.replaceWith(...s.nodes[0].nodes);
                }
                1 !== r.nodes.length || "selector" !== r.nodes[0].type || 1 !== r.nodes[0].nodes.length || r.nodes[0].nodes[0] !== s ? childAdjacentChild(s.parent) || isInCompoundWithOneOtherElement(s.parent) || isPseudoInFirstCompound(s.parent) || samePrecedingElement(s.parent) || ("warning" === o.onComplexSelector && n(), s.value = ":is") : s.replaceWith(...s.nodes[0].nodes);
            } else s.remove();
        }), r.walk((e)=>{
            "selector" === e.type && "nodes" in e && 1 === e.nodes.length && "selector" === e.nodes[0].type && e.replaceWith(e.nodes[0]);
        }), r.walk((e)=>{
            "nodes" in e && sortCompoundSelectorsInsideComplexSelector(e);
        }), r.toString();
    }).filter((e)=>!!e);
}
function splitSelectors(o, n, t = 0) {
    const r = ":not(#" + n.specificityMatchingName + ")", d = ":not(." + n.specificityMatchingName + ")", l = ":not(" + n.specificityMatchingName + ")";
    return o.flatMap((o)=>{
        if (-1 === o.toLowerCase().indexOf(":is")) return o;
        let i = !1;
        const a = [];
        if (e().astSync(o).walkPseudos((e)=>{
            if (":is" !== e.value.toLowerCase() || !e.nodes || !e.nodes.length) return;
            if ("selector" === e.nodes[0].type && 0 === e.nodes[0].nodes.length) return;
            if ("pseudo" === e.parent?.parent?.type && ":not" === e.parent?.parent?.value?.toLowerCase()) return void a.push([
                {
                    start: e.parent.parent.sourceIndex,
                    end: e.parent.parent.sourceIndex + e.parent.parent.toString().length,
                    option: `:not(${e.nodes.toString()})`
                }
            ]);
            if ("pseudo" === e.parent?.parent?.type && ":has" === e.parent?.parent?.value?.toLowerCase()) return void (e.value = ":-csstools-matches");
            let o = e.parent;
            for(; o;){
                if (o.value && ":is" === o.value.toLowerCase() && "pseudo" === o.type) return void (i = !0);
                o = o.parent;
            }
            const n = s.selectorSpecificity(e), t = e.sourceIndex, c = t + e.toString().length, u = [];
            e.nodes.forEach((e)=>{
                const o = {
                    start: t,
                    end: c,
                    option: ""
                }, i = s.selectorSpecificity(e);
                let a = e.toString().trim();
                const p = Math.max(0, n.a - i.a), h = Math.max(0, n.b - i.b), f = Math.max(0, n.c - i.c);
                for(let e = 0; e < p; e++)a += r;
                for(let e = 0; e < h; e++)a += d;
                for(let e = 0; e < f; e++)a += l;
                o.option = a, u.push(o);
            }), a.push(u);
        }), !a.length) return [
            o
        ];
        let c = [];
        return cartesianProduct(...a).forEach((e)=>{
            let s = "";
            for(let n = 0; n < e.length; n++){
                const t = e[n];
                s += o.substring(e[n - 1]?.end || 0, e[n].start), s += ":-csstools-matches(" + t.option + ")", n === e.length - 1 && (s += o.substring(e[n].end));
            }
            c.push(s);
        }), i && t < 10 && (c = splitSelectors(c, n, t + 1)), c;
    }).filter((e)=>!!e);
}
function cartesianProduct(...e) {
    const s = [], o = e.length - 1;
    return function helper(n, t) {
        for(let r = 0, d = e[t].length; r < d; r++){
            const d = n.slice(0);
            d.push(e[t][r]), t === o ? s.push(d) : helper(d, t + 1);
        }
    }([], 0), s;
}
const n = /:is\(/i, creator = (e)=>{
    const s = {
        specificityMatchingName: "does-not-exist",
        ...e || {}
    };
    return {
        postcssPlugin: "postcss-is-pseudo-class",
        prepare () {
            const e = new WeakSet;
            return {
                postcssPlugin: "postcss-is-pseudo-class",
                Rule (o, { result: t }) {
                    if (!o.selector) return;
                    if (!n.test(o.selector)) return;
                    if (e.has(o)) return;
                    let r = !1;
                    const warnOnComplexSelector = ()=>{
                        "warning" === s.onComplexSelector && (r || (r = !0, o.warn(t, `Complex selectors in '${o.selector}' can not be transformed to an equivalent selector without ':is()'.`)));
                    };
                    let d = !1;
                    const warnOnPseudoElements = ()=>{
                        "warning" === s.onPseudoElement && (d || (d = !0, o.warn(t, `Pseudo elements are not allowed in ':is()', unable to transform '${o.selector}'`)));
                    };
                    try {
                        let n = !1;
                        const t = [], r = complexSelectors(splitSelectors(o.selectors, {
                            specificityMatchingName: s.specificityMatchingName
                        }), {
                            onComplexSelector: s.onComplexSelector
                        }, warnOnComplexSelector, warnOnPseudoElements);
                        if (Array.from(new Set(r)).forEach((s)=>{
                            if (o.selectors.indexOf(s) > -1) t.push(s);
                            else {
                                if (alwaysValidSelector(s)) return t.push(s), void (n = !0);
                                e.add(o), o.cloneBefore({
                                    selector: s
                                }), n = !0;
                            }
                        }), t.length && n && (e.add(o), o.cloneBefore({
                            selectors: t
                        })), !s.preserve) {
                            if (!n) return;
                            o.remove();
                        }
                    } catch (e) {
                        if (!(e instanceof Error)) throw e;
                        if (e.message.indexOf("call stack size exceeded") > -1) throw e;
                        o.warn(t, `Failed to parse selector "${o.selector}" with error: ${e.message}`);
                    }
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-lab-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:lab|lch)\(/i, l = /^(?:lab|lch)$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-lab-function",
        Declaration (n) {
            const i = n.value;
            if (!o.test(i)) return;
            if (t.hasFallback(n)) return;
            if (t.hasSupportsAtRuleAncestor(n, o)) return;
            const u = r.tokenize({
                css: i
            }), c = a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), p = a.stringify(c);
            if (p === i) return;
            let g = p;
            s?.subFeatures.displayP3 && (g = a.stringify(a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.colorDataFitsRGB_Gamut(t) ? e.serializeRGB(t) : e.serializeP3(t) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && g !== p && n.cloneBefore({
                value: g
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return t.subFeatures = Object.assign({
        displayP3: !0
    }, t.subFeatures), t.enableProgressiveCustomProperties && (t.preserve || t.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-lab-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-light-dark-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const s = "--csstools-color-scheme--light", n = "initial";
function toggleNameGenerator(e) {
    return `--csstools-light-dark-toggle--${e}`;
}
const i = /dark/i, a = /light/i;
function colorSchemes(e) {
    const t = o.tokenize({
        css: e
    });
    let r = !1, s = !1;
    return t.forEach((e)=>{
        o.isTokenIdent(e) && (a.test(e[4].value) ? r = !0 : i.test(e[4].value) && (s = !0));
    }), [
        r,
        s
    ];
}
const c = /^light-dark$/i;
function isComma(e) {
    return r.isTokenNode(e) && o.isTokenComma(e.value);
}
function parseLightDark(e) {
    if (!r.isFunctionNode(e) || !c.test(e.getName())) return !1;
    const o = e.value.filter((e)=>!r.isWhitespaceNode(e) && !r.isCommentNode(e));
    if (3 !== o.length) return !1;
    let t = o[0];
    const s = o[1];
    let n = o[2];
    if (!t || !s || !n) return !1;
    if (!isComma(s)) return !1;
    if (isComma(t) || isComma(n)) return !1;
    if (r.isFunctionNode(t)) {
        const e = [
            t
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, !0);
        }), [t] = e;
    }
    if (r.isFunctionNode(n)) {
        const e = [
            n
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, !1);
        }), [n] = e;
    }
    return [
        t,
        n
    ];
}
function recurseLightDark(e, o, t, s) {
    if ("number" != typeof t) return;
    const n = parseLightDark(e);
    if (!n) return;
    let i = n[s ? 0 : 1];
    if (r.isFunctionNode(i)) {
        const e = [
            i
        ];
        r.walk(e, ({ node: e, parent: o }, t)=>{
            recurseLightDark(e, o, t, s);
        }), [i] = e;
    }
    o.value[t] = i;
}
function transformLightDark(e, t) {
    const n = new Map, i = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(o.tokenize({
        css: e
    })), (e)=>{
        const i = parseLightDark(e);
        if (!i) return;
        const [a, c] = i, u = t();
        return n.set(u, `var(${s}) ${c.toString()}`), new r.FunctionNode([
            o.TokenType.Function,
            "var(",
            -1,
            -1,
            {
                value: "var"
            }
        ], [
            o.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], [
            new r.TokenNode([
                o.TokenType.Ident,
                u,
                -1,
                -1,
                {
                    value: u
                }
            ]),
            new r.TokenNode([
                o.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]),
            new r.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            a
        ]);
    });
    return {
        value: r.stringify(i),
        toggles: n
    };
}
function newNestedRuleWithSupportsNot(e, o, t, r) {
    const s = o({
        selector: "& *",
        source: e.source
    });
    if (!r) return {
        inner: s,
        outer: s
    };
    const n = t({
        name: "supports",
        params: "not (color: light-dark(tan, tan))",
        source: e.source
    });
    return n.append(s), {
        inner: s,
        outer: n
    };
}
const u = /^color-scheme$/i, l = /\blight-dark\(/i, basePlugin = (e)=>({
        postcssPlugin: "postcss-light-dark-function",
        prepare () {
            let o = 0;
            const currentToggleNameGenerator = ()=>toggleNameGenerator(o++), r = new Map;
            return {
                postcssPlugin: "postcss-light-dark-function",
                Declaration (o, { atRule: i, rule: a }) {
                    const c = o.parent;
                    if (c) {
                        if (u.test(o.prop)) {
                            if (c.some((e)=>"decl" === e.type && e.prop === s)) return;
                            const [e, t] = colorSchemes(o.value);
                            if (e && t) {
                                o.cloneBefore({
                                    prop: s,
                                    value: n
                                });
                                const e = c.clone();
                                e.removeAll(), e.append(o.clone({
                                    prop: s,
                                    value: " "
                                }));
                                const t = i({
                                    name: "media",
                                    params: "(prefers-color-scheme: dark)",
                                    source: c.source
                                });
                                return t.append(e), void c.after(t);
                            }
                            return t ? void o.cloneBefore({
                                prop: s,
                                value: " "
                            }) : e ? void o.cloneBefore({
                                prop: s,
                                value: n
                            }) : void 0;
                        }
                        if (l.test(o.value)) {
                            if (t.hasFallback(o)) return;
                            if (t.hasSupportsAtRuleAncestor(o, l)) return;
                            const s = transformLightDark(o.value, currentToggleNameGenerator);
                            if (s.value === o.value) return;
                            for (const [e, t] of s.toggles)o.cloneBefore({
                                prop: e,
                                value: t
                            });
                            if (o.cloneBefore({
                                value: s.value
                            }), o.variable && o.parent) {
                                const t = r.get(o.parent) ?? newNestedRuleWithSupportsNot(o, a, i, e?.preserve);
                                for (const [e, r] of s.toggles)t.inner.append(o.clone({
                                    prop: e,
                                    value: r
                                }));
                                t.inner.append(o.clone({
                                    value: s.value
                                })), r.has(o.parent) || (o.parent.append(t.outer), r.set(o.parent, t));
                            }
                            e?.preserve || o.remove();
                        }
                    }
                }
            };
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (o)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !0
    }, o);
    return t.enableProgressiveCustomProperties && t.preserve ? {
        postcssPlugin: "postcss-light-dark-function",
        plugins: [
            e(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-logical-overflow/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o;
function transformAxes(o, t) {
    const e = t ? "-x" : "-y", i = t ? "-y" : "-x", n = o.prop.toLowerCase().replace("-inline", e).replace("-block", i), s = o.value;
    o.parent?.some((o)=>"decl" == o.type && o.prop === n && o.value === s) || (o.cloneBefore({
        prop: n,
        value: s
    }), o.remove());
}
!function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(o || (o = {}));
const creator = (t)=>{
    const e = Object.assign({
        inlineDirection: o.LeftToRight
    }, t);
    switch(e.inlineDirection){
        case o.LeftToRight:
        case o.RightToLeft:
        case o.TopToBottom:
        case o.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(o).join(", ")}`);
    }
    const i = [
        o.LeftToRight,
        o.RightToLeft
    ].includes(e.inlineDirection);
    return {
        postcssPlugin: "postcss-logical-overflow",
        Declaration: {
            "overflow-block": (o)=>transformAxes(o, i),
            "overflow-inline": (o)=>transformAxes(o, i)
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-overscroll-behavior/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o;
function transformAxes(o, t) {
    const e = t ? "-x" : "-y", i = t ? "-y" : "-x", r = o.prop.toLowerCase().replace("-inline", e).replace("-block", i), s = o.value;
    o.parent?.some((o)=>"decl" == o.type && o.prop === r && o.value === s) || (o.cloneBefore({
        prop: r,
        value: s
    }), o.remove());
}
!function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(o || (o = {}));
const creator = (t)=>{
    const e = Object.assign({
        inlineDirection: o.LeftToRight
    }, t);
    switch(e.inlineDirection){
        case o.LeftToRight:
        case o.RightToLeft:
        case o.TopToBottom:
        case o.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(o).join(", ")}`);
    }
    const i = [
        o.LeftToRight,
        o.RightToLeft
    ].includes(e.inlineDirection);
    return {
        postcssPlugin: "postcss-logical-overscroll-behavior",
        Declaration: {
            "overscroll-behavior-block": (o)=>transformAxes(o, i),
            "overscroll-behavior-inline": (o)=>transformAxes(o, i)
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-logical/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var r, e, n = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
!function(r) {
    r.Block = "block", r.Inline = "inline";
}(r || (r = {})), function(r) {
    r.Start = "start", r.End = "end";
}(e || (e = {}));
const o = {
    BlockStart: "block-start",
    BlockEnd: "block-end",
    InlineStart: "inline-start",
    InlineEnd: "inline-end"
};
var t, i;
function directionFlowToAxes(r) {
    switch(r){
        case t.TopToBottom:
            return [
                i.Top,
                i.Bottom
            ];
        case t.BottomToTop:
            return [
                i.Bottom,
                i.Top
            ];
        case t.RightToLeft:
            return [
                i.Right,
                i.Left
            ];
        case t.LeftToRight:
            return [
                i.Left,
                i.Right
            ];
    }
}
function cloneDeclaration(r, e, n) {
    return r.parent && r.parent.some((r)=>"decl" == r.type && r.prop === n && r.value === e) ? [] : [
        r.clone({
            value: e,
            prop: n
        })
    ];
}
function transformTransition(r, e, o) {
    const { prop: t, value: i } = r, l = n(i), a = [];
    let s = [];
    l.nodes.forEach((r)=>{
        if ("div" === r.type && "," === r.value) return a.push(s), void (s = []);
        s.push(r);
    }), a.push(s);
    for(let r = 0; r < a.length; r++){
        const n = a[r];
        for(let t = 0; t < n.length; t++){
            const i = n[t];
            if ("word" !== i.type) continue;
            const l = i.value.toLowerCase(), s = o[l];
            if (!s) continue;
            const d = s(e.decl({
                prop: l,
                value: "initial"
            }));
            if (0 !== d.length) {
                for(let e = d.length - 1; e >= 0; e--){
                    const o = JSON.parse(JSON.stringify(n));
                    o[t].value = d[e].prop, a.splice(r + 1, 0, o);
                }
                a.splice(r, 1), r++;
            }
        }
    }
    const d = [];
    for(let r = 0; r < a.length; r++){
        const e = a[r];
        d.push(...e), r !== a.length - 1 && d.push({
            type: "div",
            value: ",",
            sourceIndex: 0,
            sourceEndIndex: 0,
            before: "",
            after: " "
        });
    }
    const c = n.stringify(d);
    return c !== i ? cloneDeclaration(r, c, t) : [];
}
function parseValueCouple(r) {
    const e = n(r.value).nodes.filter((r)=>"space" !== r.type);
    if (e.length > 2 || 0 === e.length) {
        const n = `[postcss-logical] Invalid number of values for ${r.prop}. Found ${e.length} values, expected 1 or 2.`;
        throw r.error(n);
    }
    let o, t;
    return 1 === e.length ? (o = n.stringify(e[0]), t = o) : (o = n.stringify(e[0]), t = n.stringify(e[1])), [
        o,
        t
    ];
}
function transformBorder(r, e) {
    return (n)=>cloneDeclaration(n, n.value, `border-${e}-${r}`);
}
function transformBorderProperty(r, e) {
    return (n)=>{
        const [o, t] = e, [i, l] = parseValueCouple(n);
        return [
            ...cloneDeclaration(n, i, `border-${o}-${r}`),
            ...cloneDeclaration(n, l, `border-${t}-${r}`)
        ];
    };
}
function transformBorderShorthand(r) {
    return (e)=>r.flatMap((r)=>cloneDeclaration(e, e.value, `border-${r}`));
}
function transformBorderRadius(r) {
    return (e)=>{
        let n;
        switch(e.prop.toLowerCase()){
            case "border-start-start-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[0]}-${r.inline[0]}` : `${r.inline[0]}-${r.block[0]}`}-radius`;
                break;
            case "border-start-end-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[0]}-${r.inline[1]}` : `${r.inline[1]}-${r.block[0]}`}-radius`;
                break;
            case "border-end-start-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[1]}-${r.inline[0]}` : `${r.inline[0]}-${r.block[1]}`}-radius`;
                break;
            case "border-end-end-radius":
                n = `border-${r.inlineIsHorizontal ? `${r.block[1]}-${r.inline[1]}` : `${r.inline[1]}-${r.block[1]}`}-radius`;
                break;
        }
        return n ? cloneDeclaration(e, e.value, n) : [];
    };
}
function transformLogicalSize(r) {
    return (e)=>{
        const { value: n } = e, o = r.inlineIsHorizontal ? "width" : "height", t = r.inlineIsHorizontal ? "height" : "width", i = e.prop.toLowerCase().replace("inline-size", o).replace("block-size", t);
        return cloneDeclaration(e, n, i);
    };
}
function transformOffset(r) {
    return (e)=>cloneDeclaration(e, e.value, r);
}
function transformOffsetShorthand(r) {
    return (e)=>{
        const [n, o] = r, [t, i] = parseValueCouple(e);
        return [
            ...cloneDeclaration(e, t, n),
            ...cloneDeclaration(e, i, o)
        ];
    };
}
function transformSide(r, e) {
    return (n)=>cloneDeclaration(n, n.value, `${r}-${e}`);
}
function transformSideShorthand(r, e) {
    return (n)=>{
        const [o, t] = e, [i, l] = parseValueCouple(n);
        return [
            ...cloneDeclaration(n, i, `${r}-${o}`),
            ...cloneDeclaration(n, l, `${r}-${t}`)
        ];
    };
}
function logicalToPhysical(r, e) {
    const [n, t] = e.block, [i, l] = e.inline;
    switch(r){
        case o.BlockStart:
            return n;
        case o.BlockEnd:
            return t;
        case o.InlineStart:
            return i;
        case o.InlineEnd:
            return l;
        default:
            throw new Error("Unsupported logical direction");
    }
}
function doTransform(r, e, o) {
    const { prop: t, value: i } = r, l = n(i);
    l.nodes.forEach((r)=>{
        if ("word" === r.type) {
            const n = r.value.toLowerCase();
            e.includes(n) && (r.value = logicalToPhysical(n, o));
        }
    });
    const a = l.toString();
    return a !== i ? cloneDeclaration(r, a, t) : [];
}
function prepareTransforms(r, t, i, l, a) {
    return {
        "caption-side": (d = r, (r)=>doTransform(r, Object.values(o), d)),
        "text-align": r.inlineIsHorizontal ? (s = r.inline, (r)=>{
            const { prop: o, value: t } = r, i = n(t), [l, a] = s;
            i.nodes.forEach((r)=>{
                if ("word" === r.type) {
                    const n = r.value.toLowerCase();
                    if (n === e.End) return void (r.value = a);
                    if (n === e.Start) return void (r.value = l);
                }
            });
            const d = i.toString();
            return d !== t ? cloneDeclaration(r, d, o) : [];
        }) : null,
        "block-size": transformLogicalSize(r),
        "inline-size": transformLogicalSize(r),
        "min-block-size": transformLogicalSize(r),
        "max-block-size": transformLogicalSize(r),
        "min-inline-size": transformLogicalSize(r),
        "max-inline-size": transformLogicalSize(r),
        "margin-block-start": transformSide("margin", t),
        "margin-block-end": transformSide("margin", i),
        "margin-inline-start": transformSide("margin", l),
        "margin-inline-end": transformSide("margin", a),
        "margin-block": transformSideShorthand("margin", r.block),
        "margin-inline": transformSideShorthand("margin", r.inline),
        "inset-block": transformOffsetShorthand(r.block),
        "inset-block-start": transformOffset(t),
        "inset-block-end": transformOffset(i),
        "inset-inline": transformOffsetShorthand(r.inline),
        "inset-inline-start": transformOffset(l),
        "inset-inline-end": transformOffset(a),
        inset: (r)=>{
            const e = n(r.value).nodes.filter((r)=>"space" !== r.type && "comment" !== r.type);
            if (e.length > 4) {
                const n = `[postcss-logical] Invalid number of values for ${r.prop}. Found ${e.length} values, expected up to 4 values.`;
                throw r.error(n);
            }
            let o, t, i, l;
            if (1 === e.length) o = n.stringify(e[0]), t = o, i = o, l = o;
            else if (2 === e.length) o = n.stringify(e[0]), t = n.stringify(e[1]), i = o, l = t;
            else if (3 === e.length) o = n.stringify(e[0]), t = n.stringify(e[1]), l = t, i = n.stringify(e[2]);
            else {
                if (4 !== e.length) return [];
                o = n.stringify(e[0]), t = n.stringify(e[1]), i = n.stringify(e[2]), l = n.stringify(e[3]);
            }
            return [
                ...cloneDeclaration(r, o, "top"),
                ...cloneDeclaration(r, t, "right"),
                ...cloneDeclaration(r, i, "bottom"),
                ...cloneDeclaration(r, l, "left")
            ];
        },
        "padding-block-start": transformSide("padding", t),
        "padding-block-end": transformSide("padding", i),
        "padding-inline-start": transformSide("padding", l),
        "padding-inline-end": transformSide("padding", a),
        "padding-block": transformSideShorthand("padding", r.block),
        "padding-inline": transformSideShorthand("padding", r.inline),
        "border-block-start-width": transformBorder("width", t),
        "border-block-end-width": transformBorder("width", i),
        "border-inline-start-width": transformBorder("width", l),
        "border-inline-end-width": transformBorder("width", a),
        "border-block-width": transformBorderProperty("width", r.block),
        "border-inline-width": transformBorderProperty("width", r.inline),
        "border-block-start-style": transformBorder("style", t),
        "border-block-end-style": transformBorder("style", i),
        "border-inline-start-style": transformBorder("style", l),
        "border-inline-end-style": transformBorder("style", a),
        "border-block-style": transformBorderProperty("style", r.block),
        "border-inline-style": transformBorderProperty("style", r.inline),
        "border-block-start-color": transformBorder("color", t),
        "border-block-end-color": transformBorder("color", i),
        "border-inline-start-color": transformBorder("color", l),
        "border-inline-end-color": transformBorder("color", a),
        "border-block-color": transformBorderProperty("color", r.block),
        "border-inline-color": transformBorderProperty("color", r.inline),
        "border-block": transformBorderShorthand(r.block),
        "border-block-start": transformBorderShorthand([
            t
        ]),
        "border-block-end": transformBorderShorthand([
            i
        ]),
        "border-inline": transformBorderShorthand(r.inline),
        "border-inline-start": transformBorderShorthand([
            l
        ]),
        "border-inline-end": transformBorderShorthand([
            a
        ]),
        "border-start-start-radius": transformBorderRadius(r),
        "border-start-end-radius": transformBorderRadius(r),
        "border-end-start-radius": transformBorderRadius(r),
        "border-end-end-radius": transformBorderRadius(r)
    };
    "TURBOPACK unreachable";
    var s, d;
}
!function(r) {
    r.TopToBottom = "top-to-bottom", r.BottomToTop = "bottom-to-top", r.RightToLeft = "right-to-left", r.LeftToRight = "left-to-right";
}(t || (t = {})), function(r) {
    r.Top = "top", r.Right = "right", r.Bottom = "bottom", r.Left = "left";
}(i || (i = {}));
const l = /var\(/i, creator = (r)=>{
    const e = Object.assign({
        blockDirection: t.TopToBottom,
        inlineDirection: t.LeftToRight
    }, r), n = Object.values(t);
    if (!n.includes(e.blockDirection)) throw new Error(`[postcss-logical] "blockDirection" must be one of ${n.join(", ")}`);
    if (!n.includes(e.inlineDirection)) throw new Error(`[postcss-logical] "inlineDirection" must be one of ${n.join(", ")}`);
    const [o, a] = directionFlowToAxes(e.blockDirection), [s, d] = directionFlowToAxes(e.inlineDirection);
    if (!Object.values(i).every((r)=>[
            o,
            a,
            s,
            d
        ].includes(r))) throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');
    const makeTransform = (r)=>(n, { result: o })=>{
            if (!r) return;
            if (e.ignoreCustomProperties && l.test(n.value)) return;
            let t = [];
            try {
                t = r(n);
            } catch (r) {
                return void n.warn(o, r instanceof Error ? r.message : String(r));
            }
            t?.length && (t.forEach((r)=>{
                n.cloneBefore(r);
            }), n.remove());
        }, c = prepareTransforms({
        block: [
            o,
            a
        ],
        inline: [
            s,
            d
        ],
        inlineIsHorizontal: [
            t.LeftToRight,
            t.RightToLeft
        ].includes(e.inlineDirection)
    }, o, a, s, d);
    return {
        postcssPlugin: "postcss-logical",
        Declaration: {
            "caption-side": makeTransform(c["caption-side"]),
            "text-align": makeTransform(c["text-align"]),
            "block-size": makeTransform(c["block-size"]),
            "inline-size": makeTransform(c["inline-size"]),
            "min-block-size": makeTransform(c["min-block-size"]),
            "max-block-size": makeTransform(c["max-block-size"]),
            "min-inline-size": makeTransform(c["min-inline-size"]),
            "max-inline-size": makeTransform(c["max-inline-size"]),
            "margin-block-start": makeTransform(c["margin-block-start"]),
            "margin-block-end": makeTransform(c["margin-block-end"]),
            "margin-inline-start": makeTransform(c["margin-inline-start"]),
            "margin-inline-end": makeTransform(c["margin-inline-end"]),
            "margin-block": makeTransform(c["margin-block"]),
            "margin-inline": makeTransform(c["margin-inline"]),
            "inset-block": makeTransform(c["inset-block"]),
            "inset-block-start": makeTransform(c["inset-block-start"]),
            "inset-block-end": makeTransform(c["inset-block-end"]),
            "inset-inline": makeTransform(c["inset-inline"]),
            "inset-inline-start": makeTransform(c["inset-inline-start"]),
            "inset-inline-end": makeTransform(c["inset-inline-end"]),
            inset: makeTransform(c.inset),
            "padding-block-start": makeTransform(c["padding-block-start"]),
            "padding-block-end": makeTransform(c["padding-block-end"]),
            "padding-inline-start": makeTransform(c["padding-inline-start"]),
            "padding-inline-end": makeTransform(c["padding-inline-end"]),
            "padding-block": makeTransform(c["padding-block"]),
            "padding-inline": makeTransform(c["padding-inline"]),
            "border-block-start-width": makeTransform(c["border-block-start-width"]),
            "border-block-end-width": makeTransform(c["border-block-end-width"]),
            "border-inline-start-width": makeTransform(c["border-inline-start-width"]),
            "border-inline-end-width": makeTransform(c["border-inline-end-width"]),
            "border-block-width": makeTransform(c["border-block-width"]),
            "border-inline-width": makeTransform(c["border-inline-width"]),
            "border-block-start-style": makeTransform(c["border-block-start-style"]),
            "border-block-end-style": makeTransform(c["border-block-end-style"]),
            "border-inline-start-style": makeTransform(c["border-inline-start-style"]),
            "border-inline-end-style": makeTransform(c["border-inline-end-style"]),
            "border-block-style": makeTransform(c["border-block-style"]),
            "border-inline-style": makeTransform(c["border-inline-style"]),
            "border-block-start-color": makeTransform(c["border-block-start-color"]),
            "border-block-end-color": makeTransform(c["border-block-end-color"]),
            "border-inline-start-color": makeTransform(c["border-inline-start-color"]),
            "border-inline-end-color": makeTransform(c["border-inline-end-color"]),
            "border-block-color": makeTransform(c["border-block-color"]),
            "border-inline-color": makeTransform(c["border-inline-color"]),
            "border-block": makeTransform(c["border-block"]),
            "border-block-start": makeTransform(c["border-block-start"]),
            "border-block-end": makeTransform(c["border-block-end"]),
            "border-inline": makeTransform(c["border-inline"]),
            "border-inline-start": makeTransform(c["border-inline-start"]),
            "border-inline-end": makeTransform(c["border-inline-end"]),
            "border-start-start-radius": makeTransform(c["border-start-start-radius"]),
            "border-start-end-radius": makeTransform(c["border-start-end-radius"]),
            "border-end-start-radius": makeTransform(c["border-end-start-radius"]),
            "border-end-end-radius": makeTransform(c["border-end-end-radius"]),
            transition: (r, { result: n, postcss: o })=>{
                if (e.ignoreCustomProperties && l.test(r.value)) return;
                let t = [];
                try {
                    t = transformTransition(r, o, c);
                } catch (e) {
                    return void r.warn(n, e instanceof Error ? e.message : String(e));
                }
                t?.length && (t.forEach((e)=>{
                    r.cloneBefore(e);
                }), r.remove());
            }
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-resize/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var o, t, e, i = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function cloneDeclaration(o, t, e) {
    o.parent && o.parent.some((o)=>"decl" == o.type && o.prop === e && o.value === t) || o.cloneBefore({
        value: t,
        prop: e
    });
}
function transformResize(o) {
    return (t)=>{
        const { prop: e, value: n } = t, r = i(n), c = o.inlineIsHorizontal ? "horizontal" : "vertical", s = o.inlineIsHorizontal ? "vertical" : "horizontal";
        r.nodes.forEach((o)=>{
            if ("word" === o.type) {
                const t = o.value.toLowerCase();
                if ("inline" === t) return void (o.value = c);
                "block" === t && (o.value = s);
            }
        });
        const l = r.toString();
        return l !== n && (cloneDeclaration(t, l, e), !0);
    };
}
function directionFlowToAxes(o) {
    switch(o){
        case t.TopToBottom:
            return [
                e.Top,
                e.Bottom
            ];
        case t.BottomToTop:
            return [
                e.Bottom,
                e.Top
            ];
        case t.RightToLeft:
            return [
                e.Right,
                e.Left
            ];
        case t.LeftToRight:
            return [
                e.Left,
                e.Right
            ];
    }
}
!function(o) {
    o.Block = "block", o.Inline = "inline";
}(o || (o = {})), function(o) {
    o.TopToBottom = "top-to-bottom", o.BottomToTop = "bottom-to-top", o.RightToLeft = "right-to-left", o.LeftToRight = "left-to-right";
}(t || (t = {})), function(o) {
    o.Top = "top", o.Right = "right", o.Bottom = "bottom", o.Left = "left";
}(e || (e = {}));
const creator = (o)=>{
    const i = Object.assign({
        blockDirection: t.TopToBottom,
        inlineDirection: t.LeftToRight
    }, o), n = Object.values(t);
    if (!n.includes(i.blockDirection)) throw new Error(`[postcss-logical-resize] "blockDirection" must be one of ${n.join(", ")}`);
    if (!n.includes(i.inlineDirection)) throw new Error(`[postcss-logical-resize] "inlineDirection" must be one of ${n.join(", ")}`);
    const [r, c] = directionFlowToAxes(i.blockDirection), [s, l] = directionFlowToAxes(i.inlineDirection);
    if (!Object.values(e).every((o)=>[
            r,
            c,
            s,
            l
        ].includes(o))) throw new Error('[postcss-logical-resize] "blockDirection" and "inlineDirection" must be on separate axes');
    const a = {
        block: [
            r,
            c
        ],
        inline: [
            s,
            l
        ],
        inlineIsHorizontal: [
            t.LeftToRight,
            t.RightToLeft
        ].includes(i.inlineDirection)
    };
    return {
        postcssPlugin: "postcss-logical-resize",
        Declaration: {
            resize: (u = transformResize(a), (o, { result: t })=>{
                if (!u) return;
                let e = !1;
                try {
                    e = u(o);
                } catch (e) {
                    return void o.warn(t, e instanceof Error ? e.message : String(e));
                }
                e && o.remove();
            })
        }
    };
    "TURBOPACK unreachable";
    var u;
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-logical-viewport-units/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var t, e = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
function transform(t, e) {
    const i = o.tokenizer({
        css: t
    }), n = [];
    let s = !1;
    for(;;){
        const t = i.nextToken();
        if (!t) break;
        if (n.push(t), o.isTokenEOF(t)) break;
        if (!o.isTokenDimension(t)) continue;
        const r = t[4].unit.toLowerCase();
        let c;
        "vi" === r ? c = e.vi : "vb" === r && (c = e.vb), c && (t[1] = t[4].value.toString() + c, t[4].unit = c, s = !0);
    }
    return s ? o.stringify(...n) : t;
}
!function(t) {
    t.TopToBottom = "top-to-bottom", t.BottomToTop = "bottom-to-top", t.RightToLeft = "right-to-left", t.LeftToRight = "left-to-right";
}(t || (t = {}));
const i = /vb|vi/i, n = {
    test (t) {
        if (!i.test(t)) return !1;
        const e = o.tokenizer({
            css: t
        });
        for(;;){
            const t = e.nextToken();
            if (o.isTokenEOF(t)) break;
            if (!o.isTokenDimension(t)) continue;
            const i = t[4].unit.toLowerCase();
            if ("vb" === i || "vi" === i) return !0;
        }
        return !1;
    }
}, s = /(?:vi|vb)\b/i, creator = (o)=>{
    const i = Object.assign({
        inlineDirection: t.LeftToRight,
        preserve: !0
    }, o);
    switch(i.inlineDirection){
        case t.LeftToRight:
        case t.RightToLeft:
        case t.TopToBottom:
        case t.BottomToTop:
            break;
        default:
            throw new Error(`[postcss-logical-viewport-units] "inlineDirection" must be one of ${Object.values(t).join(", ")}`);
    }
    const r = [
        t.LeftToRight,
        t.RightToLeft
    ].includes(i.inlineDirection), c = {
        vb: "vh",
        vi: "vw"
    };
    return r || (c.vb = "vw", c.vi = "vh"), {
        postcssPlugin: "postcss-logical-viewport-units",
        Declaration (t, { atRule: o }) {
            if (!s.test(t.value)) return;
            if (e.hasFallback(t)) return;
            if (e.hasSupportsAtRuleAncestor(t, n)) return;
            const r = transform(t.value, c);
            if (r === t.value) return;
            if (t.cloneBefore({
                value: r
            }), !i.preserve) return void t.remove();
            if (!t.variable) return;
            const u = o({
                name: "supports",
                params: "(top: 1vi)",
                source: t.source
            }), a = t.parent;
            if (!a) return;
            const f = a.cloneAfter({
                nodes: []
            });
            f.append(t), u.append(f), a.after(u);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-media-queries-aspect-ratio-number-values/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = 1e5, t = 2147483647;
function transformMediaFeatureValue(a) {
    if (Array.isArray(a.value) && e.matchesRatioExactly(a.value)) {
        const e = [];
        for(let o = 0; o < a.value.length; o++){
            const t = a.value[o];
            r.isTokenNode(t) && n.isTokenNumber(t.value) ? e.push(t) : r.isFunctionNode(t) && "calc" === t.getName().toLowerCase() && e.push(t);
        }
        if (2 !== e.length) return;
        const i = e[0], u = a.value.indexOf(i), s = e[1], l = a.value.indexOf(s);
        if (r.isTokenNode(s) && n.isTokenNumber(s.value) && 0 === s.value[4].value) return a.value.splice(u, 1, new r.TokenNode([
            n.TokenType.Number,
            t.toString(),
            -1,
            -1,
            {
                value: t,
                type: n.NumberType.Integer
            }
        ])), void a.value.splice(l, 1, new r.TokenNode([
            n.TokenType.Number,
            "1",
            -1,
            -1,
            {
                value: 1,
                type: n.NumberType.Integer
            }
        ]));
        if (r.isTokenNode(i) && n.isTokenNumber(i.value) && i.value[4].type === n.NumberType.Integer && r.isTokenNode(s) && n.isTokenNumber(s.value) && s.value[4].type === n.NumberType.Integer) return;
        let c = null, d = null;
        if (r.isFunctionNode(i) && "calc" === i.getName().toLowerCase()) {
            if (i.toString().includes(o.toString())) return;
            c = modifyCalc(i);
        }
        if (r.isFunctionNode(s) && "calc" === s.getName().toLowerCase()) {
            if (s.toString().includes(o.toString())) return;
            d = modifyCalc(s);
        }
        if (r.isTokenNode(i) && n.isTokenNumber(i.value) && r.isTokenNode(s) && n.isTokenNumber(s.value)) {
            const e = i.value, t = s.value, a = Math.round(e[4].value * o), u = Math.round(t[4].value * o), l = greatestCommonDivisor(a, u);
            c = new r.TokenNode([
                n.TokenType.Number,
                Math.round(a / l).toString(),
                -1,
                -1,
                {
                    value: Math.round(a / l),
                    type: n.NumberType.Integer
                }
            ]), d = new r.TokenNode([
                n.TokenType.Number,
                Math.round(u / l).toString(),
                -1,
                -1,
                {
                    value: Math.round(u / l),
                    type: n.NumberType.Integer
                }
            ]);
        } else {
            if (r.isTokenNode(i) && n.isTokenNumber(i.value)) {
                const e = i.value;
                c = new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(e[4].value * o).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(e[4].value * o),
                        type: n.NumberType.Integer
                    }
                ]);
            }
            if (r.isTokenNode(s) && n.isTokenNumber(s.value)) {
                const e = s.value;
                d = new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(e[4].value * o).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(e[4].value * o),
                        type: n.NumberType.Integer
                    }
                ]);
            }
        }
        return c && d ? (a.value.splice(u, 1, c), void a.value.splice(l, 1, d)) : void 0;
    }
    const i = Array.isArray(a.value) ? a.value : [
        a.value
    ];
    for(let e = 0; e < i.length; e++){
        const t = i[e];
        if (r.isTokenNode(t)) {
            const u = t.value;
            if (!n.isTokenNumber(u)) return;
            if (u[4].type === n.NumberType.Integer) return i.splice(e + 1, 0, new r.TokenNode([
                n.TokenType.Delim,
                "/",
                -1,
                -1,
                {
                    value: "/"
                }
            ]), new r.TokenNode([
                n.TokenType.Number,
                "1",
                -1,
                -1,
                {
                    value: 1,
                    type: n.NumberType.Integer
                }
            ])), void (a.value = i);
            if (u[4].type === n.NumberType.Number) {
                const t = Math.round(u[4].value * o), s = greatestCommonDivisor(t, o);
                return i.splice(e, 1, new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(t / s).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(t / s),
                        type: n.NumberType.Integer
                    }
                ]), new r.TokenNode([
                    n.TokenType.Delim,
                    "/",
                    -1,
                    -1,
                    {
                        value: "/"
                    }
                ]), new r.TokenNode([
                    n.TokenType.Number,
                    Math.round(o / s).toString(),
                    -1,
                    -1,
                    {
                        value: Math.round(o / s),
                        type: n.NumberType.Integer
                    }
                ])), void (a.value = i);
            }
            return;
        }
        if (r.isFunctionNode(t) && "calc" === t.getName().toLowerCase()) return i.splice(e, 1, modifyCalc(t), new r.TokenNode([
            n.TokenType.Delim,
            "/",
            -1,
            -1,
            {
                value: "/"
            }
        ]), new r.TokenNode([
            n.TokenType.Number,
            o.toString(),
            -1,
            -1,
            {
                value: o,
                type: n.NumberType.Integer
            }
        ])), void (a.value = i);
    }
}
function modifyCalc(e) {
    return new r.FunctionNode([
        n.TokenType.Function,
        "calc(",
        -1,
        -1,
        {
            value: "calc("
        }
    ], [
        n.TokenType.CloseParen,
        ")",
        -1,
        -1,
        void 0
    ], [
        new r.SimpleBlockNode([
            n.TokenType.OpenParen,
            "(",
            -1,
            -1,
            void 0
        ], [
            n.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], e.value),
        new r.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]),
        new r.TokenNode([
            n.TokenType.Delim,
            "*",
            -1,
            -1,
            {
                value: "*"
            }
        ]),
        new r.WhitespaceNode([
            [
                n.TokenType.Whitespace,
                " ",
                -1,
                -1,
                void 0
            ]
        ]),
        new r.TokenNode([
            n.TokenType.Number,
            o.toString(),
            -1,
            -1,
            {
                value: o,
                type: n.NumberType.Integer
            }
        ])
    ]);
}
function greatestCommonDivisor(e, r) {
    if (Number.isNaN(e) || Number.isNaN(r)) throw new Error("Unexpected 'NaN' when calculating the greatest common divisor.");
    if (!Number.isFinite(e) || !Number.isFinite(r)) throw new Error("Unexpected 'Infinite' value when calculating the greatest common divisor.");
    for(r > e && ([e, r] = [
        r,
        e
    ]);;){
        if (0 == r) return e;
        if (0 == (e %= r)) return r;
        r %= e;
    }
}
const a = new Set([
    "aspect-ratio",
    "min-aspect-ratio",
    "max-aspect-ratio",
    "device-aspect-ratio",
    "min-device-aspect-ratio",
    "max-device-aspect-ratio"
]);
function transformMediaQueryList(r, n) {
    const o = e.parse(r, {
        preserveInvalidMediaQueries: !0,
        onParseError: ()=>{
            throw new Error(`Unable to parse media query "${r}"`);
        }
    }), t = new Set(o.map((e)=>e.toString()));
    return o.flatMap((r)=>{
        if (e.isMediaQueryInvalid(r)) return [
            r.toString()
        ];
        const o = e.cloneMediaQuery(r);
        o.walk((r)=>{
            const n = r.node;
            if (e.isMediaFeaturePlain(n) || e.isMediaFeatureRangeNameValue(n) || e.isMediaFeatureRangeValueName(n)) {
                const e = n.name.getName().toLowerCase();
                if (!a.has(e)) return;
                transformMediaFeatureValue(n.value);
            } else if (e.isMediaFeatureRangeValueNameValue(n)) {
                const e = n.name.getName().toLowerCase();
                if (!a.has(e)) return;
                transformMediaFeatureValue(n.valueOne);
                transformMediaFeatureValue(n.valueTwo);
            } else ;
        });
        const i = r.toString(), u = o.toString();
        return u === i || t.has(u) ? [
            i
        ] : n ? [
            i,
            u
        ] : [
            u
        ];
    }).join(",");
}
const creator = (e)=>{
    const r = Object.assign({
        preserve: !1
    }, e);
    return {
        postcssPlugin: "postcss-media-queries-aspect-ratio-number-values",
        AtRule (e, { result: n }) {
            if ("media" !== e.name.toLowerCase()) return;
            const o = e.params.toLowerCase();
            if (!(o.includes("aspect-ratio") || o.includes("min-aspect-ratio") || o.includes("max-aspect-ratio") || o.includes("device-aspect-ratio") || o.includes("min-device-aspect-ratio") || o.includes("max-device-aspect-ratio"))) return;
            let t;
            try {
                if (t = transformMediaQueryList(e.params, r.preserve), t === e.params) return;
            } catch (r) {
                return void e.warn(n, `Failed to transform @media params for "${e.params}" with message: "${r instanceof Error ? r.message : r}"`);
            }
            e.cloneBefore({
                params: t
            }), e.remove();
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-media-minmax/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/media-query-list-parser/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const t = {
    width: "px",
    height: "px",
    "device-width": "px",
    "device-height": "px",
    "aspect-ratio": "",
    "device-aspect-ratio": "",
    color: "",
    "color-index": "",
    monochrome: "",
    resolution: "dpi"
}, r = {
    width: !1,
    height: !1,
    "device-width": !1,
    "device-height": !1,
    "aspect-ratio": !1,
    "device-aspect-ratio": !1,
    color: !0,
    "color-index": !0,
    monochrome: !0,
    resolution: "dpi"
};
function featureNamePrefix(e) {
    return e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? "max-" : e === n.MediaFeatureGT.GT || e === n.MediaFeatureGT.GT_OR_EQ ? "min-" : "";
}
const o = {
    ">": 1,
    "<": -1
}, s = .001;
function transformSingleNameValuePair(u, d, l, c) {
    let p = l.before, m = l.after;
    if (c || (p = l.after, m = l.before), !c) {
        const e = n.invertComparison(d);
        if (!1 === e) return;
        d = e;
    }
    if (d === n.MediaFeatureEQ.EQ || d === n.MediaFeatureLT.LT_OR_EQ || d === n.MediaFeatureGT.GT_OR_EQ) return Array.isArray(l.value) ? n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, ...l.value.flatMap((e)=>e.tokens()), ...m) : n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, ...l.value.tokens(), ...m);
    let T, f, v = !1;
    if (Array.isArray(l.value)) {
        if (!n.matchesRatioExactly(l.value)) return;
        if ("aspect-ratio" !== u && "device-aspect-ratio" !== u) return;
        const e = n.matchesRatio(l.value);
        if (-1 === e) return;
        v = !0, T = l.value[e[0]], f = [
            ...l.value.slice(e[0] + 1).flatMap((e)=>e.tokens())
        ];
    } else T = l.value, f = [];
    const y = t[u.toLowerCase()];
    if (e.isFunctionNode(T)) {
        const t = T.getName().toLowerCase();
        if (a.mathFunctionNames.has(t) || "env" === t) {
            const [[t]] = a.calcFromComponentValues([
                [
                    T
                ]
            ], {
                precision: 5,
                toCanonicalUnits: !0
            });
            if (!(t && e.isTokenNode(t) && i.isTokenNumeric(t.value) && Number.isInteger(t.value[4].value))) {
                let e;
                if (void 0 !== y) {
                    const n = o[d] * ("px" === y ? .02 : s);
                    e = [
                        i.TokenType.Dimension,
                        `${n.toString()}${y}`,
                        -1,
                        -1,
                        {
                            value: n,
                            unit: y,
                            type: i.NumberType.Integer
                        }
                    ];
                } else if (!0 === r[u]) {
                    const n = o[d];
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                } else if (v) {
                    const n = o[d] * s;
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                } else {
                    const n = o[d];
                    e = [
                        i.TokenType.Number,
                        n.toString(),
                        -1,
                        -1,
                        {
                            value: n,
                            type: i.NumberType.Integer
                        }
                    ];
                }
                return n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, [
                    i.TokenType.Function,
                    "calc(",
                    -1,
                    -1,
                    {
                        value: "calc("
                    }
                ], [
                    i.TokenType.OpenParen,
                    "(",
                    -1,
                    -1,
                    void 0
                ], ...T.tokens().slice(1), [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ], [
                    i.TokenType.Delim,
                    "+",
                    -1,
                    -1,
                    {
                        value: "+"
                    }
                ], [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ], e, [
                    i.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ], ...f, ...m);
            }
            T = t;
        }
    }
    if (!e.isTokenNode(T)) return;
    let h, M = T.value, g = "";
    if (void 0 !== y && i.isTokenNumber(M) && 0 === M[4].value) h = o[d], g = y;
    else if (i.isTokenNumber(M) && 0 === M[4].value) h = o[d], g = "";
    else if (i.isTokenDimension(M) && 0 === M[4].value) h = o[d], g = M[4].unit;
    else if (i.isTokenNumber(M) && !0 === r[u]) h = M[4].value + o[d];
    else if (i.isTokenDimension(M) && "px" === M[4].unit && M[4].type === i.NumberType.Integer) h = Number(Math.round(Number(M[4].value + .02 * o[d] + "e6")) + "e-6");
    else {
        if (!i.isTokenDimension(M) && !i.isTokenNumber(M)) return;
        h = Number(Math.round(Number(M[4].value + s * o[d] + "e6")) + "e-6");
    }
    return g && (M = [
        i.TokenType.Dimension,
        M[1],
        M[2],
        M[3],
        {
            value: M[4].value,
            unit: g,
            type: M[4].type
        }
    ]), M[4].value = h, i.isTokenDimension(M) ? M[1] = M[4].value.toString() + M[4].unit : M[1] = M[4].value.toString(), n.newMediaFeaturePlain(featureNamePrefix(d) + u, ...p, M, ...f, ...m);
}
const u = new Set([
    "aspect-ratio",
    "color",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "height",
    "horizontal-viewport-segments",
    "monochrome",
    "resolution",
    "vertical-viewport-segments",
    "width"
]);
function transform(a) {
    return a.map((a, t)=>{
        const r = e.gatherNodeAncestry(a);
        a.walk((e)=>{
            const t = e.node;
            if (!n.isMediaFeatureRange(t)) return;
            const o = e.parent;
            if (!n.isMediaFeature(o)) return;
            const s = t.name.getName().toLowerCase();
            if (!u.has(s)) return;
            if (n.isMediaFeatureRangeNameValue(t) || n.isMediaFeatureRangeValueName(t)) {
                const e = t.operatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.value, n.isMediaFeatureRangeNameValue(t));
                return void (i && (o.feature = i.feature));
            }
            const d = r.get(o);
            if (!n.isMediaInParens(d)) return;
            let l = null, c = null;
            {
                const e = t.valueOneOperatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.valueOne, !1);
                if (!i) return;
                e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? (l = i, l.before = o.before) : (c = i, c.after = o.after);
            }
            {
                const e = t.valueTwoOperatorKind();
                if (!1 === e) return;
                const i = transformSingleNameValuePair(s, e, t.valueTwo, !0);
                if (!i) return;
                e === n.MediaFeatureLT.LT || e === n.MediaFeatureLT.LT_OR_EQ ? (c = i, c.before = o.before) : (l = i, l.after = o.after);
            }
            if (!l || !c) return;
            const p = new n.MediaInParens(l), m = new n.MediaInParens(c), T = getMediaConditionListWithAndFromAncestry(d, r);
            if (T) return T.leading === d ? (T.leading = p, void (T.list = [
                new n.MediaAnd([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ],
                    [
                        i.TokenType.Ident,
                        "and",
                        -1,
                        -1,
                        {
                            value: "and"
                        }
                    ],
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ], m),
                ...T.list
            ])) : void T.list.splice(T.indexOf(r.get(d)), 1, new n.MediaAnd([
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], p), new n.MediaAnd([
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.Ident,
                    "and",
                    -1,
                    -1,
                    {
                        value: "and"
                    }
                ],
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ], m));
            const f = new n.MediaConditionListWithAnd(p, [
                new n.MediaAnd([
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ],
                    [
                        i.TokenType.Ident,
                        "and",
                        -1,
                        -1,
                        {
                            value: "and"
                        }
                    ],
                    [
                        i.TokenType.Whitespace,
                        " ",
                        -1,
                        -1,
                        void 0
                    ]
                ], m)
            ], [
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]), v = getMediaConditionInShallowMediaQueryFromAncestry(d, a, r);
            v ? v.media = f : d.media = new n.MediaCondition(new n.MediaInParens(new n.MediaCondition(f), [
                [
                    i.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ],
                [
                    i.TokenType.OpenParen,
                    "(",
                    -1,
                    -1,
                    void 0
                ]
            ], [
                [
                    i.TokenType.CloseParen,
                    ")",
                    -1,
                    -1,
                    void 0
                ]
            ]));
        });
        const o = a.tokens();
        return i.stringify(...o.filter((e, n)=>(0 !== n || 0 !== t || !i.isTokenWhitespace(e)) && !(i.isTokenWhitespace(e) && o[n + 1] && i.isTokenWhitespace(o[n + 1]))));
    }).join(",");
}
function getMediaConditionListWithAndFromAncestry(e, i) {
    let a = e;
    if (a) {
        if (a = i.get(a), n.isMediaConditionListWithAnd(a)) return a;
        if (n.isMediaAnd(a)) return a = i.get(a), n.isMediaConditionListWithAnd(a) ? a : void 0;
    }
}
function getMediaConditionInShallowMediaQueryFromAncestry(e, i, a) {
    let t = e;
    if (!t) return;
    if (t = a.get(t), !n.isMediaCondition(t)) return;
    const r = t;
    return t = a.get(t), n.isMediaQuery(t) && t === i ? r : void 0;
}
const creator = ()=>({
        postcssPlugin: "postcss-media-minmax",
        AtRule: {
            media (e) {
                if (!(e.params.includes("<") || e.params.includes(">") || e.params.includes("="))) return;
                const i = transform(n.parse(e.params, {
                    preserveInvalidMediaQueries: !0,
                    onParseError: ()=>{
                        throw e.error(`Unable to parse media query "${e.params}"`);
                    }
                }));
                e.params !== i && (e.params = i);
            },
            "custom-media" (e) {
                if (!(e.params.includes("<") || e.params.includes(">") || e.params.includes("="))) return;
                const a = n.parseCustomMedia(e.params, {
                    preserveInvalidMediaQueries: !0,
                    onParseError: ()=>{
                        throw e.error(`Unable to parse media query "${e.params}"`);
                    }
                });
                if (!a || !a.mediaQueryList) return;
                const t = a.mediaQueryList.map((e)=>e.toString()).join(","), r = transform(a.mediaQueryList);
                t !== r && (e.params = `${i.stringify(...a.name)} ${r}`);
            }
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-nested-calc/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const r = /calc\(/gi;
const creator = (s)=>{
    const a = Object.assign({
        preserve: !0
    }, s);
    return {
        postcssPlugin: "postcss-nested-calc",
        Declaration (s, { result: o }) {
            if ((s.value.match(r) || []).length < 2) return;
            if (s.variable) return;
            if (t.hasFallback(s)) return;
            const c = s.value;
            let l;
            try {
                l = e(c);
            } catch  {
                return void s.warn(o, `Failed to parse value '${c}'. Leaving the original value intact.`);
            }
            if (void 0 === l) return;
            e.walk(l.nodes, (t)=>{
                t.type && "function" === t.type && "calc" === t.value.toLowerCase() && e.walk(t.nodes, (e)=>{
                    if (e.type && "function" === e.type) return "calc" === e.value.toLowerCase() && void (e.value = "");
                });
            }, !0);
            const n = String(l);
            n !== c && (s.cloneBefore({
                value: n
            }), a.preserve || s.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-resolve-nested/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function sourceFrom(e) {
    return {
        sourceIndex: e.sourceIndex ?? 0,
        source: e.source
    };
}
function sortCompoundSelectorsInsideComplexSelector(o) {
    const t = [];
    let r = [];
    o.each((o)=>{
        if ("combinator" === o.type) return t.push(r, [
            o
        ]), void (r = []);
        if (e.isPseudoElement(o)) return t.push(r), void (r = [
            o
        ]);
        if ("universal" === o.type && r.find((e)=>"universal" === e.type)) o.remove();
        else {
            if ("tag" === o.type && r.find((e)=>"tag" === e.type)) {
                o.remove();
                const t = e.selector({
                    value: "",
                    ...sourceFrom(o)
                });
                t.append(o);
                const n = e.pseudo({
                    value: ":is",
                    ...sourceFrom(o)
                });
                return n.append(t), void r.push(n);
            }
            r.push(o);
        }
    }), t.push(r);
    const n = [];
    for(let e = 0; e < t.length; e++){
        const o = t[e];
        o.sort((e, o)=>selectorTypeOrder(e) - selectorTypeOrder(o)), n.push(...o);
    }
    o.removeAll();
    for(let e = n.length - 1; e >= 0; e--)n[e].remove(), n[e].parent = o, o.nodes.unshift(n[e]);
}
function selectorTypeOrder(t) {
    return e.isPseudoElement(t) ? o.pseudoElement : o[t.type];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    nesting: 3,
    id: 4,
    class: 5,
    attribute: 6,
    pseudo: 7,
    comment: 8
};
function prepareParentSelectors(o, t = !1) {
    if (t || !isCompoundSelector(o.nodes)) {
        const t = e.pseudo({
            value: ":is",
            ...sourceFrom(o)
        });
        return o.nodes.forEach((e)=>{
            t.append(e.clone());
        }), [
            t
        ];
    }
    return o.nodes[0].nodes.map((e)=>e.clone());
}
function isCompoundSelector(o) {
    return 1 === o.length && !o[0].nodes.some((o)=>"combinator" === o.type || e.isPseudoElement(o));
}
function combinationsWithSizeN(e, o) {
    if (o < 2) throw new Error("n must be greater than 1");
    if (e.length < 2) throw new Error("s must be greater than 1");
    if (Math.pow(e.length, o) > 1e4) throw new Error("Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors");
    const t = [];
    for(let e = 0; e < o; e++)t[e] = 0;
    const r = [];
    for(;;){
        const n = [];
        for(let s = o - 1; s >= 0; s--){
            let o = t[s];
            if (o >= e.length) {
                if (o = 0, t[s] = 0, 0 === s) return r;
                t[s - 1] += 1;
            }
            n[s] = e[o].clone();
        }
        r.push(n), t[t.length - 1]++;
    }
}
exports.flattenNestedSelector = function flattenNestedSelector(o, t) {
    const r = [];
    for(let n = 0; n < o.nodes.length; n++){
        const s = o.nodes[n].clone();
        let c, l = 0;
        {
            let o = !1;
            s.walkNesting(()=>{
                o = !0, l++;
            }), o ? "combinator" === s.nodes[0]?.type && (s.prepend(e.nesting({
                ...sourceFrom(s)
            })), l++) : (s.prepend(e.combinator({
                value: " ",
                ...sourceFrom(s)
            })), s.prepend(e.nesting({
                ...sourceFrom(s)
            })), l++);
        }
        let p = [];
        if (l > 1 && t.nodes.length > 1) p = combinationsWithSizeN(t.nodes, l), c = p.length;
        else {
            c = t.nodes.length;
            for(let e = 0; e < t.nodes.length; e++){
                p.push([]);
                for(let o = 0; o < l; o++)p[e].push(t.nodes[e].clone());
            }
        }
        for(let e = 0; e < c; e++){
            let o = 0;
            const t = s.clone();
            t.walkNesting((t)=>{
                const r = p[e][o];
                o++, t.replaceWith(...r.nodes);
            }), r.push(t);
        }
    }
    const n = e.root({
        value: "",
        ...sourceFrom(o)
    });
    return r.forEach((e)=>{
        n.append(e);
    }), n;
}, exports.resolveNestedSelector = function resolveNestedSelector(o, t, r) {
    const n = [];
    for(let s = 0; s < o.nodes.length; s++){
        const c = o.nodes[s].clone();
        if (!r?.ignoreImplicitNesting) {
            let o = !1;
            c.walkNesting(()=>(o = !0, !1)), o ? "combinator" === c.nodes[0]?.type && c.prepend(e.nesting({
                ...sourceFrom(c)
            })) : (c.prepend(e.combinator({
                value: " ",
                ...sourceFrom(c)
            })), c.prepend(e.nesting({
                ...sourceFrom(c)
            })));
        }
        {
            const e = new Set;
            c.walkNesting((o)=>{
                const r = o.parent;
                r && (e.add(r), "pseudo" === r.parent?.type && ":has" === r.parent.value?.toLowerCase() ? o.replaceWith(...prepareParentSelectors(t, !0)) : o.replaceWith(...prepareParentSelectors(t)));
            });
            for (const o of e)sortCompoundSelectorsInsideComplexSelector(o);
        }
        c.walk((e)=>{
            "combinator" === e.type && "" !== e.value.trim() ? (e.rawSpaceAfter = " ", e.rawSpaceBefore = " ") : (e.rawSpaceAfter = "", e.rawSpaceBefore = "");
        }), n.push(c);
    }
    const s = e.root({
        value: "",
        ...sourceFrom(o)
    });
    return n.forEach((e)=>{
        s.append(e);
    }), s;
};
}}),
"[project]/node_modules/postcss-nesting/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-specificity/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/postcss-nesting/node_modules/@csstools/selector-resolve-nested/dist/index.cjs [postcss] (ecmascript)");
const r = e.pseudo({
    value: ":is"
});
function sortCompoundSelectorsInsideComplexSelector(t) {
    if (!t || !t.nodes) return;
    const n = [];
    let o = [];
    for(let s = 0; s < t.nodes.length; s++)if ("combinator" !== t.nodes[s].type) if (e.isPseudoElement(t.nodes[s])) n.push(o), o = [
        t.nodes[s]
    ];
    else {
        if ("tag" === t.nodes[s].type && o.find((e)=>"tag" === e.type)) {
            const n = r.clone({}), o = t.nodes[s];
            o.replaceWith(n), n.append(e.selector({
                nodes: [
                    o
                ],
                value: void 0
            }));
        }
        o.push(t.nodes[s]);
    }
    else n.push(o), n.push([
        t.nodes[s]
    ]), o = [];
    n.push(o);
    const s = [];
    for(let e = 0; e < n.length; e++){
        const t = n[e];
        t.sort((e, t)=>"selector" === e.type && "selector" === t.type && e.nodes.length && t.nodes.length ? selectorTypeOrder(e.nodes[0]) - selectorTypeOrder(t.nodes[0]) : "selector" === e.type && e.nodes.length ? selectorTypeOrder(e.nodes[0]) - selectorTypeOrder(t) : "selector" === t.type && t.nodes.length ? selectorTypeOrder(e) - selectorTypeOrder(t.nodes[0]) : selectorTypeOrder(e) - selectorTypeOrder(t));
        for(let e = 0; e < t.length; e++)s.push(t[e]);
    }
    t.removeAll();
    for(let e = s.length - 1; e >= 0; e--)s[e].remove(), s[e].parent = t, t.nodes.unshift(s[e]);
}
function selectorTypeOrder(t) {
    return e.isPseudoElement(t) ? o.pseudoElement : o[t.type];
}
const o = {
    universal: 0,
    tag: 1,
    pseudoElement: 2,
    id: 3,
    class: 4,
    attribute: 5,
    pseudo: 6,
    selector: 7,
    string: 8,
    root: 9,
    comment: 10
};
function isAtRule(e) {
    return e && "atrule" === e.type;
}
function isNestRule(e) {
    return e && isAtRule(e) && "nest" === e.name;
}
function isRule(e) {
    return e && "rule" === e.type;
}
function ampersandToScope$1(t, n) {
    let r, o = t.parent;
    for(; o;){
        if ("rule" === o.type) return;
        if (isAtRule(o) && "scope" === o.name) return;
        o = o.parent;
    }
    try {
        r = e().astSync(t.selector);
    } catch (e) {
        return void t.warn(n, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
    }
    r && (r.walkNesting((t)=>{
        const n = t.parent;
        t.replaceWith(e.pseudo({
            value: ":scope"
        })), n && sortCompoundSelectorsInsideComplexSelector(n);
    }), t.selector = r.toString());
}
function cleanupParent(e) {
    if (!e.nodes.length) return void e.remove();
    const t = e.nodes.filter((e)=>"comment" === e.type);
    t.length === e.nodes.length && e.replaceWith(...t);
}
function groupDeclarations(e) {
    const t = [], n = [];
    e.each((e)=>{
        if (isDeclarationLike(e, n.length > 0)) t.push(e);
        else {
            if ("comment" === e.type) {
                let r = e.next();
                for(; r && "comment" === r.type;)r = r.next();
                if (isDeclarationLike(r, n.length > 0)) return void t.push(e);
            }
            n.push(e);
        }
    }), e.removeAll(), t.forEach((t)=>{
        e.append(t);
    }), n.forEach((t)=>{
        e.append(t);
    });
}
function isDeclarationLike(e, t) {
    return !!e && ("decl" === e.type || "atrule" === e.type && "mixin" === e.name.toLowerCase() && !t);
}
function comma(e) {
    const t = [];
    let n = "", r = !1, o = 0, s = !1, i = !1;
    for (const l of e)i ? i = !1 : "\\" === l ? i = !0 : s ? l === s && (s = !1) : '"' === l || "'" === l ? s = l : "(" === l ? o += 1 : ")" === l ? o > 0 && (o -= 1) : 0 === o && "," === l && (r = !0), r ? ("" !== n && t.push(n.trim()), n = "", r = !1) : n += l;
    return t.push(n.trim()), t;
}
function shiftNodesBeforeParent(e, t) {
    const n = t.index(e);
    if (n) {
        const e = t.cloneBefore().removeAll().append(t.nodes.slice(0, n));
        e.raws.semicolon = !0, cleanupParent(e);
    }
    t.before(e), t.raws.semicolon = !0;
}
var s = [
    "container",
    "document",
    "media",
    "supports",
    "layer",
    "starting-style"
];
function transformAtruleWithinAtrule(e, t) {
    var n, r;
    groupDeclarations(t), shiftNodesBeforeParent(e, t), e.params = (n = t.params, r = e.params, comma(n).map((e)=>comma(r).map((t)=>`${e} and ${t}`).join(", ")).join(", ")), cleanupParent(t);
}
function isAtruleWithinAtrule(e, t) {
    return s.includes(e.name) && e.name === t.name;
}
function atruleWithinRule$1(e, t, n, r, o) {
    if (groupDeclarations(t), shiftNodesBeforeParent(e, t), e.nodes) {
        const s = t.clone().removeAll().append(e.nodes);
        e.append(s), cleanupParent(t), r(s, n, o);
    } else cleanupParent(t);
}
function isAtruleWithinRule$1(e) {
    return s.includes(e.name);
}
function combinationsWithSizeN(e, t) {
    if (t < 2) throw new Error("n must be greater than 1");
    if (e.length < 2) throw new Error("s must be greater than 1");
    if (Math.pow(e.length, t) > 1e4) throw new Error("Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors");
    const n = [];
    for(let e = 0; e < t; e++)n[e] = 0;
    const r = [];
    for(;;){
        const o = [];
        for(let s = t - 1; s >= 0; s--){
            let t = n[s];
            if (t >= e.length) {
                if (t = 0, n[s] = 0, 0 === s) return r;
                n[s - 1] += 1;
            }
            o[s] = e[t].clone();
        }
        r.push(o), n[n.length - 1]++;
    }
}
function nodesAreEquallySpecific(n) {
    const r = n.map((t)=>e().astSync(t)).map((e)=>t.selectorSpecificity(e)), o = r[0];
    for(let e = 1; e < r.length; e++)if (o.a !== r[e].a || o.b !== r[e].b || o.c !== r[e].c) return !1;
    return !0;
}
function mergeSelectors$1(t, n, r) {
    let o = [];
    o = nodesAreEquallySpecific(t) || r.noIsPseudoSelector ? t.map((t)=>e().astSync(t)) : [
        e().astSync(`:is(${t.join(",")})`)
    ];
    const s = [];
    for(let t = 0; t < n.length; t++){
        let i, l = n[t];
        {
            const t = e().astSync(l);
            let n = !1;
            t.walk((e)=>{
                "nesting" === e.type && (n = !0);
            });
            const r = t.nodes[0];
            let o = !1;
            r.each((e)=>"combinator" === e.type && (o = !0, !1)), n ? o && r.insertBefore(r.at(0), e.nesting()) : (r.insertBefore(r.at(0), e.combinator({
                value: " "
            })), r.insertBefore(r.at(0), e.nesting())), l = t.toString();
        }
        let c = [], a = 0;
        if (e().astSync(l).walkNesting(()=>{
            a++;
        }), a > 1 && o.length > 1) c = combinationsWithSizeN(o, a), i = c.length;
        else {
            i = o.length;
            for(let e = 0; e < o.length; e++){
                c.push([]);
                for(let t = 0; t < a; t++)c[e].push(o[e]);
            }
        }
        for(let t = 0; t < i; t++){
            let n = 0;
            const o = e().astSync(l);
            o.walk((o)=>{
                if ("nesting" !== o.type) return;
                let s = c[t][n];
                n++, "root" === s.type && 1 === s.nodes.length && (s = s.nodes[0]);
                const i = e().astSync(`:is(${s.toString()})`), l = isSimpleSelector(s.nodes[0]), a = isCompoundSelector(s.nodes[0]), u = isSimpleSelector(o), p = isCompoundSelector(o);
                if (l && u) return void o.replaceWith(s.clone());
                if ((l || a) && (u || p)) {
                    const e = o.parent;
                    return l && "selector" === s.type ? o.replaceWith(s.clone().nodes[0]) : o.replaceWith(...s.clone().nodes), void (e && e.nodes.length > 1 && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (l) {
                    const e = o.parent;
                    return o.replaceWith(s.clone().nodes[0]), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (a) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(o)) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                if (nestingIsNotInsideCompoundSelector(o)) {
                    const e = o.parent;
                    return o.replaceWith(...s.clone().nodes), void (e && sortCompoundSelectorsInsideComplexSelector(e));
                }
                const d = o.parent;
                r.noIsPseudoSelector ? o.replaceWith(...s.clone().nodes) : o.replaceWith(...i.clone({}).nodes), d && sortCompoundSelectorsInsideComplexSelector(d);
            }), s.push(o.toString());
        }
    }
    return s;
}
function isSimpleSelector(e) {
    return "combinator" !== e.type && !(e.parent && e.parent.nodes.length > 1);
}
function isCompoundSelector(e, t = null) {
    if (isSimpleSelector(e)) return !1;
    if (!e.parent) return !1;
    if (!!e.parent.nodes.find((e)=>"combinator" === e.type)) return !1;
    return !(!!e.parent.nodes.find((e)=>"nesting" === e.type) && t && !isCompoundSelector(t));
}
function nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(e) {
    if (!e.parent) return !1;
    if (0 !== e.parent.nodes.indexOf(e)) return !1;
    for(let t = 1; t < e.parent.nodes.length; t++)if ("combinator" === e.parent.nodes[t].type && " " !== e.parent.nodes[t].value && ">" !== e.parent.nodes[t].value) return !1;
    return !0;
}
function nestingIsNotInsideCompoundSelector(e) {
    if (isSimpleSelector(e)) return !0;
    if (!e.parent) return !1;
    for(let t = 0; t < e.parent.nodes.length; t++)if ("nesting" !== e.parent.nodes[t].type && (e.parent.nodes[t].prev() || e.parent.nodes[t].next())) {
        if (e.parent.nodes[t].prev() && "combinator" !== e.parent.nodes[t].prev().type) return !1;
        if (e.parent.nodes[t].next() && "combinator" !== e.parent.nodes[t].next().type) return !1;
    }
    return !0;
}
function transformNestRuleWithinRule(e, t, n, r, o) {
    let s = [];
    try {
        s = mergeSelectors$1(t.selectors, comma(e.params), o);
    } catch (r) {
        return void e.warn(n, `Failed to parse selectors : "${t.selector}" / "${e.params}" with message: "${r instanceof Error ? r.message : r}"`);
    }
    if (!s.length) return;
    shiftNodesBeforeParent(e, t);
    const i = t.clone().removeAll().append(e.nodes);
    i.raws.semicolon = !0, i.selectors = s, e.replaceWith(i), cleanupParent(t), r(i, n, o);
}
function isValidNestRuleWithinRule(e) {
    return comma(e.params).every((e)=>e.split("&").length >= 2 && -1 === e.indexOf("|"));
}
function transformRuleWithinRule$1(e, t, n, r) {
    let o = [];
    try {
        o = mergeSelectors$1(t.selectors, e.selectors, r);
    } catch (r) {
        return void e.warn(n, `Failed to parse selectors : "${t.selector}" / "${e.selector}" with message: "${r instanceof Error ? r.message : r}"`);
    }
    if (!o.length) return;
    groupDeclarations(t), shiftNodesBeforeParent(e, t), e.selectors = o;
    "rule" === e.type && "rule" === t.type && e.selector === t.selector && e.append(...t.nodes), cleanupParent(t);
}
function isValidRuleWithinRule$1(e) {
    return e.selectors.every((e)=>-1 === e.indexOf("|"));
}
function walk$1(e, t, n) {
    e.each((r)=>{
        const o = r.parent;
        isNestRule(r) && !n.silenceAtNestWarning && e.warn(t, `\`@nest\` was removed from the CSS Nesting specification and will be removed from PostCSS Nesting in the next major version.\nChange \`@nest ${r.params} {}\` to \`${r.params} {}\` to migrate to the latest standard.`), isRule(r) && isRule(o) && isValidRuleWithinRule$1(r) ? transformRuleWithinRule$1(r, o, t, n) : isNestRule(r) && isRule(o) && isValidNestRuleWithinRule(r) ? transformNestRuleWithinRule(r, o, t, walk$1, n) : isAtRule(r) && isRule(o) && isAtruleWithinRule$1(r) ? atruleWithinRule$1(r, o, t, walk$1, n) : isAtRule(r) && isAtRule(o) && isAtruleWithinAtrule(r, o) && transformAtruleWithinAtrule(r, o), "nodes" in r && r.nodes.length && walk$1(r, t, n);
    });
}
const creator$2 = (e)=>{
    const t = Object.assign({
        noIsPseudoSelector: !1,
        silenceAtNestWarning: !1
    }, e);
    return {
        postcssPlugin: "postcss-nesting",
        Rule (e, { result: n }) {
            walk$1(e, n, t), e.selector.includes("&") && ampersandToScope$1(e, n);
        }
    };
};
creator$2.postcss = !0;
const i = e();
function mergeSelectors(e, t, r, o) {
    let s;
    try {
        s = n.resolveNestedSelector(i.astSync(t), i.astSync(r));
    } catch (n) {
        return e.warn(o, `Failed to parse selectors : "${r}" / "${t}" with message: "${n instanceof Error ? n.message : n}"`), !1;
    }
    return !!s && s.toString();
}
function ampersandToScope(t, n) {
    {
        let r = t.parent;
        for(; r;){
            if ("rule" === r.type) return;
            if (isAtRule(r) && "scope" === r.name) return;
            r = r.parent;
        }
        try {
            let n = !1;
            if (e().astSync(t.selector).walkNesting(()=>(n = !0, !1)), !n) return;
        } catch (e) {
            return void t.warn(n, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
        }
    }
    const r = mergeSelectors(t, t.selector, ":scope", n);
    r && (t.selector = r);
}
function atruleWithinRule(e, t, n, r) {
    if (shiftNodesBeforeParent(e, t), e.nodes) {
        const o = t.clone().removeAll().append(e.nodes);
        e.append(o), cleanupParent(t), r(o, n);
    } else cleanupParent(t);
}
function isAtruleWithinRule(e) {
    return s.includes(e.name);
}
function transformRuleWithinRule(e, t, n) {
    const r = mergeSelectors(e, e.selector, t.selector, n);
    if (!r) return;
    shiftNodesBeforeParent(e, t), e.selector = r;
    "rule" === e.type && "rule" === t.type && e.selector === t.selector && e.append(...t.nodes), cleanupParent(t);
}
function isValidRuleWithinRule(e) {
    return e.selectors.every((e)=>-1 === e.indexOf("|"));
}
function walk(e, t) {
    e.each((e)=>{
        const n = e.parent;
        isRule(e) && isRule(n) && isValidRuleWithinRule(e) ? transformRuleWithinRule(e, n, t) : isAtRule(e) && isRule(n) && isAtruleWithinRule(e) && atruleWithinRule(e, n, t, walk), "nodes" in e && e.nodes.length && walk(e, t);
    });
}
const creator$1 = ()=>({
        postcssPlugin: "postcss-nesting",
        Rule (e, { result: t }) {
            walk(e, t), e.selector.includes("&") && ampersandToScope(e, t);
        },
        AtRule: {
            nest (e) {
                throw e.error(`\`@nest\` was removed from the CSS Nesting specification and will be removed from PostCSS Nesting in the next major version.\nChange \`@nest ${e.params} {}\` to \`${e.params} {}\` to migrate to the latest standard.`);
            }
        }
    });
creator$1.postcss = !0;
const creator = (e)=>{
    const t = Object.assign({
        edition: "2024-02"
    }, e);
    switch(t.edition){
        case "2021":
            return creator$2(e);
        case "2024-02":
            return creator$1();
        default:
            throw new Error(`Invalid edition: ${t.edition}`);
    }
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-selector-not/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-selector-not/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
function cleanupWhitespace(e) {
    e.spaces && (e.spaces.after = "", e.spaces.before = ""), e.nodes && e.nodes.length > 0 && (e.nodes[0] && e.nodes[0].spaces && (e.nodes[0].spaces.before = ""), e.nodes[e.nodes.length - 1] && e.nodes[e.nodes.length - 1].spaces && (e.nodes[e.nodes.length - 1].spaces.after = ""));
}
const creator = ()=>({
        postcssPlugin: "postcss-selector-not",
        Rule (s, { result: o }) {
            if (s.selector && s.selector.toLowerCase().includes(":not(")) try {
                const o = e().astSync(s.selector);
                o.walkPseudos((s)=>{
                    if (":not" !== s.value.toLowerCase()) return;
                    if (!s.nodes || s.nodes.length < 2) return;
                    const o = [];
                    s.nodes.forEach((s)=>{
                        cleanupWhitespace(s);
                        const t = e.pseudo({
                            value: ":not",
                            nodes: [
                                s
                            ]
                        });
                        o.push(t);
                    }), s.replaceWith(...o);
                });
                const t = o.toString();
                t !== s.selector && s.replaceWith(s.clone({
                    selector: t
                }));
            } catch (e) {
                s.warn(o, `Failed to parse selector : "${s.selector}" with message: "${e instanceof Error ? e.message : e}"`);
            }
        }
    });
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-oklab-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:oklab|oklch)\(/i, l = /^(?:oklab|oklch)$/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-oklab-function",
        Declaration (n) {
            const i = n.value;
            if (!o.test(i)) return;
            if (t.hasFallback(n)) return;
            if (t.hasSupportsAtRuleAncestor(n, o)) return;
            const u = r.tokenize({
                css: i
            }), c = a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.serializeRGB(t) : void 0;
            }), p = a.stringify(c);
            if (p === i) return;
            let g = p;
            s?.subFeatures.displayP3 && (g = a.stringify(a.replaceComponentValues(a.parseCommaSeparatedListOfComponentValues(u), (s)=>{
                if (!a.isFunctionNode(s) || !l.test(s.getName())) return;
                const t = e.color(s);
                return t && !(t.syntaxFlags.has(e.SyntaxFlag.Experimental) || t.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) || t.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax)) ? e.colorDataFitsRGB_Gamut(t) ? e.serializeRGB(t) : e.serializeP3(t) : void 0;
            }))), n.cloneBefore({
                value: p
            }), s?.subFeatures.displayP3 && g !== p && n.cloneBefore({
                value: g
            }), s?.preserve || n.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const t = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return t.subFeatures = Object.assign({
        displayP3: !0
    }, t.subFeatures), t.enableProgressiveCustomProperties && (t.preserve || t.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-oklab-function",
        plugins: [
            s(),
            basePlugin(t)
        ]
    } : basePlugin(t);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/postcss-opacity-percentage/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const doNothingValues = new Set([
    'inherit',
    'initial',
    'revert',
    'unset'
]);
/**
 * @type {import('postcss').PluginCreator}
 */ module.exports = ({ preserve = false } = {})=>({
        postcssPlugin: 'postcss-opacity-percentage',
        Declaration: {
            opacity (decl) {
                if (!decl.value || decl.value.startsWith('var(') || !decl.value.endsWith('%') || doNothingValues.has(decl.value)) {
                    return;
                }
                decl.cloneBefore({
                    value: String(Number.parseFloat(decl.value) / 100)
                });
                if (!preserve) {
                    decl.remove();
                }
            }
        }
    });
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-overflow-shorthand/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
const creator = (r)=>{
    const o = Object.assign({
        preserve: !0
    }, r);
    return {
        postcssPlugin: "postcss-overflow-shorthand",
        Declaration (r, { result: s }) {
            if ("overflow" !== r.prop.toLowerCase()) return;
            let t = "", a = "";
            const l = r.value;
            try {
                const r = e(l).nodes.slice().filter((e)=>"comment" !== e.type && "space" !== e.type);
                if (r.length < 2) return;
                t = e.stringify(r[0]), a = e.stringify(r[1]);
            } catch  {
                return void r.warn(s, `Failed to parse value '${l}' as a shorthand for "overflow". Leaving the original value intact.`);
            }
            t && a && (t.toLowerCase() === a.toLowerCase() ? r.cloneBefore({
                value: t
            }) : (r.cloneBefore({
                prop: "overflow-x",
                value: t
            }), r.cloneBefore({
                prop: "overflow-y",
                value: a
            })), o.preserve || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-replace-overflow-wrap/index.js [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-check
module.exports = function(opts) {
    opts = opts || {};
    var method = opts.method || 'replace';
    return {
        postcssPlugin: 'postcss-replace-overflow-wrap',
        Declaration: {
            'overflow-wrap': (decl)=>{
                decl.cloneBefore({
                    prop: 'word-wrap'
                });
                if (method === 'replace') {
                    decl.remove();
                }
            }
        }
    };
};
module.exports.postcss = true;
}}),
"[project]/node_modules/postcss-place/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)");
function onCSSDeclaration(r, o, s) {
    const n = r.prop.match(t)?.[1].toLowerCase();
    if (!n) return;
    let a;
    try {
        a = e(r.value);
    } catch  {
        r.warn(o, `Failed to parse value '${r.value}'. Leaving the original value intact.`);
    }
    if (void 0 === a) return;
    let i = [];
    i = a.nodes.length ? a.nodes.filter((e)=>"word" === e.type || "function" === e.type).map((t)=>e.stringify(t)) : [
        e.stringify(a.nodes)
    ], r.cloneBefore({
        prop: `align-${n}`,
        value: i[0]
    }), r.cloneBefore({
        prop: `justify-${n}`,
        value: i[1] || i[0]
    }), s.preserve || r.remove();
}
const t = /^place-(content|items|self)/i, creator = (e)=>{
    const r = Object.assign({
        preserve: !0
    }, e);
    return {
        postcssPlugin: "postcss-place",
        Declaration (e, { result: o }) {
            t.test(e.prop) && onCSSDeclaration(e, o, r);
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/css-prefers-color-scheme/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = /\(\s*prefers-color-scheme\s*:\s*(dark|light)\s*\)/gi, s = "(color: 48842621)", r = "(color: 70318723)", creator = (o)=>{
    const t = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-prefers-color-scheme",
        prepare () {
            const o = new WeakSet;
            return {
                postcssPlugin: "postcss-prefers-color-scheme",
                AtRule (c) {
                    if (o.has(c)) return;
                    if ("media" !== c.name.toLowerCase()) return;
                    const { params: a } = c, p = a.replace(e, (e, o)=>"dark" === o.toLowerCase() ? s : "light" === o.toLowerCase() ? r : e);
                    a !== p && (o.add(c), c.cloneBefore({
                        params: p
                    }), t.preserve || c.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-random-function/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const r = String.fromCodePoint(0);
function randomCacheKeyFromPostcssDeclaration(e) {
    let o = "", s = e.parent;
    for(; s;){
        switch(s.type){
            case "rule":
                o += r + "selector" + r + s.selector + r;
                break;
            case "atrule":
                "scope" === s.name && (o += r + "prelude" + r + s.params + r);
        }
        s = s.parent;
    }
    return {
        propertyName: e.prop,
        propertyN: 0,
        elementID: o,
        documentID: e.source?.input.css ?? e.root().toString()
    };
}
const o = /(?<![-\w])(?:random)\(/i, creator = (r)=>{
    const s = Object.assign({
        preserve: !1
    }, r);
    return {
        postcssPlugin: "postcss-random-function",
        Declaration (r) {
            if (!o.test(r.value)) return;
            const t = e.calc(r.value, {
                precision: 5,
                toCanonicalUnits: !0,
                randomCaching: randomCacheKeyFromPostcssDeclaration(r)
            });
            t !== r.value && (r.cloneBefore({
                value: t
            }), s.preserve || r.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-color-rebeccapurple/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)");
const s = /rebeccapurple/i, t = /^rebeccapurple$/i, creator = (c)=>{
    const l = Object.assign({
        preserve: !1
    }, c);
    return {
        postcssPlugin: "postcss-color-rebeccapurple",
        Declaration (c) {
            if (!s.test(c.value)) return;
            if (r.hasFallback(c)) return;
            const a = e(c.value);
            a.walk((e)=>{
                "word" === e.type && t.test(e.value) && (e.value = "#639");
            });
            const o = String(a);
            o !== c.value && (c.cloneBefore({
                value: o
            }), l.preserve || c.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-relative-color-syntax/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/@csstools/css-color-parser/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/@csstools/utilities/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)");
const o = /\b(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)\(/i, l = /\b(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)\(\s*from/i, i = /^(?:rgb|rgba|hsl|hsla|hwb|lab|lch|oklch|oklab|color)$/i, n = /from/i, basePlugin = (s)=>({
        postcssPlugin: "postcss-relative-color-syntax",
        Declaration (c) {
            const u = c.value;
            if (!o.test(u) || !n.test(u)) return;
            if (a.hasFallback(c)) return;
            if (a.hasSupportsAtRuleAncestor(c, l)) return;
            const p = t.tokenize({
                css: u
            }), g = r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(p), (s)=>{
                if (!r.isFunctionNode(s) || !i.test(s.getName())) return;
                const a = e.color(s);
                return a && !a.syntaxFlags.has(e.SyntaxFlag.Experimental) && !a.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) && a.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) ? e.serializeRGB(a) : void 0;
            }), b = r.stringify(g);
            if (b === u) return;
            let y = b;
            s?.subFeatures.displayP3 && (y = r.stringify(r.replaceComponentValues(r.parseCommaSeparatedListOfComponentValues(p), (s)=>{
                if (!r.isFunctionNode(s) || !i.test(s.getName())) return;
                const a = e.color(s);
                return a && !a.syntaxFlags.has(e.SyntaxFlag.Experimental) && !a.syntaxFlags.has(e.SyntaxFlag.HasNoneKeywords) && a.syntaxFlags.has(e.SyntaxFlag.RelativeColorSyntax) ? e.colorDataFitsRGB_Gamut(a) ? e.serializeRGB(a) : e.serializeP3(a) : void 0;
            }))), c.cloneBefore({
                value: b
            }), s?.subFeatures.displayP3 && y !== b && c.cloneBefore({
                value: y
            }), s?.preserve || c.remove();
        }
    });
basePlugin.postcss = !0;
const postcssPlugin = (e)=>{
    const a = Object.assign({
        enableProgressiveCustomProperties: !0,
        preserve: !1,
        subFeatures: {
            displayP3: !0
        }
    }, e);
    return a.subFeatures = Object.assign({
        displayP3: !0
    }, a.subFeatures), a.enableProgressiveCustomProperties && (a.preserve || a.subFeatures.displayP3) ? {
        postcssPlugin: "postcss-relative-color-syntax",
        plugins: [
            s(),
            basePlugin(a)
        ]
    } : basePlugin(a);
};
postcssPlugin.postcss = !0, module.exports = postcssPlugin;
}}),
"[project]/node_modules/@csstools/postcss-scope-pseudo-class/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-scope-pseudo-class/node_modules/postcss-selector-parser/dist/index.js [postcss] (ecmascript)");
const creator = (s)=>{
    const r = Object.assign({
        preserve: !1
    }, s);
    return {
        postcssPlugin: "postcss-scope-pseudo-class",
        prepare () {
            const s = new WeakSet;
            return {
                postcssPlugin: "postcss-scope-pseudo-class",
                Rule (t, { result: o }) {
                    if (!t.selector.toLowerCase().includes(":scope")) return;
                    if (s.has(t)) return;
                    {
                        let e = t.parent;
                        for(; e;){
                            if ("atrule" === e.type && "scope" === e.name.toLowerCase()) return;
                            e = e.parent;
                        }
                    }
                    let c = t.selector;
                    try {
                        const s = e().astSync(c);
                        if (!s) return;
                        s.walkPseudos((e)=>{
                            if (":has" === e.value.toLowerCase()) return !1;
                            ":scope" === e.value.toLowerCase() && (e.value = ":root");
                        }), c = s.toString();
                    } catch (e) {
                        t.warn(o, `Failed to parse selector : "${t.selector}" with message: "${e instanceof Error ? e.message : e}"`);
                    }
                    c !== t.selector && (s.add(t), t.cloneBefore({
                        selector: c
                    }), r.preserve || t.remove());
                }
            };
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-sign-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/css-tokenizer/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/@csstools/css-parser-algorithms/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:sign|abs)\(/i, a = /(?<![-\w])(?:sign|abs)\(/i, creator = (t)=>{
    const r = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-sign-functions",
        Declaration (t) {
            if (!s.test(t.value)) return;
            let i;
            i = a.test(t.value) ? n.replaceComponentValues(n.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: t.value
            })), replacer) : n.parseCommaSeparatedListOfComponentValues(o.tokenize({
                css: t.value
            }));
            const p = n.stringify(e.calcFromComponentValues(i, {
                precision: 5,
                toCanonicalUnits: !0
            }));
            p !== t.value && (t.cloneBefore({
                value: p
            }), r.preserve || t.remove());
        }
    };
};
function replacer(e) {
    if (!n.isFunctionNode(e)) return;
    if ("abs" !== e.getName().toLowerCase()) return;
    const [s] = n.replaceComponentValues([
        e.value
    ], replacer);
    return [
        new n.FunctionNode([
            o.TokenType.Function,
            "max(",
            -1,
            -1,
            {
                value: "max"
            }
        ], [
            o.TokenType.CloseParen,
            ")",
            -1,
            -1,
            void 0
        ], [
            new n.SimpleBlockNode([
                o.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ], [
                o.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], n.parseListOfComponentValues(s.flatMap((e)=>e.tokens()))),
            new n.TokenNode([
                o.TokenType.Comma,
                ",",
                -1,
                -1,
                void 0
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.TokenNode([
                o.TokenType.Number,
                "-1",
                -1,
                -1,
                {
                    value: -1,
                    type: o.NumberType.Integer,
                    signCharacter: "-"
                }
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.TokenNode([
                o.TokenType.Delim,
                "*",
                -1,
                -1,
                {
                    value: "*"
                }
            ]),
            new n.WhitespaceNode([
                [
                    o.TokenType.Whitespace,
                    " ",
                    -1,
                    -1,
                    void 0
                ]
            ]),
            new n.SimpleBlockNode([
                o.TokenType.OpenParen,
                "(",
                -1,
                -1,
                void 0
            ], [
                o.TokenType.CloseParen,
                ")",
                -1,
                -1,
                void 0
            ], n.parseListOfComponentValues(s.flatMap((e)=>e.tokens())))
        ])
    ];
}
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-stepped-value-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const s = /(?<![-\w])(?:mod|rem|round)\(/i, creator = (o)=>{
    const t = Object.assign({
        preserve: !1
    }, o);
    return {
        postcssPlugin: "postcss-stepped-value-functions",
        Declaration (o) {
            if (!s.test(o.value)) return;
            const c = e.calc(o.value, {
                precision: 5,
                toCanonicalUnits: !0
            });
            c !== o.value && (o.cloneBefore({
                value: c
            }), t.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-text-decoration-shorthand/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var e = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)"), o = __turbopack_context__.r("[project]/node_modules/@csstools/color-helpers/dist/index.cjs [postcss] (ecmascript)");
const r = /^text-decoration$/i, creator = (o)=>{
    const c = Object.assign({
        preserve: !0
    }, o);
    return {
        postcssPlugin: "postcss-text-decoration-shorthand",
        prepare () {
            const o = new Map;
            return {
                postcssPlugin: "postcss-text-decoration-shorthand",
                OnceExit () {
                    o.clear();
                },
                Declaration (u) {
                    if (!r.test(u.prop)) return;
                    const a = u.parent;
                    if (!a) return;
                    const i = a.index(u);
                    if (a.nodes.some((e)=>"decl" === e.type && r.test(e.prop) && o.get(u.value) === e.value && a.index(e) !== i)) return;
                    const d = e(u.value), p = d.nodes.filter((e)=>"space" !== e.type && "comment" !== e.type);
                    if (p.find((e)=>"var" === e.value.toLowerCase() && "function" === e.type)) return;
                    if (p.find((e)=>"word" === e.type && t.includes(e.value))) return;
                    const f = {
                        line: [],
                        style: null,
                        color: null,
                        thickness: null
                    };
                    for(let o = 0; o < p.length; o++){
                        const r = p[o];
                        if (f.line.length || "word" !== r.type || !n.includes(r.value.toLowerCase())) if (f.line.length || "word" !== r.type || "none" !== r.value.toLowerCase()) if (f.style || "word" !== r.type || !s.includes(r.value.toLowerCase())) if (f.thickness || "word" !== r.type || !l.includes(r.value.toLowerCase())) if (f.thickness || "function" !== r.type || "calc" !== r.value.toLowerCase()) if (f.color || !nodeIsAColor(r)) {
                            if ("word" !== r.type) return;
                            {
                                let o;
                                try {
                                    o = e.unit(r.value);
                                } catch  {
                                    return;
                                }
                                if (!o || !o.unit) return;
                                f.thickness = r, "%" === o.unit && (f.thickness = {
                                    before: "",
                                    after: "",
                                    sourceIndex: 0,
                                    sourceEndIndex: 0,
                                    type: "function",
                                    value: "calc",
                                    nodes: [
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: "0.01em"
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "space",
                                            value: " "
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: "*"
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "space",
                                            value: " "
                                        },
                                        {
                                            before: "",
                                            after: "",
                                            sourceIndex: 0,
                                            sourceEndIndex: 0,
                                            type: "word",
                                            value: o.number
                                        }
                                    ]
                                });
                            }
                        } else f.color = r;
                        else f.thickness = r;
                        else f.thickness = r;
                        else f.style = r;
                        else f.line.push(r);
                        else {
                            const e = r;
                            let t = r;
                            for(;;){
                                const e = p[o + 1];
                                if (!e || "word" !== e.type || !n.includes(e.value.toLowerCase())) break;
                                t = e, o++;
                            }
                            f.line = d.nodes.slice(d.nodes.indexOf(e), d.nodes.indexOf(t) + 1);
                        }
                    }
                    f.line.length || f.line.push({
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "none"
                    }), f.style || (f.style = {
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "solid"
                    }), f.color || (f.color = {
                        before: "",
                        after: "",
                        sourceIndex: 0,
                        sourceEndIndex: 0,
                        type: "word",
                        value: "currentColor"
                    });
                    const v = e.stringify(f.line);
                    if (u.value.toLowerCase() === v.toLowerCase()) {
                        const e = u.next();
                        return void (e && "decl" === e.type && "text-decoration" === e.prop.toLowerCase() || u.cloneBefore({
                            prop: "-webkit-text-decoration",
                            value: v
                        }));
                    }
                    u.cloneBefore({
                        prop: "text-decoration",
                        value: v
                    });
                    const y = e.stringify([
                        ...f.line,
                        {
                            before: "",
                            after: "",
                            sourceIndex: 0,
                            sourceEndIndex: 0,
                            type: "space",
                            value: " "
                        },
                        f.style,
                        {
                            before: "",
                            after: "",
                            sourceIndex: 0,
                            sourceEndIndex: 0,
                            type: "space",
                            value: " "
                        },
                        f.color
                    ]);
                    f.thickness && u.cloneBefore({
                        prop: "text-decoration",
                        value: y
                    }), f.thickness && u.cloneBefore({
                        prop: "text-decoration-thickness",
                        value: e.stringify([
                            f.thickness
                        ])
                    }), o.set(u.value, v), o.set(y, v), c.preserve || u.remove();
                }
            };
        }
    };
};
function nodeIsAColor(e) {
    return !("word" !== e.type || !e.value.startsWith("#")) || !("word" !== e.type || !u.includes(e.value.toLowerCase())) || !("function" !== e.type || !c.includes(e.value.toLowerCase()));
}
creator.postcss = !0;
const t = [
    "unset",
    "inherit",
    "initial",
    "revert",
    "revert-layer"
], n = [
    "underline",
    "overline",
    "line-through",
    "blink",
    "spelling-error",
    "grammar-error"
], s = [
    "solid",
    "double",
    "dotted",
    "dashed",
    "wavy"
], l = [
    "auto",
    "from-font"
], c = [
    "color",
    "color-mix",
    "hsl",
    "hsla",
    "hwb",
    "lab",
    "lch",
    "oklab",
    "oklch",
    "rgb",
    "rgba"
], u = [
    "currentcolor",
    "transparent",
    ...Object.keys(o.namedColors)
];
module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-trigonometric-functions/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/@csstools/css-calc/dist/index.cjs [postcss] (ecmascript)");
const e = /(?<![-\w])(?:asin|acos|atan|atan2|sin|cos|tan)\(/i, creator = (t)=>{
    const c = Object.assign({
        preserve: !1
    }, t);
    return {
        postcssPlugin: "postcss-trigonometric-functions",
        Declaration (t) {
            if (!e.test(t.value)) return;
            const o = s.calc(t.value, {
                precision: 5,
                toCanonicalUnits: !0
            });
            o !== t.value && (t.cloneBefore({
                value: o
            }), c.preserve || t.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/@csstools/postcss-unset-value/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const e = new Set([
    "block-ellipsis",
    "border-boundary",
    "border-collapse",
    "border-spacing",
    "box-snap",
    "caption-side",
    "caret",
    "caret-shape",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "cursor",
    "direction",
    "dominant-baseline",
    "empty-cells",
    "fill",
    "fill-color",
    "fill-image",
    "fill-opacity",
    "fill-position",
    "fill-repeat",
    "fill-rule",
    "fill-size",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-variant",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-weight",
    "forced-color-adjust",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphenate-limit-last",
    "hyphenate-limit-lines",
    "hyphenate-limit-zone",
    "hyphens",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "initial-letter-wrap",
    "letter-spacing",
    "line-break",
    "line-height",
    "line-padding",
    "line-snap",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-side",
    "marker-start",
    "orphans",
    "overflow-wrap",
    "paint-order",
    "pointer-events",
    "print-color-adjust",
    "quotes",
    "ruby-merge",
    "ruby-overhang",
    "ruby-position",
    "shape-rendering",
    "speak",
    "speak-as",
    "stroke",
    "stroke-align",
    "stroke-alignment",
    "stroke-color",
    "stroke-dash-corner",
    "stroke-dash-justify",
    "stroke-dashadjust",
    "stroke-dasharray",
    "stroke-dashcorner",
    "stroke-dashoffset",
    "stroke-image",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-position",
    "stroke-repeat",
    "stroke-size",
    "stroke-width",
    "tab-size",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration-skip",
    "text-decoration-skip-box",
    "text-decoration-skip-inset",
    "text-decoration-skip-self",
    "text-decoration-skip-spaces",
    "text-edge",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-skip",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-space-collapse",
    "text-spacing",
    "text-transform",
    "text-underline-position",
    "text-wrap",
    "visibility",
    "voice-balance",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "widows",
    "word-boundary-detection",
    "word-boundary-expansion",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode"
]), t = new Set([
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-block",
    "background-position-inline",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "baseline-source",
    "block-step",
    "block-step-align",
    "block-step-insert",
    "block-step-round",
    "block-step-size",
    "bookmark-label",
    "bookmark-level",
    "bookmark-state",
    "border",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-clip",
    "border-clip-bottom",
    "border-clip-left",
    "border-clip-right",
    "border-clip-top",
    "border-color",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-limit",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "clear",
    "clip",
    "clip-path",
    "color-adjust",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "continue",
    "copy-into",
    "corner-shape",
    "corners",
    "counter-increment",
    "counter-reset",
    "cue",
    "cue-after",
    "cue-before",
    "cx",
    "cy",
    "d",
    "display",
    "fill-break",
    "fill-origin",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "float-defer",
    "float-offset",
    "float-reference",
    "flood-color",
    "flood-opacity",
    "flow-from",
    "flow-into",
    "footnote-display",
    "footnote-policy",
    "gap",
    "glyph-orientation-vertical",
    "grid-auto-columns",
    "grid-auto-rows",
    "grid-column-gap",
    "grid-gap",
    "grid-row-gap",
    "grid-template-columns",
    "grid-template-rows",
    "height",
    "initial-letter",
    "inline-sizing",
    "input-security",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "leading-trim",
    "left",
    "lighting-color",
    "line-clamp",
    "line-grid",
    "margin",
    "margin-bottom",
    "margin-break",
    "margin-left",
    "margin-right",
    "margin-top",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-image",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "max-height",
    "max-lines",
    "max-width",
    "min-height",
    "min-intrinsic-sizing",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-left",
    "nav-right",
    "nav-up",
    "object-fit",
    "object-position",
    "opacity",
    "order",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-x",
    "overflow-y",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "position",
    "r",
    "region-fragment",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "row-gap",
    "rx",
    "ry",
    "scroll-snap-type",
    "shape-image-threshold",
    "shape-inside",
    "shape-margin",
    "shape-outside",
    "shape-padding",
    "shape-subtract",
    "spatial-navigation-action",
    "spatial-navigation-contain",
    "spatial-navigation-function",
    "stop-color",
    "stop-opacity",
    "string-set",
    "stroke-break",
    "stroke-origin",
    "table-layout",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-style",
    "text-emphasis",
    "text-group-align",
    "text-overflow",
    "text-space-trim",
    "top",
    "touch-action",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "unicode-bidi",
    "user-select",
    "vector-effect",
    "vertical-align",
    "voice-duration",
    "width",
    "will-change",
    "wrap-after",
    "wrap-before",
    "wrap-flow",
    "wrap-inside",
    "wrap-through",
    "x",
    "y",
    "z-index"
]), creator = (o)=>{
    const i = Object.assign({
        preserve: !1
    }, o);
    return {
        postcssPlugin: "postcss-unset-value",
        Declaration (o) {
            if ("unset" !== o.value.toLowerCase()) return;
            let r = !1;
            e.has(o.prop.toLowerCase()) ? r = "inherit" : t.has(o.prop.toLowerCase()) && (r = "initial"), r && (o.cloneBefore({
                prop: o.prop,
                value: r
            }), i.preserve || o.remove());
        }
    };
};
creator.postcss = !0, module.exports = creator;
}}),
"[project]/node_modules/postcss-preset-env/dist/index.cjs [postcss] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var s = __turbopack_context__.r("[project]/node_modules/autoprefixer/lib/autoprefixer.js [postcss] (ecmascript)"), e = __turbopack_context__.r("[project]/node_modules/cssdb/cssdb.json (json)"), o = __turbopack_context__.r("[project]/node_modules/browserslist/index.js [postcss] (ecmascript)"), t = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-initial/dist/index.cjs [postcss] (ecmascript)"), i = __turbopack_context__.r("[project]/node_modules/postcss-pseudo-class-any-link/dist/index.cjs [postcss] (ecmascript)"), r = __turbopack_context__.r("[project]/node_modules/css-blank-pseudo/dist/index.cjs [postcss] (ecmascript)"), a = __turbopack_context__.r("[project]/node_modules/postcss-page-break/index.js [postcss] (ecmascript)"), c = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-cascade-layers/dist/index.cjs [postcss] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/postcss-attribute-case-insensitive/dist/index.cjs [postcss] (ecmascript)"), p = __turbopack_context__.r("[project]/node_modules/postcss-clamp/index.js [postcss] (ecmascript)"), l = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-function/dist/index.cjs [postcss] (ecmascript)"), u = __turbopack_context__.r("[project]/node_modules/postcss-color-functional-notation/dist/index.cjs [postcss] (ecmascript)"), m = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-mix-function/dist/index.cjs [postcss] (ecmascript)"), d = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-color-mix-variadic-function-arguments/dist/index.cjs [postcss] (ecmascript)"), g = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-content-alt-text/dist/index.cjs [postcss] (ecmascript)"), f = __turbopack_context__.r("[project]/node_modules/postcss-custom-media/dist/index.cjs [postcss] (ecmascript)"), h = __turbopack_context__.r("[project]/node_modules/postcss-custom-properties/dist/index.cjs [postcss] (ecmascript)"), b = __turbopack_context__.r("[project]/node_modules/postcss-custom-selectors/dist/index.cjs [postcss] (ecmascript)"), v = __turbopack_context__.r("[project]/node_modules/postcss-dir-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), N = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-normalize-display-values/dist/index.cjs [postcss] (ecmascript)"), k = __turbopack_context__.r("[project]/node_modules/postcss-double-position-gradients/dist/index.cjs [postcss] (ecmascript)"), y = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-exponential-functions/dist/index.cjs [postcss] (ecmascript)"), w = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-float-and-clear/dist/index.cjs [postcss] (ecmascript)"), q = __turbopack_context__.r("[project]/node_modules/postcss-focus-visible/dist/index.cjs [postcss] (ecmascript)"), x = __turbopack_context__.r("[project]/node_modules/postcss-focus-within/dist/index.cjs [postcss] (ecmascript)"), F = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-font-format-keywords/dist/index.cjs [postcss] (ecmascript)"), $ = __turbopack_context__.r("[project]/node_modules/postcss-font-variant/index.js [postcss] (ecmascript)"), O = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-gamut-mapping/dist/index.cjs [postcss] (ecmascript)"), S = __turbopack_context__.r("[project]/node_modules/postcss-gap-properties/dist/index.cjs [postcss] (ecmascript)"), C = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-gradients-interpolation-method/dist/index.cjs [postcss] (ecmascript)"), P = __turbopack_context__.r("[project]/node_modules/css-has-pseudo/dist/index.cjs [postcss] (ecmascript)"), E = __turbopack_context__.r("[project]/node_modules/postcss-color-hex-alpha/dist/index.cjs [postcss] (ecmascript)"), I = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-hwb-function/dist/index.cjs [postcss] (ecmascript)"), A = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-ic-unit/dist/index.cjs [postcss] (ecmascript)"), B = __turbopack_context__.r("[project]/node_modules/postcss-image-set-function/dist/index.cjs [postcss] (ecmascript)"), L = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-is-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), _ = __turbopack_context__.r("[project]/node_modules/postcss-lab-function/dist/index.cjs [postcss] (ecmascript)"), U = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-light-dark-function/dist/index.cjs [postcss] (ecmascript)"), j = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-overflow/dist/index.cjs [postcss] (ecmascript)"), M = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-overscroll-behavior/dist/index.cjs [postcss] (ecmascript)"), z = __turbopack_context__.r("[project]/node_modules/postcss-logical/dist/index.cjs [postcss] (ecmascript)"), D = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-resize/dist/index.cjs [postcss] (ecmascript)"), R = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-logical-viewport-units/dist/index.cjs [postcss] (ecmascript)"), T = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-media-queries-aspect-ratio-number-values/dist/index.cjs [postcss] (ecmascript)"), V = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-media-minmax/dist/index.cjs [postcss] (ecmascript)"), H = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-nested-calc/dist/index.cjs [postcss] (ecmascript)"), W = __turbopack_context__.r("[project]/node_modules/postcss-nesting/dist/index.cjs [postcss] (ecmascript)"), G = __turbopack_context__.r("[project]/node_modules/postcss-selector-not/dist/index.cjs [postcss] (ecmascript)"), K = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-oklab-function/dist/index.cjs [postcss] (ecmascript)"), Z = __turbopack_context__.r("[project]/node_modules/postcss-opacity-percentage/index.js [postcss] (ecmascript)"), Q = __turbopack_context__.r("[project]/node_modules/postcss-overflow-shorthand/dist/index.cjs [postcss] (ecmascript)"), J = __turbopack_context__.r("[project]/node_modules/postcss-replace-overflow-wrap/index.js [postcss] (ecmascript)"), X = __turbopack_context__.r("[project]/node_modules/postcss-place/dist/index.cjs [postcss] (ecmascript)"), Y = __turbopack_context__.r("[project]/node_modules/css-prefers-color-scheme/dist/index.cjs [postcss] (ecmascript)"), ss = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-progressive-custom-properties/dist/index.cjs [postcss] (ecmascript)"), es = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-random-function/dist/index.cjs [postcss] (ecmascript)"), os = __turbopack_context__.r("[project]/node_modules/postcss-color-rebeccapurple/dist/index.cjs [postcss] (ecmascript)"), ts = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-relative-color-syntax/dist/index.cjs [postcss] (ecmascript)"), is = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-scope-pseudo-class/dist/index.cjs [postcss] (ecmascript)"), rs = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-sign-functions/dist/index.cjs [postcss] (ecmascript)"), as = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-stepped-value-functions/dist/index.cjs [postcss] (ecmascript)"), cs = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-text-decoration-shorthand/dist/index.cjs [postcss] (ecmascript)"), ns = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-trigonometric-functions/dist/index.cjs [postcss] (ecmascript)"), ps = __turbopack_context__.r("[project]/node_modules/@csstools/postcss-unset-value/dist/index.cjs [postcss] (ecmascript)");
const ls = {
    "blank-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-blank-pseudo/README.md#browser",
    "focus-visible-pseudo-class": "https://github.com/WICG/focus-visible",
    "focus-within-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/postcss-focus-within/README.md#browser",
    "has-pseudo-class": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-has-pseudo/README.md#browser",
    "prefers-color-scheme-query": "https://github.com/csstools/postcss-plugins/blob/main/plugins/css-prefers-color-scheme/README.md#browser"
}, us = [
    "blank-pseudo-class",
    "focus-visible-pseudo-class",
    "focus-within-pseudo-class",
    "has-pseudo-class",
    "prefers-color-scheme-query"
];
function logFeaturesList(s, e, o) {
    if (e.debug) {
        o.log("Enabling the following feature(s):");
        const t = [], i = [];
        !1 !== e.autoprefixer && i.push("  autoprefixer"), s.forEach((s)=>{
            s.id.startsWith("before") || s.id.startsWith("after") ? i.push(`  ${s.id} (injected via options)`) : i.push(`  ${s.id}`), void 0 !== ls[s.id] && t.push(s.id);
        }), i.sort((s, e)=>s.localeCompare(e)), t.sort((s, e)=>s.localeCompare(e)), i.forEach((s)=>o.log(s)), t.length && (o.log("These feature(s) need a browser library to work:"), t.forEach((s)=>o.log(`  ${s}: ${ls[s]}`)));
    }
}
function initializeSharedOptions(s) {
    if ("preserve" in s) {
        const e = {};
        return e.preserve = s.preserve, e;
    }
    return !1;
}
function clamp(s, e, o) {
    return Math.max(s, Math.min(e, o));
}
function stageFromOptions(s, e) {
    let o = 2;
    if (void 0 === s.stage) return e.log("Using features from Stage 2 (default)."), o;
    if (!1 === s.stage) o = 5;
    else {
        let e = parseInt(s.stage, 10);
        Number.isNaN(e) && (e = 0), o = clamp(0, e, 5);
    }
    return 5 === o ? e.log('Stage has been disabled, features will be handled via the "features" option.') : e.log(`Using features from Stage ${o}.`), o;
}
const ms = Symbol("insertBefore"), ds = Symbol("insertAfter"), gs = Symbol("insertOrder"), fs = Symbol("plugin");
function getTransformedInsertions(s, e, o) {
    if ("insertBefore" !== o && "insertAfter" !== o) return [];
    const t = "insertBefore" === o ? ms : ds, i = [];
    for(const o in e){
        if (!Object.hasOwnProperty.call(e, o)) continue;
        if (!s.find((s)=>s.id === o)) continue;
        let r = e[o];
        Array.isArray(r) || (r = [
            r
        ]);
        for(let s = 0; s < r.length; s++)i.push({
            id: o,
            [fs]: r[s],
            [gs]: s,
            [t]: !0
        });
    }
    return i;
}
var hs = [
    "custom-media-queries",
    "environment-variables",
    "image-set-function",
    "media-query-ranges",
    "media-queries-aspect-ratio-number-values",
    "prefers-color-scheme-query",
    "nesting-rules",
    "custom-selectors",
    "any-link-pseudo-class",
    "case-insensitive-attributes",
    "focus-visible-pseudo-class",
    "focus-within-pseudo-class",
    "not-pseudo-class",
    "logical-properties-and-values",
    "float-clear-logical-values",
    "logical-overflow",
    "logical-overscroll-behavior",
    "logical-resize",
    "logical-viewport-units",
    "dir-pseudo-class",
    "all-property",
    "gradients-interpolation-method",
    "color-mix-variadic-function-arguments",
    "color-mix",
    "relative-color-syntax",
    "lab-function",
    "oklab-function",
    "color-function",
    "hwb-function",
    "color-functional-notation",
    "rebeccapurple-color",
    "hexadecimal-alpha-notation",
    "light-dark-function",
    "double-position-gradients",
    "blank-pseudo-class",
    "break-properties",
    "font-variant-property",
    "is-pseudo-class",
    "scope-pseudo-class",
    "has-pseudo-class",
    "gap-properties",
    "overflow-property",
    "overflow-wrap-property",
    "place-properties",
    "system-ui-font-family",
    "font-format-keywords",
    "display-two-values",
    "content-alt-text",
    "ic-unit",
    "opacity-percentage",
    "text-decoration-shorthand",
    "unset-value",
    "random-function",
    "sign-functions",
    "stepped-value-functions",
    "trigonometric-functions",
    "exponential-functions",
    "clamp",
    "nested-calc",
    "custom-properties",
    "cascade-layers",
    "progressive-custom-properties",
    "gamut-mapping"
];
function featureIsLess(s, e) {
    return s.id === e.id ? s[ms] && e[ms] || s[ds] && e[ds] ? clamp(-1, s[gs] - e[gs], 1) : s[ms] || e[ds] ? -1 : s[ds] || e[ms] ? 1 : 0 : clamp(-1, hs.indexOf(s.id) - hs.indexOf(e.id), 1);
}
function postcssSystemUiFont() {
    return {
        postcssPlugin: "postcss-system-ui-font",
        Declaration (s) {
            bs.test(s.prop) && (s.value.includes(ks) || (s.value = s.value.replace(ys, ws)));
        }
    };
}
postcssSystemUiFont.postcss = !0;
const bs = /(?:^(?:-|\\002d){2})|(?:^font(?:-family)?$)/i, vs = "[\\f\\n\\r\\x09\\x20]", Ns = [
    "system-ui",
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Ubuntu",
    "Cantarell",
    "Noto Sans",
    "sans-serif"
], ks = Ns.join(", "), ys = new RegExp(`(^|,|${vs}+)(?:system-ui${vs}*)(?:,${vs}*(?:${Ns.join("|")})${vs}*)?(,|$)`, "i"), ws = `$1${ks}$2`, qs = new Map([
    [
        "all-property",
        t
    ],
    [
        "any-link-pseudo-class",
        i
    ],
    [
        "blank-pseudo-class",
        r
    ],
    [
        "break-properties",
        a
    ],
    [
        "cascade-layers",
        c
    ],
    [
        "case-insensitive-attributes",
        n
    ],
    [
        "clamp",
        p
    ],
    [
        "color-function",
        l
    ],
    [
        "color-functional-notation",
        u
    ],
    [
        "color-mix",
        m
    ],
    [
        "color-mix-variadic-function-arguments",
        d
    ],
    [
        "content-alt-text",
        g
    ],
    [
        "custom-media-queries",
        f
    ],
    [
        "custom-properties",
        h
    ],
    [
        "custom-selectors",
        b
    ],
    [
        "dir-pseudo-class",
        v
    ],
    [
        "display-two-values",
        N
    ],
    [
        "double-position-gradients",
        k
    ],
    [
        "exponential-functions",
        y
    ],
    [
        "float-clear-logical-values",
        w
    ],
    [
        "focus-visible-pseudo-class",
        q
    ],
    [
        "focus-within-pseudo-class",
        x
    ],
    [
        "font-format-keywords",
        F
    ],
    [
        "font-variant-property",
        $
    ],
    [
        "gamut-mapping",
        O
    ],
    [
        "gap-properties",
        S
    ],
    [
        "gradients-interpolation-method",
        C
    ],
    [
        "has-pseudo-class",
        P
    ],
    [
        "hexadecimal-alpha-notation",
        E
    ],
    [
        "hwb-function",
        I
    ],
    [
        "ic-unit",
        A
    ],
    [
        "image-set-function",
        B
    ],
    [
        "is-pseudo-class",
        L
    ],
    [
        "lab-function",
        _
    ],
    [
        "light-dark-function",
        U
    ],
    [
        "logical-overflow",
        j
    ],
    [
        "logical-overscroll-behavior",
        M
    ],
    [
        "logical-properties-and-values",
        z
    ],
    [
        "logical-resize",
        D
    ],
    [
        "logical-viewport-units",
        R
    ],
    [
        "media-queries-aspect-ratio-number-values",
        T
    ],
    [
        "media-query-ranges",
        V
    ],
    [
        "nested-calc",
        H
    ],
    [
        "nesting-rules",
        W
    ],
    [
        "not-pseudo-class",
        G
    ],
    [
        "oklab-function",
        K
    ],
    [
        "opacity-percentage",
        Z
    ],
    [
        "overflow-property",
        Q
    ],
    [
        "overflow-wrap-property",
        J
    ],
    [
        "place-properties",
        X
    ],
    [
        "prefers-color-scheme-query",
        Y
    ],
    [
        "progressive-custom-properties",
        ss
    ],
    [
        "random-function",
        es
    ],
    [
        "rebeccapurple-color",
        os
    ],
    [
        "relative-color-syntax",
        ts
    ],
    [
        "scope-pseudo-class",
        is
    ],
    [
        "sign-functions",
        rs
    ],
    [
        "stepped-value-functions",
        as
    ],
    [
        "system-ui-font-family",
        postcssSystemUiFont
    ],
    [
        "text-decoration-shorthand",
        cs
    ],
    [
        "trigonometric-functions",
        ns
    ],
    [
        "unset-value",
        ps
    ]
]);
function featureIsInsertedOrHasAPlugin(s) {
    return !!s[ms] || !!s[ds] || !!qs.has(s.id);
}
function prepareFeaturesList(s, e, o) {
    return s.concat(getTransformedInsertions(s, e, "insertBefore"), getTransformedInsertions(s, o, "insertAfter")).filter((s)=>featureIsInsertedOrHasAPlugin(s)).sort((s, e)=>featureIsLess(s, e));
}
function getOptionsForBrowsersByFeature(s, e, o, t) {
    switch(e.id){
        case "is-pseudo-class":
            return {
                onComplexSelector: "warning"
            };
        case "any-link-pseudo-class":
            if (s.find((s)=>s.startsWith("ie ") || "edge 12" === s || "edge 13" === s || "edge 14" === s || "edge 15" === s || "edge 16" === s || "edge 17" === s || "edge 18" === s)) return t.log("- 'any-link-pseudo-class' setting 'subFeatures: { areaHrefNeedsFixing: true }' due to lack of browser support for area[href] in Edge and IE."), {
                subFeatures: {
                    areaHrefNeedsFixing: !0
                }
            };
            return {};
        case "logical-properties-and-values":
        case "float-clear-logical-values":
        case "logical-resize":
        case "logical-viewport-units":
        case "logical-overflow":
        case "logical-overscroll-behavior":
            return "logical" in o ? o.logical : {};
        default:
            return {};
    }
}
const xs = [
    "and_chr",
    "and_ff",
    "android",
    "chrome",
    "edge",
    "firefox",
    "ie",
    "ios_saf",
    "op_mini",
    "op_mob",
    "opera",
    "safari",
    "samsung"
];
function getUnsupportedBrowsersByFeature(s) {
    if (!s) return [];
    if (!("browser_support" in s)) return [
        "> 0%"
    ];
    const e = [];
    return xs.forEach((o)=>{
        if ("op_mini" === o && void 0 === s.browser_support[o]) return void e.push("op_mini all");
        const t = s.browser_support[o];
        "string" == typeof t && Fs.test(t) ? e.push(`${o} < ${s.browser_support[o]}`) : e.push(`${o} >= 1`);
    }), e;
}
const Fs = /^[0-9|.]+$/;
function formatPolyfillableFeature(s) {
    const e = getUnsupportedBrowsersByFeature(s);
    if (s[ms] || s[ds]) {
        let o = s.id;
        return o = s.insertBefore ? `before-${o}` : `after-${o}`, {
            browsers: e,
            vendors_implementations: s.vendors_implementations,
            plugin: s[fs],
            id: o,
            stage: 6
        };
    }
    return {
        browsers: e,
        vendors_implementations: s.vendors_implementations,
        plugin: qs.get(s.id),
        id: s.id,
        stage: s.stage
    };
}
function formatStagedFeature(s, e, o, t, i, r) {
    let a, c;
    return a = getOptionsForBrowsersByFeature(s, o, i, r), a = t ? Object.assign({}, a, t, featureOptions(e, o.id)) : Object.assign({}, a, featureOptions(e, o.id)), "progressive-custom-properties" !== o.id && (a.enableProgressiveCustomProperties = !1), "overflow-wrap-property" === o.id && "preserve" in a && (a.method = a.preserve ? "copy" : "replace"), c = o.plugin.postcss && "function" == typeof o.plugin ? o.plugin(a) : o.plugin && o.plugin.default && "function" == typeof o.plugin.default && o.plugin.default.postcss ? o.plugin.default(a) : o.plugin, {
        browsers: o.browsers,
        vendors_implementations: o.vendors_implementations,
        plugin: c,
        pluginOptions: a,
        id: o.id
    };
}
function featureOptions(s, e) {
    if (!(e in s)) return;
    const o = s[e];
    return Array.isArray(o) ? o[1] : o;
}
function intOrZero(s) {
    const e = parseInt(s, 10);
    return Number.isNaN(e) ? 0 : e;
}
const $s = new Set([
    "progressive-custom-properties"
]);
function listFeatures(s, e, t, i) {
    const r = Object(e.features), a = "enableClientSidePolyfills" in e && e.enableClientSidePolyfills, c = Object(e.insertBefore), n = Object(e.insertAfter), p = e.browsers ? void 0 : e.env, l = e.browsers, u = clamp(0, intOrZero(e.minimumVendorImplementations), 3);
    u > 0 && i.log(`Using features with ${u} or more vendor implementations.`);
    const m = stageFromOptions(e, i), d = prepareFeaturesList([
        ...s,
        {
            id: "progressive-custom-properties"
        }
    ], c, n).map((s)=>formatPolyfillableFeature(s)).filter((s)=>!!$s.has(s.id) || 0 === u || !(!s[ms] && !s[ds]) || u <= s.vendors_implementations || (!0 === featureEnabledByOptions(r, s.id) ? (i.log(`- '${s.id}' enabled manually even when it lacks the required interop (${s.vendors_implementations} out of ${u}).`), !0) : (i.log(`- '${s.id}' disabled because it lacks the required interop (${s.vendors_implementations} out of ${u}).`), !1))), g = o(l, {
        env: p,
        ignoreUnknownVersions: !0
    }).filter((s)=>xs.includes(s.split(" ")[0]));
    return d.filter((s)=>{
        if ($s.has(s.id)) return !0;
        const e = s.stage >= m, o = a || !us.includes(s.id), t = featureEnabledByOptions(r, s.id), c = !1 === t, n = !0 === t || e && o;
        return c ? i.log(`- '${s.id}' disabled manually`) : e ? o || i.log(`- '${s.id}' disabled because 'enableClientSidePolyfills' is 'false'.`) : n ? i.log(`- '${s.id}' enabled manually even when it lacks the required stage (${s.stage} out of ${m}).`) : i.log(`- '${s.id}' disabled because it lacks the required stage (${s.stage} out of ${m}).`), !c && n;
    }).map((s)=>formatStagedFeature(g, r, s, t, e, i)).filter((s)=>{
        if ($s.has(s.id)) return !0;
        const e = featureEnabledByOptions(r, s.id);
        if (!0 === e || !1 === e) return e;
        const t = o(s.browsers, {
            ignoreUnknownVersions: !0
        }), a = g.filter((s)=>t.some((e)=>e === s));
        return a.length > 0 ? i.log(`- '${s.id}' enabled for:\n    ${a.join("\n    ")}`) : i.log(`- '${s.id}' disabled because all targeted browsers support it.`), a.length > 0;
    });
}
function featureEnabledByOptions(s, e) {
    if (!(e in s)) return "auto";
    const o = s[e];
    return Array.isArray(o) ? !0 === o[0] || !1 !== o[0] && "auto" : Boolean(o);
}
class Logger {
    constructor(){
        this.logs = [];
    }
    log(s) {
        this.logs.push(s);
    }
    resetLogger() {
        this.logs.length = 0;
    }
    emitLogs(s) {
        s && s.warn(this.logs.join("\n")), this.resetLogger();
    }
}
var Os = [
    {
        packageName: "css-blank-pseudo",
        id: "blank-pseudo-class",
        importName: "postcssBlankPseudo"
    },
    {
        packageName: "css-has-pseudo",
        id: "has-pseudo-class",
        importName: "postcssHasPseudo"
    },
    {
        packageName: "css-prefers-color-scheme",
        id: "prefers-color-scheme-query",
        importName: "postcssPrefersColorScheme"
    },
    {
        packageName: "postcss-attribute-case-insensitive",
        id: "case-insensitive-attributes",
        importName: "postcssAttributeCaseInsensitive"
    },
    {
        packageName: "postcss-clamp",
        id: "clamp",
        importName: "postcssClamp"
    },
    {
        packageName: "@csstools/postcss-color-mix-variadic-function-arguments",
        id: "color-mix-variadic-function-arguments",
        importName: "postcssColorMixVariadicFunctionArguments"
    },
    {
        packageName: "@csstools/postcss-color-mix-function",
        id: "color-mix",
        importName: "postcssColorMixFunction"
    },
    {
        packageName: "@csstools/postcss-color-function",
        id: "color-function",
        importName: "postcssColorFunction"
    },
    {
        packageName: "postcss-color-functional-notation",
        id: "color-functional-notation",
        importName: "postcssColorFunctionalNotation"
    },
    {
        packageName: "postcss-color-hex-alpha",
        id: "hexadecimal-alpha-notation",
        importName: "postcssColorHexAlpha"
    },
    {
        packageName: "@csstools/postcss-content-alt-text",
        id: "content-alt-text",
        importName: "postcssContentAltText"
    },
    {
        packageName: "postcss-color-rebeccapurple",
        id: "rebeccapurple-color",
        importName: "postcssColorRebeccapurple"
    },
    {
        packageName: "postcss-custom-media",
        id: "custom-media-queries",
        importName: "postcssCustomMedia"
    },
    {
        packageName: "postcss-custom-properties",
        id: "custom-properties",
        importName: "postcssCustomProperties"
    },
    {
        packageName: "postcss-custom-selectors",
        id: "custom-selectors",
        importName: "postcssCustomSelectors"
    },
    {
        packageName: "postcss-dir-pseudo-class",
        id: "dir-pseudo-class",
        importName: "postcssDirPseudoClass"
    },
    {
        packageName: "postcss-double-position-gradients",
        id: "double-position-gradients",
        importName: "postcssDoublePositionGradients"
    },
    {
        packageName: "@csstools/postcss-exponential-functions",
        id: "exponential-functions",
        importName: "postcssExponentialFunctions"
    },
    {
        packageName: "postcss-focus-visible",
        id: "focus-visible-pseudo-class",
        importName: "postcssFocusVisible"
    },
    {
        packageName: "postcss-focus-within",
        id: "focus-within-pseudo-class",
        importName: "postcssFocusWithin"
    },
    {
        packageName: "@csstools/postcss-font-format-keywords",
        id: "font-format-keywords",
        importName: "postcssFontFormatKeywords"
    },
    {
        packageName: "postcss-font-variant",
        id: "font-variant-property",
        importName: "postcssFontVariant"
    },
    {
        packageName: "@csstools/postcss-gamut-mapping",
        id: "gamut-mapping",
        importName: "postcssGamutMapping"
    },
    {
        packageName: "postcss-gap-properties",
        id: "gap-properties",
        importName: "postcssGapProperties"
    },
    {
        packageName: "@csstools/postcss-gradients-interpolation-method",
        id: "gradients-interpolation-method",
        importName: "postcssGradientsInterpolationMethod"
    },
    {
        packageName: "@csstools/postcss-hwb-function",
        id: "hwb-function",
        importName: "postcssHWBFunction"
    },
    {
        packageName: "@csstools/postcss-ic-unit",
        id: "ic-unit",
        importName: "postcssICUnit"
    },
    {
        packageName: "postcss-image-set-function",
        id: "image-set-function",
        importName: "postcssImageSetFunction"
    },
    {
        packageName: "@csstools/postcss-initial",
        id: "all-property",
        importName: "postcssInitial"
    },
    {
        packageName: "@csstools/postcss-is-pseudo-class",
        id: "is-pseudo-class",
        importName: "postcssIsPseudoClass"
    },
    {
        packageName: "@csstools/postcss-scope-pseudo-class",
        id: "scope-pseudo-class",
        importName: "postcssScopePseudoClass"
    },
    {
        packageName: "postcss-lab-function",
        id: "lab-function",
        importName: "postcssLabFunction"
    },
    {
        packageName: "@csstools/postcss-light-dark-function",
        id: "light-dark-function",
        importName: "postcssLightDarkFunction"
    },
    {
        packageName: "postcss-logical",
        id: "logical-properties-and-values",
        importName: "postcssLogical"
    },
    {
        packageName: "@csstools/postcss-logical-float-and-clear",
        id: "float-clear-logical-values",
        importName: "postcssLogicalFloatAndClear"
    },
    {
        packageName: "@csstools/postcss-logical-overflow",
        id: "logical-overflow",
        importName: "postcssLogicalOverflow"
    },
    {
        packageName: "@csstools/postcss-logical-overscroll-behavior",
        id: "logical-overscroll-behavior",
        importName: "postcssLogicalOverscrollBehavor"
    },
    {
        packageName: "@csstools/postcss-logical-resize",
        id: "logical-resize",
        importName: "postcssLogicalResize"
    },
    {
        packageName: "@csstools/postcss-logical-viewport-units",
        id: "logical-viewport-units",
        importName: "postcssLogicalViewportUnits"
    },
    {
        packageName: "@csstools/postcss-media-minmax",
        id: "media-query-ranges",
        importName: "postcssMediaMinmax"
    },
    {
        packageName: "@csstools/postcss-media-queries-aspect-ratio-number-values",
        id: "media-queries-aspect-ratio-number-values",
        importName: "postcssMediaQueriesAspectRatioNumberValues"
    },
    {
        packageName: "postcss-nesting",
        id: "nesting-rules",
        importName: "postcssNesting"
    },
    {
        packageName: "@csstools/postcss-normalize-display-values",
        id: "display-two-values",
        importName: "postcssNormalizeDisplayValues"
    },
    {
        packageName: "@csstools/postcss-oklab-function",
        id: "oklab-function",
        importName: "postcssOKLabFunction"
    },
    {
        packageName: "@csstools/postcss-relative-color-syntax",
        id: "relative-color-syntax",
        importName: "postcssRelativeColorSyntax"
    },
    {
        packageName: "postcss-opacity-percentage",
        id: "opacity-percentage",
        importName: "postcssOpacityPercentage"
    },
    {
        packageName: "postcss-overflow-shorthand",
        id: "overflow-property",
        importName: "postcssOverflowShorthand"
    },
    {
        packageName: "postcss-page-break",
        id: "break-properties",
        importName: "postcssPageBreak"
    },
    {
        packageName: "postcss-place",
        id: "place-properties",
        importName: "postcssPlace"
    },
    {
        packageName: "postcss-pseudo-class-any-link",
        id: "any-link-pseudo-class",
        importName: "postcssPseudoClassAnyLink"
    },
    {
        packageName: "postcss-replace-overflow-wrap",
        id: "overflow-wrap-property",
        importName: "postcssReplaceOverflowWrap"
    },
    {
        packageName: "postcss-selector-not",
        id: "not-pseudo-class",
        importName: "postcssSelectorNot"
    },
    {
        packageName: "@csstools/postcss-stepped-value-functions",
        id: "stepped-value-functions",
        importName: "postcssSteppedValueFunctions"
    },
    {
        packageName: "postcss-system-ui-font-family",
        importedPackage: "../patch/postcss-system-ui-font-family.mjs",
        id: "system-ui-font-family",
        importName: "postcssFontFamilySystemUI"
    },
    {
        packageName: "@csstools/postcss-unset-value",
        id: "unset-value",
        importName: "postcssUnsetValue"
    },
    {
        packageName: "@csstools/postcss-cascade-layers",
        id: "cascade-layers",
        importName: "postcssCascadeLayers"
    },
    {
        packageName: "@csstools/postcss-trigonometric-functions",
        id: "trigonometric-functions",
        importName: "postcssTrigonometricFunctions"
    },
    {
        packageName: "@csstools/postcss-nested-calc",
        id: "nested-calc",
        importName: "postcssNestedCalc"
    },
    {
        packageName: "@csstools/postcss-text-decoration-shorthand",
        id: "text-decoration-shorthand",
        importName: "postcssTextDecorationShorthand"
    },
    {
        packageName: "@csstools/postcss-sign-functions",
        id: "sign-functions",
        importName: "postcssSignFunctions"
    },
    {
        packageName: "@csstools/postcss-random-function",
        id: "random-function",
        importName: "postcssRandomFunction"
    },
    {
        packageName: "@csstools/postcss-progressive-custom-properties",
        id: "progressive-custom-properties",
        importName: "postcssProgressiveCustomProperties",
        omitTypedOptions: !0,
        omitDocs: !0
    }
];
function getPackageNamesToIds() {
    const s = {};
    return Os.forEach((e)=>{
        s[e.packageName] = e.id;
    }), s;
}
function pluginIdHelp(s, e, o) {
    const t = Os.map((s)=>s.id), i = Os.map((s)=>s.packageName), r = getPackageNamesToIds();
    s.forEach((s)=>{
        if (t.includes(s)) return;
        const a = [
            ...t.map((e)=>[
                    e,
                    levenshteinDistance(s, e)
                ]),
            ...i.map((e)=>[
                    r[e],
                    levenshteinDistance(s, e)
                ])
        ].sort((s, e)=>s[1] - e[1]).filter((s)=>s[1] < 10), c = new Set;
        for(let s = 0; s < a.length && (c.add(a[s][0]), !(c.size >= 3)); s++);
        if (!c.size) return void e.warn(o, `Unknown feature: "${s}", see the list of features https://github.com/csstools/postcss-plugins/blob/main/plugin-packs/postcss-preset-env/FEATURES.md`);
        let n = '"';
        n += Array.from(c).join('", "'), n += '"', e.warn(o, `Unknown feature: "${s}", did you mean one of: ${n}`);
    });
}
function levenshteinDistance(s, e) {
    if (!s.length) return e.length;
    if (!e.length) return s.length;
    const o = [];
    for(let t = 0; t <= e.length; t++){
        o[t] = [
            t
        ];
        for(let i = 1; i <= s.length; i++)o[t][i] = 0 === t ? i : Math.min(o[t - 1][i] + 1, o[t][i - 1] + 1, o[t - 1][i - 1] + (s[i - 1] === e[t - 1] ? 0 : 1));
    }
    return o[e.length][s.length];
}
const creator = (o)=>{
    const t = new Logger, i = Object(o), r = Object.keys(Object(i.features)), a = i.browsers ? void 0 : i.env, c = i.browsers, n = initializeSharedOptions(i), p = listFeatures(e, i, n, t), l = p.map((s)=>s.plugin);
    !1 !== i.autoprefixer && l.push(s(Object.assign({
        env: a,
        overrideBrowserslist: c
    }, i.autoprefixer))), logFeaturesList(p, i, t);
    const internalPlugin = ()=>({
            postcssPlugin: "postcss-preset-env",
            OnceExit (s, { result: e }) {
                pluginIdHelp(r, s, e), i.debug && t.emitLogs(e), t.resetLogger();
            }
        });
    return internalPlugin.postcss = !0, {
        postcssPlugin: "postcss-preset-env",
        plugins: [
            ...l,
            internalPlugin()
        ]
    };
};
creator.postcss = !0, module.exports = creator;
}}),

};

//# sourceMappingURL=node_modules_cc95849a._.js.map